{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/logo.png","path":"images/logo.png","modified":0,"renderable":0},{"_id":"source/images/vertex_attribute_pointer.png","path":"images/vertex_attribute_pointer.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"public/search.xml","hash":"e7603214378618c9517101033fb93ad35d0d0999","modified":1529428870458},{"_id":"source/_posts/#hexo-in-different-computers.md#","hash":"7c9970e54b0eb1d6f82e64642c9869f102be00b8","modified":1529428609847},{"_id":"source/_posts/.add-git-bash-to-right-click-menu.md.un~","hash":"5ebfdeaf6fd4098f711eca50fc5e1cd329838a8e","modified":1529424903915},{"_id":"source/_posts/.hexo-random-symbol.md.un~","hash":"81b24335d2ed7b9de18b5e0e9a45f7ad457b0df2","modified":1529424903915},{"_id":"source/_posts/append-path-on-mac.md","hash":"9fa2e2032b568073c8cc4329f7680af382cd31dd","modified":1529428712389},{"_id":"source/_posts/append-path-on-mac.md~","hash":"5e73285a4bdc85701f06f147bac4cfae41842316","modified":1529428547777},{"_id":"source/_posts/architecture-english-temp2.md","hash":"cc1e29774caecc5c8f7653bb34f9dab9721ac120","modified":1529424903918},{"_id":"source/_posts/d3d-preparation.md","hash":"1870cf7a72b1d802f218e21988e92c76f4e14d3f","modified":1529424903921},{"_id":"source/_posts/add-git-bash-to-right-click-menu.md","hash":"e4a2dcea2ce7d3c8f109641f58fa7576684a0503","modified":1529424903917},{"_id":"source/_posts/My-First-Post.md","hash":"42f9d5c0ca52f3039af5c57c8f0e69594de9887d","modified":1529424903917},{"_id":"source/_posts/.srr.txt.swp","hash":"e946eedba20eb89ecfce9b6e5ba3bfd54c3741d3","modified":1529424903917},{"_id":"source/_posts/doc-computer-graphic-learn.md","hash":"3816a23aa56661590e9afe082585d03c5a53af79","modified":1529424903922},{"_id":"source/_posts/git-push-credential.md","hash":"02a52cbc4cf75ff95f5eb39256fb6e2fd87dcd1a","modified":1529424903932},{"_id":"source/_posts/hexo-in-different-computers.md","hash":"7c9970e54b0eb1d6f82e64642c9869f102be00b8","modified":1529424903934},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1529424903934},{"_id":"source/_posts/how-to-learn-program.md","hash":"92508e250408f968223ae96d22538cbce9131932","modified":1529424903935},{"_id":"source/_posts/gitignore-invalid.md","hash":"3162f15d45561317c03330a0bb850dee8558bde3","modified":1529424903932},{"_id":"source/_posts/markdown-delete-line.md","hash":"dd3fed7034a55981f65a9a31ce317c484578e7a2","modified":1529424903936},{"_id":"source/_posts/hexo-random-symbol.md","hash":"544ec0c207f445626e0438dc701ee27e7d9a5f01","modified":1529424903934},{"_id":"source/_posts/hello-triangle-three-execises.md","hash":"7aab6c04fd51a38c855a555699b6cd9f98621599","modified":1529424903933},{"_id":"source/_posts/trip-of-game-notes.md","hash":"9e8695c18a5c620862c0ba4660ba54a5b705ad7c","modified":1529424903937},{"_id":"source/_posts/install-openGL-in-ubuntu14-04.md","hash":"34865f6e7d423448f7ce96c82f18d9fb071b227a","modified":1529424903935},{"_id":"source/categories/.index.md.un~","hash":"c9a1aa5741e503495f3a950318a3adf97f698937","modified":1529424903938},{"_id":"source/_posts/temp-history.md","hash":"e25aa75a285418cdec8470a4b0cd721790b299f6","modified":1529424903937},{"_id":"source/categories/index.md","hash":"d6e30bf321c09a9496629a1bbad873ba730d5ed3","modified":1529424903938},{"_id":"source/categories/index.md~","hash":"6c36b8e983b96a6764ac1763bde2c028da49d456","modified":1529424903938},{"_id":"source/tags/.index.md.un~","hash":"99c6043f396d0057c5f4be8b980db9d5958c29b3","modified":1529424903939},{"_id":"source/images/logo.png","hash":"cca97ec099f730e6478d101e3e9bf16b2583a336","modified":1529424903939},{"_id":"source/_posts/.My-First-Post.md.un~","hash":"4ceee140a750b2d03ee74f0f24619933e67506b9","modified":1529424903914},{"_id":"source/images/vertex_attribute_pointer.png","hash":"705abe74942775d1dc09092863f6121070ce2861","modified":1529424903939},{"_id":"source/tags/index.md","hash":"5012cf70d44daae07a721e2fa4a5890294f68bcf","modified":1529424903940},{"_id":"source/tags/index.md~","hash":"c4378fd4354b18e8b3fb7899f3061d7ab36c9bd5","modified":1529424903940},{"_id":"source/_posts/cpp/cpp-notes-0003.md","hash":"d8c64a37eae93ceddacdefeba28362f76c060347","modified":1529424903918},{"_id":"source/_posts/cpp/cpp-notes-0004.md","hash":"bea5e525494fb599fe1d9768df6def367917401f","modified":1529424903919},{"_id":"source/_posts/cpp/cpp-notes-0005.md~","hash":"a676c746e0e1dad6071ff43f69e5f13614802338","modified":1529424903919},{"_id":"source/_posts/cpp/cpp-notes-0005.md","hash":"965ecafc85c6e1078f1e1cca6f9de0807066df8f","modified":1529424903919},{"_id":"source/_posts/cpp/cpp-notes-0006.md","hash":"161854e59daf0e1ee12960d19bc9ef739c742a2e","modified":1529424903920},{"_id":"source/_posts/cpp/cpp-notes-0006.md~","hash":"83b7509370f4704e5a613d8ec67bbcc561e4fa32","modified":1529424903920},{"_id":"source/_posts/cpp/cpp-notes-02.md","hash":"34fb5d993b11c0bd9cbafbf1fb7b19dc7b781f00","modified":1529424903921},{"_id":"source/_posts/cpp/cpp-notes-01.md","hash":"64be8c006f2ae0a826e6090481d417674144c070","modified":1529424903920},{"_id":"source/_posts/dsacpp/01-C.md","hash":"35d1d9b3c634bbca8a00be59fbebef99d0ce60d3","modified":1529424903923},{"_id":"source/_posts/dsacpp/01-D.md","hash":"cfde19fa09e411b462589439431da33e6d094210","modified":1529424903923},{"_id":"source/_posts/dsacpp/01-B.md","hash":"b37e88c1688b954b2dcbca450a5d308e47f7fdd3","modified":1529424903923},{"_id":"source/_posts/dsacpp/01-E.md","hash":"fcb803fe9a825aeb4438850d0bed94c72bb5bc41","modified":1529424903924},{"_id":"source/_posts/dsacpp/01-F.md","hash":"de54e1155731a3869d39e0480d198470ea0747ef","modified":1529424903924},{"_id":"source/_posts/dsacpp/02-A.md","hash":"5bd1378b098a4b173edf4488a16bcc9e18d0183b","modified":1529424903924},{"_id":"source/_posts/dsacpp/02-B.md","hash":"da772aceefd494bca48e268f7af2e26fb8b70b28","modified":1529424903925},{"_id":"source/_posts/dsacpp/02-C.md","hash":"8fad7d21e0417d14123d0cfb873d5f344114b97e","modified":1529424903925},{"_id":"source/_posts/dsacpp/02-D1.md~","hash":"428b07c222d5bf9535021a1f53b1a320b3b07c90","modified":1529424903926},{"_id":"source/_posts/dsacpp/02-D1.md","hash":"d0cf2d82ea785a8f0bbc452440ca57eb4d4f09b2","modified":1529424903925},{"_id":"source/_posts/dsacpp/02-D2.md","hash":"fce5b9e69013f3eb72fdb0b0a45561c79b57613c","modified":1529424903926},{"_id":"source/_posts/dsacpp/02-D2.md~","hash":"40c4441a25ac97a9f649f8a5606f5ef018e3aeff","modified":1529424903926},{"_id":"source/_posts/dsacpp/02-D3.md","hash":"8fde2f2998514a76d094357cdc35ebc39d2f8b16","modified":1529424903927},{"_id":"source/_posts/dsacpp/02-D3.md~","hash":"f538c5e10de7e0853036d5b05c0c1836c558bf2c","modified":1529424903927},{"_id":"source/_posts/dsacpp/02-D4.md","hash":"2ac5154c3aa39263c4c2eb9827774623df1f6aee","modified":1529424903928},{"_id":"source/_posts/dsacpp/02-D4.md~","hash":"bd85206de3dd1394867853929fd1bfd153e36c68","modified":1529424903928},{"_id":"source/_posts/dsacpp/02-E.md~","hash":"405a48d35918cf8d0e0b4a3a70fd3c47da8da1ba","modified":1529424903929},{"_id":"source/_posts/dsacpp/02-E.md","hash":"65154f0dff73d1cf7f53c39f0bd9b4e1c9874a13","modified":1529424903928},{"_id":"source/_posts/essay/about-rest.md","hash":"48797cd9861db1e19260e3cfe7b551465afbaa0e","modified":1529424903930},{"_id":"source/_posts/dsacpp/a.out","hash":"33959ae2c21a5dcd5c3557bc2369f1da75a7d199","modified":1529424903929},{"_id":"source/_posts/essay/a-little-light.md","hash":"5d4ce2acf3820d49635673f784fd2c8f9e32b7c4","modified":1529424903930},{"_id":"source/_posts/essay/architecture-application-between-computer-science.md","hash":"35f0b25f553aa2a99e906a196125b96133c87e1f","modified":1529424903931},{"_id":"source/_posts/essay/about-rest.md~","hash":"cff635ccb8c74798656485e44f1d18dd1ece270c","modified":1529424903930},{"_id":"source/_posts/essay/architecture-application-between-computer-science.md~","hash":"ba6964af7a94b6a9b066ef12e9cd9002640b9796","modified":1529424903931},{"_id":"source/_posts/movies/the-Truman-show-critic.md","hash":"1d81d178342ac59c68d7df15e0815eacb3344beb","modified":1529424903936},{"_id":"source/_posts/movies/the-Truman-show-critic.md~","hash":"84dd3f1af0f3dcae9197d85109aa467220288ead","modified":1529424903936},{"_id":"public/categories/index.html","hash":"eb2403358d5aaa36dbd0a4c31a8a849394b5078d","modified":1529429354062},{"_id":"public/tags/index.html","hash":"74aef1f059f0f27c584344d4bcb783e4900db685","modified":1529429354062},{"_id":"public/2018/01/23/architecture-english-temp2/index.html","hash":"fc02c8d2a450fc5bad9f9dfc34e1c6689d62ac91","modified":1529429354068},{"_id":"public/2018/01/21/dsacpp/02-E/index.html","hash":"c61974298f17fcdf9cfb244b3e40f1ca253fbc9e","modified":1529429354063},{"_id":"public/2018/01/21/dsacpp/02-D4/index.html","hash":"5c9eaaee6f269447c7d9251fe4e5f52ee0c61ffe","modified":1529429354068},{"_id":"public/2018/01/20/dsacpp/02-D3/index.html","hash":"8a5880d55564c492f4889c8ae6ffdc6e6a6f8fbd","modified":1529429354068},{"_id":"public/2018/01/18/temp-history/index.html","hash":"09faef396d0950363b05a191a1138ae0df47bd33","modified":1529429354068},{"_id":"public/2018/01/16/cpp/cpp-notes-0006/index.html","hash":"9ceace83cd42f3b92ded33b92e7a8b13bcc2a9f3","modified":1529429354069},{"_id":"public/2018/01/15/essay/about-rest/index.html","hash":"b5bf075df9d0672829719a6f32844af0eed682f0","modified":1529429354069},{"_id":"public/2018/01/13/cpp/cpp-notes-0005/index.html","hash":"bd7d6e28868621374b287bcaf03f7236586f6e3f","modified":1529429354069},{"_id":"public/2018/01/13/movies/the-Truman-show-critic/index.html","hash":"3a984dcd83db9b9299b624065c561b41ad588418","modified":1529429354063},{"_id":"public/2018/01/12/dsacpp/02-D2/index.html","hash":"5e821438b0f984d30bd15268fe33477c643fb0f3","modified":1529429354069},{"_id":"public/2018/01/12/cpp/cpp-notes-0004/index.html","hash":"718aaeeb499e0b2e440adc2ea5182d05cabe01c4","modified":1529429354069},{"_id":"public/2018/01/11/dsacpp/02-D1/index.html","hash":"eb04db33cd4c7d30960dd16a39c8b2115e63a66e","modified":1529429354069},{"_id":"public/2018/01/11/cpp/cpp-notes-0003/index.html","hash":"e3c8cefdbab8ebc62d1827d360b20fd8964dc270","modified":1529429354069},{"_id":"public/2018/01/10/essay/architecture-application-between-computer-science/index.html","hash":"9ec5d48ea11222f06464df1e4eb49ff7ae11c021","modified":1529429354063},{"_id":"public/2018/01/10/cpp/cpp-notes-02/index.html","hash":"68684bd8658ef9a8b935991e605f6cf4a4bd1cb8","modified":1529429354069},{"_id":"public/2018/01/10/cpp/cpp-notes-01/index.html","hash":"5c83eae74cafa278949ed38316ec7f55a44a18a7","modified":1529429354069},{"_id":"public/2018/01/10/dsacpp/02-C/index.html","hash":"0bcc501b696eaf4f941e460c26564aaa6b89599f","modified":1529429354069},{"_id":"public/2018/01/10/dsacpp/02-B/index.html","hash":"a35069090ead5c1fccd490352080ee400c6abccc","modified":1529429354070},{"_id":"public/2018/01/10/dsacpp/02-A/index.html","hash":"3da7511dc012b0a1585d2286703e03098108c15f","modified":1529429354070},{"_id":"public/2018/01/10/dsacpp/01-F/index.html","hash":"2672b770673b5050616a000460778c767d081434","modified":1529429354070},{"_id":"public/2018/01/10/dsacpp/01-E/index.html","hash":"86bb3e33e3110f8db3fa073521e8e287970e4a7f","modified":1529429354070},{"_id":"public/2018/01/10/dsacpp/01-C/index.html","hash":"cd845de90010a03e570705a81bd0f61d6956e902","modified":1529429354063},{"_id":"public/2018/01/10/dsacpp/01-B/index.html","hash":"b8742d628b16e5f9ea689988d345db68bc442f76","modified":1529429354063},{"_id":"public/2018/01/04/trip-of-game-notes/index.html","hash":"bd8800a041f6088f7779f1df85e1a053036b1603","modified":1529429354070},{"_id":"public/2017/12/28/doc-computer-graphic-learn/index.html","hash":"91ced8a6f31e6f4fba6e3286349adc511892489d","modified":1529429354070},{"_id":"public/2017/12/28/dsacpp/01-D/index.html","hash":"f93763aea89f105e7d72855a2f835c2610fe798b","modified":1529429354070},{"_id":"public/2017/12/27/gitignore-invalid/index.html","hash":"d3484e58a8ceb6c2663469ca8f6f99d1df03db6b","modified":1529429354063},{"_id":"public/2017/12/25/hello-triangle-three-execises/index.html","hash":"b858715445decdc7919e4898895c9805a7567e9b","modified":1529429354070},{"_id":"public/2017/12/24/how-to-learn-program/index.html","hash":"4d74b98b53735b55977ea27490e4dab8f7d85b1e","modified":1529429354070},{"_id":"public/2017/12/22/essay/a-little-light/index.html","hash":"e8a770950ca72fa7115ae91563b85cf913051d47","modified":1529429354070},{"_id":"public/2017/12/22/git-push-credential/index.html","hash":"e47b3769ee786485ab7e79bb6042874f3e8bb4c5","modified":1529429354070},{"_id":"public/2017/12/22/markdown-delete-line/index.html","hash":"363e4b7acbcd378343df9dc3c59c452026453706","modified":1529429354063},{"_id":"public/2017/12/20/install-openGL-in-ubuntu14-04/index.html","hash":"b045085a80f9b5ea7979c2573b17410859e3c064","modified":1529429354071},{"_id":"public/2017/12/20/hexo-in-different-computers/index.html","hash":"7a68530bd90fc07c095c99bfc0ecb07b16a9da0c","modified":1529429354071},{"_id":"public/2017/11/23/add-git-bash-to-right-click-menu/index.html","hash":"cfe0a31287e0d6249a494f2a4ac4ebc4b33a047d","modified":1529429354063},{"_id":"public/2017/11/23/hexo-random-symbol/index.html","hash":"ff4360218943a190566d39ea22fa4774d483309e","modified":1529429354063},{"_id":"public/2017/11/22/d3d-preparation/index.html","hash":"1952e6ffd1b95112157241361237014f57b0a4a0","modified":1529429354063},{"_id":"public/2017/11/21/My-First-Post/index.html","hash":"57fc430750a71c742fc7bd8b65db20930e8216e5","modified":1529429354071},{"_id":"public/archives/index.html","hash":"1e0e7aa95e1f064e3d9045c7c86bb89223dd67b4","modified":1529429354063},{"_id":"public/archives/page/2/index.html","hash":"ae1110534fc19e0888e022565460f7dae1a72501","modified":1529429354063},{"_id":"public/archives/page/3/index.html","hash":"d6d55b420efc06ffa23b69378660caed02375c08","modified":1529429354063},{"_id":"public/archives/page/4/index.html","hash":"c89d256b8d0c8b83daa6422ce0f8b2e519979233","modified":1529429354063},{"_id":"public/archives/2017/index.html","hash":"3452fb3fe7d01dd7f266e7b50d1aab5fb7d35c00","modified":1529429354064},{"_id":"public/archives/2017/page/2/index.html","hash":"4e870a66e9a26e0e0f7a2cf4b6c3e65a4fc45858","modified":1529429354064},{"_id":"public/archives/2017/11/index.html","hash":"7b699e6bea5f3d4eea95352587d8f2fa0a89aa17","modified":1529429354064},{"_id":"public/archives/2017/12/index.html","hash":"7f216e53460296185169af54ba84702d358d56a2","modified":1529429354064},{"_id":"public/archives/2018/index.html","hash":"a11577d2d9d1c4f2628df068c46327f5b600a5d4","modified":1529429354064},{"_id":"public/archives/2018/page/2/index.html","hash":"378a93934df31d383a51e31037d3a0a1282e901e","modified":1529429354064},{"_id":"public/archives/2018/page/3/index.html","hash":"63071c0ce506ee2a2d734ceda25e7774b70edb60","modified":1529429354064},{"_id":"public/archives/2018/01/index.html","hash":"1470a687fdce8894c635a69eb195f5d74706750f","modified":1529429354064},{"_id":"public/archives/2018/01/page/2/index.html","hash":"a7282409f9ef0123bb2a6379194edc75c9692d0a","modified":1529429354064},{"_id":"public/archives/2018/01/page/3/index.html","hash":"34928964d245266270120bb72ac62500e6bce33f","modified":1529429354064},{"_id":"public/index.html","hash":"3e337b914efed5a21d8842da7283cd1bb772febc","modified":1529429354071},{"_id":"public/page/2/index.html","hash":"9b0a0b7f5f3c1fe7110b9a786045d83217bfbed5","modified":1529429354071},{"_id":"public/page/3/index.html","hash":"991370d47b412fefeac35c225b2a4654ae3738d4","modified":1529429354071},{"_id":"public/page/4/index.html","hash":"ac316735c3e7840268cdb883608f27f1e6e1a62a","modified":1529429354071},{"_id":"public/tags/markdown/index.html","hash":"d2d8cfdbe3950e6aaef3476a5334ff1351a893f4","modified":1529429354064},{"_id":"public/tags/git/index.html","hash":"cf0dfd97b00cc38e87853f412be182cb3afca170","modified":1529429354064},{"_id":"public/tags/DirectX/index.html","hash":"923836858792e89b492ebac8934e5fbbc399fa08","modified":1529429354065},{"_id":"public/tags/Games/index.html","hash":"6ec612b761f5e962539798ab1930358e0bc5c774","modified":1529429354065},{"_id":"public/tags/图形学/index.html","hash":"e8a06510a2c46ce584cf407ed7b272805b4e7826","modified":1529429354065},{"_id":"public/tags/OpenGL/index.html","hash":"e239c8288456c76f33480057e2c438d3c30abccb","modified":1529429354065},{"_id":"public/tags/读书/index.html","hash":"22e4086c8c3cac8393c6b2d3f19c38310bea4f01","modified":1529429354065},{"_id":"public/tags/随想/index.html","hash":"fde41c2592febab50081d61eddd6ddcaf3e56479","modified":1529429354065},{"_id":"public/tags/方法论/index.html","hash":"8f08652efa9901040b0ce0c32706a557f1a7a6f5","modified":1529429354065},{"_id":"public/tags/引擎/index.html","hash":"aa1d7f4cc958c951337056b9af7c250e3fee1882","modified":1529429354065},{"_id":"public/tags/hexo/index.html","hash":"54a8820c1852f5f6410d432277c5ac6c11fbb047","modified":1529429354065},{"_id":"public/tags/UTF-8/index.html","hash":"114a5208235ad2030270bffe120d67e27d21b0ee","modified":1529429354065},{"_id":"public/tags/program/index.html","hash":"4ed0e9b50aea9e133404ce2c7819f58874e56883","modified":1529429354065},{"_id":"public/tags/learn/index.html","hash":"223f3e0ce108f819ecb63131f45adf181ad74cf1","modified":1529429354066},{"_id":"public/tags/游戏/index.html","hash":"71691f1f3b32f58f6058529666ac01fa055f22fe","modified":1529429354066},{"_id":"public/tags/C/index.html","hash":"924391ce1359617f957ce7c807966f5a059f17a0","modified":1529429354066},{"_id":"public/tags/继承/index.html","hash":"e1ca11b104941c81b0126c4dc996653943150bc4","modified":1529429354066},{"_id":"public/tags/类/index.html","hash":"e5f6a25e7e4c4d0ba18dd0a13ff02e499063f543","modified":1529429354066},{"_id":"public/tags/virtual/index.html","hash":"b465ce744e277c9df45137eb0d166139931c917c","modified":1529429354066},{"_id":"public/tags/override/index.html","hash":"cfd630480a7ca9328daa1ad96776c2d179708b7c","modified":1529429354066},{"_id":"public/tags/函数重载/index.html","hash":"0e9c557239879136501d77449a5e487eb94f24e5","modified":1529429354066},{"_id":"public/tags/static/index.html","hash":"ae33bbae6b45e66e22d72b28c61bef77c0085dfa","modified":1529429354066},{"_id":"public/tags/静态成员/index.html","hash":"5e6974941180d71c4ec24e1f5625a0b2720d5e5f","modified":1529429354066},{"_id":"public/tags/const/index.html","hash":"6da56ccbddb00b316fffe5963fdce94089cb0b1e","modified":1529429354066},{"_id":"public/tags/常量指针/index.html","hash":"c86e3e262034cf273bee8603469c568f1d6a9f03","modified":1529429354066},{"_id":"public/tags/常量引用/index.html","hash":"f434afdfcfd420905b19e2f2b8c31f415c424855","modified":1529429354066},{"_id":"public/tags/protected/index.html","hash":"89a267ced883d94794c1e275032c66bba3a8f895","modified":1529429354067},{"_id":"public/tags/for/index.html","hash":"db3479ad05999b78d1914cc80aaa9f0bb102faea","modified":1529429354067},{"_id":"public/tags/位操作/index.html","hash":"47f23ab0dc012d7b17d8dcb3aea7dd9e54562afc","modified":1529429354067},{"_id":"public/tags/new/index.html","hash":"e3a2e0ba77644fb2ceda25c93f152e5eb860015b","modified":1529429354067},{"_id":"public/tags/delete/index.html","hash":"5c43a335f45251d81dfb900f7cd3e2ab953f2a3e","modified":1529429354067},{"_id":"public/tags/运算符重载/index.html","hash":"4b2367247eceb9fdea404e0d05a2f850ad3dd7fb","modified":1529429354067},{"_id":"public/tags/函数指针/index.html","hash":"bf4f664103324ca466d612f89443e2514b640169","modified":1529429354067},{"_id":"public/tags/函数对象/index.html","hash":"10d3d9026ea62da381312dab5329d69f6de5c012","modified":1529429354067},{"_id":"public/tags/指针/index.html","hash":"db564264754cd3b1f1229d813f5c03ba8afeb484","modified":1529429354067},{"_id":"public/tags/数组/index.html","hash":"f210e26755eb58d3e421d87418a0db1679754e25","modified":1529429354067},{"_id":"public/tags/常量成员函数/index.html","hash":"d86790f6128c99703d348862d4a4d36eb493b8f7","modified":1529429354067},{"_id":"public/tags/模板/index.html","hash":"5e7ba77cd9a3b35ec95528fa6bb05f83715b56e5","modified":1529429354067},{"_id":"public/tags/数据结构/index.html","hash":"6c98554b0ea2dd6aecf86d9ecf4ec221f56eec51","modified":1529429354067},{"_id":"public/tags/数据结构/page/2/index.html","hash":"da772e49ad0030004feb4e0f8d4e82c1f06dcd11","modified":1529429354068},{"_id":"public/tags/复杂度/index.html","hash":"7ac685160e15939fea62f2419a19bdda124aa17b","modified":1529429354068},{"_id":"public/tags/动态规划/index.html","hash":"cb31ede1eb453ad3f097314c6c3430abbf6e2761","modified":1529429354068},{"_id":"public/tags/向量/index.html","hash":"babd9b5943e24942cea105aa2835af5b56dd0dca","modified":1529429354068},{"_id":"public/tags/有序向量/index.html","hash":"66f06a79d11a3e43244e78236491061269f61f50","modified":1529429354068},{"_id":"public/tags/建筑/index.html","hash":"b2722271e20722b852f9336eb5f9540e461a1496","modified":1529429354068},{"_id":"public/tags/计算机科学/index.html","hash":"e61a9e50fe8fee22c62914a5bcb7448fb7478e0b","modified":1529429354068},{"_id":"public/tags/电影/index.html","hash":"bb42aa51cb136a2f1da12c17cf6055ec38324778","modified":1529429354068},{"_id":"public/2018/06/20/append-path-on-mac/index.html","hash":"00b28816678268326190a63f64f458e2c0d81f6e","modified":1529429354062},{"_id":"public/2018/06/20/hello-world/index.html","hash":"5d1ff046bdb6b5c157a4b7afbb8d3c74f8fd0ac2","modified":1529429354062},{"_id":"public/archives/2018/06/index.html","hash":"c744c4bcb848e1e6d1018fe38f671481725ef737","modified":1529429354064},{"_id":"public/tags/shell/index.html","hash":"9be9459d9cbc3cad5e800e3f0272def31c3b106a","modified":1529429354065},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1514806389000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1514806389000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1514806389000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1514806389000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1514806389000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1514806389000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1514806389000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1514806389000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1514806389000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1514806389000},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1514806389000},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1514806389000},{"_id":"themes/next/_config.yml","hash":"5ff37e90e4d6812c8fc40c03fa6e1d903d743470","modified":1514806389000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1514806389000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1514806389000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1514806389000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1514806389000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1514806389000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1514806389000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1514806389000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1514806389000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1514806389000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1514806389000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1514806389000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1514806389000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1514806389000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1514806389000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1514806389000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1514806389000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1514806389000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1514806389000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1514806389000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1514806389000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1514806389000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1514806389000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1514806389000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1514806389000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1514806389000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1514806389000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1514806389000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1514806389000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1514806389000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1514806389000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1514806389000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1514806389000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1514806389000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1514806389000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1514806389000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1514806389000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806389000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1514806389000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1514806389000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1514806389000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1514806389000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1514806389000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1514806389000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1514806389000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1514806389000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1514806389000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1514806389000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1514806389000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1514806389000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1514806389000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1514806389000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1514806389000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1514806389000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1514806389000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1514806389000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1514806389000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1514806389000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1514806389000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1514806389000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1514806389000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1514806389000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1514806389000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1514806389000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1514806389000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1514806389000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1514806389000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1514806389000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1514806389000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1514806389000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1514806389000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1514806389000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514806389000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1514806389000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1514806389000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1514806389000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1514806389000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514806389000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514806389000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1514806389000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514806389000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1514806389000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1514806389000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1514806389000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1514806389000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1514806389000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1514806389000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1514806389000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1514806389000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1514806389000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1514806389000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1514806389000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1514806389000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1514806389000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1514806389000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514806389000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514806389000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514806389000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514806389000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514806389000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514806389000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514806389000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514806389000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514806389000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514806389000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514806389000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514806389000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514806389000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514806389000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514806389000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514806389000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514806389000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1514806389000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1514806389000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1514806389000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1514806389000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514806389000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514806389000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514806389000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1514806389000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514806389000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514806389000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514806389000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514806389000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514806389000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1514806389000},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1529429354093},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1529429354093},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1529429354094},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1529429354094},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1529429354094},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1529429354094},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1529429354094},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1529429354094},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1529429354094},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1529429354095},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1529429354095},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1529429354095},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529429354095},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1529429354095},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529429354095},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1529429354095},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1529429354095},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1529429354096},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1529429354096},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1529429354096},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1529429354096},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1529429354096},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1529429354096},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1529429354097},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1529429354097},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1529429354097},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1529429354097},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1529429354097},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1529429354097},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1529429354097},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1529429354097},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1529429354098},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1529429354098},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1529429354726},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1529429354734},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1529429355587},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1529429355587},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1529429355587},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1529429355588},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1529429355588},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1529429355588},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1529429355588},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1529429355588},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1529429355588},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1529429355588},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1529429355588},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1529429355588},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1529429355588},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1529429355589},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1529429355589},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1529429355589},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1529429355589},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1529429355589},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1529429355589},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1529429355589},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1529429355589},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1529429355589},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1529429355589},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1529429355590},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1529429355591},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1529429355591},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1529429355591},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1529429355591},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1529429355591},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1529429355591},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1529429355591},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1529429355591},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1529429355591},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1529429355591},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1529429355592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1529429355592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1529429355592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1529429355592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1529429355592},{"_id":"public/css/main.css","hash":"10fcfdb35e44c10a04e970ff4e70cda552ffdeef","modified":1529429355592},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1529429355592},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1529429355592},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1529429355592},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1529429355592},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1529429355593},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1529429355593},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1529429355593},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1529429355593},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1529429355597},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1529429355597},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1529429355598},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1529429355598},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1529429355598},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1529429355598},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1529429355598},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1529429355598},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1529429355598},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1529429355598},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1529429355598},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1529429355598},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1529429355599},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1529429355599},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1529429355599},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1529429355845}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-11-22T04:39:22.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-11-22 12:39:22\ntype: \"categories\"\n\n---\n","updated":"2018-06-19T16:15:03.938Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjilydyir0000k8mf4qth9njr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-11-22T04:36:33.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-11-22 12:36:33\ntype: \"tags\"\n\n---\n","updated":"2018-06-19T16:15:03.940Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjilydyiw0002k8mf3jz973ml","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown语法整理(不定期更新)","date":"2017-11-21T05:31:03.000Z","_content":"\n\nIn this post, I will focus on use of Markdown and hexo push.\n \n> 1. title level\n> 2. insert a link\n> 3. highlight the code\n> 4. three lists of point\n> 5. insert a note\"[^code]\"\n> 6. bold fonts\n> 7. reference\n> 8. edit a formula\n> 9. draw a flow picture\n> * [补充](#补充)\n\nreference website: [Cmd Markdown reader](https://www.zybuluo.com/mdeditor#fn:latex)\n\n\n\n## 1. Title level\n\n### level 3-0\n#### level 4-0\n### level 3-1\n#### level 4-1\n#### level 4-2\n\n## 2. Insert a link.\n\n### [Tim's Blog](https://timtingwei.github.io/)\n### [Tim's Blog][2]\n\n## 3. Highlight the code\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n\n```cpp\n#include <iostream>\n\nclass Foo {\n public:\n  int f();\n};\n\nint main() {\n  // ...\n  return 0;\n}\n```\n\n\n\n## 4. three lists of point\n\n### Bulleted List\n> * first line\n> * second line\n> * third line\n\n### Numbered List\n> 1. first line\n> 2. second line\n> 3. third line\n\n### TODO list\n- [ ] first todo \n- [ ] second todo\n- [x] third todo -> Done\n\n## 5. insert a note[^code]\nLaTex formula support [LaTex][^LaTex]\nhigh light code [code][^code]\ninsert a web note [MathJax][1]\n\n## 6. bold fonts\n\n** bold fonts ** by adding two asteriskes *  as prefix and suffix respectively\n\n\n## 7. Reference \n\n> You can insert a reference by \">\",\nand input enter to create a new line,\nThis is the end line. Until the next symbol occur.\n\n## 8. edit a formula\n$$E=mc^2$$    use $$\n\n## 9.draw a flow picture\n\n```flow\nst=>start: Start\nop=>operation: Your Opreation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n[^LaTex]: support **LaTex** edit and display, such as: $\\sum_{i=1}^n a_i=0$, visit [MathJax][1] for more information.\n[^code]: include Java, Python, JavaScript etc.\n[1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[2]: https://timtingwei.github.io/\n\n------\n\n# 补充\n\n> * [背景色灰](#背景色灰)\n> * [实现页面内跳转](#实现页面内跳转)\n> * [删除线](#删除线)\n> * [插入图片](#插入图片)\n> * [标记文本颜色](#标记文本颜色)\n20171224之后补充但未作整理。本来可以将每个语法分成多个博客离散列出，但后来出于对博客页面和知识索引的考虑，还是放在一个post内，也许将来会又变动，但是先不提前优化。\n\n\n## 背景色灰\n\\`gray background\\`\n\n`gray background`\n\n背景灰可以代替 反斜杠 \\\\,去完成注释。这个很好用。原理估计和代码块差不多吧。\n\n## 实现页面内跳转\n\n`[create an anchor](#anchors-in-markdown)`\n\n[create an anchor](#anchors-in-markdown)\n\n\\===========\nrefwebsite:\n\n[Anchors in Markdown](https://gist.github.com/asabaylus/3071099)\n\n\n### anchors in markdown\n\tskip into this title\n\n\n## 删除线\n\n`~~删除一句~~`\n~~删除一句~~\n\n`~~删除`\n`多行~~`\n~~删除\n多行~~\n\n`~~删除包含语法[mituh’s notes][timtingwei.github.io]~~`\n~~删除包含语法\\[mituh’s notes\\]\\[timtingwei.github.io\\]~~\n\n====\n不知道还有其他方法否？\n\n\\==========\nrefwebsite:\n\nhttps://en.wikipedia.org/wiki/Markdown\n\n\n\n## 插入图片\n\n`![Logo](/images/logo.png)`\n![Logo](/images/logo.png)\n\n\\===========\nrefwebsite:\n\nhexo图片的其他用法：https://hexo.io/zh-cn/docs/asset-folders.html\nhttps://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo\n\n## 标记文本颜色\n\n`<span style=\"color:blue\">*This is Blue italic.*</span>`\n<span style=\"color:blue\">*This is Blue italic.*</span>\n\n`<span style=\"color:red\">**This is Red Bold.**</span>`\n<span style=\"color:red\">**This is Red Bold.**</span>\n\n相比之下,\nitalic 给人轻松的感觉，\nblod有种警告意味。\n\n\\===========\nrefwebsite:\n\nhttps://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown\n\n## next one ?\n\n---------------------------------------------------------------\n以上是我的个人笔记收录，markdown主要用来写笔记和写博客\n其他有什么好玩的用法，欢迎指教。\ntimtingwei#hotmail.com\n","source":"_posts/My-First-Post.md","raw":"---\ntitle: Markdown语法整理(不定期更新)\ndate: 2017-11-21 13:31:03\ntags: \"markdown\"\ncategories: \n\n---\n\n\nIn this post, I will focus on use of Markdown and hexo push.\n \n> 1. title level\n> 2. insert a link\n> 3. highlight the code\n> 4. three lists of point\n> 5. insert a note\"[^code]\"\n> 6. bold fonts\n> 7. reference\n> 8. edit a formula\n> 9. draw a flow picture\n> * [补充](#补充)\n\nreference website: [Cmd Markdown reader](https://www.zybuluo.com/mdeditor#fn:latex)\n\n\n\n## 1. Title level\n\n### level 3-0\n#### level 4-0\n### level 3-1\n#### level 4-1\n#### level 4-2\n\n## 2. Insert a link.\n\n### [Tim's Blog](https://timtingwei.github.io/)\n### [Tim's Blog][2]\n\n## 3. Highlight the code\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n\n```cpp\n#include <iostream>\n\nclass Foo {\n public:\n  int f();\n};\n\nint main() {\n  // ...\n  return 0;\n}\n```\n\n\n\n## 4. three lists of point\n\n### Bulleted List\n> * first line\n> * second line\n> * third line\n\n### Numbered List\n> 1. first line\n> 2. second line\n> 3. third line\n\n### TODO list\n- [ ] first todo \n- [ ] second todo\n- [x] third todo -> Done\n\n## 5. insert a note[^code]\nLaTex formula support [LaTex][^LaTex]\nhigh light code [code][^code]\ninsert a web note [MathJax][1]\n\n## 6. bold fonts\n\n** bold fonts ** by adding two asteriskes *  as prefix and suffix respectively\n\n\n## 7. Reference \n\n> You can insert a reference by \">\",\nand input enter to create a new line,\nThis is the end line. Until the next symbol occur.\n\n## 8. edit a formula\n$$E=mc^2$$    use $$\n\n## 9.draw a flow picture\n\n```flow\nst=>start: Start\nop=>operation: Your Opreation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n[^LaTex]: support **LaTex** edit and display, such as: $\\sum_{i=1}^n a_i=0$, visit [MathJax][1] for more information.\n[^code]: include Java, Python, JavaScript etc.\n[1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[2]: https://timtingwei.github.io/\n\n------\n\n# 补充\n\n> * [背景色灰](#背景色灰)\n> * [实现页面内跳转](#实现页面内跳转)\n> * [删除线](#删除线)\n> * [插入图片](#插入图片)\n> * [标记文本颜色](#标记文本颜色)\n20171224之后补充但未作整理。本来可以将每个语法分成多个博客离散列出，但后来出于对博客页面和知识索引的考虑，还是放在一个post内，也许将来会又变动，但是先不提前优化。\n\n\n## 背景色灰\n\\`gray background\\`\n\n`gray background`\n\n背景灰可以代替 反斜杠 \\\\,去完成注释。这个很好用。原理估计和代码块差不多吧。\n\n## 实现页面内跳转\n\n`[create an anchor](#anchors-in-markdown)`\n\n[create an anchor](#anchors-in-markdown)\n\n\\===========\nrefwebsite:\n\n[Anchors in Markdown](https://gist.github.com/asabaylus/3071099)\n\n\n### anchors in markdown\n\tskip into this title\n\n\n## 删除线\n\n`~~删除一句~~`\n~~删除一句~~\n\n`~~删除`\n`多行~~`\n~~删除\n多行~~\n\n`~~删除包含语法[mituh’s notes][timtingwei.github.io]~~`\n~~删除包含语法\\[mituh’s notes\\]\\[timtingwei.github.io\\]~~\n\n====\n不知道还有其他方法否？\n\n\\==========\nrefwebsite:\n\nhttps://en.wikipedia.org/wiki/Markdown\n\n\n\n## 插入图片\n\n`![Logo](/images/logo.png)`\n![Logo](/images/logo.png)\n\n\\===========\nrefwebsite:\n\nhexo图片的其他用法：https://hexo.io/zh-cn/docs/asset-folders.html\nhttps://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo\n\n## 标记文本颜色\n\n`<span style=\"color:blue\">*This is Blue italic.*</span>`\n<span style=\"color:blue\">*This is Blue italic.*</span>\n\n`<span style=\"color:red\">**This is Red Bold.**</span>`\n<span style=\"color:red\">**This is Red Bold.**</span>\n\n相比之下,\nitalic 给人轻松的感觉，\nblod有种警告意味。\n\n\\===========\nrefwebsite:\n\nhttps://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown\n\n## next one ?\n\n---------------------------------------------------------------\n以上是我的个人笔记收录，markdown主要用来写笔记和写博客\n其他有什么好玩的用法，欢迎指教。\ntimtingwei#hotmail.com\n","slug":"My-First-Post","published":1,"updated":"2018-06-19T16:15:03.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyit0001k8mfhwbd7y82","content":"<p>In this post, I will focus on use of Markdown and hexo push.</p>\n<blockquote>\n<ol>\n<li>title level</li>\n<li>insert a link</li>\n<li>highlight the code</li>\n<li>three lists of point</li>\n<li>insert a note”[^code]”</li>\n<li>bold fonts</li>\n<li>reference</li>\n<li>edit a formula</li>\n<li>draw a flow picture</li>\n</ol>\n<ul>\n<li><a href=\"#补充\">补充</a></li>\n</ul>\n</blockquote>\n<p>reference website: <a href=\"https://www.zybuluo.com/mdeditor#fn:latex\" target=\"_blank\" rel=\"noopener\">Cmd Markdown reader</a></p>\n<h2 id=\"1-Title-level\"><a href=\"#1-Title-level\" class=\"headerlink\" title=\"1. Title level\"></a>1. Title level</h2><h3 id=\"level-3-0\"><a href=\"#level-3-0\" class=\"headerlink\" title=\"level 3-0\"></a>level 3-0</h3><h4 id=\"level-4-0\"><a href=\"#level-4-0\" class=\"headerlink\" title=\"level 4-0\"></a>level 4-0</h4><h3 id=\"level-3-1\"><a href=\"#level-3-1\" class=\"headerlink\" title=\"level 3-1\"></a>level 3-1</h3><h4 id=\"level-4-1\"><a href=\"#level-4-1\" class=\"headerlink\" title=\"level 4-1\"></a>level 4-1</h4><h4 id=\"level-4-2\"><a href=\"#level-4-2\" class=\"headerlink\" title=\"level 4-2\"></a>level 4-2</h4><h2 id=\"2-Insert-a-link\"><a href=\"#2-Insert-a-link\" class=\"headerlink\" title=\"2. Insert a link.\"></a>2. Insert a link.</h2><h3 id=\"Tim’s-Blog\"><a href=\"#Tim’s-Blog\" class=\"headerlink\" title=\"Tim’s Blog\"></a><a href=\"https://timtingwei.github.io/\">Tim’s Blog</a></h3><h3 id=\"Tim’s-Blog-1\"><a href=\"#Tim’s-Blog-1\" class=\"headerlink\" title=\"Tim’s Blog\"></a><a href=\"https://timtingwei.github.io/\">Tim’s Blog</a></h3><h2 id=\"3-Highlight-the-code\"><a href=\"#3-Highlight-the-code\" class=\"headerlink\" title=\"3. Highlight the code\"></a>3. Highlight the code</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># A comment</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'hello world'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-three-lists-of-point\"><a href=\"#4-three-lists-of-point\" class=\"headerlink\" title=\"4. three lists of point\"></a>4. three lists of point</h2><h3 id=\"Bulleted-List\"><a href=\"#Bulleted-List\" class=\"headerlink\" title=\"Bulleted List\"></a>Bulleted List</h3><blockquote>\n<ul>\n<li>first line</li>\n<li>second line</li>\n<li>third line</li>\n</ul>\n</blockquote>\n<h3 id=\"Numbered-List\"><a href=\"#Numbered-List\" class=\"headerlink\" title=\"Numbered List\"></a>Numbered List</h3><blockquote>\n<ol>\n<li>first line</li>\n<li>second line</li>\n<li>third line</li>\n</ol>\n</blockquote>\n<h3 id=\"TODO-list\"><a href=\"#TODO-list\" class=\"headerlink\" title=\"TODO list\"></a>TODO list</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> first todo </li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> second todo</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> third todo -&gt; Done</li>\n</ul>\n<h2 id=\"5-insert-a-note-code\"><a href=\"#5-insert-a-note-code\" class=\"headerlink\" title=\"5. insert a note[^code]\"></a>5. insert a note[^code]</h2><p>LaTex formula support [LaTex][^LaTex]<br>high light code [code][^code]<br>insert a web note <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a></p>\n<h2 id=\"6-bold-fonts\"><a href=\"#6-bold-fonts\" class=\"headerlink\" title=\"6. bold fonts\"></a>6. bold fonts</h2><p><strong> bold fonts </strong> by adding two asteriskes *  as prefix and suffix respectively</p>\n<h2 id=\"7-Reference\"><a href=\"#7-Reference\" class=\"headerlink\" title=\"7. Reference\"></a>7. Reference</h2><blockquote>\n<p>You can insert a reference by “&gt;”,<br>and input enter to create a new line,<br>This is the end line. Until the next symbol occur.</p>\n</blockquote>\n<h2 id=\"8-edit-a-formula\"><a href=\"#8-edit-a-formula\" class=\"headerlink\" title=\"8. edit a formula\"></a>8. edit a formula</h2><p>$$E=mc^2$$    use $$</p>\n<h2 id=\"9-draw-a-flow-picture\"><a href=\"#9-draw-a-flow-picture\" class=\"headerlink\" title=\"9.draw a flow picture\"></a>9.draw a flow picture</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">st=&gt;start: Start</span><br><span class=\"line\">op=&gt;operation: Your Opreation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<p>[^LaTex]: support <strong>LaTex</strong> edit and display, such as: $\\sum_{i=1}^n a_i=0$, visit <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a> for more information.<br>[^code]: include Java, Python, JavaScript etc.</p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<ul>\n<li><a href=\"#背景色灰\">背景色灰</a></li>\n<li><a href=\"#实现页面内跳转\">实现页面内跳转</a></li>\n<li><a href=\"#删除线\">删除线</a></li>\n<li><a href=\"#插入图片\">插入图片</a></li>\n<li><a href=\"#标记文本颜色\">标记文本颜色</a><br>20171224之后补充但未作整理。本来可以将每个语法分成多个博客离散列出，但后来出于对博客页面和知识索引的考虑，还是放在一个post内，也许将来会又变动，但是先不提前优化。</li>\n</ul>\n</blockquote>\n<h2 id=\"背景色灰\"><a href=\"#背景色灰\" class=\"headerlink\" title=\"背景色灰\"></a>背景色灰</h2><p>`gray background`</p>\n<p><code>gray background</code></p>\n<p>背景灰可以代替 反斜杠 \\,去完成注释。这个很好用。原理估计和代码块差不多吧。</p>\n<h2 id=\"实现页面内跳转\"><a href=\"#实现页面内跳转\" class=\"headerlink\" title=\"实现页面内跳转\"></a>实现页面内跳转</h2><p><code>[create an anchor](#anchors-in-markdown)</code></p>\n<p><a href=\"#anchors-in-markdown\">create an anchor</a></p>\n<p>\\===========<br>refwebsite:</p>\n<p><a href=\"https://gist.github.com/asabaylus/3071099\" target=\"_blank\" rel=\"noopener\">Anchors in Markdown</a></p>\n<h3 id=\"anchors-in-markdown\"><a href=\"#anchors-in-markdown\" class=\"headerlink\" title=\"anchors in markdown\"></a>anchors in markdown</h3><pre><code>skip into this title\n</code></pre><h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><code>~~删除一句~~</code><br><del>删除一句</del></p>\n<p><code>~~删除</code><br><code>多行~~</code><br><del>删除<br>多行</del></p>\n<p><code>~~删除包含语法[mituh’s notes][timtingwei.github.io]~~</code><br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>\n<p>====<br>不知道还有其他方法否？</p>\n<p>\\==========<br>refwebsite:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Markdown</a></p>\n<h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><p><code>![Logo](/images/logo.png)</code><br><img src=\"/images/logo.png\" alt=\"Logo\"></p>\n<p>\\===========<br>refwebsite:</p>\n<p>hexo图片的其他用法：<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/asset-folders.html</a><br><a href=\"https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo\" target=\"_blank\" rel=\"noopener\">https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo</a></p>\n<h2 id=\"标记文本颜色\"><a href=\"#标记文本颜色\" class=\"headerlink\" title=\"标记文本颜色\"></a>标记文本颜色</h2><p><code>&lt;span style=&quot;color:blue&quot;&gt;*This is Blue italic.*&lt;/span&gt;</code><br><span style=\"color:blue\"><em>This is Blue italic.</em></span></p>\n<p><code>&lt;span style=&quot;color:red&quot;&gt;**This is Red Bold.**&lt;/span&gt;</code><br><span style=\"color:red\"><strong>This is Red Bold.</strong></span></p>\n<p>相比之下,<br>italic 给人轻松的感觉，<br>blod有种警告意味。</p>\n<p>\\===========<br>refwebsite:</p>\n<p><a href=\"https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown</a></p>\n<h2 id=\"next-one\"><a href=\"#next-one\" class=\"headerlink\" title=\"next one ?\"></a>next one ?</h2><hr>\n<p>以上是我的个人笔记收录，markdown主要用来写笔记和写博客<br>其他有什么好玩的用法，欢迎指教。<br>timtingwei#hotmail.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p>In this post, I will focus on use of Markdown and hexo push.</p>\n<blockquote>\n<ol>\n<li>title level</li>\n<li>insert a link</li>\n<li>highlight the code</li>\n<li>three lists of point</li>\n<li>insert a note”[^code]”</li>\n<li>bold fonts</li>\n<li>reference</li>\n<li>edit a formula</li>\n<li>draw a flow picture</li>\n</ol>\n<ul>\n<li><a href=\"#补充\">补充</a></li>\n</ul>\n</blockquote>\n<p>reference website: <a href=\"https://www.zybuluo.com/mdeditor#fn:latex\" target=\"_blank\" rel=\"noopener\">Cmd Markdown reader</a></p>\n<h2 id=\"1-Title-level\"><a href=\"#1-Title-level\" class=\"headerlink\" title=\"1. Title level\"></a>1. Title level</h2><h3 id=\"level-3-0\"><a href=\"#level-3-0\" class=\"headerlink\" title=\"level 3-0\"></a>level 3-0</h3><h4 id=\"level-4-0\"><a href=\"#level-4-0\" class=\"headerlink\" title=\"level 4-0\"></a>level 4-0</h4><h3 id=\"level-3-1\"><a href=\"#level-3-1\" class=\"headerlink\" title=\"level 3-1\"></a>level 3-1</h3><h4 id=\"level-4-1\"><a href=\"#level-4-1\" class=\"headerlink\" title=\"level 4-1\"></a>level 4-1</h4><h4 id=\"level-4-2\"><a href=\"#level-4-2\" class=\"headerlink\" title=\"level 4-2\"></a>level 4-2</h4><h2 id=\"2-Insert-a-link\"><a href=\"#2-Insert-a-link\" class=\"headerlink\" title=\"2. Insert a link.\"></a>2. Insert a link.</h2><h3 id=\"Tim’s-Blog\"><a href=\"#Tim’s-Blog\" class=\"headerlink\" title=\"Tim’s Blog\"></a><a href=\"https://timtingwei.github.io/\">Tim’s Blog</a></h3><h3 id=\"Tim’s-Blog-1\"><a href=\"#Tim’s-Blog-1\" class=\"headerlink\" title=\"Tim’s Blog\"></a><a href=\"https://timtingwei.github.io/\">Tim’s Blog</a></h3><h2 id=\"3-Highlight-the-code\"><a href=\"#3-Highlight-the-code\" class=\"headerlink\" title=\"3. Highlight the code\"></a>3. Highlight the code</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># A comment</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'hello world'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-three-lists-of-point\"><a href=\"#4-three-lists-of-point\" class=\"headerlink\" title=\"4. three lists of point\"></a>4. three lists of point</h2><h3 id=\"Bulleted-List\"><a href=\"#Bulleted-List\" class=\"headerlink\" title=\"Bulleted List\"></a>Bulleted List</h3><blockquote>\n<ul>\n<li>first line</li>\n<li>second line</li>\n<li>third line</li>\n</ul>\n</blockquote>\n<h3 id=\"Numbered-List\"><a href=\"#Numbered-List\" class=\"headerlink\" title=\"Numbered List\"></a>Numbered List</h3><blockquote>\n<ol>\n<li>first line</li>\n<li>second line</li>\n<li>third line</li>\n</ol>\n</blockquote>\n<h3 id=\"TODO-list\"><a href=\"#TODO-list\" class=\"headerlink\" title=\"TODO list\"></a>TODO list</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> first todo </li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> second todo</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> third todo -&gt; Done</li>\n</ul>\n<h2 id=\"5-insert-a-note-code\"><a href=\"#5-insert-a-note-code\" class=\"headerlink\" title=\"5. insert a note[^code]\"></a>5. insert a note[^code]</h2><p>LaTex formula support [LaTex][^LaTex]<br>high light code [code][^code]<br>insert a web note <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a></p>\n<h2 id=\"6-bold-fonts\"><a href=\"#6-bold-fonts\" class=\"headerlink\" title=\"6. bold fonts\"></a>6. bold fonts</h2><p><strong> bold fonts </strong> by adding two asteriskes *  as prefix and suffix respectively</p>\n<h2 id=\"7-Reference\"><a href=\"#7-Reference\" class=\"headerlink\" title=\"7. Reference\"></a>7. Reference</h2><blockquote>\n<p>You can insert a reference by “&gt;”,<br>and input enter to create a new line,<br>This is the end line. Until the next symbol occur.</p>\n</blockquote>\n<h2 id=\"8-edit-a-formula\"><a href=\"#8-edit-a-formula\" class=\"headerlink\" title=\"8. edit a formula\"></a>8. edit a formula</h2><p>$$E=mc^2$$    use $$</p>\n<h2 id=\"9-draw-a-flow-picture\"><a href=\"#9-draw-a-flow-picture\" class=\"headerlink\" title=\"9.draw a flow picture\"></a>9.draw a flow picture</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">st=&gt;start: Start</span><br><span class=\"line\">op=&gt;operation: Your Opreation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<p>[^LaTex]: support <strong>LaTex</strong> edit and display, such as: $\\sum_{i=1}^n a_i=0$, visit <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a> for more information.<br>[^code]: include Java, Python, JavaScript etc.</p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<ul>\n<li><a href=\"#背景色灰\">背景色灰</a></li>\n<li><a href=\"#实现页面内跳转\">实现页面内跳转</a></li>\n<li><a href=\"#删除线\">删除线</a></li>\n<li><a href=\"#插入图片\">插入图片</a></li>\n<li><a href=\"#标记文本颜色\">标记文本颜色</a><br>20171224之后补充但未作整理。本来可以将每个语法分成多个博客离散列出，但后来出于对博客页面和知识索引的考虑，还是放在一个post内，也许将来会又变动，但是先不提前优化。</li>\n</ul>\n</blockquote>\n<h2 id=\"背景色灰\"><a href=\"#背景色灰\" class=\"headerlink\" title=\"背景色灰\"></a>背景色灰</h2><p>`gray background`</p>\n<p><code>gray background</code></p>\n<p>背景灰可以代替 反斜杠 \\,去完成注释。这个很好用。原理估计和代码块差不多吧。</p>\n<h2 id=\"实现页面内跳转\"><a href=\"#实现页面内跳转\" class=\"headerlink\" title=\"实现页面内跳转\"></a>实现页面内跳转</h2><p><code>[create an anchor](#anchors-in-markdown)</code></p>\n<p><a href=\"#anchors-in-markdown\">create an anchor</a></p>\n<p>\\===========<br>refwebsite:</p>\n<p><a href=\"https://gist.github.com/asabaylus/3071099\" target=\"_blank\" rel=\"noopener\">Anchors in Markdown</a></p>\n<h3 id=\"anchors-in-markdown\"><a href=\"#anchors-in-markdown\" class=\"headerlink\" title=\"anchors in markdown\"></a>anchors in markdown</h3><pre><code>skip into this title\n</code></pre><h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p><code>~~删除一句~~</code><br><del>删除一句</del></p>\n<p><code>~~删除</code><br><code>多行~~</code><br><del>删除<br>多行</del></p>\n<p><code>~~删除包含语法[mituh’s notes][timtingwei.github.io]~~</code><br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>\n<p>====<br>不知道还有其他方法否？</p>\n<p>\\==========<br>refwebsite:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Markdown</a></p>\n<h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><p><code>![Logo](/images/logo.png)</code><br><img src=\"/images/logo.png\" alt=\"Logo\"></p>\n<p>\\===========<br>refwebsite:</p>\n<p>hexo图片的其他用法：<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/asset-folders.html</a><br><a href=\"https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo\" target=\"_blank\" rel=\"noopener\">https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo</a></p>\n<h2 id=\"标记文本颜色\"><a href=\"#标记文本颜色\" class=\"headerlink\" title=\"标记文本颜色\"></a>标记文本颜色</h2><p><code>&lt;span style=&quot;color:blue&quot;&gt;*This is Blue italic.*&lt;/span&gt;</code><br><span style=\"color:blue\"><em>This is Blue italic.</em></span></p>\n<p><code>&lt;span style=&quot;color:red&quot;&gt;**This is Red Bold.**&lt;/span&gt;</code><br><span style=\"color:red\"><strong>This is Red Bold.</strong></span></p>\n<p>相比之下,<br>italic 给人轻松的感觉，<br>blod有种警告意味。</p>\n<p>\\===========<br>refwebsite:</p>\n<p><a href=\"https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown</a></p>\n<h2 id=\"next-one\"><a href=\"#next-one\" class=\"headerlink\" title=\"next one ?\"></a>next one ?</h2><hr>\n<p>以上是我的个人笔记收录，markdown主要用来写笔记和写博客<br>其他有什么好玩的用法，欢迎指教。<br>timtingwei#hotmail.com</p>\n"},{"title":"添加git bash到右键菜单","date":"2017-11-23T03:52:34.000Z","_content":"\n## issue:\n\n因为.git文件所在的目录如下：\n> C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d\n\n当在bash中cd到该目录时：\n```\n$ cd C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d\nbash: syntax error near unexpected token `('\n```\n试图通过右键进入bash\n\n## hack:\n\n> 1. CMD中输入\"regedit\"\n> 2. 切换到 HKEY_CURRENT_USER\\SOFTWARE\\Classes\\Directory\\Background\\shell\n> 3. 右键点击 \"shell\" 选择 New > Key. 将KEY命名为 \"Bash\"\n> 4. 设置值为 \"open in Bash\" \n> 5. 创建一个新的KEY命名为\"command\". 设置值为git-bash.exe 路径.\n\n此时在文件夹中右键, 出现Open in bash选项.\n\n以上为通过注册表添加bash到右键的方法，但还是建议重装git\n\n------\n\nreference:\n[1]: https://www.zhihu.com/question/48091139 @轩辕Rowboat的回答\n","source":"_posts/add-git-bash-to-right-click-menu.md","raw":"---\ntitle: 添加git bash到右键菜单 \ndate: 2017-11-23 11:52:34\ntags:\n- git\n---\n\n## issue:\n\n因为.git文件所在的目录如下：\n> C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d\n\n当在bash中cd到该目录时：\n```\n$ cd C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d\nbash: syntax error near unexpected token `('\n```\n试图通过右键进入bash\n\n## hack:\n\n> 1. CMD中输入\"regedit\"\n> 2. 切换到 HKEY_CURRENT_USER\\SOFTWARE\\Classes\\Directory\\Background\\shell\n> 3. 右键点击 \"shell\" 选择 New > Key. 将KEY命名为 \"Bash\"\n> 4. 设置值为 \"open in Bash\" \n> 5. 创建一个新的KEY命名为\"command\". 设置值为git-bash.exe 路径.\n\n此时在文件夹中右键, 出现Open in bash选项.\n\n以上为通过注册表添加bash到右键的方法，但还是建议重装git\n\n------\n\nreference:\n[1]: https://www.zhihu.com/question/48091139 @轩辕Rowboat的回答\n","slug":"add-git-bash-to-right-click-menu","published":1,"updated":"2018-06-19T16:15:03.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyix0003k8mf6njzud0o","content":"<h2 id=\"issue\"><a href=\"#issue\" class=\"headerlink\" title=\"issue:\"></a>issue:</h2><p>因为.git文件所在的目录如下：</p>\n<blockquote>\n<p>C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d</p>\n</blockquote>\n<p>当在bash中cd到该目录时：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d</span><br><span class=\"line\">bash: syntax error near unexpected token `(&apos;</span><br></pre></td></tr></table></figure></p>\n<p>试图通过右键进入bash</p>\n<h2 id=\"hack\"><a href=\"#hack\" class=\"headerlink\" title=\"hack:\"></a>hack:</h2><blockquote>\n<ol>\n<li>CMD中输入”regedit”</li>\n<li>切换到 HKEY_CURRENT_USER\\SOFTWARE\\Classes\\Directory\\Background\\shell</li>\n<li>右键点击 “shell” 选择 New &gt; Key. 将KEY命名为 “Bash”</li>\n<li>设置值为 “open in Bash” </li>\n<li>创建一个新的KEY命名为”command”. 设置值为git-bash.exe 路径.</li>\n</ol>\n</blockquote>\n<p>此时在文件夹中右键, 出现Open in bash选项.</p>\n<p>以上为通过注册表添加bash到右键的方法，但还是建议重装git</p>\n<hr>\n<p>reference:<br>[1]: <a href=\"https://www.zhihu.com/question/48091139\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/48091139</a> @轩辕Rowboat的回答</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"issue\"><a href=\"#issue\" class=\"headerlink\" title=\"issue:\"></a>issue:</h2><p>因为.git文件所在的目录如下：</p>\n<blockquote>\n<p>C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d</p>\n</blockquote>\n<p>当在bash中cd到该目录时：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\d3d</span><br><span class=\"line\">bash: syntax error near unexpected token `(&apos;</span><br></pre></td></tr></table></figure></p>\n<p>试图通过右键进入bash</p>\n<h2 id=\"hack\"><a href=\"#hack\" class=\"headerlink\" title=\"hack:\"></a>hack:</h2><blockquote>\n<ol>\n<li>CMD中输入”regedit”</li>\n<li>切换到 HKEY_CURRENT_USER\\SOFTWARE\\Classes\\Directory\\Background\\shell</li>\n<li>右键点击 “shell” 选择 New &gt; Key. 将KEY命名为 “Bash”</li>\n<li>设置值为 “open in Bash” </li>\n<li>创建一个新的KEY命名为”command”. 设置值为git-bash.exe 路径.</li>\n</ol>\n</blockquote>\n<p>此时在文件夹中右键, 出现Open in bash选项.</p>\n<p>以上为通过注册表添加bash到右键的方法，但还是建议重装git</p>\n<hr>\n<p>reference:<br>[1]: <a href=\"https://www.zhihu.com/question/48091139\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/48091139</a> @轩辕Rowboat的回答</p>\n"},{"title":"Mac添加PATH环境变量","date":"2018-06-19T17:15:47.000Z","_content":"\n用常规方法安装好npm之后, \n```sh\n$ npm --version\nbash: npm: commmand not found\n```\n\n以为是没有安装后，换用brewhome[https://brew.sh/index_zh-cn.html](参考 - brewhome官网)进行安装\n```sh\n$ brew --version\n```\n依旧 command not found\n\n注意到，warning:\n```sh\n==> Cleaning up /Library/Caches/Homebrew...\n==> Migrating /Library/Caches/Homebrew to /Users/htwt/Library/Caches/Homebrew...\n==> Deleting /Library/Caches/Homebrew...\nAlready up-to-date.\nWarning: /usr/local/bin is not in your PATH.\n==> Installation successful!\n```\n\n```\n$ echo $PATH\n/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9\n```\n\n需要手动添加一个PATH\n```sh\n$ export PATH=/usr/local/bin:$PATH\n$ echo $PATH\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9\n```\n\n现在npm, brew都可以直接用了\n","source":"_posts/append-path-on-mac.md","raw":"---\ntitle: Mac添加PATH环境变量\ndate: 2018-06-20 01:15:47\ntags: shell \n---\n\n用常规方法安装好npm之后, \n```sh\n$ npm --version\nbash: npm: commmand not found\n```\n\n以为是没有安装后，换用brewhome[https://brew.sh/index_zh-cn.html](参考 - brewhome官网)进行安装\n```sh\n$ brew --version\n```\n依旧 command not found\n\n注意到，warning:\n```sh\n==> Cleaning up /Library/Caches/Homebrew...\n==> Migrating /Library/Caches/Homebrew to /Users/htwt/Library/Caches/Homebrew...\n==> Deleting /Library/Caches/Homebrew...\nAlready up-to-date.\nWarning: /usr/local/bin is not in your PATH.\n==> Installation successful!\n```\n\n```\n$ echo $PATH\n/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9\n```\n\n需要手动添加一个PATH\n```sh\n$ export PATH=/usr/local/bin:$PATH\n$ echo $PATH\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9\n```\n\n现在npm, brew都可以直接用了\n","slug":"append-path-on-mac","published":1,"updated":"2018-06-19T17:18:32.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyj30005k8mf9ucgs3ta","content":"<p>用常规方法安装好npm之后,<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm --version</span><br><span class=\"line\">bash: npm: commmand not found</span><br></pre></td></tr></table></figure></p>\n<p>以为是没有安装后，换用brewhome<a href=\"参考 - brewhome官网\">https://brew.sh/index_zh-cn.html</a>进行安装<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew --version</span><br></pre></td></tr></table></figure></p>\n<p>依旧 command not found</p>\n<p>注意到，warning:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">==&gt; Cleaning up /Library/Caches/Homebrew...</span><br><span class=\"line\">==&gt; Migrating /Library/Caches/Homebrew to /Users/htwt/Library/Caches/Homebrew...</span><br><span class=\"line\">==&gt; Deleting /Library/Caches/Homebrew...</span><br><span class=\"line\">Already up-to-date.</span><br><span class=\"line\">Warning: /usr/<span class=\"built_in\">local</span>/bin is not <span class=\"keyword\">in</span> your PATH.</span><br><span class=\"line\">==&gt; Installation successful!</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ echo $PATH</span><br><span class=\"line\">/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure>\n<p>需要手动添加一个PATH<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">export</span> PATH=/usr/<span class=\"built_in\">local</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure></p>\n<p>现在npm, brew都可以直接用了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用常规方法安装好npm之后,<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm --version</span><br><span class=\"line\">bash: npm: commmand not found</span><br></pre></td></tr></table></figure></p>\n<p>以为是没有安装后，换用brewhome<a href=\"参考 - brewhome官网\">https://brew.sh/index_zh-cn.html</a>进行安装<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew --version</span><br></pre></td></tr></table></figure></p>\n<p>依旧 command not found</p>\n<p>注意到，warning:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">==&gt; Cleaning up /Library/Caches/Homebrew...</span><br><span class=\"line\">==&gt; Migrating /Library/Caches/Homebrew to /Users/htwt/Library/Caches/Homebrew...</span><br><span class=\"line\">==&gt; Deleting /Library/Caches/Homebrew...</span><br><span class=\"line\">Already up-to-date.</span><br><span class=\"line\">Warning: /usr/<span class=\"built_in\">local</span>/bin is not <span class=\"keyword\">in</span> your PATH.</span><br><span class=\"line\">==&gt; Installation successful!</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ echo $PATH</span><br><span class=\"line\">/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure>\n<p>需要手动添加一个PATH<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">export</span> PATH=/usr/<span class=\"built_in\">local</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"variable\">$PATH</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure></p>\n<p>现在npm, brew都可以直接用了</p>\n"},{"title":"architecture-english-temp2","date":"2018-01-23T11:36:32.000Z","_content":"\n# 1. 完型填空(10%)\n## 绿色建筑\n生态 ecological \n可循环的 recycle\n环境的，景观 landscape\n## 建筑的构成\n梁 beam\n剖面 section\n柱子 column\n覆盖 cover/ blanket\n\n# 2. 词义配对(20%)\n(wood - timber)\n(aesthetic - creative)\n(hospital - medical institution)\n(innovative - originality)\n(site plan - situation plan)\n(art - meaningful)   **ERROR::creative piece**\n(stone thick wall - ???) 厚的石墙  **ERROR::masonry wide division**\n(architecture experience - architecture apprehension) 理解，领悟,感觉\n(transform - convert) 改变\n(creative - ??)   **ERROR::ingenious**\n(perception - understanding) 知觉，理解\n(guest house - visit house) 参观房间\n(commercial enterpise - ind?? ) 商业的  **ERROR::industrial**\n\n# 3. 词义搭配中文(10%)\n给出单词，选择中文单词。\n\nBeam - 梁\nAesthetic - 美学\nArchitect - 建筑师\nComposition - 构成\nStaircase - 楼梯\nMulti-story building - 多层建筑\nBalcony - ??    **ERROR::Balcony - 阳台**\nScheme - 方案\nFacade - 立面\nMaterial - 材料\nSubdued architecture - ??   **ERROR:: 平缓的建筑**\nExit - 安全出口\nEntrance - 玄关\nWheelchair ramp - 轮椅坡道\nResidential building - 住宅\n\n# 4. 英译中(10%)\n\n## 1、第一篇原文：\n\tDB:how would you describe your architectural approach?\n\tPV：I'm extremely concerned by the fact that design and architecture has a social impact.\n\twe are called to utilize the resources that are not renewable:space,time,money,life...\n\tbecause in order to design a building and to build it you need years. so, I believe that\n\tmy attitudes are extremely serious and conscious about all those elements. I am not someone\n\twho is playing with the project, or doing any'fun stuff, if you like. I prefer to achieve\n\tsomething that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.\n## 2、第一篇译文:\n\tDB：你如何描述你的建筑观点\n\t我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。\n## 3、第二篇原文：\n\tDB:do you think there is an increasingly 'globalized approach' To architecture?\n\tDC:\n\tthere shouldn't be. a building can last for a very long time.\n\tit's fixed to the ground and it contributes to the idea of 'a place'.\n\thowever contemporary we feel that we are, we still want to find different characteristics in different places. \n\tif we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. \n\tI find it very weak for an architect to disregard the history and  culture of a city and say ' I have an international style'. \n\tthere's absolutely no intellectual justification for that. \n\tit's the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.\n\tThis romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that's where character is important, we have to be careful no to just create bland products.\n## 4、第二篇译文:\n\t你如何评价越来越多的全球化？\n不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。\n\n\n# Part1, 1, 2, 3, 4错误总结\n\n(art - meaningful)   **ERROR::creative piece**\n(stone thick wall - ???) 厚的石墙  **ERROR::masonry wide division**\n(creative - ??)   **ERROR::ingenious**\n(commercial enterpise - ind?? ) 商业的  **ERROR::industrial**\n\nBalcony - ??    **ERROR::Balcony - 阳台**\nSubdued architecture - ??   **ERROR:: 平缓的建筑**\n\nit's the equivalent of having no variation in cuisine, 这就像没有变换的烹饪\n\n--------------\n\n#  part2 5, 7总结\n\n# 5. 看图描述(15%)\n10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分\n\nSou Fujimoto N HOUSE\n\n1, A home for two plus a dog.    // 两个人的家加上一只狗。\n2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。\n3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。\n4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。\n5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活\n\n\n6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动\n7, And this house fuses with the environment since there are green trees embed in it's shell.    // 与环境融合, 因为有树在其中.\n8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念\n9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间\n10, But it's special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。\n11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。\n\n// 两个人的家加上一只狗。\n// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。\n// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。\n// 第二外壳在覆盖的室外空间内封闭有限的空间。\n// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。\n// 方案平面灵活，像在场地上流动。\n// 与环境融合, 因为有树在其中。\n// 作为一个实验建筑, N house提出未来住宅的理念。\n// 传统住宅设计, 倾向于分开外部和内部空间。\n// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。\n// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。\n\n\n## 自我批改\nA house for two plus a dog.\nThe house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.\n**RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.**\nThe outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).\nThe second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~\nThe third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)\n\nThe situation plan is flexiable, and seems flowing over the small ground.\nAnd the building fuses with environment since there are green trees embed in the shell.\nAs an exam architecture, architect propose an idea about features of future ~????house.~ (residence)\nIn traditional design prosess, architects perfer to seperate of interior space and external space.\nBut (it's) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).\nThree shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)\n\nThree shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.\n\n\nThe house for two plus a dog.\nThe house itself is comprised of three shells of progressive size nested inside one another.\nThe outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.\nSecond shells encloses a limited space insided the coverd outdoor space.\nThird shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.\n\nThe (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape\n\n\n\n \n# 6. 中译英(20%)\n给中文采访的文章，生态学的，绿色建筑；英文回答5个问题\n尽量多写。\n\n# 7. 描述(15%)\n家的平面或喜欢的建筑。\n10句话。每句1分。\n画两张图。1张图2.5分。\n\n\nMention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it's a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.\n\nEnter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.\n\n\n客厅 living room\n主卧 master bedroom\n客卧 guest bedroom\n卫生间 bathroom\n阳台 balcony\n厨房 kitchen\n餐厅 dining room\n书房 study room\n天台 roof\n门廊 porch\n储物室 store room\n衣帽间 locker room\n一层平面 ground floor plan\n","source":"_posts/architecture-english-temp2.md","raw":"---\ntitle: architecture-english-temp2\ndate: 2018-01-23 19:36:32\ntags:\n---\n\n# 1. 完型填空(10%)\n## 绿色建筑\n生态 ecological \n可循环的 recycle\n环境的，景观 landscape\n## 建筑的构成\n梁 beam\n剖面 section\n柱子 column\n覆盖 cover/ blanket\n\n# 2. 词义配对(20%)\n(wood - timber)\n(aesthetic - creative)\n(hospital - medical institution)\n(innovative - originality)\n(site plan - situation plan)\n(art - meaningful)   **ERROR::creative piece**\n(stone thick wall - ???) 厚的石墙  **ERROR::masonry wide division**\n(architecture experience - architecture apprehension) 理解，领悟,感觉\n(transform - convert) 改变\n(creative - ??)   **ERROR::ingenious**\n(perception - understanding) 知觉，理解\n(guest house - visit house) 参观房间\n(commercial enterpise - ind?? ) 商业的  **ERROR::industrial**\n\n# 3. 词义搭配中文(10%)\n给出单词，选择中文单词。\n\nBeam - 梁\nAesthetic - 美学\nArchitect - 建筑师\nComposition - 构成\nStaircase - 楼梯\nMulti-story building - 多层建筑\nBalcony - ??    **ERROR::Balcony - 阳台**\nScheme - 方案\nFacade - 立面\nMaterial - 材料\nSubdued architecture - ??   **ERROR:: 平缓的建筑**\nExit - 安全出口\nEntrance - 玄关\nWheelchair ramp - 轮椅坡道\nResidential building - 住宅\n\n# 4. 英译中(10%)\n\n## 1、第一篇原文：\n\tDB:how would you describe your architectural approach?\n\tPV：I'm extremely concerned by the fact that design and architecture has a social impact.\n\twe are called to utilize the resources that are not renewable:space,time,money,life...\n\tbecause in order to design a building and to build it you need years. so, I believe that\n\tmy attitudes are extremely serious and conscious about all those elements. I am not someone\n\twho is playing with the project, or doing any'fun stuff, if you like. I prefer to achieve\n\tsomething that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.\n## 2、第一篇译文:\n\tDB：你如何描述你的建筑观点\n\t我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。\n## 3、第二篇原文：\n\tDB:do you think there is an increasingly 'globalized approach' To architecture?\n\tDC:\n\tthere shouldn't be. a building can last for a very long time.\n\tit's fixed to the ground and it contributes to the idea of 'a place'.\n\thowever contemporary we feel that we are, we still want to find different characteristics in different places. \n\tif we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. \n\tI find it very weak for an architect to disregard the history and  culture of a city and say ' I have an international style'. \n\tthere's absolutely no intellectual justification for that. \n\tit's the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.\n\tThis romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that's where character is important, we have to be careful no to just create bland products.\n## 4、第二篇译文:\n\t你如何评价越来越多的全球化？\n不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。\n\n\n# Part1, 1, 2, 3, 4错误总结\n\n(art - meaningful)   **ERROR::creative piece**\n(stone thick wall - ???) 厚的石墙  **ERROR::masonry wide division**\n(creative - ??)   **ERROR::ingenious**\n(commercial enterpise - ind?? ) 商业的  **ERROR::industrial**\n\nBalcony - ??    **ERROR::Balcony - 阳台**\nSubdued architecture - ??   **ERROR:: 平缓的建筑**\n\nit's the equivalent of having no variation in cuisine, 这就像没有变换的烹饪\n\n--------------\n\n#  part2 5, 7总结\n\n# 5. 看图描述(15%)\n10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分\n\nSou Fujimoto N HOUSE\n\n1, A home for two plus a dog.    // 两个人的家加上一只狗。\n2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。\n3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。\n4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。\n5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活\n\n\n6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动\n7, And this house fuses with the environment since there are green trees embed in it's shell.    // 与环境融合, 因为有树在其中.\n8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念\n9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间\n10, But it's special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。\n11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。\n\n// 两个人的家加上一只狗。\n// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。\n// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。\n// 第二外壳在覆盖的室外空间内封闭有限的空间。\n// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。\n// 方案平面灵活，像在场地上流动。\n// 与环境融合, 因为有树在其中。\n// 作为一个实验建筑, N house提出未来住宅的理念。\n// 传统住宅设计, 倾向于分开外部和内部空间。\n// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。\n// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。\n\n\n## 自我批改\nA house for two plus a dog.\nThe house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.\n**RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.**\nThe outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).\nThe second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~\nThe third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)\n\nThe situation plan is flexiable, and seems flowing over the small ground.\nAnd the building fuses with environment since there are green trees embed in the shell.\nAs an exam architecture, architect propose an idea about features of future ~????house.~ (residence)\nIn traditional design prosess, architects perfer to seperate of interior space and external space.\nBut (it's) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).\nThree shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)\n\nThree shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.\n\n\nThe house for two plus a dog.\nThe house itself is comprised of three shells of progressive size nested inside one another.\nThe outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.\nSecond shells encloses a limited space insided the coverd outdoor space.\nThird shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.\n\nThe (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape\n\n\n\n \n# 6. 中译英(20%)\n给中文采访的文章，生态学的，绿色建筑；英文回答5个问题\n尽量多写。\n\n# 7. 描述(15%)\n家的平面或喜欢的建筑。\n10句话。每句1分。\n画两张图。1张图2.5分。\n\n\nMention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it's a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.\n\nEnter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.\n\n\n客厅 living room\n主卧 master bedroom\n客卧 guest bedroom\n卫生间 bathroom\n阳台 balcony\n厨房 kitchen\n餐厅 dining room\n书房 study room\n天台 roof\n门廊 porch\n储物室 store room\n衣帽间 locker room\n一层平面 ground floor plan\n","slug":"architecture-english-temp2","published":1,"updated":"2018-06-19T16:15:03.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyj60006k8mfl3spruuw","content":"<h1 id=\"1-完型填空-10\"><a href=\"#1-完型填空-10\" class=\"headerlink\" title=\"1. 完型填空(10%)\"></a>1. 完型填空(10%)</h1><h2 id=\"绿色建筑\"><a href=\"#绿色建筑\" class=\"headerlink\" title=\"绿色建筑\"></a>绿色建筑</h2><p>生态 ecological<br>可循环的 recycle<br>环境的，景观 landscape</p>\n<h2 id=\"建筑的构成\"><a href=\"#建筑的构成\" class=\"headerlink\" title=\"建筑的构成\"></a>建筑的构成</h2><p>梁 beam<br>剖面 section<br>柱子 column<br>覆盖 cover/ blanket</p>\n<h1 id=\"2-词义配对-20\"><a href=\"#2-词义配对-20\" class=\"headerlink\" title=\"2. 词义配对(20%)\"></a>2. 词义配对(20%)</h1><p>(wood - timber)<br>(aesthetic - creative)<br>(hospital - medical institution)<br>(innovative - originality)<br>(site plan - situation plan)<br>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(architecture experience - architecture apprehension) 理解，领悟,感觉<br>(transform - convert) 改变<br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(perception - understanding) 知觉，理解<br>(guest house - visit house) 参观房间<br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>\n<h1 id=\"3-词义搭配中文-10\"><a href=\"#3-词义搭配中文-10\" class=\"headerlink\" title=\"3. 词义搭配中文(10%)\"></a>3. 词义搭配中文(10%)</h1><p>给出单词，选择中文单词。</p>\n<p>Beam - 梁<br>Aesthetic - 美学<br>Architect - 建筑师<br>Composition - 构成<br>Staircase - 楼梯<br>Multi-story building - 多层建筑<br>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Scheme - 方案<br>Facade - 立面<br>Material - 材料<br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong><br>Exit - 安全出口<br>Entrance - 玄关<br>Wheelchair ramp - 轮椅坡道<br>Residential building - 住宅</p>\n<h1 id=\"4-英译中-10\"><a href=\"#4-英译中-10\" class=\"headerlink\" title=\"4. 英译中(10%)\"></a>4. 英译中(10%)</h1><h2 id=\"1、第一篇原文：\"><a href=\"#1、第一篇原文：\" class=\"headerlink\" title=\"1、第一篇原文：\"></a>1、第一篇原文：</h2><pre><code>DB:how would you describe your architectural approach?\nPV：I&apos;m extremely concerned by the fact that design and architecture has a social impact.\nwe are called to utilize the resources that are not renewable:space,time,money,life...\nbecause in order to design a building and to build it you need years. so, I believe that\nmy attitudes are extremely serious and conscious about all those elements. I am not someone\nwho is playing with the project, or doing any&apos;fun stuff, if you like. I prefer to achieve\nsomething that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.\n</code></pre><h2 id=\"2、第一篇译文\"><a href=\"#2、第一篇译文\" class=\"headerlink\" title=\"2、第一篇译文:\"></a>2、第一篇译文:</h2><pre><code>DB：你如何描述你的建筑观点\n我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。\n</code></pre><h2 id=\"3、第二篇原文：\"><a href=\"#3、第二篇原文：\" class=\"headerlink\" title=\"3、第二篇原文：\"></a>3、第二篇原文：</h2><pre><code>DB:do you think there is an increasingly &apos;globalized approach&apos; To architecture?\nDC:\nthere shouldn&apos;t be. a building can last for a very long time.\nit&apos;s fixed to the ground and it contributes to the idea of &apos;a place&apos;.\nhowever contemporary we feel that we are, we still want to find different characteristics in different places. \nif we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. \nI find it very weak for an architect to disregard the history and  culture of a city and say &apos; I have an international style&apos;. \nthere&apos;s absolutely no intellectual justification for that. \nit&apos;s the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.\nThis romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that&apos;s where character is important, we have to be careful no to just create bland products.\n</code></pre><h2 id=\"4、第二篇译文\"><a href=\"#4、第二篇译文\" class=\"headerlink\" title=\"4、第二篇译文:\"></a>4、第二篇译文:</h2><pre><code>你如何评价越来越多的全球化？\n</code></pre><p>不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。</p>\n<h1 id=\"Part1-1-2-3-4错误总结\"><a href=\"#Part1-1-2-3-4错误总结\" class=\"headerlink\" title=\"Part1, 1, 2, 3, 4错误总结\"></a>Part1, 1, 2, 3, 4错误总结</h1><p>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>\n<p>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong></p>\n<p>it’s the equivalent of having no variation in cuisine, 这就像没有变换的烹饪</p>\n<hr>\n<h1 id=\"part2-5-7总结\"><a href=\"#part2-5-7总结\" class=\"headerlink\" title=\"part2 5, 7总结\"></a>part2 5, 7总结</h1><h1 id=\"5-看图描述-15\"><a href=\"#5-看图描述-15\" class=\"headerlink\" title=\"5. 看图描述(15%)\"></a>5. 看图描述(15%)</h1><p>10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分</p>\n<p>Sou Fujimoto N HOUSE</p>\n<p>1, A home for two plus a dog.    // 两个人的家加上一只狗。<br>2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。<br>5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活</p>\n<p>6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动<br>7, And this house fuses with the environment since there are green trees embed in it’s shell.    // 与环境融合, 因为有树在其中.<br>8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念<br>9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间<br>10, But it’s special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>\n<p>// 两个人的家加上一只狗。<br>// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>// 第二外壳在覆盖的室外空间内封闭有限的空间。<br>// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。<br>// 方案平面灵活，像在场地上流动。<br>// 与环境融合, 因为有树在其中。<br>// 作为一个实验建筑, N house提出未来住宅的理念。<br>// 传统住宅设计, 倾向于分开外部和内部空间。<br>// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>\n<h2 id=\"自我批改\"><a href=\"#自我批改\" class=\"headerlink\" title=\"自我批改\"></a>自我批改</h2><p>A house for two plus a dog.<br>The house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.<br><strong>RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.</strong><br>The outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).<br>The second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~<br>The third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)</p>\n<p>The situation plan is flexiable, and seems flowing over the small ground.<br>And the building fuses with environment since there are green trees embed in the shell.<br>As an exam architecture, architect propose an idea about features of future ~????house.~ (residence)<br>In traditional design prosess, architects perfer to seperate of interior space and external space.<br>But (it’s) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).<br>Three shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)</p>\n<p>Three shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.</p>\n<p>The house for two plus a dog.<br>The house itself is comprised of three shells of progressive size nested inside one another.<br>The outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.<br>Second shells encloses a limited space insided the coverd outdoor space.<br>Third shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.</p>\n<p>The (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape</p>\n<h1 id=\"6-中译英-20\"><a href=\"#6-中译英-20\" class=\"headerlink\" title=\"6. 中译英(20%)\"></a>6. 中译英(20%)</h1><p>给中文采访的文章，生态学的，绿色建筑；英文回答5个问题<br>尽量多写。</p>\n<h1 id=\"7-描述-15\"><a href=\"#7-描述-15\" class=\"headerlink\" title=\"7. 描述(15%)\"></a>7. 描述(15%)</h1><p>家的平面或喜欢的建筑。<br>10句话。每句1分。<br>画两张图。1张图2.5分。</p>\n<p>Mention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it’s a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.</p>\n<p>Enter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.</p>\n<p>客厅 living room<br>主卧 master bedroom<br>客卧 guest bedroom<br>卫生间 bathroom<br>阳台 balcony<br>厨房 kitchen<br>餐厅 dining room<br>书房 study room<br>天台 roof<br>门廊 porch<br>储物室 store room<br>衣帽间 locker room<br>一层平面 ground floor plan</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-完型填空-10\"><a href=\"#1-完型填空-10\" class=\"headerlink\" title=\"1. 完型填空(10%)\"></a>1. 完型填空(10%)</h1><h2 id=\"绿色建筑\"><a href=\"#绿色建筑\" class=\"headerlink\" title=\"绿色建筑\"></a>绿色建筑</h2><p>生态 ecological<br>可循环的 recycle<br>环境的，景观 landscape</p>\n<h2 id=\"建筑的构成\"><a href=\"#建筑的构成\" class=\"headerlink\" title=\"建筑的构成\"></a>建筑的构成</h2><p>梁 beam<br>剖面 section<br>柱子 column<br>覆盖 cover/ blanket</p>\n<h1 id=\"2-词义配对-20\"><a href=\"#2-词义配对-20\" class=\"headerlink\" title=\"2. 词义配对(20%)\"></a>2. 词义配对(20%)</h1><p>(wood - timber)<br>(aesthetic - creative)<br>(hospital - medical institution)<br>(innovative - originality)<br>(site plan - situation plan)<br>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(architecture experience - architecture apprehension) 理解，领悟,感觉<br>(transform - convert) 改变<br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(perception - understanding) 知觉，理解<br>(guest house - visit house) 参观房间<br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>\n<h1 id=\"3-词义搭配中文-10\"><a href=\"#3-词义搭配中文-10\" class=\"headerlink\" title=\"3. 词义搭配中文(10%)\"></a>3. 词义搭配中文(10%)</h1><p>给出单词，选择中文单词。</p>\n<p>Beam - 梁<br>Aesthetic - 美学<br>Architect - 建筑师<br>Composition - 构成<br>Staircase - 楼梯<br>Multi-story building - 多层建筑<br>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Scheme - 方案<br>Facade - 立面<br>Material - 材料<br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong><br>Exit - 安全出口<br>Entrance - 玄关<br>Wheelchair ramp - 轮椅坡道<br>Residential building - 住宅</p>\n<h1 id=\"4-英译中-10\"><a href=\"#4-英译中-10\" class=\"headerlink\" title=\"4. 英译中(10%)\"></a>4. 英译中(10%)</h1><h2 id=\"1、第一篇原文：\"><a href=\"#1、第一篇原文：\" class=\"headerlink\" title=\"1、第一篇原文：\"></a>1、第一篇原文：</h2><pre><code>DB:how would you describe your architectural approach?\nPV：I&apos;m extremely concerned by the fact that design and architecture has a social impact.\nwe are called to utilize the resources that are not renewable:space,time,money,life...\nbecause in order to design a building and to build it you need years. so, I believe that\nmy attitudes are extremely serious and conscious about all those elements. I am not someone\nwho is playing with the project, or doing any&apos;fun stuff, if you like. I prefer to achieve\nsomething that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.\n</code></pre><h2 id=\"2、第一篇译文\"><a href=\"#2、第一篇译文\" class=\"headerlink\" title=\"2、第一篇译文:\"></a>2、第一篇译文:</h2><pre><code>DB：你如何描述你的建筑观点\n我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。\n</code></pre><h2 id=\"3、第二篇原文：\"><a href=\"#3、第二篇原文：\" class=\"headerlink\" title=\"3、第二篇原文：\"></a>3、第二篇原文：</h2><pre><code>DB:do you think there is an increasingly &apos;globalized approach&apos; To architecture?\nDC:\nthere shouldn&apos;t be. a building can last for a very long time.\nit&apos;s fixed to the ground and it contributes to the idea of &apos;a place&apos;.\nhowever contemporary we feel that we are, we still want to find different characteristics in different places. \nif we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. \nI find it very weak for an architect to disregard the history and  culture of a city and say &apos; I have an international style&apos;. \nthere&apos;s absolutely no intellectual justification for that. \nit&apos;s the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.\nThis romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that&apos;s where character is important, we have to be careful no to just create bland products.\n</code></pre><h2 id=\"4、第二篇译文\"><a href=\"#4、第二篇译文\" class=\"headerlink\" title=\"4、第二篇译文:\"></a>4、第二篇译文:</h2><pre><code>你如何评价越来越多的全球化？\n</code></pre><p>不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。</p>\n<h1 id=\"Part1-1-2-3-4错误总结\"><a href=\"#Part1-1-2-3-4错误总结\" class=\"headerlink\" title=\"Part1, 1, 2, 3, 4错误总结\"></a>Part1, 1, 2, 3, 4错误总结</h1><p>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>\n<p>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong></p>\n<p>it’s the equivalent of having no variation in cuisine, 这就像没有变换的烹饪</p>\n<hr>\n<h1 id=\"part2-5-7总结\"><a href=\"#part2-5-7总结\" class=\"headerlink\" title=\"part2 5, 7总结\"></a>part2 5, 7总结</h1><h1 id=\"5-看图描述-15\"><a href=\"#5-看图描述-15\" class=\"headerlink\" title=\"5. 看图描述(15%)\"></a>5. 看图描述(15%)</h1><p>10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分</p>\n<p>Sou Fujimoto N HOUSE</p>\n<p>1, A home for two plus a dog.    // 两个人的家加上一只狗。<br>2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。<br>5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活</p>\n<p>6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动<br>7, And this house fuses with the environment since there are green trees embed in it’s shell.    // 与环境融合, 因为有树在其中.<br>8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念<br>9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间<br>10, But it’s special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>\n<p>// 两个人的家加上一只狗。<br>// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>// 第二外壳在覆盖的室外空间内封闭有限的空间。<br>// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。<br>// 方案平面灵活，像在场地上流动。<br>// 与环境融合, 因为有树在其中。<br>// 作为一个实验建筑, N house提出未来住宅的理念。<br>// 传统住宅设计, 倾向于分开外部和内部空间。<br>// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>\n<h2 id=\"自我批改\"><a href=\"#自我批改\" class=\"headerlink\" title=\"自我批改\"></a>自我批改</h2><p>A house for two plus a dog.<br>The house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.<br><strong>RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.</strong><br>The outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).<br>The second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~<br>The third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)</p>\n<p>The situation plan is flexiable, and seems flowing over the small ground.<br>And the building fuses with environment since there are green trees embed in the shell.<br>As an exam architecture, architect propose an idea about features of future ~????house.~ (residence)<br>In traditional design prosess, architects perfer to seperate of interior space and external space.<br>But (it’s) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).<br>Three shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)</p>\n<p>Three shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.</p>\n<p>The house for two plus a dog.<br>The house itself is comprised of three shells of progressive size nested inside one another.<br>The outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.<br>Second shells encloses a limited space insided the coverd outdoor space.<br>Third shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.</p>\n<p>The (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape</p>\n<h1 id=\"6-中译英-20\"><a href=\"#6-中译英-20\" class=\"headerlink\" title=\"6. 中译英(20%)\"></a>6. 中译英(20%)</h1><p>给中文采访的文章，生态学的，绿色建筑；英文回答5个问题<br>尽量多写。</p>\n<h1 id=\"7-描述-15\"><a href=\"#7-描述-15\" class=\"headerlink\" title=\"7. 描述(15%)\"></a>7. 描述(15%)</h1><p>家的平面或喜欢的建筑。<br>10句话。每句1分。<br>画两张图。1张图2.5分。</p>\n<p>Mention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it’s a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.</p>\n<p>Enter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.</p>\n<p>客厅 living room<br>主卧 master bedroom<br>客卧 guest bedroom<br>卫生间 bathroom<br>阳台 balcony<br>厨房 kitchen<br>餐厅 dining room<br>书房 study room<br>天台 roof<br>门廊 porch<br>储物室 store room<br>衣帽间 locker room<br>一层平面 ground floor plan</p>\n"},{"title":"DirectX9.0 notes 1.3 预备知识","date":"2017-11-22T13:55:41.000Z","_content":"\n### 深度缓存(depth buffer)\n\n> 定义: 一个含有特定像素的深度信息而不含图像数据的表面。\n  用于计算每个像素而定深度值并进行深度测试: 让处于同一位置的不同像素进行竞争，选出应写入该位置的像素。距离摄像机最近的像素获胜。\n  深度缓存格式决定深度测试精度, 精度度 16位<24位<32位, 一般选择24位满足效果\n\n> * D3DFMT_D32         32位深度缓存\n> * D3DFMT_D23S8       24位深度缓存, 其中8位保留供模板缓存(stencil buffer)[1]使用\n> * D3DFMT_D24X8       24位深度缓存\n> * D3DFMT_D16         16位深度缓存\n\n### 顶点运算(Vertex Processing)\n\n> * 软件顶点运算(software vertex process)\n> * 硬件顶点运算(harfware ...)\n\n软件顶点运算 ** 总是会被支持 ** , 硬件只有得到图形卡的支持才可使用。\n\n优先考虑硬件顶点运算方式，理由：\n> 1. 使用的硬件可能有加速功能\n> 2. 可以不占用CPU， CPU可被解放出来进行其他运算\n\n### 设备性能(Device Capabilities)\n\nDeCaps 表示\"Device Capabilities\"\nD3DCAP9::DevCaps的D3DDEVCAPS_HWTYRANSFORMANDLIGHT 可用来表示设备是否支持变换和光照的硬件计算。\n多查阅D3DCAP9相关的SDK文档, 继续研究一下Directt3D所提供能够设备性能的完整列表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1] : 18章论述\n","source":"_posts/d3d-preparation.md","raw":"---\ntitle: DirectX9.0 notes 1.3 预备知识\ndate: 2017-11-22 21:55:41\ntags:\n- DirectX\n- Games\n\n---\n\n### 深度缓存(depth buffer)\n\n> 定义: 一个含有特定像素的深度信息而不含图像数据的表面。\n  用于计算每个像素而定深度值并进行深度测试: 让处于同一位置的不同像素进行竞争，选出应写入该位置的像素。距离摄像机最近的像素获胜。\n  深度缓存格式决定深度测试精度, 精度度 16位<24位<32位, 一般选择24位满足效果\n\n> * D3DFMT_D32         32位深度缓存\n> * D3DFMT_D23S8       24位深度缓存, 其中8位保留供模板缓存(stencil buffer)[1]使用\n> * D3DFMT_D24X8       24位深度缓存\n> * D3DFMT_D16         16位深度缓存\n\n### 顶点运算(Vertex Processing)\n\n> * 软件顶点运算(software vertex process)\n> * 硬件顶点运算(harfware ...)\n\n软件顶点运算 ** 总是会被支持 ** , 硬件只有得到图形卡的支持才可使用。\n\n优先考虑硬件顶点运算方式，理由：\n> 1. 使用的硬件可能有加速功能\n> 2. 可以不占用CPU， CPU可被解放出来进行其他运算\n\n### 设备性能(Device Capabilities)\n\nDeCaps 表示\"Device Capabilities\"\nD3DCAP9::DevCaps的D3DDEVCAPS_HWTYRANSFORMANDLIGHT 可用来表示设备是否支持变换和光照的硬件计算。\n多查阅D3DCAP9相关的SDK文档, 继续研究一下Directt3D所提供能够设备性能的完整列表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1] : 18章论述\n","slug":"d3d-preparation","published":1,"updated":"2018-06-19T16:15:03.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyj80007k8mf8aa7nqk4","content":"<h3 id=\"深度缓存-depth-buffer\"><a href=\"#深度缓存-depth-buffer\" class=\"headerlink\" title=\"深度缓存(depth buffer)\"></a>深度缓存(depth buffer)</h3><blockquote>\n<p>定义: 一个含有特定像素的深度信息而不含图像数据的表面。<br>  用于计算每个像素而定深度值并进行深度测试: 让处于同一位置的不同像素进行竞争，选出应写入该位置的像素。距离摄像机最近的像素获胜。<br>  深度缓存格式决定深度测试精度, 精度度 16位&lt;24位&lt;32位, 一般选择24位满足效果</p>\n<ul>\n<li>D3DFMT_D32         32位深度缓存</li>\n<li>D3DFMT_D23S8       24位深度缓存, 其中8位保留供模板缓存(stencil buffer)[1]使用</li>\n<li>D3DFMT_D24X8       24位深度缓存</li>\n<li>D3DFMT_D16         16位深度缓存</li>\n</ul>\n</blockquote>\n<h3 id=\"顶点运算-Vertex-Processing\"><a href=\"#顶点运算-Vertex-Processing\" class=\"headerlink\" title=\"顶点运算(Vertex Processing)\"></a>顶点运算(Vertex Processing)</h3><blockquote>\n<ul>\n<li>软件顶点运算(software vertex process)</li>\n<li>硬件顶点运算(harfware …)</li>\n</ul>\n</blockquote>\n<p>软件顶点运算 <strong> 总是会被支持 </strong> , 硬件只有得到图形卡的支持才可使用。</p>\n<p>优先考虑硬件顶点运算方式，理由：</p>\n<blockquote>\n<ol>\n<li>使用的硬件可能有加速功能</li>\n<li>可以不占用CPU， CPU可被解放出来进行其他运算</li>\n</ol>\n</blockquote>\n<h3 id=\"设备性能-Device-Capabilities\"><a href=\"#设备性能-Device-Capabilities\" class=\"headerlink\" title=\"设备性能(Device Capabilities)\"></a>设备性能(Device Capabilities)</h3><p>DeCaps 表示”Device Capabilities”<br>D3DCAP9::DevCaps的D3DDEVCAPS_HWTYRANSFORMANDLIGHT 可用来表示设备是否支持变换和光照的硬件计算。<br>多查阅D3DCAP9相关的SDK文档, 继续研究一下Directt3D所提供能够设备性能的完整列表。</p>\n<p>[1] : 18章论述</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"深度缓存-depth-buffer\"><a href=\"#深度缓存-depth-buffer\" class=\"headerlink\" title=\"深度缓存(depth buffer)\"></a>深度缓存(depth buffer)</h3><blockquote>\n<p>定义: 一个含有特定像素的深度信息而不含图像数据的表面。<br>  用于计算每个像素而定深度值并进行深度测试: 让处于同一位置的不同像素进行竞争，选出应写入该位置的像素。距离摄像机最近的像素获胜。<br>  深度缓存格式决定深度测试精度, 精度度 16位&lt;24位&lt;32位, 一般选择24位满足效果</p>\n<ul>\n<li>D3DFMT_D32         32位深度缓存</li>\n<li>D3DFMT_D23S8       24位深度缓存, 其中8位保留供模板缓存(stencil buffer)[1]使用</li>\n<li>D3DFMT_D24X8       24位深度缓存</li>\n<li>D3DFMT_D16         16位深度缓存</li>\n</ul>\n</blockquote>\n<h3 id=\"顶点运算-Vertex-Processing\"><a href=\"#顶点运算-Vertex-Processing\" class=\"headerlink\" title=\"顶点运算(Vertex Processing)\"></a>顶点运算(Vertex Processing)</h3><blockquote>\n<ul>\n<li>软件顶点运算(software vertex process)</li>\n<li>硬件顶点运算(harfware …)</li>\n</ul>\n</blockquote>\n<p>软件顶点运算 <strong> 总是会被支持 </strong> , 硬件只有得到图形卡的支持才可使用。</p>\n<p>优先考虑硬件顶点运算方式，理由：</p>\n<blockquote>\n<ol>\n<li>使用的硬件可能有加速功能</li>\n<li>可以不占用CPU， CPU可被解放出来进行其他运算</li>\n</ol>\n</blockquote>\n<h3 id=\"设备性能-Device-Capabilities\"><a href=\"#设备性能-Device-Capabilities\" class=\"headerlink\" title=\"设备性能(Device Capabilities)\"></a>设备性能(Device Capabilities)</h3><p>DeCaps 表示”Device Capabilities”<br>D3DCAP9::DevCaps的D3DDEVCAPS_HWTYRANSFORMANDLIGHT 可用来表示设备是否支持变换和光照的硬件计算。<br>多查阅D3DCAP9相关的SDK文档, 继续研究一下Directt3D所提供能够设备性能的完整列表。</p>\n<p>[1] : 18章论述</p>\n"},{"title":"关于文档学习方法和图形学学习的随想","date":"2017-12-28T12:59:50.000Z","_content":"\n上篇笔记[OpenGL绘制三角形附练习](http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/)来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的`<<游戏之旅>>`， 查阅了OpenGL与图形引擎的相关资料, \n\n## BLOG整理文档学习方法\n从云风的书中偶得一段话，\n\n`学习新的技术，翻译一本相关的英语著作可以算是捷径。`\n> * 比囫囵吞枣的读一遍英文原文要有效的多。\n> * 因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。\n> * 即使对此有所了解，翻译后也能更上一层楼。\n> * 英语水平也会提高。\n\n`发现产生了一些共鸣。`\n其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了`<<grasshopper运算器手册>>`一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？\n\n之二是石老师推荐学生翻译`<<Form Space & Order>>, <<Parten Language>>, <<A New Kind of Science>>`等书来学习数字化技术。\n\n我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。\n\n## 图形学学习\n\n另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：\n> * 图形学是研究用计算机如果画出一个图像的学科。\n> * OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。\n> * 他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。\n> * 但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。\n\n下面是摘自 <span style=\"color:red\">**Milo Yip**</span> 叶神在[知乎](https://www.zhihu.com/question/24786878)上的回答，要借鉴这个学习轨迹, 并以此勉励自己：\n\n`如何开始用 C++ 写一个光栅化渲染器？`\n\n**Milo Yip**\n计算机图形学、编程、C++ 等 7 个话题的优秀回答者\n228 人赞同了该回答\n@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。\n\n首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。\n\n如果我们从图形学的历史进程来学习，可以这样做练习：\n\n2D部分：\n> 1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）\n> 2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）\n> 3, 2D直线的剪切算法（见Line clipping）\n> 4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。\n> 5, 光栅化简单／复杂多边形\n3D部分：\n> 1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。\n> 2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型\n> 3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。\n> 改为使用深度缓冲。\n> 4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。\n> 5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。\n> 6, 通过顶点法线插值，实现Phong shading。\n> 7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。\n\n","source":"_posts/doc-computer-graphic-learn.md","raw":"---\ntitle: 关于文档学习方法和图形学学习的随想\ndate: 2017-12-28 20:59:50\ntags: [图形学, OpenGL, 读书, 随想, 方法论, 引擎]\n---\n\n上篇笔记[OpenGL绘制三角形附练习](http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/)来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的`<<游戏之旅>>`， 查阅了OpenGL与图形引擎的相关资料, \n\n## BLOG整理文档学习方法\n从云风的书中偶得一段话，\n\n`学习新的技术，翻译一本相关的英语著作可以算是捷径。`\n> * 比囫囵吞枣的读一遍英文原文要有效的多。\n> * 因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。\n> * 即使对此有所了解，翻译后也能更上一层楼。\n> * 英语水平也会提高。\n\n`发现产生了一些共鸣。`\n其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了`<<grasshopper运算器手册>>`一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？\n\n之二是石老师推荐学生翻译`<<Form Space & Order>>, <<Parten Language>>, <<A New Kind of Science>>`等书来学习数字化技术。\n\n我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。\n\n## 图形学学习\n\n另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：\n> * 图形学是研究用计算机如果画出一个图像的学科。\n> * OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。\n> * 他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。\n> * 但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。\n\n下面是摘自 <span style=\"color:red\">**Milo Yip**</span> 叶神在[知乎](https://www.zhihu.com/question/24786878)上的回答，要借鉴这个学习轨迹, 并以此勉励自己：\n\n`如何开始用 C++ 写一个光栅化渲染器？`\n\n**Milo Yip**\n计算机图形学、编程、C++ 等 7 个话题的优秀回答者\n228 人赞同了该回答\n@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。\n\n首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。\n\n如果我们从图形学的历史进程来学习，可以这样做练习：\n\n2D部分：\n> 1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）\n> 2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）\n> 3, 2D直线的剪切算法（见Line clipping）\n> 4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。\n> 5, 光栅化简单／复杂多边形\n3D部分：\n> 1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。\n> 2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型\n> 3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。\n> 改为使用深度缓冲。\n> 4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。\n> 5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。\n> 6, 通过顶点法线插值，实现Phong shading。\n> 7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。\n\n","slug":"doc-computer-graphic-learn","published":1,"updated":"2018-06-19T16:15:03.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjc000ak8mfzkmzwlmp","content":"<p>上篇笔记<a href=\"http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/\">OpenGL绘制三角形附练习</a>来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的<code>&lt;&lt;游戏之旅&gt;&gt;</code>， 查阅了OpenGL与图形引擎的相关资料, </p>\n<h2 id=\"BLOG整理文档学习方法\"><a href=\"#BLOG整理文档学习方法\" class=\"headerlink\" title=\"BLOG整理文档学习方法\"></a>BLOG整理文档学习方法</h2><p>从云风的书中偶得一段话，</p>\n<p><code>学习新的技术，翻译一本相关的英语著作可以算是捷径。</code></p>\n<blockquote>\n<ul>\n<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>\n<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>\n<li>即使对此有所了解，翻译后也能更上一层楼。</li>\n<li>英语水平也会提高。</li>\n</ul>\n</blockquote>\n<p><code>发现产生了一些共鸣。</code><br>其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了<code>&lt;&lt;grasshopper运算器手册&gt;&gt;</code>一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？</p>\n<p>之二是石老师推荐学生翻译<code>&lt;&lt;Form Space &amp; Order&gt;&gt;, &lt;&lt;Parten Language&gt;&gt;, &lt;&lt;A New Kind of Science&gt;&gt;</code>等书来学习数字化技术。</p>\n<p>我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。</p>\n<h2 id=\"图形学学习\"><a href=\"#图形学学习\" class=\"headerlink\" title=\"图形学学习\"></a>图形学学习</h2><p>另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：</p>\n<blockquote>\n<ul>\n<li>图形学是研究用计算机如果画出一个图像的学科。</li>\n<li>OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。</li>\n<li>他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。</li>\n<li>但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。</li>\n</ul>\n</blockquote>\n<p>下面是摘自 <span style=\"color:red\"><strong>Milo Yip</strong></span> 叶神在<a href=\"https://www.zhihu.com/question/24786878\" target=\"_blank\" rel=\"noopener\">知乎</a>上的回答，要借鉴这个学习轨迹, 并以此勉励自己：</p>\n<p><code>如何开始用 C++ 写一个光栅化渲染器？</code></p>\n<p><strong>Milo Yip</strong><br>计算机图形学、编程、C++ 等 7 个话题的优秀回答者<br>228 人赞同了该回答<br>@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。</p>\n<p>首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。</p>\n<p>如果我们从图形学的历史进程来学习，可以这样做练习：</p>\n<p>2D部分：</p>\n<blockquote>\n<p>1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）<br>2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）<br>3, 2D直线的剪切算法（见Line clipping）<br>4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。<br>5, 光栅化简单／复杂多边形<br>3D部分：<br>1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。<br>2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型<br>3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。<br>改为使用深度缓冲。<br>4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。<br>5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。<br>6, 通过顶点法线插值，实现Phong shading。<br>7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>上篇笔记<a href=\"http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/\">OpenGL绘制三角形附练习</a>来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的<code>&lt;&lt;游戏之旅&gt;&gt;</code>， 查阅了OpenGL与图形引擎的相关资料, </p>\n<h2 id=\"BLOG整理文档学习方法\"><a href=\"#BLOG整理文档学习方法\" class=\"headerlink\" title=\"BLOG整理文档学习方法\"></a>BLOG整理文档学习方法</h2><p>从云风的书中偶得一段话，</p>\n<p><code>学习新的技术，翻译一本相关的英语著作可以算是捷径。</code></p>\n<blockquote>\n<ul>\n<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>\n<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>\n<li>即使对此有所了解，翻译后也能更上一层楼。</li>\n<li>英语水平也会提高。</li>\n</ul>\n</blockquote>\n<p><code>发现产生了一些共鸣。</code><br>其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了<code>&lt;&lt;grasshopper运算器手册&gt;&gt;</code>一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？</p>\n<p>之二是石老师推荐学生翻译<code>&lt;&lt;Form Space &amp; Order&gt;&gt;, &lt;&lt;Parten Language&gt;&gt;, &lt;&lt;A New Kind of Science&gt;&gt;</code>等书来学习数字化技术。</p>\n<p>我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。</p>\n<h2 id=\"图形学学习\"><a href=\"#图形学学习\" class=\"headerlink\" title=\"图形学学习\"></a>图形学学习</h2><p>另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：</p>\n<blockquote>\n<ul>\n<li>图形学是研究用计算机如果画出一个图像的学科。</li>\n<li>OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。</li>\n<li>他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。</li>\n<li>但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。</li>\n</ul>\n</blockquote>\n<p>下面是摘自 <span style=\"color:red\"><strong>Milo Yip</strong></span> 叶神在<a href=\"https://www.zhihu.com/question/24786878\" target=\"_blank\" rel=\"noopener\">知乎</a>上的回答，要借鉴这个学习轨迹, 并以此勉励自己：</p>\n<p><code>如何开始用 C++ 写一个光栅化渲染器？</code></p>\n<p><strong>Milo Yip</strong><br>计算机图形学、编程、C++ 等 7 个话题的优秀回答者<br>228 人赞同了该回答<br>@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。</p>\n<p>首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。</p>\n<p>如果我们从图形学的历史进程来学习，可以这样做练习：</p>\n<p>2D部分：</p>\n<blockquote>\n<p>1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）<br>2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）<br>3, 2D直线的剪切算法（见Line clipping）<br>4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。<br>5, 光栅化简单／复杂多边形<br>3D部分：<br>1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。<br>2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型<br>3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。<br>改为使用深度缓冲。<br>4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。<br>5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。<br>6, 通过顶点法线插值，实现Phong shading。<br>7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。</p>\n</blockquote>\n"},{"title":"Git Push免密码设置","date":"2017-12-22T00:02:48.000Z","_content":"\n## **使用.git-credentials保存验证**\n\n```sh\n$ cd\n$ touch .git-credentials\n$ emacs .git-credentials\nhttps://{timting***}:{********}@github.com\n```\n\n```sh\n$ cd ~/.emacs.d/\n$ git push -u origin master\nUsername for 'https://github.com':   C-c C-c\n```\n\n**去掉{}**\n\n```sh\n$ emacs ~/.git-credentials\nhttps://timting***:********@github.com\n$ git config --global credential.helper store\n\n$ cd\n$ cat ~/.gitconfig\n[user]\n\temail = timtingwei@hotmail.com\n\tname = timtingwei\n[credential]\n\thelper = store\n```\n\n现在push不再需要验证。\n\n**但我不希望用文件保存我的密码**\n\n```sh\n$ ls -ld .git-credentials\n-rw------- 1 tim tim 42 12月 22 15:00 .git-credentials\ntim@htwt:~$ sudo chmod 200 .git-credentials\n[sudo] password for tim: \ntim@htwt:~$ ls -ld .git-credentials\n--w------- 1 tim tim 42 12月 22 15:00 .git-credentials\ntim@htwt:~$ git config --global credential.helper store\n```\n\n重启bash\n\n```sh\ntim@htwt:~/.emacs.d$ git push origin master\nfatal: unable to open /home/tim/.git-credentials: Permission denied\n```\n\n=> 修改权限的方法没用, 别人看不到, git也看不到。\n\n======\n\n## **安全性存疑，因此改用设置cache**\n```sh\n$ rm ~/.git-credentials\n```\n通过设置git的cache的话可以让它记住密码之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性。\n\n```sh\n$ git config --global credential.helper cache\n\\# Set git to use the credential memory cache\n```\n\n```sh\n$ git config --global credential.helper 'cache --timeout=3600'\n\\# Set the cache to timeout after 1 hour (setting is in seconds)\n```\n======\n\nrefwebsite:\n[1], https://www.zhihu.com/question/31836445\n[2], http://www.jianshu.com/p/f54053afecf2\n[3], https://help.github.com/articles/caching-your-github-password-in-git/\n","source":"_posts/git-push-credential.md","raw":"---\ntitle: Git Push免密码设置\ndate: 2017-12-22 08:02:48\ntags: git\n---\n\n## **使用.git-credentials保存验证**\n\n```sh\n$ cd\n$ touch .git-credentials\n$ emacs .git-credentials\nhttps://{timting***}:{********}@github.com\n```\n\n```sh\n$ cd ~/.emacs.d/\n$ git push -u origin master\nUsername for 'https://github.com':   C-c C-c\n```\n\n**去掉{}**\n\n```sh\n$ emacs ~/.git-credentials\nhttps://timting***:********@github.com\n$ git config --global credential.helper store\n\n$ cd\n$ cat ~/.gitconfig\n[user]\n\temail = timtingwei@hotmail.com\n\tname = timtingwei\n[credential]\n\thelper = store\n```\n\n现在push不再需要验证。\n\n**但我不希望用文件保存我的密码**\n\n```sh\n$ ls -ld .git-credentials\n-rw------- 1 tim tim 42 12月 22 15:00 .git-credentials\ntim@htwt:~$ sudo chmod 200 .git-credentials\n[sudo] password for tim: \ntim@htwt:~$ ls -ld .git-credentials\n--w------- 1 tim tim 42 12月 22 15:00 .git-credentials\ntim@htwt:~$ git config --global credential.helper store\n```\n\n重启bash\n\n```sh\ntim@htwt:~/.emacs.d$ git push origin master\nfatal: unable to open /home/tim/.git-credentials: Permission denied\n```\n\n=> 修改权限的方法没用, 别人看不到, git也看不到。\n\n======\n\n## **安全性存疑，因此改用设置cache**\n```sh\n$ rm ~/.git-credentials\n```\n通过设置git的cache的话可以让它记住密码之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性。\n\n```sh\n$ git config --global credential.helper cache\n\\# Set git to use the credential memory cache\n```\n\n```sh\n$ git config --global credential.helper 'cache --timeout=3600'\n\\# Set the cache to timeout after 1 hour (setting is in seconds)\n```\n======\n\nrefwebsite:\n[1], https://www.zhihu.com/question/31836445\n[2], http://www.jianshu.com/p/f54053afecf2\n[3], https://help.github.com/articles/caching-your-github-password-in-git/\n","slug":"git-push-credential","published":1,"updated":"2018-06-19T16:15:03.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjf000bk8mfhhuqde30","content":"<h2 id=\"使用-git-credentials保存验证\"><a href=\"#使用-git-credentials保存验证\" class=\"headerlink\" title=\"使用.git-credentials保存验证\"></a><strong>使用.git-credentials保存验证</strong></h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span></span><br><span class=\"line\">$ touch .git-credentials</span><br><span class=\"line\">$ emacs .git-credentials</span><br><span class=\"line\">https://&#123;timting***&#125;:&#123;********&#125;@github.com</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/.emacs.d/</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:   C-c C-c</span><br></pre></td></tr></table></figure>\n<p><strong>去掉{}</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ emacs ~/.git-credentials</span><br><span class=\"line\">https://timting***:********@github.com</span><br><span class=\"line\">$ git config --global credential.helper store</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span></span><br><span class=\"line\">$ cat ~/.gitconfig</span><br><span class=\"line\">[user]</span><br><span class=\"line\">\temail = timtingwei@hotmail.com</span><br><span class=\"line\">\tname = timtingwei</span><br><span class=\"line\">[credential]</span><br><span class=\"line\">\thelper = store</span><br></pre></td></tr></table></figure>\n<p>现在push不再需要验证。</p>\n<p><strong>但我不希望用文件保存我的密码</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -ld .git-credentials</span><br><span class=\"line\">-rw------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class=\"line\">tim@htwt:~$ sudo chmod 200 .git-credentials</span><br><span class=\"line\">[sudo] password <span class=\"keyword\">for</span> tim: </span><br><span class=\"line\">tim@htwt:~$ ls -ld .git-credentials</span><br><span class=\"line\">--w------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class=\"line\">tim@htwt:~$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n<p>重启bash</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">tim@htwt:~/.emacs.d$ git push origin master</span><br><span class=\"line\">fatal: unable to open /home/tim/.git-credentials: Permission denied</span><br></pre></td></tr></table></figure>\n<p>=&gt; 修改权限的方法没用, 别人看不到, git也看不到。</p>\n<p>======</p>\n<h2 id=\"安全性存疑，因此改用设置cache\"><a href=\"#安全性存疑，因此改用设置cache\" class=\"headerlink\" title=\"安全性存疑，因此改用设置cache\"></a><strong>安全性存疑，因此改用设置cache</strong></h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm ~/.git-credentials</span><br></pre></td></tr></table></figure>\n<p>通过设置git的cache的话可以让它记住密码之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper cache</span><br><span class=\"line\">\\<span class=\"comment\"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper <span class=\"string\">'cache --timeout=3600'</span></span><br><span class=\"line\">\\<span class=\"comment\"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>\n<p>======</p>\n<p>refwebsite:<br>[1], <a href=\"https://www.zhihu.com/question/31836445\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/31836445</a><br>[2], <a href=\"http://www.jianshu.com/p/f54053afecf2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/f54053afecf2</a><br>[3], <a href=\"https://help.github.com/articles/caching-your-github-password-in-git/\" target=\"_blank\" rel=\"noopener\">https://help.github.com/articles/caching-your-github-password-in-git/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用-git-credentials保存验证\"><a href=\"#使用-git-credentials保存验证\" class=\"headerlink\" title=\"使用.git-credentials保存验证\"></a><strong>使用.git-credentials保存验证</strong></h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span></span><br><span class=\"line\">$ touch .git-credentials</span><br><span class=\"line\">$ emacs .git-credentials</span><br><span class=\"line\">https://&#123;timting***&#125;:&#123;********&#125;@github.com</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> ~/.emacs.d/</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"string\">'https://github.com'</span>:   C-c C-c</span><br></pre></td></tr></table></figure>\n<p><strong>去掉{}</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ emacs ~/.git-credentials</span><br><span class=\"line\">https://timting***:********@github.com</span><br><span class=\"line\">$ git config --global credential.helper store</span><br><span class=\"line\"></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span></span><br><span class=\"line\">$ cat ~/.gitconfig</span><br><span class=\"line\">[user]</span><br><span class=\"line\">\temail = timtingwei@hotmail.com</span><br><span class=\"line\">\tname = timtingwei</span><br><span class=\"line\">[credential]</span><br><span class=\"line\">\thelper = store</span><br></pre></td></tr></table></figure>\n<p>现在push不再需要验证。</p>\n<p><strong>但我不希望用文件保存我的密码</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -ld .git-credentials</span><br><span class=\"line\">-rw------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class=\"line\">tim@htwt:~$ sudo chmod 200 .git-credentials</span><br><span class=\"line\">[sudo] password <span class=\"keyword\">for</span> tim: </span><br><span class=\"line\">tim@htwt:~$ ls -ld .git-credentials</span><br><span class=\"line\">--w------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class=\"line\">tim@htwt:~$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n<p>重启bash</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">tim@htwt:~/.emacs.d$ git push origin master</span><br><span class=\"line\">fatal: unable to open /home/tim/.git-credentials: Permission denied</span><br></pre></td></tr></table></figure>\n<p>=&gt; 修改权限的方法没用, 别人看不到, git也看不到。</p>\n<p>======</p>\n<h2 id=\"安全性存疑，因此改用设置cache\"><a href=\"#安全性存疑，因此改用设置cache\" class=\"headerlink\" title=\"安全性存疑，因此改用设置cache\"></a><strong>安全性存疑，因此改用设置cache</strong></h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm ~/.git-credentials</span><br></pre></td></tr></table></figure>\n<p>通过设置git的cache的话可以让它记住密码之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper cache</span><br><span class=\"line\">\\<span class=\"comment\"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global credential.helper <span class=\"string\">'cache --timeout=3600'</span></span><br><span class=\"line\">\\<span class=\"comment\"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>\n<p>======</p>\n<p>refwebsite:<br>[1], <a href=\"https://www.zhihu.com/question/31836445\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/31836445</a><br>[2], <a href=\"http://www.jianshu.com/p/f54053afecf2\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/f54053afecf2</a><br>[3], <a href=\"https://help.github.com/articles/caching-your-github-password-in-git/\" target=\"_blank\" rel=\"noopener\">https://help.github.com/articles/caching-your-github-password-in-git/</a></p>\n"},{"title":"gitignore-invalid","date":"2017-12-27T00:55:27.000Z","_content":"","source":"_posts/gitignore-invalid.md","raw":"---\ntitle: gitignore-invalid\ndate: 2017-12-27 08:55:27\ntags:\n---\n","slug":"gitignore-invalid","published":1,"updated":"2018-06-19T16:15:03.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjh000dk8mfms3zerj7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OpenGL绘制三角形附练习","date":"2017-12-25T06:56:13.000Z","_content":"\n代码已托管在[/timtingwei/LearnOpenGL](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started)\n\n# 图形管线渲染有哪几个阶段？\n\n顶点数据(Vertex data[])  ->\n> 1, **顶点着色器**(Vertex Shader) ->\n> 2, 形状(图元)装配(Shape Assembly) ->\n> 3, **几何着色器**(Geometry Shader) ->\n> 4, 光栅化(Rasterization) ->\n> 5, **片段着色器**(Fragment Shader) ->\n> 6, 测试与混合(Test And Blending)\n\n三个着色器可以自己定义。\n\n**顶点数据(Vertex data)：**\n> * Vertex是一个3D坐标的集合\n> * Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color\n\n\n**顶点着色器(Vertex Shader)：**\n> * 把3D坐标转换成另外一种3D坐标\n> * 允许对Vertex Attribute做基本处理\n\n**片段着色器(Fragment Shader)：**\n> * 计算一个像素最终的颜色\n> * 着色器包含3D场景数据(光照，阴影，光的颜色)\n\n**Alpha测试和混合(Blending):**\n> * 测试深度，反应前后。\n> * 检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)\n\n\n补充: 图元(Primitive):\n> * 任何一个绘制指令的调用，都把图元传递给OpenGL。\n> * 如GL\\_POINTS、GL\\_TRIANGLES、GL\\_LINE_STRIP。\n\n\n# 绘制绘制三角形\n\t\n## 顶点着色器\n使用GLSL(OpenGL Shading Language)编写顶点着色器\n```c\n#version 330 core          // 每个着色器起始于版本声明, core代表核心模式\n\nlayout (location=0) in vec3 aPos;      // 设定输入变量的位置值\n\nvoid main() {\n  gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n}\n\n```\n\n为什么需要**layout (location=0)**设定位置值？\n> * **glVertexAttributPointer**函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。\n\n\n相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，[着色器中](https://timtingwei.github.io)讲解\n\n## 编译顶点着色器\n\n编写着色器源码后，\n> 1, 先创建着色器对象;\n> 2, 再把源码附加到着色器对象上;\n> 3, 编译并检查\n\n**1, 创建顶点着色器对象**\n```cpp\nunsigned int vertexShader;                         // ID引用\nvertexShader = glCreateShader(GL_VERTEX_SHADER);   // 传递着色器类型参数\n```\n\n**2, 附源码**\n```cpp\nglShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\n```\n\n**glShaderSource**函数的几个参数：\n> 0, 着色器对象\n> 1, 传递的源码字符数量\n> 2, 顶点着色器的真正源码\n> 3, 先设置为NULL\n\n**3, 编译**\n```cpp\nglCompileShader(vertexShader);\n// 检查编译是否成功\nint success;\nchar infoLog[512];\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印\nif {!success} {\n  glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n  std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n}\n```\n\n## 片段着色器\n同理顶点着色器，编写着色器源码\n\n```c\n#version 330 core\n\nout vec4 FragColor;\n\nvoid main() {\n  FragColor =  vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n```\n\n片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量\n\n## 编译片段着色器\n1, 创建对象\n2, 附加源码\n3, 编译并检查\n\n自己重新写一遍, 并检查错误\n1, 创建对象尝试\n```cpp\nunsigned int fragmentShader;\nglCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   // ERROR\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nunsigned int fragmentShader;\nglCreateShader(GL_FRAGMENT_SHADER);     // DEBUG::不需要用着色器对象作为函数的参数，\n```\n\n查阅[khronos.org - glCreateShader](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml)\n> * Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.\n会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。\n\n\n2, 附源码尝试\n```cpp\nglShaderSource(1, fragmentShader, fragmentSource, NULL)   // ERROR\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nglShaderSource(fragmentShader, 1, fragmentShaderSource, NULL);  // DEBUG::交换参数位置\n```\n\n> 1. 着色器对象\n> 2. 传递源码字符的数量\n\n3, 尝试编译\n```cpp\nbool success;    // ERROR\nglCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); // ERROR\nunsigned char* infoLog[512];                                // ERROR\nif (!success) {\n  // 失败把报错内容储存再infoLog中输出\n  glGetShaderinfoLog(fragmentShader, &success, &infoLog);   // ERROR\n  std::cout << \"COMPILE::ERROR::FRAGEMENT::SHADER\" \n            << infoLog << std::endl;\n}\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nglCompileShader(fragmentShader);     // DEBUG::只要着色器对象一个参数\nint success;                         // DEBUG:: success是一个int类型\nchar infoLog[512];                   // DEBUG:: char 并非 unsigned cha*\nglGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);   // DEBUG::获取success在先，才能对success做判断\nif (!success) {\n  // 失败输出\n  std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n}\n```\n\n## 创建着色器程序\n绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序\n\n```cpp\nunsigned int shaderProgram;\nshaderProgram = glCreateProgram();\n```\n\n\n## 链接着色器对象\n两个着色器对象要链接。\n```cpp\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram);\n```\n\n## 编译着色程序\n与之前的着色器编译原理相同，只是调用函数和参数变量改变了。\n```cpp\nglGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);\nif (!success) {\n  glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);\n  std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n}\n```\n\n之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。\n## 删除着色器\n完成以上几步后不要忘记删除着色器\n```cpp\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n```\n\n## 输入顶点以及索引\n\n```cpp\n// 顶点输入\nGLfloat vertices[] = {\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.5f,  -0.5f, 0.0f,    // 右下角\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.5f,  0.5f, 0.0f     // 左上角\n};\n```\n\n**赋值array的时候, 不要忘记{};**\n\n```cpp\n// 顶点索引\nGLuint indices[] = {\n  0, 1, 3                // 第一个三角形\n  // ...                 // 可根据vertices数组, 建立多组索引\n};\n```\n\n## **创建和绑定顶点数组对象(VAO)**\nVAO = Vertex Array Object\n\n功能:\n> * 随后的顶点属性调用都会储存在这个VAO之中。\n> * 使得在不同顶点数据和属性设置之间切换变得简单。\n\n**存储内容**:\n> * glEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n> * 通过glVertexAttribPointer设置的顶点属性配置。\n> * 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。\n\n使用注意:\n> * **先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针**\n\n```cpp\nGLuint VAO;\nglGenVertexArrays(1, &VAO);   // 创建VAO对象\nglBindVertexArray(VAO);       // 绑定顶点数组对象\n```\n\n\n## **创建和绑定顶点缓冲对象(VBO)**\n\nOpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。\n\n作用:\n> * 通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。\n> * 一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。\n\n<span style=\"color:blue\">*我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上* </span>\n```cpp\nGLuint VBO;\nglGenBuffer(1, &VBO);           // 创建\n// 把顶点数组复制到缓存中提供OpenGL使用\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n```\n\n## **索引缓冲对象(EBO)**\n\n可以创建不同的索引数组，而使用同一个顶点数组。如下：\n```cpp\nunsigned int indices[] = { // 注意索引从0开始! \n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n```\n\n```cpp\nGLuint EBO;\nglGenBuffer(1, &EBO);                // 创建\n// 把顶点索引复制到缓存中提供OpenGL使用\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n```\n\n\n\t\n## **设置顶点属性**\n\t\n![vertex_attribute_pointer](/images/vertex_attribute_pointer.png)\t\n\n> * 位置数据被储存为32位(4字节)浮点值 => siezeof(flaot) = 4 types = 32bits\n> * 每个位置包含3个这样的值\n> * 没有空隙, 紧密排列。\n> * 数据中的第一个值再缓冲开始位置。\n\n```cpp\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexattribArray(0);    // 开启位置为0的顶点属性\n```\n\n**glVertexAttribPointer参数**\n> 1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style=\"color:red\">**layout (location=0) in vec3 xx**</span> 吗？ \n> 2, 顶点属性的大小。 vec3 => 3个值组成\n> 3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)\n> 4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;\n> 5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。\n> 6. 偏移量。位置数据在数组开头就设置成0\n\n\n顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。\n输入的参数顶点属性的位置值。<span style=\"color:red\">**layout (location=0) in vec3 xx**</span> \n\n## 绘制图元\n\n`在主循环内部绘制图元。`\n\n1, 激活程序对象\n2, 绑定缓存对象\n3, 绘制\n4, 解绑缓存对象\n\n**绘制两种方式：**\nglDrawArrays();\n> * 使用当前绑定的顶点缓存对象进行绘制\nglDrawElements()\n> * 使用当前绑定的索引缓冲对象中的索引进行绘制\n\n第一种，\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\n// 绑定顶点数组对象\nglBindVertexArray(VAO);\n// 使用当前绑定的顶点缓存对象进行绘制\nglDrawArrays(GL_TRIANGLES, 0, 3);\n// 解绑缓存对象\nglBindVertArray(0);\n```\n第二种,\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\n// 绑定顶点数组对象 \nglBindVertexArray(VAO);\n// 使用当前绑定的索引缓冲对象中的索引进行绘制\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n// 解绑缓存对象\nglBindVertArray(0);\n```\n\n<span style=\"color:blue\">*VAO有种结合VBO+EBO的意思*</span>\n**再回顾一遍它的存储内容**:\n> * glEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n> * 通过glVertexAttribPointer设置的顶点属性配置。\n> * 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。\n\n`退出循环后删除对象，释放缓存`\n```cpp\nglDeleteVertexArray(1, &VAO);\nglDeleteBuffers(1, &VBO);\nglDeleteBuffers(1, &EBO);\n```\n\n-----\n\n# 课后练习\n实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，\n> 1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？\n> 2, 顶点着色器和片段着色器之间的关系？\n> 3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？\n\n## **1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形**\n\n\n**glDrawArrays();**\n根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。\n\n\n```cpp\n// 先设置顶点数组\nGLfloat vertices[] = {\n    // 第一个triangle\n    0.5f,   0.5f, 0.0f,    // 右上角\n    0.5f,  -0.5f, 0.0f,    // 右下角\n    0.0f,   0.0f, 0.0f,    // 连接处\n    // 第二个triangle\n    -0.5f, -0.5f, 0.0f,    // 左下角\n    -0.5f,  0.5f, 0.0f,    // 左上角\n    0.0f,   0.0f, 0.0f     // 连接处\n  };\n```\n\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawArrays(GL_TRIANGLES, 0, 6);  // 从顶点数组索引0开始依次绘制6个顶点\n\n```\n\n\n**glDrawElements();**\n根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针\n\n\n```cpp\n// 顶点输入\nGLfloat vertices[] = {\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.5f,  -0.5f, 0.0f,    // 右下角\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.5f,  0.5f, 0.0f     // 左上角\n};\n\nGLuint indices[] = {     // 索引从0开始\n  0, 1, 3,               // 第一个三角形\n  1, 2, 3                // 第二个三角形\n};\n```\n\n还需要在绑定VAO后绑定VBO和EBO\n```cpp\n// ...\n```\n\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)  // 索引数组绘制6个顶点\n```\n\n<span style=\"color:blue\">*这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。*</span>\n\n[练习1源码 - github](https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp)\n\n-----\n\n## **2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO**\n// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。\n\n**glGenBuffers**(GLsizei n,\n                GLuint* buffers);\n生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在**Buffers**中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。\n\n**glGenVertexArrays**(GLsizei n,\n                      GLuint* arrays);\n返回n个顶点数组对象名字，存储到arrays指针中。\n\n**glBindBuffer(GLenum target, \n               GLuint buffer);**\n绑定一个已经命名的缓存对象。\n\n*target*\n`----------------------------------------------------------`\n`GL_ARRAY_BUFFER`            |     顶点属性\n`GL_ELEMENT_ARRAY_BUFFER`    |     顶点数组索引\n`GL_TEXTURE_BUFFER`          |     纹理数据缓存\n`GL_UNIFORM_BUFFER`          |     Uniform块存储\n`----------------------------------------------------------`\n\n*buffer*\n    缓存对象的名字\n\n\n**glBindVertexArray**(GLuint array);\n用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。\n\n\n**glBufferData**(GLenum target\n                 GLsizeiptr size\n\t\t\t\t const GLvoid * data\n\t\t\t\t GLenum usage);\n创建或者初始化一个缓冲对象的数据的储存。\n\n*target*\n     这里是GL_ARRAY_BUFFER\n\n*size*\n   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到\n\n*data*\n   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝\n   \n*usage*\n    储存好的数据的使用模式。 `GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY`有这么几种。这里只用于静态绘制\n\n\n**glVertexAttribPointer**(GLuint index,\n                      GLint size,\n \t                  GLenum type,\n \t                  GLboolean normalized,\n \t                  GLsizei stride,\n \t                  const GLvoid * pointer);\n上面有所解释。现在就够用了。\n\n**glEnableVertexAttribArray**(GLuint index);\n启用设置好的顶点属性数组，\n*glDisableVertexAttribArray*(GLuint index);\n关闭\n\n*index* \n   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.\n\n**glBindVertexArray**();\n用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。\n\n**glDrawArrays**(GLenum mode,\n               GLint first,\n\t\t\t   GLsizei count);\n练习1中已经出现过，调用之前先要绑定Array;\n根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。\n\n\n代码实现如下：\n```cpp\n// 输入两个三角形各自的顶点数组\nGLfloat firstTriangleVertices[] = {\n  // 第一个triangle\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.1f,  -0.5f, 0.0f,    // 右下角\n  -0.5f,  0.3f, 0.0f,    // 左下角\n};\n\nGLfloat secondTriangleVertices[] = {\n  // 第二个triangle\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.1f,  0.5f, 0.0f,    // 左上角\n  0.5f,  -0.3f, 0.0f     // 右下角\n};\n```\n\n\n1, 共同以VAOs和VBOs以数组创建\n```cpp\nGLuint VBOs[2], VAOs[2];\nglGenBuffers(2, VAOs);\nglGenVertexArrays(2, VAOs);\n```\n2, 单独绑定, 复制, 设置顶点属性 \n```cpp\nglBindVertexArray(VAOs[0]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);\nglBufferData(GL_GL_ARRAY_BUFFER, sizeof(firstTriangleVertices),\n               firstTriangleVertices, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,\n                        3 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0);\n\n// 同理VAOs[1], VBOs[1]..\nglBindVertexArray(VAOs[1]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);\nglBufferData(GL_GL_ARRAY_BUFFER, sizeof(secondTriangleVertices),\n               secondTriangleVertices, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,\n                        3 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0);\n```\n\n\n3, 单独绘制\n```cpp\n// ==========firstTriangle=========\nglUseProgram(shaderProgram);\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n// ==========secondTriangle========\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglBindVertexArray(0);\n```\n\n\n[练习2源码](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2)\n\n## **3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色**\n\n之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。\n\n// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组\n// 注意：片段着色器不能放在数组里。\n// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。\n\n1, GLSL编写橙色和黄色着色器代码\n2，分别附着，编译，检查着色器，并attach到不同的program\n3, 用不同的program进行draw\n\n\n**1, GLSL编写橙色和黄色着色器代码**\n```cpp\n// 片段着色器0\nconst GLchar* fragmentShaderSource0 = \"#version 330 core\\n\"\n    \"out vec4 color;\\n\"\n    \"void main() {\\n\"\n    \"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"   // orange\n    \"}\\n\\0\";\n\n// 片段着色器1\nconst GLchar* fragmentShaderSource1 = \"#version 330 core\\n\"\n    \"out vec4 color;\\n\"\n    \"void main() {\\n\"\n    \"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\\n\"   // yellow\n    \"}\\n\\0\";\n```\n\n**2，分别附着，编译，检查着色器，并attach到不同的program**\n```cpp\n// 创建片段着色器\n  GLuint fragmentShaderOrange;\n  GLuint fragmentShaderYellow;\n  GLuint shaderProgramOrange;\n  GLuint shaderProgramYellow;\n  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);\n  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);\n  shaderProgramOrange = glCreateProgram();\n  shaderProgramYellow = glCreateProgram();\n  // ===========编译第一个片段着色器===================\n  // 源码附加到着色器对象上\n  glShaderSource(fragmentShaderOrange, 1, &fragmentShaderSource0, NULL);\n  glCompileShader(fragmentShaderOrange);\n  // 检测glComplieShader是否编译成功\n  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n  if (!success) {\n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n\n  // ===========编译第二个片段黄色着色器===================\n  // 源码附加到着色器对象上\n  glShaderSource(fragmentShaderYellow, 1, &fragmentShaderSource1, NULL);\n  glCompileShader(fragmentShaderYellow);\n  // 检测glComplieShader是否编译成功\n  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n  if (!success) {\n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // 把两个着色器对象链接到用来渲染的两个着色程序中\n  glAttachShader(shaderProgramOrange, vertexShader);\n  // =====连接第一个片段着色器=====\n  glAttachShader(shaderProgramOrange, fragmentShaderOrange);\n  glLinkProgram(shaderProgramOrange);\n  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &success);\n  if (!success) {\n    glGetProgramInfoLog(shaderProgramOrange, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // =====连接第二个片段着色器=====\n  glAttachShader(shaderProgramYellow, vertexShader);\n  glAttachShader(shaderProgramYellow, fragmentShaderYellow);\n  glLinkProgram(shaderProgramYellow);\n  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &success);\n  if (!success) {\n    glGetProgramInfoLog(shaderProgramYellow, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // 删除着色器\n  glDeleteShader(vertexShader);\n  glDeleteShader(fragmentShaderOrange);\n  glDeleteShader(fragmentShaderYellow);\n```\n\n**3, 用不同的program进行draw**\n```cpp\n// =====激活程序对象绘制第一个triangle======\nglUseProgram(shaderProgramOrange);      // 使用第一个片段着色器连接的program\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);  // 从索引0开始依次绘制3个顶点\n\n// =====激活程序对象绘制第二个triangle======\nglUseProgram(shaderProgramYellow);      // 使用第二个片段着色器连接的program\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);  // 从索引0开始依次绘制3个顶点\n```\n\n[练习3源码](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3)\n\n=======\n\nrefwebsite:\n[你好三角形 - learnopengl-CN](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/)\n\n\n","source":"_posts/hello-triangle-three-execises.md","raw":"---\ntitle: OpenGL绘制三角形附练习\ndate: 2017-12-25 14:56:13\ntags: OpenGL\n---\n\n代码已托管在[/timtingwei/LearnOpenGL](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started)\n\n# 图形管线渲染有哪几个阶段？\n\n顶点数据(Vertex data[])  ->\n> 1, **顶点着色器**(Vertex Shader) ->\n> 2, 形状(图元)装配(Shape Assembly) ->\n> 3, **几何着色器**(Geometry Shader) ->\n> 4, 光栅化(Rasterization) ->\n> 5, **片段着色器**(Fragment Shader) ->\n> 6, 测试与混合(Test And Blending)\n\n三个着色器可以自己定义。\n\n**顶点数据(Vertex data)：**\n> * Vertex是一个3D坐标的集合\n> * Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color\n\n\n**顶点着色器(Vertex Shader)：**\n> * 把3D坐标转换成另外一种3D坐标\n> * 允许对Vertex Attribute做基本处理\n\n**片段着色器(Fragment Shader)：**\n> * 计算一个像素最终的颜色\n> * 着色器包含3D场景数据(光照，阴影，光的颜色)\n\n**Alpha测试和混合(Blending):**\n> * 测试深度，反应前后。\n> * 检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)\n\n\n补充: 图元(Primitive):\n> * 任何一个绘制指令的调用，都把图元传递给OpenGL。\n> * 如GL\\_POINTS、GL\\_TRIANGLES、GL\\_LINE_STRIP。\n\n\n# 绘制绘制三角形\n\t\n## 顶点着色器\n使用GLSL(OpenGL Shading Language)编写顶点着色器\n```c\n#version 330 core          // 每个着色器起始于版本声明, core代表核心模式\n\nlayout (location=0) in vec3 aPos;      // 设定输入变量的位置值\n\nvoid main() {\n  gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n}\n\n```\n\n为什么需要**layout (location=0)**设定位置值？\n> * **glVertexAttributPointer**函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。\n\n\n相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，[着色器中](https://timtingwei.github.io)讲解\n\n## 编译顶点着色器\n\n编写着色器源码后，\n> 1, 先创建着色器对象;\n> 2, 再把源码附加到着色器对象上;\n> 3, 编译并检查\n\n**1, 创建顶点着色器对象**\n```cpp\nunsigned int vertexShader;                         // ID引用\nvertexShader = glCreateShader(GL_VERTEX_SHADER);   // 传递着色器类型参数\n```\n\n**2, 附源码**\n```cpp\nglShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\n```\n\n**glShaderSource**函数的几个参数：\n> 0, 着色器对象\n> 1, 传递的源码字符数量\n> 2, 顶点着色器的真正源码\n> 3, 先设置为NULL\n\n**3, 编译**\n```cpp\nglCompileShader(vertexShader);\n// 检查编译是否成功\nint success;\nchar infoLog[512];\nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印\nif {!success} {\n  glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n  std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n}\n```\n\n## 片段着色器\n同理顶点着色器，编写着色器源码\n\n```c\n#version 330 core\n\nout vec4 FragColor;\n\nvoid main() {\n  FragColor =  vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n```\n\n片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量\n\n## 编译片段着色器\n1, 创建对象\n2, 附加源码\n3, 编译并检查\n\n自己重新写一遍, 并检查错误\n1, 创建对象尝试\n```cpp\nunsigned int fragmentShader;\nglCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   // ERROR\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nunsigned int fragmentShader;\nglCreateShader(GL_FRAGMENT_SHADER);     // DEBUG::不需要用着色器对象作为函数的参数，\n```\n\n查阅[khronos.org - glCreateShader](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml)\n> * Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.\n会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。\n\n\n2, 附源码尝试\n```cpp\nglShaderSource(1, fragmentShader, fragmentSource, NULL)   // ERROR\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nglShaderSource(fragmentShader, 1, fragmentShaderSource, NULL);  // DEBUG::交换参数位置\n```\n\n> 1. 着色器对象\n> 2. 传递源码字符的数量\n\n3, 尝试编译\n```cpp\nbool success;    // ERROR\nglCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); // ERROR\nunsigned char* infoLog[512];                                // ERROR\nif (!success) {\n  // 失败把报错内容储存再infoLog中输出\n  glGetShaderinfoLog(fragmentShader, &success, &infoLog);   // ERROR\n  std::cout << \"COMPILE::ERROR::FRAGEMENT::SHADER\" \n            << infoLog << std::endl;\n}\n```\n\n<span style=\"color:red\"> *改正* </span>\n```cpp\nglCompileShader(fragmentShader);     // DEBUG::只要着色器对象一个参数\nint success;                         // DEBUG:: success是一个int类型\nchar infoLog[512];                   // DEBUG:: char 并非 unsigned cha*\nglGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);   // DEBUG::获取success在先，才能对success做判断\nif (!success) {\n  // 失败输出\n  std::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n}\n```\n\n## 创建着色器程序\n绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序\n\n```cpp\nunsigned int shaderProgram;\nshaderProgram = glCreateProgram();\n```\n\n\n## 链接着色器对象\n两个着色器对象要链接。\n```cpp\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram);\n```\n\n## 编译着色程序\n与之前的着色器编译原理相同，只是调用函数和参数变量改变了。\n```cpp\nglGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);\nif (!success) {\n  glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);\n  std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n}\n```\n\n之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。\n## 删除着色器\n完成以上几步后不要忘记删除着色器\n```cpp\nglDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n```\n\n## 输入顶点以及索引\n\n```cpp\n// 顶点输入\nGLfloat vertices[] = {\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.5f,  -0.5f, 0.0f,    // 右下角\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.5f,  0.5f, 0.0f     // 左上角\n};\n```\n\n**赋值array的时候, 不要忘记{};**\n\n```cpp\n// 顶点索引\nGLuint indices[] = {\n  0, 1, 3                // 第一个三角形\n  // ...                 // 可根据vertices数组, 建立多组索引\n};\n```\n\n## **创建和绑定顶点数组对象(VAO)**\nVAO = Vertex Array Object\n\n功能:\n> * 随后的顶点属性调用都会储存在这个VAO之中。\n> * 使得在不同顶点数据和属性设置之间切换变得简单。\n\n**存储内容**:\n> * glEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n> * 通过glVertexAttribPointer设置的顶点属性配置。\n> * 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。\n\n使用注意:\n> * **先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针**\n\n```cpp\nGLuint VAO;\nglGenVertexArrays(1, &VAO);   // 创建VAO对象\nglBindVertexArray(VAO);       // 绑定顶点数组对象\n```\n\n\n## **创建和绑定顶点缓冲对象(VBO)**\n\nOpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。\n\n作用:\n> * 通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。\n> * 一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。\n\n<span style=\"color:blue\">*我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上* </span>\n```cpp\nGLuint VBO;\nglGenBuffer(1, &VBO);           // 创建\n// 把顶点数组复制到缓存中提供OpenGL使用\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n```\n\n## **索引缓冲对象(EBO)**\n\n可以创建不同的索引数组，而使用同一个顶点数组。如下：\n```cpp\nunsigned int indices[] = { // 注意索引从0开始! \n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n```\n\n```cpp\nGLuint EBO;\nglGenBuffer(1, &EBO);                // 创建\n// 把顶点索引复制到缓存中提供OpenGL使用\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n```\n\n\n\t\n## **设置顶点属性**\n\t\n![vertex_attribute_pointer](/images/vertex_attribute_pointer.png)\t\n\n> * 位置数据被储存为32位(4字节)浮点值 => siezeof(flaot) = 4 types = 32bits\n> * 每个位置包含3个这样的值\n> * 没有空隙, 紧密排列。\n> * 数据中的第一个值再缓冲开始位置。\n\n```cpp\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexattribArray(0);    // 开启位置为0的顶点属性\n```\n\n**glVertexAttribPointer参数**\n> 1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style=\"color:red\">**layout (location=0) in vec3 xx**</span> 吗？ \n> 2, 顶点属性的大小。 vec3 => 3个值组成\n> 3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)\n> 4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;\n> 5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。\n> 6. 偏移量。位置数据在数组开头就设置成0\n\n\n顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。\n输入的参数顶点属性的位置值。<span style=\"color:red\">**layout (location=0) in vec3 xx**</span> \n\n## 绘制图元\n\n`在主循环内部绘制图元。`\n\n1, 激活程序对象\n2, 绑定缓存对象\n3, 绘制\n4, 解绑缓存对象\n\n**绘制两种方式：**\nglDrawArrays();\n> * 使用当前绑定的顶点缓存对象进行绘制\nglDrawElements()\n> * 使用当前绑定的索引缓冲对象中的索引进行绘制\n\n第一种，\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\n// 绑定顶点数组对象\nglBindVertexArray(VAO);\n// 使用当前绑定的顶点缓存对象进行绘制\nglDrawArrays(GL_TRIANGLES, 0, 3);\n// 解绑缓存对象\nglBindVertArray(0);\n```\n第二种,\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\n// 绑定顶点数组对象 \nglBindVertexArray(VAO);\n// 使用当前绑定的索引缓冲对象中的索引进行绘制\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n// 解绑缓存对象\nglBindVertArray(0);\n```\n\n<span style=\"color:blue\">*VAO有种结合VBO+EBO的意思*</span>\n**再回顾一遍它的存储内容**:\n> * glEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n> * 通过glVertexAttribPointer设置的顶点属性配置。\n> * 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。\n\n`退出循环后删除对象，释放缓存`\n```cpp\nglDeleteVertexArray(1, &VAO);\nglDeleteBuffers(1, &VBO);\nglDeleteBuffers(1, &EBO);\n```\n\n-----\n\n# 课后练习\n实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，\n> 1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？\n> 2, 顶点着色器和片段着色器之间的关系？\n> 3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？\n\n## **1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形**\n\n\n**glDrawArrays();**\n根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。\n\n\n```cpp\n// 先设置顶点数组\nGLfloat vertices[] = {\n    // 第一个triangle\n    0.5f,   0.5f, 0.0f,    // 右上角\n    0.5f,  -0.5f, 0.0f,    // 右下角\n    0.0f,   0.0f, 0.0f,    // 连接处\n    // 第二个triangle\n    -0.5f, -0.5f, 0.0f,    // 左下角\n    -0.5f,  0.5f, 0.0f,    // 左上角\n    0.0f,   0.0f, 0.0f     // 连接处\n  };\n```\n\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawArrays(GL_TRIANGLES, 0, 6);  // 从顶点数组索引0开始依次绘制6个顶点\n\n```\n\n\n**glDrawElements();**\n根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针\n\n\n```cpp\n// 顶点输入\nGLfloat vertices[] = {\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.5f,  -0.5f, 0.0f,    // 右下角\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.5f,  0.5f, 0.0f     // 左上角\n};\n\nGLuint indices[] = {     // 索引从0开始\n  0, 1, 3,               // 第一个三角形\n  1, 2, 3                // 第二个三角形\n};\n```\n\n还需要在绑定VAO后绑定VBO和EBO\n```cpp\n// ...\n```\n\n```cpp\n// 激活程序对象\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)  // 索引数组绘制6个顶点\n```\n\n<span style=\"color:blue\">*这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。*</span>\n\n[练习1源码 - github](https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp)\n\n-----\n\n## **2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO**\n// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。\n\n**glGenBuffers**(GLsizei n,\n                GLuint* buffers);\n生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在**Buffers**中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。\n\n**glGenVertexArrays**(GLsizei n,\n                      GLuint* arrays);\n返回n个顶点数组对象名字，存储到arrays指针中。\n\n**glBindBuffer(GLenum target, \n               GLuint buffer);**\n绑定一个已经命名的缓存对象。\n\n*target*\n`----------------------------------------------------------`\n`GL_ARRAY_BUFFER`            |     顶点属性\n`GL_ELEMENT_ARRAY_BUFFER`    |     顶点数组索引\n`GL_TEXTURE_BUFFER`          |     纹理数据缓存\n`GL_UNIFORM_BUFFER`          |     Uniform块存储\n`----------------------------------------------------------`\n\n*buffer*\n    缓存对象的名字\n\n\n**glBindVertexArray**(GLuint array);\n用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。\n\n\n**glBufferData**(GLenum target\n                 GLsizeiptr size\n\t\t\t\t const GLvoid * data\n\t\t\t\t GLenum usage);\n创建或者初始化一个缓冲对象的数据的储存。\n\n*target*\n     这里是GL_ARRAY_BUFFER\n\n*size*\n   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到\n\n*data*\n   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝\n   \n*usage*\n    储存好的数据的使用模式。 `GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY`有这么几种。这里只用于静态绘制\n\n\n**glVertexAttribPointer**(GLuint index,\n                      GLint size,\n \t                  GLenum type,\n \t                  GLboolean normalized,\n \t                  GLsizei stride,\n \t                  const GLvoid * pointer);\n上面有所解释。现在就够用了。\n\n**glEnableVertexAttribArray**(GLuint index);\n启用设置好的顶点属性数组，\n*glDisableVertexAttribArray*(GLuint index);\n关闭\n\n*index* \n   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.\n\n**glBindVertexArray**();\n用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。\n\n**glDrawArrays**(GLenum mode,\n               GLint first,\n\t\t\t   GLsizei count);\n练习1中已经出现过，调用之前先要绑定Array;\n根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。\n\n\n代码实现如下：\n```cpp\n// 输入两个三角形各自的顶点数组\nGLfloat firstTriangleVertices[] = {\n  // 第一个triangle\n  0.5f,   0.5f, 0.0f,    // 右上角\n  0.1f,  -0.5f, 0.0f,    // 右下角\n  -0.5f,  0.3f, 0.0f,    // 左下角\n};\n\nGLfloat secondTriangleVertices[] = {\n  // 第二个triangle\n  -0.5f, -0.5f, 0.0f,    // 左下角\n  -0.1f,  0.5f, 0.0f,    // 左上角\n  0.5f,  -0.3f, 0.0f     // 右下角\n};\n```\n\n\n1, 共同以VAOs和VBOs以数组创建\n```cpp\nGLuint VBOs[2], VAOs[2];\nglGenBuffers(2, VAOs);\nglGenVertexArrays(2, VAOs);\n```\n2, 单独绑定, 复制, 设置顶点属性 \n```cpp\nglBindVertexArray(VAOs[0]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);\nglBufferData(GL_GL_ARRAY_BUFFER, sizeof(firstTriangleVertices),\n               firstTriangleVertices, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,\n                        3 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0);\n\n// 同理VAOs[1], VBOs[1]..\nglBindVertexArray(VAOs[1]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);\nglBufferData(GL_GL_ARRAY_BUFFER, sizeof(secondTriangleVertices),\n               secondTriangleVertices, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,\n                        3 * sizeof(GLfloat), (GLvoid*)0);\nglEnableVertexAttribArray(0);\n```\n\n\n3, 单独绘制\n```cpp\n// ==========firstTriangle=========\nglUseProgram(shaderProgram);\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n// ==========secondTriangle========\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\nglBindVertexArray(0);\n```\n\n\n[练习2源码](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2)\n\n## **3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色**\n\n之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。\n\n// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组\n// 注意：片段着色器不能放在数组里。\n// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。\n\n1, GLSL编写橙色和黄色着色器代码\n2，分别附着，编译，检查着色器，并attach到不同的program\n3, 用不同的program进行draw\n\n\n**1, GLSL编写橙色和黄色着色器代码**\n```cpp\n// 片段着色器0\nconst GLchar* fragmentShaderSource0 = \"#version 330 core\\n\"\n    \"out vec4 color;\\n\"\n    \"void main() {\\n\"\n    \"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"   // orange\n    \"}\\n\\0\";\n\n// 片段着色器1\nconst GLchar* fragmentShaderSource1 = \"#version 330 core\\n\"\n    \"out vec4 color;\\n\"\n    \"void main() {\\n\"\n    \"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\\n\"   // yellow\n    \"}\\n\\0\";\n```\n\n**2，分别附着，编译，检查着色器，并attach到不同的program**\n```cpp\n// 创建片段着色器\n  GLuint fragmentShaderOrange;\n  GLuint fragmentShaderYellow;\n  GLuint shaderProgramOrange;\n  GLuint shaderProgramYellow;\n  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);\n  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);\n  shaderProgramOrange = glCreateProgram();\n  shaderProgramYellow = glCreateProgram();\n  // ===========编译第一个片段着色器===================\n  // 源码附加到着色器对象上\n  glShaderSource(fragmentShaderOrange, 1, &fragmentShaderSource0, NULL);\n  glCompileShader(fragmentShaderOrange);\n  // 检测glComplieShader是否编译成功\n  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n  if (!success) {\n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n\n  // ===========编译第二个片段黄色着色器===================\n  // 源码附加到着色器对象上\n  glShaderSource(fragmentShaderYellow, 1, &fragmentShaderSource1, NULL);\n  glCompileShader(fragmentShaderYellow);\n  // 检测glComplieShader是否编译成功\n  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);\n  if (!success) {\n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // 把两个着色器对象链接到用来渲染的两个着色程序中\n  glAttachShader(shaderProgramOrange, vertexShader);\n  // =====连接第一个片段着色器=====\n  glAttachShader(shaderProgramOrange, fragmentShaderOrange);\n  glLinkProgram(shaderProgramOrange);\n  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &success);\n  if (!success) {\n    glGetProgramInfoLog(shaderProgramOrange, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // =====连接第二个片段着色器=====\n  glAttachShader(shaderProgramYellow, vertexShader);\n  glAttachShader(shaderProgramYellow, fragmentShaderYellow);\n  glLinkProgram(shaderProgramYellow);\n  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &success);\n  if (!success) {\n    glGetProgramInfoLog(shaderProgramYellow, 512, NULL, infoLog);\n    std::cout << \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"\n              << infoLog << std::endl;\n  }\n  // 删除着色器\n  glDeleteShader(vertexShader);\n  glDeleteShader(fragmentShaderOrange);\n  glDeleteShader(fragmentShaderYellow);\n```\n\n**3, 用不同的program进行draw**\n```cpp\n// =====激活程序对象绘制第一个triangle======\nglUseProgram(shaderProgramOrange);      // 使用第一个片段着色器连接的program\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);  // 从索引0开始依次绘制3个顶点\n\n// =====激活程序对象绘制第二个triangle======\nglUseProgram(shaderProgramYellow);      // 使用第二个片段着色器连接的program\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);  // 从索引0开始依次绘制3个顶点\n```\n\n[练习3源码](https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3)\n\n=======\n\nrefwebsite:\n[你好三角形 - learnopengl-CN](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/)\n\n\n","slug":"hello-triangle-three-execises","published":1,"updated":"2018-06-19T16:15:03.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyji000fk8mf3eanrgvm","content":"<p>代码已托管在<a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started\" target=\"_blank\" rel=\"noopener\">/timtingwei/LearnOpenGL</a></p>\n<h1 id=\"图形管线渲染有哪几个阶段？\"><a href=\"#图形管线渲染有哪几个阶段？\" class=\"headerlink\" title=\"图形管线渲染有哪几个阶段？\"></a>图形管线渲染有哪几个阶段？</h1><p>顶点数据(Vertex data[])  -&gt;</p>\n<blockquote>\n<p>1, <strong>顶点着色器</strong>(Vertex Shader) -&gt;<br>2, 形状(图元)装配(Shape Assembly) -&gt;<br>3, <strong>几何着色器</strong>(Geometry Shader) -&gt;<br>4, 光栅化(Rasterization) -&gt;<br>5, <strong>片段着色器</strong>(Fragment Shader) -&gt;<br>6, 测试与混合(Test And Blending)</p>\n</blockquote>\n<p>三个着色器可以自己定义。</p>\n<p><strong>顶点数据(Vertex data)：</strong></p>\n<blockquote>\n<ul>\n<li>Vertex是一个3D坐标的集合</li>\n<li>Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color</li>\n</ul>\n</blockquote>\n<p><strong>顶点着色器(Vertex Shader)：</strong></p>\n<blockquote>\n<ul>\n<li>把3D坐标转换成另外一种3D坐标</li>\n<li>允许对Vertex Attribute做基本处理</li>\n</ul>\n</blockquote>\n<p><strong>片段着色器(Fragment Shader)：</strong></p>\n<blockquote>\n<ul>\n<li>计算一个像素最终的颜色</li>\n<li>着色器包含3D场景数据(光照，阴影，光的颜色)</li>\n</ul>\n</blockquote>\n<p><strong>Alpha测试和混合(Blending):</strong></p>\n<blockquote>\n<ul>\n<li>测试深度，反应前后。</li>\n<li>检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)</li>\n</ul>\n</blockquote>\n<p>补充: 图元(Primitive):</p>\n<blockquote>\n<ul>\n<li>任何一个绘制指令的调用，都把图元传递给OpenGL。</li>\n<li>如GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</li>\n</ul>\n</blockquote>\n<h1 id=\"绘制绘制三角形\"><a href=\"#绘制绘制三角形\" class=\"headerlink\" title=\"绘制绘制三角形\"></a>绘制绘制三角形</h1><h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>使用GLSL(OpenGL Shading Language)编写顶点着色器<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core          <span class=\"comment\">// 每个着色器起始于版本声明, core代表核心模式</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">layout (location=<span class=\"number\">0</span>) in vec3 aPos;      <span class=\"comment\">// 设定输入变量的位置值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么需要<strong>layout (location=0)</strong>设定位置值？</p>\n<blockquote>\n<ul>\n<li><strong>glVertexAttributPointer</strong>函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。</li>\n</ul>\n</blockquote>\n<p>相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，<a href=\"https://timtingwei.github.io\">着色器中</a>讲解</p>\n<h2 id=\"编译顶点着色器\"><a href=\"#编译顶点着色器\" class=\"headerlink\" title=\"编译顶点着色器\"></a>编译顶点着色器</h2><p>编写着色器源码后，</p>\n<blockquote>\n<p>1, 先创建着色器对象;<br>2, 再把源码附加到着色器对象上;<br>3, 编译并检查</p>\n</blockquote>\n<p><strong>1, 创建顶点着色器对象</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> vertexShader;                         <span class=\"comment\">// ID引用</span></span><br><span class=\"line\">vertexShader = glCreateShader(GL_VERTEX_SHADER);   <span class=\"comment\">// 传递着色器类型参数</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2, 附源码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(vertexShader, <span class=\"number\">1</span>, &amp;vertexShaderSource, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<p><strong>glShaderSource</strong>函数的几个参数：</p>\n<blockquote>\n<p>0, 着色器对象<br>1, 传递的源码字符数量<br>2, 顶点着色器的真正源码<br>3, 先设置为NULL</p>\n</blockquote>\n<p><strong>3, 编译</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glCompileShader(vertexShader);</span><br><span class=\"line\"><span class=\"comment\">// 检查编译是否成功</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> success;</span><br><span class=\"line\"><span class=\"keyword\">char</span> infoLog[<span class=\"number\">512</span>];</span><br><span class=\"line\">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\"><span class=\"comment\">// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;!success&#125; &#123;</span><br><span class=\"line\">  glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span> &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>同理顶点着色器，编写着色器源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"></span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  FragColor =  vec4(<span class=\"number\">1.0f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.2f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量</p>\n<h2 id=\"编译片段着色器\"><a href=\"#编译片段着色器\" class=\"headerlink\" title=\"编译片段着色器\"></a>编译片段着色器</h2><p>1, 创建对象<br>2, 附加源码<br>3, 编译并检查</p>\n<p>自己重新写一遍, 并检查错误<br>1, 创建对象尝试<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> fragmentShader;</span><br><span class=\"line\">glCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   <span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> fragmentShader;</span><br><span class=\"line\">glCreateShader(GL_FRAGMENT_SHADER);     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:不需要用着色器对象作为函数的参数，</span></span><br></pre></td></tr></table></figure></p>\n<p>查阅<a href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml\" target=\"_blank\" rel=\"noopener\">khronos.org - glCreateShader</a></p>\n<blockquote>\n<ul>\n<li>Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.<br>会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。</li>\n</ul>\n</blockquote>\n<p>2, 附源码尝试<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(<span class=\"number\">1</span>, fragmentShader, fragmentSource, <span class=\"literal\">NULL</span>)   <span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(fragmentShader, <span class=\"number\">1</span>, fragmentShaderSource, <span class=\"literal\">NULL</span>);  <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:交换参数位置</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>着色器对象</li>\n<li>传递源码字符的数量</li>\n</ol>\n</blockquote>\n<p>3, 尝试编译<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> success;    <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">glCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); <span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* infoLog[<span class=\"number\">512</span>];                                <span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败把报错内容储存再infoLog中输出</span></span><br><span class=\"line\">  glGetShaderinfoLog(fragmentShader, &amp;success, &amp;infoLog);   <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"COMPILE::ERROR::FRAGEMENT::SHADER\"</span> </span><br><span class=\"line\">            &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glCompileShader(fragmentShader);     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:只要着色器对象一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> success;                         <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>: success是一个int类型</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> infoLog[<span class=\"number\">512</span>];                   <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>: char 并非 unsigned cha*</span></span><br><span class=\"line\">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);   <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:获取success在先，才能对success做判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败输出</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\"</span> &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建着色器程序\"><a href=\"#创建着色器程序\" class=\"headerlink\" title=\"创建着色器程序\"></a>创建着色器程序</h2><p>绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> shaderProgram;</span><br><span class=\"line\">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure>\n<h2 id=\"链接着色器对象\"><a href=\"#链接着色器对象\" class=\"headerlink\" title=\"链接着色器对象\"></a>链接着色器对象</h2><p>两个着色器对象要链接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glAttachShader(shaderProgram, vertexShader);</span><br><span class=\"line\">glAttachShader(shaderProgram, fragmentShader);</span><br><span class=\"line\">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"编译着色程序\"><a href=\"#编译着色程序\" class=\"headerlink\" title=\"编译着色程序\"></a>编译着色程序</h2><p>与之前的着色器编译原理相同，只是调用函数和参数变量改变了。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  glGetProgramInfoLog(shaderProgram, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。</p>\n<h2 id=\"删除着色器\"><a href=\"#删除着色器\" class=\"headerlink\" title=\"删除着色器\"></a>删除着色器</h2><p>完成以上几步后不要忘记删除着色器<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glDeleteShader(vertexShader);</span><br><span class=\"line\">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"输入顶点以及索引\"><a href=\"#输入顶点以及索引\" class=\"headerlink\" title=\"输入顶点以及索引\"></a>输入顶点以及索引</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点输入</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>赋值array的时候, 不要忘记{};</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点索引</span></span><br><span class=\"line\">GLuint indices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>                <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">  <span class=\"comment\">// ...                 // 可根据vertices数组, 建立多组索引</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建和绑定顶点数组对象-VAO\"><a href=\"#创建和绑定顶点数组对象-VAO\" class=\"headerlink\" title=\"创建和绑定顶点数组对象(VAO)\"></a><strong>创建和绑定顶点数组对象(VAO)</strong></h2><p>VAO = Vertex Array Object</p>\n<p>功能:</p>\n<blockquote>\n<ul>\n<li>随后的顶点属性调用都会储存在这个VAO之中。</li>\n<li>使得在不同顶点数据和属性设置之间切换变得简单。</li>\n</ul>\n</blockquote>\n<p><strong>存储内容</strong>:</p>\n<blockquote>\n<ul>\n<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>\n<li>通过glVertexAttribPointer设置的顶点属性配置。</li>\n<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>\n</ul>\n</blockquote>\n<p>使用注意:</p>\n<blockquote>\n<ul>\n<li><strong>先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VAO;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;VAO);   <span class=\"comment\">// 创建VAO对象</span></span><br><span class=\"line\">glBindVertexArray(VAO);       <span class=\"comment\">// 绑定顶点数组对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建和绑定顶点缓冲对象-VBO\"><a href=\"#创建和绑定顶点缓冲对象-VBO\" class=\"headerlink\" title=\"创建和绑定顶点缓冲对象(VBO)\"></a><strong>创建和绑定顶点缓冲对象(VBO)</strong></h2><p>OpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。</p>\n<p>作用:</p>\n<blockquote>\n<ul>\n<li>通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。</li>\n<li>一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。</li>\n</ul>\n</blockquote>\n<p><span style=\"color:blue\"><em>我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VBO;</span><br><span class=\"line\">glGenBuffer(<span class=\"number\">1</span>, &amp;VBO);           <span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"comment\">// 把顶点数组复制到缓存中提供OpenGL使用</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"索引缓冲对象-EBO\"><a href=\"#索引缓冲对象-EBO\" class=\"headerlink\" title=\"索引缓冲对象(EBO)\"></a><strong>索引缓冲对象(EBO)</strong></h2><p>可以创建不同的索引数组，而使用同一个顶点数组。如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> indices[] = &#123; <span class=\"comment\">// 注意索引从0开始! </span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>  <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint EBO;</span><br><span class=\"line\">glGenBuffer(<span class=\"number\">1</span>, &amp;EBO);                <span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"comment\">// 把顶点索引复制到缓存中提供OpenGL使用</span></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置顶点属性\"><a href=\"#设置顶点属性\" class=\"headerlink\" title=\"设置顶点属性\"></a><strong>设置顶点属性</strong></h2><p><img src=\"/images/vertex_attribute_pointer.png\" alt=\"vertex_attribute_pointer\">    </p>\n<blockquote>\n<ul>\n<li>位置数据被储存为32位(4字节)浮点值 =&gt; siezeof(flaot) = 4 types = 32bits</li>\n<li>每个位置包含3个这样的值</li>\n<li>没有空隙, 紧密排列。</li>\n<li>数据中的第一个值再缓冲开始位置。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>), (<span class=\"keyword\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexattribArray(<span class=\"number\">0</span>);    <span class=\"comment\">// 开启位置为0的顶点属性</span></span><br></pre></td></tr></table></figure>\n<p><strong>glVertexAttribPointer参数</strong></p>\n<blockquote>\n<p>1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style=\"color:red\"><strong>layout (location=0) in vec3 xx</strong></span> 吗？<br>2, 顶点属性的大小。 vec3 =&gt; 3个值组成<br>3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)<br>4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;<br>5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。</p>\n<ol>\n<li>偏移量。位置数据在数组开头就设置成0</li>\n</ol>\n</blockquote>\n<p>顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。<br>输入的参数顶点属性的位置值。<span style=\"color:red\"><strong>layout (location=0) in vec3 xx</strong></span> </p>\n<h2 id=\"绘制图元\"><a href=\"#绘制图元\" class=\"headerlink\" title=\"绘制图元\"></a>绘制图元</h2><p><code>在主循环内部绘制图元。</code></p>\n<p>1, 激活程序对象<br>2, 绑定缓存对象<br>3, 绘制<br>4, 解绑缓存对象</p>\n<p><strong>绘制两种方式：</strong><br>glDrawArrays();</p>\n<blockquote>\n<ul>\n<li>使用当前绑定的顶点缓存对象进行绘制<br>glDrawElements()</li>\n<li>使用当前绑定的索引缓冲对象中的索引进行绘制</li>\n</ul>\n</blockquote>\n<p>第一种，<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\"><span class=\"comment\">// 绑定顶点数组对象</span></span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\"><span class=\"comment\">// 使用当前绑定的顶点缓存对象进行绘制</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 解绑缓存对象</span></span><br><span class=\"line\">glBindVertArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第二种,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\"><span class=\"comment\">// 绑定顶点数组对象 </span></span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\"><span class=\"comment\">// 使用当前绑定的索引缓冲对象中的索引进行绘制</span></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_INT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 解绑缓存对象</span></span><br><span class=\"line\">glBindVertArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:blue\"><em>VAO有种结合VBO+EBO的意思</em></span><br><strong>再回顾一遍它的存储内容</strong>:</p>\n<blockquote>\n<ul>\n<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>\n<li>通过glVertexAttribPointer设置的顶点属性配置。</li>\n<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>\n</ul>\n</blockquote>\n<p><code>退出循环后删除对象，释放缓存</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glDeleteVertexArray(<span class=\"number\">1</span>, &amp;VAO);</span><br><span class=\"line\">glDeleteBuffers(<span class=\"number\">1</span>, &amp;VBO);</span><br><span class=\"line\">glDeleteBuffers(<span class=\"number\">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a>课后练习</h1><p>实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，</p>\n<blockquote>\n<p>1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？<br>2, 顶点着色器和片段着色器之间的关系？<br>3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？</p>\n</blockquote>\n<h2 id=\"1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\"><a href=\"#1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\" class=\"headerlink\" title=\"1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\"></a><strong>1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形</strong></h2><p><strong>glDrawArrays();</strong><br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先设置顶点数组</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个triangle</span></span><br><span class=\"line\">    <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">    <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>,   <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 连接处</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个triangle</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>,   <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 连接处</span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// 从顶点数组索引0开始依次绘制6个顶点</span></span><br></pre></td></tr></table></figure>\n<p><strong>glDrawElements();</strong><br>根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点输入</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint indices[] = &#123;     <span class=\"comment\">// 索引从0开始</span></span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>,               <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">  <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>                <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>还需要在绑定VAO后绑定VBO和EBO<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_INT, <span class=\"number\">0</span>)  <span class=\"comment\">// 索引数组绘制6个顶点</span></span><br></pre></td></tr></table></figure>\n<p><span style=\"color:blue\"><em>这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。</em></span></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp\" target=\"_blank\" rel=\"noopener\">练习1源码 - github</a></p>\n<hr>\n<h2 id=\"2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\"><a href=\"#2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\" class=\"headerlink\" title=\"2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\"></a><strong>2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO</strong></h2><p>// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。</p>\n<p><strong>glGenBuffers</strong>(GLsizei n,<br>                GLuint<em> buffers);<br>生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在<em>*Buffers</em></em>中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。</p>\n<p><strong>glGenVertexArrays</strong>(GLsizei n,<br>                      GLuint* arrays);<br>返回n个顶点数组对象名字，存储到arrays指针中。</p>\n<p><strong>glBindBuffer(GLenum target,<br>               GLuint buffer);</strong><br>绑定一个已经命名的缓存对象。</p>\n<p><em>target</em><br><code>----------------------------------------------------------</code><br><code>GL_ARRAY_BUFFER</code>            |     顶点属性<br><code>GL_ELEMENT_ARRAY_BUFFER</code>    |     顶点数组索引<br><code>GL_TEXTURE_BUFFER</code>          |     纹理数据缓存<br><code>GL_UNIFORM_BUFFER</code>          |     Uniform块存储<br><code>----------------------------------------------------------</code></p>\n<p><em>buffer</em><br>    缓存对象的名字</p>\n<p><strong>glBindVertexArray</strong>(GLuint array);<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>\n<p><strong>glBufferData</strong>(GLenum target<br>                 GLsizeiptr size<br>                 const GLvoid * data<br>                 GLenum usage);<br>创建或者初始化一个缓冲对象的数据的储存。</p>\n<p><em>target</em><br>     这里是GL_ARRAY_BUFFER</p>\n<p><em>size</em><br>   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到</p>\n<p><em>data</em><br>   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝</p>\n<p><em>usage</em><br>    储存好的数据的使用模式。 <code>GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</code>有这么几种。这里只用于静态绘制</p>\n<p><strong>glVertexAttribPointer</strong>(GLuint index,<br>                      GLint size,<br>                       GLenum type,<br>                       GLboolean normalized,<br>                       GLsizei stride,<br>                       const GLvoid * pointer);<br>上面有所解释。现在就够用了。</p>\n<p><strong>glEnableVertexAttribArray</strong>(GLuint index);<br>启用设置好的顶点属性数组，<br><em>glDisableVertexAttribArray</em>(GLuint index);<br>关闭</p>\n<p><em>index</em><br>   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.</p>\n<p><strong>glBindVertexArray</strong>();<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>\n<p><strong>glDrawArrays</strong>(GLenum mode,<br>               GLint first,<br>               GLsizei count);<br>练习1中已经出现过，调用之前先要绑定Array;<br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>\n<p>代码实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入两个三角形各自的顶点数组</span></span><br><span class=\"line\">GLfloat firstTriangleVertices[] = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个triangle</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.1f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.3f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLfloat secondTriangleVertices[] = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第二个triangle</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.1f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.3f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>1, 共同以VAOs和VBOs以数组创建<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VBOs[<span class=\"number\">2</span>], VAOs[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, VAOs);</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">2</span>, VAOs);</span><br></pre></td></tr></table></figure></p>\n<p>2, 单独绑定, 复制, 设置顶点属性<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(firstTriangleVertices),</span><br><span class=\"line\">               firstTriangleVertices, GL_STATIC_DRAW);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class=\"line\">                        <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同理VAOs[1], VBOs[1]..</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(secondTriangleVertices),</span><br><span class=\"line\">               secondTriangleVertices, GL_STATIC_DRAW);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class=\"line\">                        <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3, 单独绘制<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ==========firstTriangle=========</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// ==========secondTriangle========</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2\" target=\"_blank\" rel=\"noopener\">练习2源码</a></p>\n<h2 id=\"3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\"><a href=\"#3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\" class=\"headerlink\" title=\"3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\"></a><strong>3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色</strong></h2><p>之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。</p>\n<p>// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组<br>// 注意：片段着色器不能放在数组里。<br>// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。</p>\n<p>1, GLSL编写橙色和黄色着色器代码<br>2，分别附着，编译，检查着色器，并attach到不同的program<br>3, 用不同的program进行draw</p>\n<p><strong>1, GLSL编写橙色和黄色着色器代码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 片段着色器0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar* fragmentShaderSource0 = <span class=\"string\">\"#version 330 core\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"out vec4 color;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"void main() &#123;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"</span>   <span class=\"comment\">// orange</span></span><br><span class=\"line\">    <span class=\"string\">\"&#125;\\n\\0\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar* fragmentShaderSource1 = <span class=\"string\">\"#version 330 core\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"out vec4 color;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"void main() &#123;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\\n\"</span>   <span class=\"comment\">// yellow</span></span><br><span class=\"line\">    <span class=\"string\">\"&#125;\\n\\0\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2，分别附着，编译，检查着色器，并attach到不同的program</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建片段着色器</span></span><br><span class=\"line\">  GLuint fragmentShaderOrange;</span><br><span class=\"line\">  GLuint fragmentShaderYellow;</span><br><span class=\"line\">  GLuint shaderProgramOrange;</span><br><span class=\"line\">  GLuint shaderProgramYellow;</span><br><span class=\"line\">  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class=\"line\">  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class=\"line\">  shaderProgramOrange = glCreateProgram();</span><br><span class=\"line\">  shaderProgramYellow = glCreateProgram();</span><br><span class=\"line\">  <span class=\"comment\">// ===========编译第一个片段着色器===================</span></span><br><span class=\"line\">  <span class=\"comment\">// 源码附加到着色器对象上</span></span><br><span class=\"line\">  glShaderSource(fragmentShaderOrange, <span class=\"number\">1</span>, &amp;fragmentShaderSource0, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  glCompileShader(fragmentShaderOrange);</span><br><span class=\"line\">  <span class=\"comment\">// 检测glComplieShader是否编译成功</span></span><br><span class=\"line\">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ===========编译第二个片段黄色着色器===================</span></span><br><span class=\"line\">  <span class=\"comment\">// 源码附加到着色器对象上</span></span><br><span class=\"line\">  glShaderSource(fragmentShaderYellow, <span class=\"number\">1</span>, &amp;fragmentShaderSource1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  glCompileShader(fragmentShaderYellow);</span><br><span class=\"line\">  <span class=\"comment\">// 检测glComplieShader是否编译成功</span></span><br><span class=\"line\">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把两个着色器对象链接到用来渲染的两个着色程序中</span></span><br><span class=\"line\">  glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class=\"line\">  <span class=\"comment\">// =====连接第一个片段着色器=====</span></span><br><span class=\"line\">  glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class=\"line\">  glLinkProgram(shaderProgramOrange);</span><br><span class=\"line\">  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetProgramInfoLog(shaderProgramOrange, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// =====连接第二个片段着色器=====</span></span><br><span class=\"line\">  glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class=\"line\">  glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class=\"line\">  glLinkProgram(shaderProgramYellow);</span><br><span class=\"line\">  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetProgramInfoLog(shaderProgramYellow, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除着色器</span></span><br><span class=\"line\">  glDeleteShader(vertexShader);</span><br><span class=\"line\">  glDeleteShader(fragmentShaderOrange);</span><br><span class=\"line\">  glDeleteShader(fragmentShaderYellow);</span><br></pre></td></tr></table></figure></p>\n<p><strong>3, 用不同的program进行draw</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// =====激活程序对象绘制第一个triangle======</span></span><br><span class=\"line\">glUseProgram(shaderProgramOrange);      <span class=\"comment\">// 使用第一个片段着色器连接的program</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 从索引0开始依次绘制3个顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// =====激活程序对象绘制第二个triangle======</span></span><br><span class=\"line\">glUseProgram(shaderProgramYellow);      <span class=\"comment\">// 使用第二个片段着色器连接的program</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 从索引0开始依次绘制3个顶点</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3\" target=\"_blank\" rel=\"noopener\">练习3源码</a></p>\n<p>=======</p>\n<p>refwebsite:<br><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\" target=\"_blank\" rel=\"noopener\">你好三角形 - learnopengl-CN</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>代码已托管在<a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started\" target=\"_blank\" rel=\"noopener\">/timtingwei/LearnOpenGL</a></p>\n<h1 id=\"图形管线渲染有哪几个阶段？\"><a href=\"#图形管线渲染有哪几个阶段？\" class=\"headerlink\" title=\"图形管线渲染有哪几个阶段？\"></a>图形管线渲染有哪几个阶段？</h1><p>顶点数据(Vertex data[])  -&gt;</p>\n<blockquote>\n<p>1, <strong>顶点着色器</strong>(Vertex Shader) -&gt;<br>2, 形状(图元)装配(Shape Assembly) -&gt;<br>3, <strong>几何着色器</strong>(Geometry Shader) -&gt;<br>4, 光栅化(Rasterization) -&gt;<br>5, <strong>片段着色器</strong>(Fragment Shader) -&gt;<br>6, 测试与混合(Test And Blending)</p>\n</blockquote>\n<p>三个着色器可以自己定义。</p>\n<p><strong>顶点数据(Vertex data)：</strong></p>\n<blockquote>\n<ul>\n<li>Vertex是一个3D坐标的集合</li>\n<li>Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color</li>\n</ul>\n</blockquote>\n<p><strong>顶点着色器(Vertex Shader)：</strong></p>\n<blockquote>\n<ul>\n<li>把3D坐标转换成另外一种3D坐标</li>\n<li>允许对Vertex Attribute做基本处理</li>\n</ul>\n</blockquote>\n<p><strong>片段着色器(Fragment Shader)：</strong></p>\n<blockquote>\n<ul>\n<li>计算一个像素最终的颜色</li>\n<li>着色器包含3D场景数据(光照，阴影，光的颜色)</li>\n</ul>\n</blockquote>\n<p><strong>Alpha测试和混合(Blending):</strong></p>\n<blockquote>\n<ul>\n<li>测试深度，反应前后。</li>\n<li>检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)</li>\n</ul>\n</blockquote>\n<p>补充: 图元(Primitive):</p>\n<blockquote>\n<ul>\n<li>任何一个绘制指令的调用，都把图元传递给OpenGL。</li>\n<li>如GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</li>\n</ul>\n</blockquote>\n<h1 id=\"绘制绘制三角形\"><a href=\"#绘制绘制三角形\" class=\"headerlink\" title=\"绘制绘制三角形\"></a>绘制绘制三角形</h1><h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>使用GLSL(OpenGL Shading Language)编写顶点着色器<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core          <span class=\"comment\">// 每个着色器起始于版本声明, core代表核心模式</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">layout (location=<span class=\"number\">0</span>) in vec3 aPos;      <span class=\"comment\">// 设定输入变量的位置值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为什么需要<strong>layout (location=0)</strong>设定位置值？</p>\n<blockquote>\n<ul>\n<li><strong>glVertexAttributPointer</strong>函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。</li>\n</ul>\n</blockquote>\n<p>相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，<a href=\"https://timtingwei.github.io\">着色器中</a>讲解</p>\n<h2 id=\"编译顶点着色器\"><a href=\"#编译顶点着色器\" class=\"headerlink\" title=\"编译顶点着色器\"></a>编译顶点着色器</h2><p>编写着色器源码后，</p>\n<blockquote>\n<p>1, 先创建着色器对象;<br>2, 再把源码附加到着色器对象上;<br>3, 编译并检查</p>\n</blockquote>\n<p><strong>1, 创建顶点着色器对象</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> vertexShader;                         <span class=\"comment\">// ID引用</span></span><br><span class=\"line\">vertexShader = glCreateShader(GL_VERTEX_SHADER);   <span class=\"comment\">// 传递着色器类型参数</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>2, 附源码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(vertexShader, <span class=\"number\">1</span>, &amp;vertexShaderSource, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure></p>\n<p><strong>glShaderSource</strong>函数的几个参数：</p>\n<blockquote>\n<p>0, 着色器对象<br>1, 传递的源码字符数量<br>2, 顶点着色器的真正源码<br>3, 先设置为NULL</p>\n</blockquote>\n<p><strong>3, 编译</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glCompileShader(vertexShader);</span><br><span class=\"line\"><span class=\"comment\">// 检查编译是否成功</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> success;</span><br><span class=\"line\"><span class=\"keyword\">char</span> infoLog[<span class=\"number\">512</span>];</span><br><span class=\"line\">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\"><span class=\"comment\">// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;!success&#125; &#123;</span><br><span class=\"line\">  glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span> &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>同理顶点着色器，编写着色器源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"></span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  FragColor =  vec4(<span class=\"number\">1.0f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.2f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量</p>\n<h2 id=\"编译片段着色器\"><a href=\"#编译片段着色器\" class=\"headerlink\" title=\"编译片段着色器\"></a>编译片段着色器</h2><p>1, 创建对象<br>2, 附加源码<br>3, 编译并检查</p>\n<p>自己重新写一遍, 并检查错误<br>1, 创建对象尝试<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> fragmentShader;</span><br><span class=\"line\">glCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   <span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> fragmentShader;</span><br><span class=\"line\">glCreateShader(GL_FRAGMENT_SHADER);     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:不需要用着色器对象作为函数的参数，</span></span><br></pre></td></tr></table></figure></p>\n<p>查阅<a href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml\" target=\"_blank\" rel=\"noopener\">khronos.org - glCreateShader</a></p>\n<blockquote>\n<ul>\n<li>Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.<br>会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。</li>\n</ul>\n</blockquote>\n<p>2, 附源码尝试<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(<span class=\"number\">1</span>, fragmentShader, fragmentSource, <span class=\"literal\">NULL</span>)   <span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glShaderSource(fragmentShader, <span class=\"number\">1</span>, fragmentShaderSource, <span class=\"literal\">NULL</span>);  <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:交换参数位置</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>着色器对象</li>\n<li>传递源码字符的数量</li>\n</ol>\n</blockquote>\n<p>3, 尝试编译<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> success;    <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">glCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); <span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>* infoLog[<span class=\"number\">512</span>];                                <span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败把报错内容储存再infoLog中输出</span></span><br><span class=\"line\">  glGetShaderinfoLog(fragmentShader, &amp;success, &amp;infoLog);   <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"COMPILE::ERROR::FRAGEMENT::SHADER\"</span> </span><br><span class=\"line\">            &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:red\"> <em>改正</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glCompileShader(fragmentShader);     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:只要着色器对象一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> success;                         <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>: success是一个int类型</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> infoLog[<span class=\"number\">512</span>];                   <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>: char 并非 unsigned cha*</span></span><br><span class=\"line\">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);   <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span>:获取success在先，才能对success做判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败输出</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\"</span> &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建着色器程序\"><a href=\"#创建着色器程序\" class=\"headerlink\" title=\"创建着色器程序\"></a>创建着色器程序</h2><p>绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> shaderProgram;</span><br><span class=\"line\">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure>\n<h2 id=\"链接着色器对象\"><a href=\"#链接着色器对象\" class=\"headerlink\" title=\"链接着色器对象\"></a>链接着色器对象</h2><p>两个着色器对象要链接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glAttachShader(shaderProgram, vertexShader);</span><br><span class=\"line\">glAttachShader(shaderProgram, fragmentShader);</span><br><span class=\"line\">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"编译着色程序\"><a href=\"#编译着色程序\" class=\"headerlink\" title=\"编译着色程序\"></a>编译着色程序</h2><p>与之前的着色器编译原理相同，只是调用函数和参数变量改变了。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">  glGetProgramInfoLog(shaderProgram, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。</p>\n<h2 id=\"删除着色器\"><a href=\"#删除着色器\" class=\"headerlink\" title=\"删除着色器\"></a>删除着色器</h2><p>完成以上几步后不要忘记删除着色器<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glDeleteShader(vertexShader);</span><br><span class=\"line\">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"输入顶点以及索引\"><a href=\"#输入顶点以及索引\" class=\"headerlink\" title=\"输入顶点以及索引\"></a>输入顶点以及索引</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点输入</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>赋值array的时候, 不要忘记{};</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点索引</span></span><br><span class=\"line\">GLuint indices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>                <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">  <span class=\"comment\">// ...                 // 可根据vertices数组, 建立多组索引</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建和绑定顶点数组对象-VAO\"><a href=\"#创建和绑定顶点数组对象-VAO\" class=\"headerlink\" title=\"创建和绑定顶点数组对象(VAO)\"></a><strong>创建和绑定顶点数组对象(VAO)</strong></h2><p>VAO = Vertex Array Object</p>\n<p>功能:</p>\n<blockquote>\n<ul>\n<li>随后的顶点属性调用都会储存在这个VAO之中。</li>\n<li>使得在不同顶点数据和属性设置之间切换变得简单。</li>\n</ul>\n</blockquote>\n<p><strong>存储内容</strong>:</p>\n<blockquote>\n<ul>\n<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>\n<li>通过glVertexAttribPointer设置的顶点属性配置。</li>\n<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>\n</ul>\n</blockquote>\n<p>使用注意:</p>\n<blockquote>\n<ul>\n<li><strong>先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VAO;</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">1</span>, &amp;VAO);   <span class=\"comment\">// 创建VAO对象</span></span><br><span class=\"line\">glBindVertexArray(VAO);       <span class=\"comment\">// 绑定顶点数组对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"创建和绑定顶点缓冲对象-VBO\"><a href=\"#创建和绑定顶点缓冲对象-VBO\" class=\"headerlink\" title=\"创建和绑定顶点缓冲对象(VBO)\"></a><strong>创建和绑定顶点缓冲对象(VBO)</strong></h2><p>OpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。</p>\n<p>作用:</p>\n<blockquote>\n<ul>\n<li>通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。</li>\n<li>一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。</li>\n</ul>\n</blockquote>\n<p><span style=\"color:blue\"><em>我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上</em> </span><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VBO;</span><br><span class=\"line\">glGenBuffer(<span class=\"number\">1</span>, &amp;VBO);           <span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"comment\">// 把顶点数组复制到缓存中提供OpenGL使用</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"索引缓冲对象-EBO\"><a href=\"#索引缓冲对象-EBO\" class=\"headerlink\" title=\"索引缓冲对象(EBO)\"></a><strong>索引缓冲对象(EBO)</strong></h2><p>可以创建不同的索引数组，而使用同一个顶点数组。如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> indices[] = &#123; <span class=\"comment\">// 注意索引从0开始! </span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>  <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint EBO;</span><br><span class=\"line\">glGenBuffer(<span class=\"number\">1</span>, &amp;EBO);                <span class=\"comment\">// 创建</span></span><br><span class=\"line\"><span class=\"comment\">// 把顶点索引复制到缓存中提供OpenGL使用</span></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置顶点属性\"><a href=\"#设置顶点属性\" class=\"headerlink\" title=\"设置顶点属性\"></a><strong>设置顶点属性</strong></h2><p><img src=\"/images/vertex_attribute_pointer.png\" alt=\"vertex_attribute_pointer\">    </p>\n<blockquote>\n<ul>\n<li>位置数据被储存为32位(4字节)浮点值 =&gt; siezeof(flaot) = 4 types = 32bits</li>\n<li>每个位置包含3个这样的值</li>\n<li>没有空隙, 紧密排列。</li>\n<li>数据中的第一个值再缓冲开始位置。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>), (<span class=\"keyword\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexattribArray(<span class=\"number\">0</span>);    <span class=\"comment\">// 开启位置为0的顶点属性</span></span><br></pre></td></tr></table></figure>\n<p><strong>glVertexAttribPointer参数</strong></p>\n<blockquote>\n<p>1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style=\"color:red\"><strong>layout (location=0) in vec3 xx</strong></span> 吗？<br>2, 顶点属性的大小。 vec3 =&gt; 3个值组成<br>3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)<br>4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;<br>5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。</p>\n<ol>\n<li>偏移量。位置数据在数组开头就设置成0</li>\n</ol>\n</blockquote>\n<p>顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。<br>输入的参数顶点属性的位置值。<span style=\"color:red\"><strong>layout (location=0) in vec3 xx</strong></span> </p>\n<h2 id=\"绘制图元\"><a href=\"#绘制图元\" class=\"headerlink\" title=\"绘制图元\"></a>绘制图元</h2><p><code>在主循环内部绘制图元。</code></p>\n<p>1, 激活程序对象<br>2, 绑定缓存对象<br>3, 绘制<br>4, 解绑缓存对象</p>\n<p><strong>绘制两种方式：</strong><br>glDrawArrays();</p>\n<blockquote>\n<ul>\n<li>使用当前绑定的顶点缓存对象进行绘制<br>glDrawElements()</li>\n<li>使用当前绑定的索引缓冲对象中的索引进行绘制</li>\n</ul>\n</blockquote>\n<p>第一种，<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\"><span class=\"comment\">// 绑定顶点数组对象</span></span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\"><span class=\"comment\">// 使用当前绑定的顶点缓存对象进行绘制</span></span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 解绑缓存对象</span></span><br><span class=\"line\">glBindVertArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>第二种,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\"><span class=\"comment\">// 绑定顶点数组对象 </span></span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\"><span class=\"comment\">// 使用当前绑定的索引缓冲对象中的索引进行绘制</span></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_INT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 解绑缓存对象</span></span><br><span class=\"line\">glBindVertArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p><span style=\"color:blue\"><em>VAO有种结合VBO+EBO的意思</em></span><br><strong>再回顾一遍它的存储内容</strong>:</p>\n<blockquote>\n<ul>\n<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>\n<li>通过glVertexAttribPointer设置的顶点属性配置。</li>\n<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>\n</ul>\n</blockquote>\n<p><code>退出循环后删除对象，释放缓存</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glDeleteVertexArray(<span class=\"number\">1</span>, &amp;VAO);</span><br><span class=\"line\">glDeleteBuffers(<span class=\"number\">1</span>, &amp;VBO);</span><br><span class=\"line\">glDeleteBuffers(<span class=\"number\">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"课后练习\"><a href=\"#课后练习\" class=\"headerlink\" title=\"课后练习\"></a>课后练习</h1><p>实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，</p>\n<blockquote>\n<p>1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？<br>2, 顶点着色器和片段着色器之间的关系？<br>3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？</p>\n</blockquote>\n<h2 id=\"1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\"><a href=\"#1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\" class=\"headerlink\" title=\"1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\"></a><strong>1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形</strong></h2><p><strong>glDrawArrays();</strong><br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先设置顶点数组</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个triangle</span></span><br><span class=\"line\">    <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">    <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>,   <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 连接处</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个triangle</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">    <span class=\"number\">0.0f</span>,   <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 连接处</span></span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// 从顶点数组索引0开始依次绘制6个顶点</span></span><br></pre></td></tr></table></figure>\n<p><strong>glDrawElements();</strong><br>根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶点输入</span></span><br><span class=\"line\">GLfloat vertices[] = &#123;</span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLuint indices[] = &#123;     <span class=\"comment\">// 索引从0开始</span></span><br><span class=\"line\">  <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>,               <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">  <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>                <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>还需要在绑定VAO后绑定VBO和EBO<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 激活程序对象</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAO);</span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_INT, <span class=\"number\">0</span>)  <span class=\"comment\">// 索引数组绘制6个顶点</span></span><br></pre></td></tr></table></figure>\n<p><span style=\"color:blue\"><em>这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。</em></span></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp\" target=\"_blank\" rel=\"noopener\">练习1源码 - github</a></p>\n<hr>\n<h2 id=\"2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\"><a href=\"#2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\" class=\"headerlink\" title=\"2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\"></a><strong>2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO</strong></h2><p>// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。</p>\n<p><strong>glGenBuffers</strong>(GLsizei n,<br>                GLuint<em> buffers);<br>生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在<em>*Buffers</em></em>中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。</p>\n<p><strong>glGenVertexArrays</strong>(GLsizei n,<br>                      GLuint* arrays);<br>返回n个顶点数组对象名字，存储到arrays指针中。</p>\n<p><strong>glBindBuffer(GLenum target,<br>               GLuint buffer);</strong><br>绑定一个已经命名的缓存对象。</p>\n<p><em>target</em><br><code>----------------------------------------------------------</code><br><code>GL_ARRAY_BUFFER</code>            |     顶点属性<br><code>GL_ELEMENT_ARRAY_BUFFER</code>    |     顶点数组索引<br><code>GL_TEXTURE_BUFFER</code>          |     纹理数据缓存<br><code>GL_UNIFORM_BUFFER</code>          |     Uniform块存储<br><code>----------------------------------------------------------</code></p>\n<p><em>buffer</em><br>    缓存对象的名字</p>\n<p><strong>glBindVertexArray</strong>(GLuint array);<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>\n<p><strong>glBufferData</strong>(GLenum target<br>                 GLsizeiptr size<br>                 const GLvoid * data<br>                 GLenum usage);<br>创建或者初始化一个缓冲对象的数据的储存。</p>\n<p><em>target</em><br>     这里是GL_ARRAY_BUFFER</p>\n<p><em>size</em><br>   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到</p>\n<p><em>data</em><br>   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝</p>\n<p><em>usage</em><br>    储存好的数据的使用模式。 <code>GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</code>有这么几种。这里只用于静态绘制</p>\n<p><strong>glVertexAttribPointer</strong>(GLuint index,<br>                      GLint size,<br>                       GLenum type,<br>                       GLboolean normalized,<br>                       GLsizei stride,<br>                       const GLvoid * pointer);<br>上面有所解释。现在就够用了。</p>\n<p><strong>glEnableVertexAttribArray</strong>(GLuint index);<br>启用设置好的顶点属性数组，<br><em>glDisableVertexAttribArray</em>(GLuint index);<br>关闭</p>\n<p><em>index</em><br>   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.</p>\n<p><strong>glBindVertexArray</strong>();<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>\n<p><strong>glDrawArrays</strong>(GLenum mode,<br>               GLint first,<br>               GLsizei count);<br>练习1中已经出现过，调用之前先要绑定Array;<br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>\n<p>代码实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入两个三角形各自的顶点数组</span></span><br><span class=\"line\">GLfloat firstTriangleVertices[] = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第一个triangle</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,   <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右上角</span></span><br><span class=\"line\">  <span class=\"number\">0.1f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>,  <span class=\"number\">0.3f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">GLfloat secondTriangleVertices[] = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 第二个triangle</span></span><br><span class=\"line\">  <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左下角</span></span><br><span class=\"line\">  <span class=\"number\">-0.1f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,    <span class=\"comment\">// 左上角</span></span><br><span class=\"line\">  <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.3f</span>, <span class=\"number\">0.0f</span>     <span class=\"comment\">// 右下角</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>1, 共同以VAOs和VBOs以数组创建<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">GLuint VBOs[<span class=\"number\">2</span>], VAOs[<span class=\"number\">2</span>];</span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, VAOs);</span><br><span class=\"line\">glGenVertexArrays(<span class=\"number\">2</span>, VAOs);</span><br></pre></td></tr></table></figure></p>\n<p>2, 单独绑定, 复制, 设置顶点属性<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(firstTriangleVertices),</span><br><span class=\"line\">               firstTriangleVertices, GL_STATIC_DRAW);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class=\"line\">                        <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同理VAOs[1], VBOs[1]..</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(secondTriangleVertices),</span><br><span class=\"line\">               secondTriangleVertices, GL_STATIC_DRAW);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class=\"line\">                        <span class=\"number\">3</span> * <span class=\"keyword\">sizeof</span>(GLfloat), (GLvoid*)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3, 单独绘制<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ==========firstTriangle=========</span></span><br><span class=\"line\">glUseProgram(shaderProgram);</span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// ==========secondTriangle========</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">glBindVertexArray(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2\" target=\"_blank\" rel=\"noopener\">练习2源码</a></p>\n<h2 id=\"3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\"><a href=\"#3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\" class=\"headerlink\" title=\"3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\"></a><strong>3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色</strong></h2><p>之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。</p>\n<p>// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组<br>// 注意：片段着色器不能放在数组里。<br>// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。</p>\n<p>1, GLSL编写橙色和黄色着色器代码<br>2，分别附着，编译，检查着色器，并attach到不同的program<br>3, 用不同的program进行draw</p>\n<p><strong>1, GLSL编写橙色和黄色着色器代码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 片段着色器0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar* fragmentShaderSource0 = <span class=\"string\">\"#version 330 core\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"out vec4 color;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"void main() &#123;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"</span>   <span class=\"comment\">// orange</span></span><br><span class=\"line\">    <span class=\"string\">\"&#125;\\n\\0\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 片段着色器1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> GLchar* fragmentShaderSource1 = <span class=\"string\">\"#version 330 core\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"out vec4 color;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"void main() &#123;\\n\"</span></span><br><span class=\"line\">    <span class=\"string\">\"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\\n\"</span>   <span class=\"comment\">// yellow</span></span><br><span class=\"line\">    <span class=\"string\">\"&#125;\\n\\0\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2，分别附着，编译，检查着色器，并attach到不同的program</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建片段着色器</span></span><br><span class=\"line\">  GLuint fragmentShaderOrange;</span><br><span class=\"line\">  GLuint fragmentShaderYellow;</span><br><span class=\"line\">  GLuint shaderProgramOrange;</span><br><span class=\"line\">  GLuint shaderProgramYellow;</span><br><span class=\"line\">  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class=\"line\">  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class=\"line\">  shaderProgramOrange = glCreateProgram();</span><br><span class=\"line\">  shaderProgramYellow = glCreateProgram();</span><br><span class=\"line\">  <span class=\"comment\">// ===========编译第一个片段着色器===================</span></span><br><span class=\"line\">  <span class=\"comment\">// 源码附加到着色器对象上</span></span><br><span class=\"line\">  glShaderSource(fragmentShaderOrange, <span class=\"number\">1</span>, &amp;fragmentShaderSource0, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  glCompileShader(fragmentShaderOrange);</span><br><span class=\"line\">  <span class=\"comment\">// 检测glComplieShader是否编译成功</span></span><br><span class=\"line\">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ===========编译第二个片段黄色着色器===================</span></span><br><span class=\"line\">  <span class=\"comment\">// 源码附加到着色器对象上</span></span><br><span class=\"line\">  glShaderSource(fragmentShaderYellow, <span class=\"number\">1</span>, &amp;fragmentShaderSource1, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  glCompileShader(fragmentShaderYellow);</span><br><span class=\"line\">  <span class=\"comment\">// 检测glComplieShader是否编译成功</span></span><br><span class=\"line\">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetShaderInfoLog(vertexShader, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 把两个着色器对象链接到用来渲染的两个着色程序中</span></span><br><span class=\"line\">  glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class=\"line\">  <span class=\"comment\">// =====连接第一个片段着色器=====</span></span><br><span class=\"line\">  glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class=\"line\">  glLinkProgram(shaderProgramOrange);</span><br><span class=\"line\">  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetProgramInfoLog(shaderProgramOrange, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// =====连接第二个片段着色器=====</span></span><br><span class=\"line\">  glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class=\"line\">  glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class=\"line\">  glLinkProgram(shaderProgramYellow);</span><br><span class=\"line\">  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">    glGetProgramInfoLog(shaderProgramYellow, <span class=\"number\">512</span>, <span class=\"literal\">NULL</span>, infoLog);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span></span><br><span class=\"line\">              &lt;&lt; infoLog &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除着色器</span></span><br><span class=\"line\">  glDeleteShader(vertexShader);</span><br><span class=\"line\">  glDeleteShader(fragmentShaderOrange);</span><br><span class=\"line\">  glDeleteShader(fragmentShaderYellow);</span><br></pre></td></tr></table></figure></p>\n<p><strong>3, 用不同的program进行draw</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// =====激活程序对象绘制第一个triangle======</span></span><br><span class=\"line\">glUseProgram(shaderProgramOrange);      <span class=\"comment\">// 使用第一个片段着色器连接的program</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 从索引0开始依次绘制3个顶点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// =====激活程序对象绘制第二个triangle======</span></span><br><span class=\"line\">glUseProgram(shaderProgramYellow);      <span class=\"comment\">// 使用第二个片段着色器连接的program</span></span><br><span class=\"line\">glBindVertexArray(VAOs[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 从索引0开始依次绘制3个顶点</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3\" target=\"_blank\" rel=\"noopener\">练习3源码</a></p>\n<p>=======</p>\n<p>refwebsite:<br><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/\" target=\"_blank\" rel=\"noopener\">你好三角形 - learnopengl-CN</a></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-06-19T16:15:03.934Z","updated":"2018-06-19T16:15:03.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjk000ik8mf9f6446fn","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"在不同机器上配置部署hexo","date":"2017-12-20T02:54:39.000Z","_content":"\n将学习平台从Windows转移到ubuntu上后，需要重新配置hexo，但和重头配置有所区别。虽然，将Windows的磁盘擦干净前，我已经把数据全转移到移动硬盘上，可以用拷贝的方式在ubuntu上重新部署hexo, 但是这种方法相对手动，且既然用了github pages， 就通过实践github来部署。\n\n查阅后得到两种比较通用的hexo发布github的方式，\n> 1. 重新create a repo, 将静态文件push上去。\n> 2. 利用git branch的特性，将静态和部署文件放在一个repo的两个branch中。\n这里我选择了后者。\n\n**检查git：**\n```sh\n$ git --version\n\n$ sudo apt-get install git-core\n```\n**安装npm(node package manager):**\n```\n$ npm --version\n\n$ sudo apt-get install npm\n```\n**安装node-legacy**\n[装node-legacy原因][1]\n```sh\n$ sudo apt-get install nodejs-legacy\n```\n\n**安装nvm**\nnvm和npm一样是node的包的管理工具\n```sh\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n**安装 Node.js**\n> Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。\nvisit [node.js][2] for more information\n```sh\n$ nvm install 4\n```\n\n**安装 hexo**\n```\n$ npm install hexo-cli -g\n\n$ npm install hexo -g\n```\n\n**配置git**\n\n查看:\n```sh\n$ ls -al ~/.ssh\nls: cannot access /home/tim/.ssh: No such file or directory\n```\n\n生成:\n```sh\n$ ssh-keygen -t rsa -b 4096 -C \"timtingwei@hotmail.com\"\n```\n\n确认:\n```sh\n$ ssh-agent -s\n```\n\n添加:\n```sh\n$ ssh-add ~/.ssh/id_rsa\n```\n\n在github中添加SHH KEY\n```\n$ clip < cat ~/.ssh/id_rsa.pub\n```\n并在github setting中添加shh key\n\n```sh\n$ ssh -T git@github.com\nHi timtingwei! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n**利用git branch在不同机器上部署hexo**\n[CrazyMilk的知乎回答][3]\n\n> 1. 创建repo, timtingwei.github.io;\n> 2. 创建master和hexo两个分支，hexo用于存放静态文件, master用于部署;\n> 3. repo setting 中设置hexo为默认分支;\n> 4. git clone git@github.com:timtingwei/timtingwei.github.io.git 拷贝repo;\n> 5. npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;如果在不同机器上不需要hexo init;\n> 6. 修改_config.yml的deploy::branch参数为master;\n> 7. 依次执行 git add., git commit -m \"...\", git push origin hexo 提交相关文件;\n> 8. 执行hexo g -d 生成并部署到github上\n> 9. 日常改动:依次7,8.\n\n以上配置完成后, hexo s没反应\n```sh\n$ hexo server\nINFO  Start processing\n```\n\nhexo 3.0把服务器独立成个别模块，必须安装hexo-server才能使用。\n```sh\n$ npm install hexo-server --save\n\n$ hexo server\n```\n安装后, 仍旧没有反应。\n\n考虑用**静态模式**, 服务器只处理public文件夹内的文件，而不处理文件变动。先要执行hexo generate\n```sh\n$ hexo generate\n$ hexo server -s\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n```\n\nrefweb:\nhttps://zh.wikipedia.org/wiki/Node.js\nhttp://www.jianshu.com/p/24cb74aeb0a3\nhttps://www.zhihu.com/question/21193762\nhttps://hexo.io/zh-cn/docs/server.html\nhttps://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\n\n[1]:https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\n[2]:https://zh.wikipedia.org/wiki/Node.js\n[3]:https://www.zhihu.com/question/21193762\n","source":"_posts/hexo-in-different-computers.md","raw":"---\ntitle: 在不同机器上配置部署hexo\ndate: 2017-12-20 10:54:39\ntags: hexo\n---\n\n将学习平台从Windows转移到ubuntu上后，需要重新配置hexo，但和重头配置有所区别。虽然，将Windows的磁盘擦干净前，我已经把数据全转移到移动硬盘上，可以用拷贝的方式在ubuntu上重新部署hexo, 但是这种方法相对手动，且既然用了github pages， 就通过实践github来部署。\n\n查阅后得到两种比较通用的hexo发布github的方式，\n> 1. 重新create a repo, 将静态文件push上去。\n> 2. 利用git branch的特性，将静态和部署文件放在一个repo的两个branch中。\n这里我选择了后者。\n\n**检查git：**\n```sh\n$ git --version\n\n$ sudo apt-get install git-core\n```\n**安装npm(node package manager):**\n```\n$ npm --version\n\n$ sudo apt-get install npm\n```\n**安装node-legacy**\n[装node-legacy原因][1]\n```sh\n$ sudo apt-get install nodejs-legacy\n```\n\n**安装nvm**\nnvm和npm一样是node的包的管理工具\n```sh\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n**安装 Node.js**\n> Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。\nvisit [node.js][2] for more information\n```sh\n$ nvm install 4\n```\n\n**安装 hexo**\n```\n$ npm install hexo-cli -g\n\n$ npm install hexo -g\n```\n\n**配置git**\n\n查看:\n```sh\n$ ls -al ~/.ssh\nls: cannot access /home/tim/.ssh: No such file or directory\n```\n\n生成:\n```sh\n$ ssh-keygen -t rsa -b 4096 -C \"timtingwei@hotmail.com\"\n```\n\n确认:\n```sh\n$ ssh-agent -s\n```\n\n添加:\n```sh\n$ ssh-add ~/.ssh/id_rsa\n```\n\n在github中添加SHH KEY\n```\n$ clip < cat ~/.ssh/id_rsa.pub\n```\n并在github setting中添加shh key\n\n```sh\n$ ssh -T git@github.com\nHi timtingwei! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n**利用git branch在不同机器上部署hexo**\n[CrazyMilk的知乎回答][3]\n\n> 1. 创建repo, timtingwei.github.io;\n> 2. 创建master和hexo两个分支，hexo用于存放静态文件, master用于部署;\n> 3. repo setting 中设置hexo为默认分支;\n> 4. git clone git@github.com:timtingwei/timtingwei.github.io.git 拷贝repo;\n> 5. npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;如果在不同机器上不需要hexo init;\n> 6. 修改_config.yml的deploy::branch参数为master;\n> 7. 依次执行 git add., git commit -m \"...\", git push origin hexo 提交相关文件;\n> 8. 执行hexo g -d 生成并部署到github上\n> 9. 日常改动:依次7,8.\n\n以上配置完成后, hexo s没反应\n```sh\n$ hexo server\nINFO  Start processing\n```\n\nhexo 3.0把服务器独立成个别模块，必须安装hexo-server才能使用。\n```sh\n$ npm install hexo-server --save\n\n$ hexo server\n```\n安装后, 仍旧没有反应。\n\n考虑用**静态模式**, 服务器只处理public文件夹内的文件，而不处理文件变动。先要执行hexo generate\n```sh\n$ hexo generate\n$ hexo server -s\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n```\n\nrefweb:\nhttps://zh.wikipedia.org/wiki/Node.js\nhttp://www.jianshu.com/p/24cb74aeb0a3\nhttps://www.zhihu.com/question/21193762\nhttps://hexo.io/zh-cn/docs/server.html\nhttps://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\n\n[1]:https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\n[2]:https://zh.wikipedia.org/wiki/Node.js\n[3]:https://www.zhihu.com/question/21193762\n","slug":"hexo-in-different-computers","published":1,"updated":"2018-06-19T16:15:03.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjl000kk8mfoxlfw3ld","content":"<p>将学习平台从Windows转移到ubuntu上后，需要重新配置hexo，但和重头配置有所区别。虽然，将Windows的磁盘擦干净前，我已经把数据全转移到移动硬盘上，可以用拷贝的方式在ubuntu上重新部署hexo, 但是这种方法相对手动，且既然用了github pages， 就通过实践github来部署。</p>\n<p>查阅后得到两种比较通用的hexo发布github的方式，</p>\n<blockquote>\n<ol>\n<li>重新create a repo, 将静态文件push上去。</li>\n<li>利用git branch的特性，将静态和部署文件放在一个repo的两个branch中。<br>这里我选择了后者。</li>\n</ol>\n</blockquote>\n<p><strong>检查git：</strong><br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装npm(node package manager):</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm --version</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install npm</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装node-legacy</strong><br><a href=\"https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\" target=\"_blank\" rel=\"noopener\">装node-legacy原因</a><br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装nvm</strong><br>nvm和npm一样是node的包的管理工具<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装 Node.js</strong></p>\n<blockquote>\n<p>Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。<br>visit <a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">node.js</a> for more information<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm install 4</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><strong>安装 hexo</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo -g</span><br></pre></td></tr></table></figure></p>\n<p><strong>配置git</strong></p>\n<p>查看:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br><span class=\"line\">ls: cannot access /home/tim/.ssh: No such file or directory</span><br></pre></td></tr></table></figure></p>\n<p>生成:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C <span class=\"string\">\"timtingwei@hotmail.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>确认:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br></pre></td></tr></table></figure></p>\n<p>添加:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n<p>在github中添加SHH KEY<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ clip &lt; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>\n<p>并在github setting中添加shh key</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi timtingwei! You<span class=\"string\">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>\n<p><strong>利用git branch在不同机器上部署hexo</strong><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">CrazyMilk的知乎回答</a></p>\n<blockquote>\n<ol>\n<li>创建repo, timtingwei.github.io;</li>\n<li>创建master和hexo两个分支，hexo用于存放静态文件, master用于部署;</li>\n<li>repo setting 中设置hexo为默认分支;</li>\n<li>git clone git@github.com:timtingwei/timtingwei.github.io.git 拷贝repo;</li>\n<li>npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;如果在不同机器上不需要hexo init;</li>\n<li>修改_config.yml的deploy::branch参数为master;</li>\n<li>依次执行 git add., git commit -m “…”, git push origin hexo 提交相关文件;</li>\n<li>执行hexo g -d 生成并部署到github上</li>\n<li>日常改动:依次7,8.</li>\n</ol>\n</blockquote>\n<p>以上配置完成后, hexo s没反应<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\">INFO  Start processing</span><br></pre></td></tr></table></figure></p>\n<p>hexo 3.0把服务器独立成个别模块，必须安装hexo-server才能使用。<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>安装后, 仍旧没有反应。</p>\n<p>考虑用<strong>静态模式</strong>, 服务器只处理public文件夹内的文件，而不处理文件变动。先要执行hexo generate<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server -s</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>\n<p>refweb:<br><a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Node.js</a><br><a href=\"http://www.jianshu.com/p/24cb74aeb0a3\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/24cb74aeb0a3</a><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21193762</a><br><a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/server.html</a><br><a href=\"https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>将学习平台从Windows转移到ubuntu上后，需要重新配置hexo，但和重头配置有所区别。虽然，将Windows的磁盘擦干净前，我已经把数据全转移到移动硬盘上，可以用拷贝的方式在ubuntu上重新部署hexo, 但是这种方法相对手动，且既然用了github pages， 就通过实践github来部署。</p>\n<p>查阅后得到两种比较通用的hexo发布github的方式，</p>\n<blockquote>\n<ol>\n<li>重新create a repo, 将静态文件push上去。</li>\n<li>利用git branch的特性，将静态和部署文件放在一个repo的两个branch中。<br>这里我选择了后者。</li>\n</ol>\n</blockquote>\n<p><strong>检查git：</strong><br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装npm(node package manager):</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm --version</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get install npm</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装node-legacy</strong><br><a href=\"https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\" target=\"_blank\" rel=\"noopener\">装node-legacy原因</a><br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装nvm</strong><br>nvm和npm一样是node的包的管理工具<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装 Node.js</strong></p>\n<blockquote>\n<p>Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。<br>visit <a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">node.js</a> for more information<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm install 4</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><strong>安装 hexo</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo -g</span><br></pre></td></tr></table></figure></p>\n<p><strong>配置git</strong></p>\n<p>查看:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br><span class=\"line\">ls: cannot access /home/tim/.ssh: No such file or directory</span><br></pre></td></tr></table></figure></p>\n<p>生成:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -b 4096 -C <span class=\"string\">\"timtingwei@hotmail.com\"</span></span><br></pre></td></tr></table></figure></p>\n<p>确认:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br></pre></td></tr></table></figure></p>\n<p>添加:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n<p>在github中添加SHH KEY<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ clip &lt; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>\n<p>并在github setting中添加shh key</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\">Hi timtingwei! You<span class=\"string\">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>\n<p><strong>利用git branch在不同机器上部署hexo</strong><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">CrazyMilk的知乎回答</a></p>\n<blockquote>\n<ol>\n<li>创建repo, timtingwei.github.io;</li>\n<li>创建master和hexo两个分支，hexo用于存放静态文件, master用于部署;</li>\n<li>repo setting 中设置hexo为默认分支;</li>\n<li>git clone git@github.com:timtingwei/timtingwei.github.io.git 拷贝repo;</li>\n<li>npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;如果在不同机器上不需要hexo init;</li>\n<li>修改_config.yml的deploy::branch参数为master;</li>\n<li>依次执行 git add., git commit -m “…”, git push origin hexo 提交相关文件;</li>\n<li>执行hexo g -d 生成并部署到github上</li>\n<li>日常改动:依次7,8.</li>\n</ol>\n</blockquote>\n<p>以上配置完成后, hexo s没反应<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br><span class=\"line\">INFO  Start processing</span><br></pre></td></tr></table></figure></p>\n<p>hexo 3.0把服务器独立成个别模块，必须安装hexo-server才能使用。<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>安装后, 仍旧没有反应。</p>\n<p>考虑用<strong>静态模式</strong>, 服务器只处理public文件夹内的文件，而不处理文件变动。先要执行hexo generate<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server -s</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>\n<p>refweb:<br><a href=\"https://zh.wikipedia.org/wiki/Node.js\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/Node.js</a><br><a href=\"http://www.jianshu.com/p/24cb74aeb0a3\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/24cb74aeb0a3</a><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/21193762</a><br><a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/server.html</a><br><a href=\"https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu</a></p>\n"},{"title":"hexo博客中文乱码","date":"2017-11-23T01:52:42.000Z","_content":"\n## issue:\n\n```\n$ hexo g && hexo s\n```\n\n此时[localhost](http://localhost:4000/)中出现如下中文乱码, 英文部分正常。\n> ��Ȼ���(depth buffer)\n\n此时\\_config.yml中:\n\n```\nlanguage: zh-Hans\n```\n## hack:\n\n> 1. Notepad++打开出现中文的\\*.md, 此时右下角为ANSI格式.\n> 2. 格式->转为UFT-8编码格式\n> 3. 保存\n> 4. $ hexo clean && hexo g && hexo s\n\n此时[localhost](http://localhost:4000/)中\n> 深度缓存(depth buffer)\n\n## issue++:\n\n> * 批量转化post中的md文件\n> * 自动生成UTF-8格式的md文件\n\n------\nreference:\n[1]: \n\n\n\n","source":"_posts/hexo-random-symbol.md","raw":"---\ntitle: hexo博客中文乱码\ndate: 2017-11-23 09:52:42\ntags: \n- hexo\n- UTF-8\n---\n\n## issue:\n\n```\n$ hexo g && hexo s\n```\n\n此时[localhost](http://localhost:4000/)中出现如下中文乱码, 英文部分正常。\n> ��Ȼ���(depth buffer)\n\n此时\\_config.yml中:\n\n```\nlanguage: zh-Hans\n```\n## hack:\n\n> 1. Notepad++打开出现中文的\\*.md, 此时右下角为ANSI格式.\n> 2. 格式->转为UFT-8编码格式\n> 3. 保存\n> 4. $ hexo clean && hexo g && hexo s\n\n此时[localhost](http://localhost:4000/)中\n> 深度缓存(depth buffer)\n\n## issue++:\n\n> * 批量转化post中的md文件\n> * 自动生成UTF-8格式的md文件\n\n------\nreference:\n[1]: \n\n\n\n","slug":"hexo-random-symbol","published":1,"updated":"2018-06-19T16:15:03.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjn000mk8mfagz2pbtl","content":"<h2 id=\"issue\"><a href=\"#issue\" class=\"headerlink\" title=\"issue:\"></a>issue:</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>此时<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost</a>中出现如下中文乱码, 英文部分正常。</p>\n<blockquote>\n<p>��Ȼ���(depth buffer)</p>\n</blockquote>\n<p>此时_config.yml中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: zh-Hans</span><br></pre></td></tr></table></figure>\n<h2 id=\"hack\"><a href=\"#hack\" class=\"headerlink\" title=\"hack:\"></a>hack:</h2><blockquote>\n<ol>\n<li>Notepad++打开出现中文的*.md, 此时右下角为ANSI格式.</li>\n<li>格式-&gt;转为UFT-8编码格式</li>\n<li>保存</li>\n<li>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</li>\n</ol>\n</blockquote>\n<p>此时<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost</a>中</p>\n<blockquote>\n<p>深度缓存(depth buffer)</p>\n</blockquote>\n<h2 id=\"issue-1\"><a href=\"#issue-1\" class=\"headerlink\" title=\"issue++:\"></a>issue++:</h2><blockquote>\n<ul>\n<li>批量转化post中的md文件</li>\n<li>自动生成UTF-8格式的md文件</li>\n</ul>\n</blockquote>\n<hr>\n<p>reference:<br>[1]: </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"issue\"><a href=\"#issue\" class=\"headerlink\" title=\"issue:\"></a>issue:</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>\n<p>此时<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost</a>中出现如下中文乱码, 英文部分正常。</p>\n<blockquote>\n<p>��Ȼ���(depth buffer)</p>\n</blockquote>\n<p>此时_config.yml中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: zh-Hans</span><br></pre></td></tr></table></figure>\n<h2 id=\"hack\"><a href=\"#hack\" class=\"headerlink\" title=\"hack:\"></a>hack:</h2><blockquote>\n<ol>\n<li>Notepad++打开出现中文的*.md, 此时右下角为ANSI格式.</li>\n<li>格式-&gt;转为UFT-8编码格式</li>\n<li>保存</li>\n<li>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</li>\n</ol>\n</blockquote>\n<p>此时<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">localhost</a>中</p>\n<blockquote>\n<p>深度缓存(depth buffer)</p>\n</blockquote>\n<h2 id=\"issue-1\"><a href=\"#issue-1\" class=\"headerlink\" title=\"issue++:\"></a>issue++:</h2><blockquote>\n<ul>\n<li>批量转化post中的md文件</li>\n<li>自动生成UTF-8格式的md文件</li>\n</ul>\n</blockquote>\n<hr>\n<p>reference:<br>[1]: </p>\n"},{"title":"(转载)谈编程语言","date":"2017-12-24T05:26:19.000Z","_content":"\n**文章目录**\n[Bruce Eckel：编程生涯](#Bruce-Eckel：编程生涯)\n[Peter Norvig：十年学会编程](#Peter-Norvig：十年学会编程)\n\n\n转载自[编程随想 - program think](https://program-think.blogspot.com/2012/05/weekly-share-5.html)整理的， 关于编程的心态定位和实践方法的文章，比较经典， 对我有所启发的两篇。\n\n----\n\n# Bruce Eckel：编程生涯\n\n作者 Bruce Eckel 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。\n本文是他对程序员（尤其是新手）的忠告。\n\n================================\n\n大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。\n\n请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。\n\n问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。\n\n**在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。** 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。\n\n我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。\n\n我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。**跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。**\n\n当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。\n\n我想说的是： **除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。**\n\n当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会...... 你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。\n\n**另一个方法是：先大致了解这个领域，找到最适合你的地方。**打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。\n\n我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。\n\n但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。**在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。**\n\n了解编程之外的领域，将会极大得提高你解决问题的能力 （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。\n\n有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：\n◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。\n> * 知道如何获取知识\n> * Study prior art\n> * 善用工具\n> * 学会把事情简化\n> * 理解业务\n> * **为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。**\n> * 成为一个领导者，善于沟通和激励。\n> * 搞清楚你在为谁服务\n> * **没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。**\n> * **明白完美是渐进的**\n\n适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。\n\n或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。**问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。** 相信我所说的，你的生活会更精彩！\n\n原文出处：\nhttp://www.artima.com/weblogs/viewpost.jsp?thread=259358\n\n\n------\n\n\n# Peter Norvig：十年学会编程\n\n作者 Peter Norvig 是计算机科学家，Google 的研究总监。\n在本文中，Peter Norvig会告诉你：为什么急功近利地学习软件开发技术是没效果滴？\n\n================================\n\n## 为啥都想速成？\n\n随便逛一下书店，你会看到《7天自学Java》等诸如此类的N天甚至N小时学习Visual Basic、Windows、Internet的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96%是计算机的书。\n\n结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。”\n\n让我们看看《三日学会C++》这个书名意味着什么：\n\n◇学习：\n**三天内你可能没有时间写出有意义的程序，或者从中积累经验。**你不可能有时间去跟职业编程者一起去理解在C++环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：一知半解是很危险的。\n\n◇C++：\n**三天内你可能学会C++的句法（如果你已经了解其他的语言），但你还不会使用它。**打个比方，假如你是个Basic程序员，你可能写出Basic风格的C++程序，而无法理解C++的真实好处。那要点是什么？艾伦·佩里斯(Alan Perlis)曾经说过：“一门不能影响你编程观点的语言不足学的。”有可能你学了一点点C++（或者诸如Javascript、Flex之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。\n\n◇三日：\n不幸地是，这远远不够，下一部分会详细讲。\n\n## 如何用十年掌握编程\n\n研究人员（Bloom (1985), Bryan & Harter (1899), Hayes (1989), Simmon & Chase (1973)）得出结论：**想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能限的事情，尝试并思考你的表现，并自我矫正。周而复始。这并无捷径！**4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（ Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况：\n所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。\n\n所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson, 1709-1784）认为还需更长时间：“卓越乃一生之追求，而非其它”。 乔叟（Chaucer, 1340-1400）抱怨道\"the lyf so short, the craft so long to lerne.\" （生之有限，学也无涯）。希波克拉底（Hippocrates, c. 400BC）因这句话被世人所知：\"ars longa, vita brevis\"（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是 \"Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile\"，翻译成英文就是 \"Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult.\" （生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。\n\n## 我的编程成功秘笈是：\n\n> * 首先要对编程感兴趣，能从编程中得到乐趣。一定要让它足够有趣，因为你要保持你的兴趣长达十年。\n\n> * **与别的程序员交流；阅读别人的代码——这比看任何书或参加培训课都重要。**\n\n> * 实践。最好的学习乃实践。俗话说：“编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。” (p. 366) **“最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。”** (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。\n\n> * 如果你愿意，花四年学习大学课程（或者再加上读研）。这将给你赢得某些工作机会，并给予你在该领域的深层见解。**但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。**“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker's Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。\n\n> * 和其他程序员一起参与工程项目。在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。**充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。**\n\n> * 继续别人的工程项目。去理解先前程序员写的程序。**学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。**\n\n> * 至少学6种程序语言。其中包括一种支持类抽象的（Java和C++），一种支持函数抽象的（如Lisp或ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如Prolog或C++模板），还有一种支援协程的（Icon或Scheme），另外一种支持并发的（Sisal）。\n\n> * 记住，在“计算机科学”里有“计算机”一词。理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。\n\n> * 参加语言标准化工作。这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。\n\n> * 知道自己应该在何时脱身于语言标准化\n\n所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。\n\n弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一书给出了寻找顶级设计师的三条建议：\n> * 尽早系统地识别出顶级设计师。\n> * 分配一个人作为其职业规划的导师。\n> * **给予机遇让成长中的设计师互相磨砺。**\n\n此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：**\"假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。”**\n\n所以，简单地买一本Java书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。\n\n原文出处：\nhttp://norvig.com/21-days.html\n","source":"_posts/how-to-learn-program.md","raw":"---\ntitle: (转载)谈编程语言\ndate: 2017-12-24 13:26:19\ntags: \n- program\n- learn \n---\n\n**文章目录**\n[Bruce Eckel：编程生涯](#Bruce-Eckel：编程生涯)\n[Peter Norvig：十年学会编程](#Peter-Norvig：十年学会编程)\n\n\n转载自[编程随想 - program think](https://program-think.blogspot.com/2012/05/weekly-share-5.html)整理的， 关于编程的心态定位和实践方法的文章，比较经典， 对我有所启发的两篇。\n\n----\n\n# Bruce Eckel：编程生涯\n\n作者 Bruce Eckel 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。\n本文是他对程序员（尤其是新手）的忠告。\n\n================================\n\n大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。\n\n请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。\n\n问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。\n\n**在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。** 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。\n\n我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。\n\n我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。**跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。**\n\n当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。\n\n我想说的是： **除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。**\n\n当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会...... 你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。\n\n**另一个方法是：先大致了解这个领域，找到最适合你的地方。**打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。\n\n我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。\n\n但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。**在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。**\n\n了解编程之外的领域，将会极大得提高你解决问题的能力 （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。\n\n有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：\n◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。\n> * 知道如何获取知识\n> * Study prior art\n> * 善用工具\n> * 学会把事情简化\n> * 理解业务\n> * **为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。**\n> * 成为一个领导者，善于沟通和激励。\n> * 搞清楚你在为谁服务\n> * **没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。**\n> * **明白完美是渐进的**\n\n适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。\n\n或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。**问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。** 相信我所说的，你的生活会更精彩！\n\n原文出处：\nhttp://www.artima.com/weblogs/viewpost.jsp?thread=259358\n\n\n------\n\n\n# Peter Norvig：十年学会编程\n\n作者 Peter Norvig 是计算机科学家，Google 的研究总监。\n在本文中，Peter Norvig会告诉你：为什么急功近利地学习软件开发技术是没效果滴？\n\n================================\n\n## 为啥都想速成？\n\n随便逛一下书店，你会看到《7天自学Java》等诸如此类的N天甚至N小时学习Visual Basic、Windows、Internet的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96%是计算机的书。\n\n结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。”\n\n让我们看看《三日学会C++》这个书名意味着什么：\n\n◇学习：\n**三天内你可能没有时间写出有意义的程序，或者从中积累经验。**你不可能有时间去跟职业编程者一起去理解在C++环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：一知半解是很危险的。\n\n◇C++：\n**三天内你可能学会C++的句法（如果你已经了解其他的语言），但你还不会使用它。**打个比方，假如你是个Basic程序员，你可能写出Basic风格的C++程序，而无法理解C++的真实好处。那要点是什么？艾伦·佩里斯(Alan Perlis)曾经说过：“一门不能影响你编程观点的语言不足学的。”有可能你学了一点点C++（或者诸如Javascript、Flex之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。\n\n◇三日：\n不幸地是，这远远不够，下一部分会详细讲。\n\n## 如何用十年掌握编程\n\n研究人员（Bloom (1985), Bryan & Harter (1899), Hayes (1989), Simmon & Chase (1973)）得出结论：**想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能限的事情，尝试并思考你的表现，并自我矫正。周而复始。这并无捷径！**4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（ Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况：\n所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。\n\n所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson, 1709-1784）认为还需更长时间：“卓越乃一生之追求，而非其它”。 乔叟（Chaucer, 1340-1400）抱怨道\"the lyf so short, the craft so long to lerne.\" （生之有限，学也无涯）。希波克拉底（Hippocrates, c. 400BC）因这句话被世人所知：\"ars longa, vita brevis\"（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是 \"Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile\"，翻译成英文就是 \"Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult.\" （生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。\n\n## 我的编程成功秘笈是：\n\n> * 首先要对编程感兴趣，能从编程中得到乐趣。一定要让它足够有趣，因为你要保持你的兴趣长达十年。\n\n> * **与别的程序员交流；阅读别人的代码——这比看任何书或参加培训课都重要。**\n\n> * 实践。最好的学习乃实践。俗话说：“编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。” (p. 366) **“最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。”** (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。\n\n> * 如果你愿意，花四年学习大学课程（或者再加上读研）。这将给你赢得某些工作机会，并给予你在该领域的深层见解。**但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。**“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker's Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。\n\n> * 和其他程序员一起参与工程项目。在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。**充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。**\n\n> * 继续别人的工程项目。去理解先前程序员写的程序。**学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。**\n\n> * 至少学6种程序语言。其中包括一种支持类抽象的（Java和C++），一种支持函数抽象的（如Lisp或ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如Prolog或C++模板），还有一种支援协程的（Icon或Scheme），另外一种支持并发的（Sisal）。\n\n> * 记住，在“计算机科学”里有“计算机”一词。理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。\n\n> * 参加语言标准化工作。这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。\n\n> * 知道自己应该在何时脱身于语言标准化\n\n所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。\n\n弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一书给出了寻找顶级设计师的三条建议：\n> * 尽早系统地识别出顶级设计师。\n> * 分配一个人作为其职业规划的导师。\n> * **给予机遇让成长中的设计师互相磨砺。**\n\n此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：**\"假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。”**\n\n所以，简单地买一本Java书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。\n\n原文出处：\nhttp://norvig.com/21-days.html\n","slug":"how-to-learn-program","published":1,"updated":"2018-06-19T16:15:03.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjo000nk8mfs9gkd01c","content":"<p><strong>文章目录</strong><br><a href=\"#Bruce-Eckel：编程生涯\">Bruce Eckel：编程生涯</a><br><a href=\"#Peter-Norvig：十年学会编程\">Peter Norvig：十年学会编程</a></p>\n<p>转载自<a href=\"https://program-think.blogspot.com/2012/05/weekly-share-5.html\" target=\"_blank\" rel=\"noopener\">编程随想 - program think</a>整理的， 关于编程的心态定位和实践方法的文章，比较经典， 对我有所启发的两篇。</p>\n<hr>\n<h1 id=\"Bruce-Eckel：编程生涯\"><a href=\"#Bruce-Eckel：编程生涯\" class=\"headerlink\" title=\"Bruce Eckel：编程生涯\"></a>Bruce Eckel：编程生涯</h1><p>作者 Bruce Eckel 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。<br>本文是他对程序员（尤其是新手）的忠告。</p>\n<p>================================</p>\n<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>\n<p>请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。</p>\n<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>\n<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>\n<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>\n<p>我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。<strong>跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</strong></p>\n<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>\n<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>\n<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… 你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</p>\n<p><strong>另一个方法是：先大致了解这个领域，找到最适合你的地方。</strong>打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>\n<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。</p>\n<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。<strong>在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。</strong></p>\n<p>了解编程之外的领域，将会极大得提高你解决问题的能力 （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>\n<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：<br>◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。</p>\n<blockquote>\n<ul>\n<li>知道如何获取知识</li>\n<li>Study prior art</li>\n<li>善用工具</li>\n<li>学会把事情简化</li>\n<li>理解业务</li>\n<li><strong>为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。</strong></li>\n<li>成为一个领导者，善于沟通和激励。</li>\n<li>搞清楚你在为谁服务</li>\n<li><strong>没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。</strong></li>\n<li><strong>明白完美是渐进的</strong></li>\n</ul>\n</blockquote>\n<p>适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>\n<p>或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。<strong>问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。</strong> 相信我所说的，你的生活会更精彩！</p>\n<p>原文出处：<br><a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=259358\" target=\"_blank\" rel=\"noopener\">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></p>\n<hr>\n<h1 id=\"Peter-Norvig：十年学会编程\"><a href=\"#Peter-Norvig：十年学会编程\" class=\"headerlink\" title=\"Peter Norvig：十年学会编程\"></a>Peter Norvig：十年学会编程</h1><p>作者 Peter Norvig 是计算机科学家，Google 的研究总监。<br>在本文中，Peter Norvig会告诉你：为什么急功近利地学习软件开发技术是没效果滴？</p>\n<p>================================</p>\n<h2 id=\"为啥都想速成？\"><a href=\"#为啥都想速成？\" class=\"headerlink\" title=\"为啥都想速成？\"></a>为啥都想速成？</h2><p>随便逛一下书店，你会看到《7天自学Java》等诸如此类的N天甚至N小时学习Visual Basic、Windows、Internet的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96%是计算机的书。</p>\n<p>结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。”</p>\n<p>让我们看看《三日学会C++》这个书名意味着什么：</p>\n<p>◇学习：<br><strong>三天内你可能没有时间写出有意义的程序，或者从中积累经验。</strong>你不可能有时间去跟职业编程者一起去理解在C++环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：一知半解是很危险的。</p>\n<p>◇C++：<br><strong>三天内你可能学会C++的句法（如果你已经了解其他的语言），但你还不会使用它。</strong>打个比方，假如你是个Basic程序员，你可能写出Basic风格的C++程序，而无法理解C++的真实好处。那要点是什么？艾伦·佩里斯(Alan Perlis)曾经说过：“一门不能影响你编程观点的语言不足学的。”有可能你学了一点点C++（或者诸如Javascript、Flex之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。</p>\n<p>◇三日：<br>不幸地是，这远远不够，下一部分会详细讲。</p>\n<h2 id=\"如何用十年掌握编程\"><a href=\"#如何用十年掌握编程\" class=\"headerlink\" title=\"如何用十年掌握编程\"></a>如何用十年掌握编程</h2><p>研究人员（Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)）得出结论：<strong>想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能限的事情，尝试并思考你的表现，并自我矫正。周而复始。这并无捷径！</strong>4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（ Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况：<br>所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。</p>\n<p>所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson, 1709-1784）认为还需更长时间：“卓越乃一生之追求，而非其它”。 乔叟（Chaucer, 1340-1400）抱怨道”the lyf so short, the craft so long to lerne.” （生之有限，学也无涯）。希波克拉底（Hippocrates, c. 400BC）因这句话被世人所知：”ars longa, vita brevis”（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是 “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”，翻译成英文就是 “Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult.” （生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。</p>\n<h2 id=\"我的编程成功秘笈是：\"><a href=\"#我的编程成功秘笈是：\" class=\"headerlink\" title=\"我的编程成功秘笈是：\"></a>我的编程成功秘笈是：</h2><blockquote>\n<ul>\n<li><p>首先要对编程感兴趣，能从编程中得到乐趣。一定要让它足够有趣，因为你要保持你的兴趣长达十年。</p>\n</li>\n<li><p><strong>与别的程序员交流；阅读别人的代码——这比看任何书或参加培训课都重要。</strong></p>\n</li>\n<li><p>实践。最好的学习乃实践。俗话说：“编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。” (p. 366) <strong>“最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。”</strong> (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。</p>\n</li>\n<li><p>如果你愿意，花四年学习大学课程（或者再加上读研）。这将给你赢得某些工作机会，并给予你在该领域的深层见解。<strong>但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。</strong>“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker’s Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。</p>\n</li>\n<li><p>和其他程序员一起参与工程项目。在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。<strong>充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。</strong></p>\n</li>\n<li><p>继续别人的工程项目。去理解先前程序员写的程序。<strong>学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。</strong></p>\n</li>\n<li><p>至少学6种程序语言。其中包括一种支持类抽象的（Java和C++），一种支持函数抽象的（如Lisp或ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如Prolog或C++模板），还有一种支援协程的（Icon或Scheme），另外一种支持并发的（Sisal）。</p>\n</li>\n<li><p>记住，在“计算机科学”里有“计算机”一词。理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。</p>\n</li>\n<li><p>参加语言标准化工作。这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。</p>\n</li>\n<li><p>知道自己应该在何时脱身于语言标准化</p>\n</li>\n</ul>\n</blockquote>\n<p>所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。</p>\n<p>弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一书给出了寻找顶级设计师的三条建议：</p>\n<blockquote>\n<ul>\n<li>尽早系统地识别出顶级设计师。</li>\n<li>分配一个人作为其职业规划的导师。</li>\n<li><strong>给予机遇让成长中的设计师互相磨砺。</strong></li>\n</ul>\n</blockquote>\n<p>此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：<strong>“假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。”</strong></p>\n<p>所以，简单地买一本Java书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。</p>\n<p>原文出处：<br><a href=\"http://norvig.com/21-days.html\" target=\"_blank\" rel=\"noopener\">http://norvig.com/21-days.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>文章目录</strong><br><a href=\"#Bruce-Eckel：编程生涯\">Bruce Eckel：编程生涯</a><br><a href=\"#Peter-Norvig：十年学会编程\">Peter Norvig：十年学会编程</a></p>\n<p>转载自<a href=\"https://program-think.blogspot.com/2012/05/weekly-share-5.html\" target=\"_blank\" rel=\"noopener\">编程随想 - program think</a>整理的， 关于编程的心态定位和实践方法的文章，比较经典， 对我有所启发的两篇。</p>\n<hr>\n<h1 id=\"Bruce-Eckel：编程生涯\"><a href=\"#Bruce-Eckel：编程生涯\" class=\"headerlink\" title=\"Bruce Eckel：编程生涯\"></a>Bruce Eckel：编程生涯</h1><p>作者 Bruce Eckel 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。<br>本文是他对程序员（尤其是新手）的忠告。</p>\n<p>================================</p>\n<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>\n<p>请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。</p>\n<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>\n<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>\n<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>\n<p>我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。<strong>跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</strong></p>\n<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>\n<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>\n<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… 你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</p>\n<p><strong>另一个方法是：先大致了解这个领域，找到最适合你的地方。</strong>打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>\n<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。</p>\n<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。<strong>在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。</strong></p>\n<p>了解编程之外的领域，将会极大得提高你解决问题的能力 （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>\n<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：<br>◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。</p>\n<blockquote>\n<ul>\n<li>知道如何获取知识</li>\n<li>Study prior art</li>\n<li>善用工具</li>\n<li>学会把事情简化</li>\n<li>理解业务</li>\n<li><strong>为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。</strong></li>\n<li>成为一个领导者，善于沟通和激励。</li>\n<li>搞清楚你在为谁服务</li>\n<li><strong>没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。</strong></li>\n<li><strong>明白完美是渐进的</strong></li>\n</ul>\n</blockquote>\n<p>适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>\n<p>或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。<strong>问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。</strong> 相信我所说的，你的生活会更精彩！</p>\n<p>原文出处：<br><a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=259358\" target=\"_blank\" rel=\"noopener\">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></p>\n<hr>\n<h1 id=\"Peter-Norvig：十年学会编程\"><a href=\"#Peter-Norvig：十年学会编程\" class=\"headerlink\" title=\"Peter Norvig：十年学会编程\"></a>Peter Norvig：十年学会编程</h1><p>作者 Peter Norvig 是计算机科学家，Google 的研究总监。<br>在本文中，Peter Norvig会告诉你：为什么急功近利地学习软件开发技术是没效果滴？</p>\n<p>================================</p>\n<h2 id=\"为啥都想速成？\"><a href=\"#为啥都想速成？\" class=\"headerlink\" title=\"为啥都想速成？\"></a>为啥都想速成？</h2><p>随便逛一下书店，你会看到《7天自学Java》等诸如此类的N天甚至N小时学习Visual Basic、Windows、Internet的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96%是计算机的书。</p>\n<p>结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。”</p>\n<p>让我们看看《三日学会C++》这个书名意味着什么：</p>\n<p>◇学习：<br><strong>三天内你可能没有时间写出有意义的程序，或者从中积累经验。</strong>你不可能有时间去跟职业编程者一起去理解在C++环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：一知半解是很危险的。</p>\n<p>◇C++：<br><strong>三天内你可能学会C++的句法（如果你已经了解其他的语言），但你还不会使用它。</strong>打个比方，假如你是个Basic程序员，你可能写出Basic风格的C++程序，而无法理解C++的真实好处。那要点是什么？艾伦·佩里斯(Alan Perlis)曾经说过：“一门不能影响你编程观点的语言不足学的。”有可能你学了一点点C++（或者诸如Javascript、Flex之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。</p>\n<p>◇三日：<br>不幸地是，这远远不够，下一部分会详细讲。</p>\n<h2 id=\"如何用十年掌握编程\"><a href=\"#如何用十年掌握编程\" class=\"headerlink\" title=\"如何用十年掌握编程\"></a>如何用十年掌握编程</h2><p>研究人员（Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)）得出结论：<strong>想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能限的事情，尝试并思考你的表现，并自我矫正。周而复始。这并无捷径！</strong>4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（ Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况：<br>所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。</p>\n<p>所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson, 1709-1784）认为还需更长时间：“卓越乃一生之追求，而非其它”。 乔叟（Chaucer, 1340-1400）抱怨道”the lyf so short, the craft so long to lerne.” （生之有限，学也无涯）。希波克拉底（Hippocrates, c. 400BC）因这句话被世人所知：”ars longa, vita brevis”（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是 “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”，翻译成英文就是 “Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult.” （生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。</p>\n<h2 id=\"我的编程成功秘笈是：\"><a href=\"#我的编程成功秘笈是：\" class=\"headerlink\" title=\"我的编程成功秘笈是：\"></a>我的编程成功秘笈是：</h2><blockquote>\n<ul>\n<li><p>首先要对编程感兴趣，能从编程中得到乐趣。一定要让它足够有趣，因为你要保持你的兴趣长达十年。</p>\n</li>\n<li><p><strong>与别的程序员交流；阅读别人的代码——这比看任何书或参加培训课都重要。</strong></p>\n</li>\n<li><p>实践。最好的学习乃实践。俗话说：“编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。” (p. 366) <strong>“最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。”</strong> (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。</p>\n</li>\n<li><p>如果你愿意，花四年学习大学课程（或者再加上读研）。这将给你赢得某些工作机会，并给予你在该领域的深层见解。<strong>但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。</strong>“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker’s Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。</p>\n</li>\n<li><p>和其他程序员一起参与工程项目。在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。<strong>充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。</strong></p>\n</li>\n<li><p>继续别人的工程项目。去理解先前程序员写的程序。<strong>学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。</strong></p>\n</li>\n<li><p>至少学6种程序语言。其中包括一种支持类抽象的（Java和C++），一种支持函数抽象的（如Lisp或ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如Prolog或C++模板），还有一种支援协程的（Icon或Scheme），另外一种支持并发的（Sisal）。</p>\n</li>\n<li><p>记住，在“计算机科学”里有“计算机”一词。理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。</p>\n</li>\n<li><p>参加语言标准化工作。这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。</p>\n</li>\n<li><p>知道自己应该在何时脱身于语言标准化</p>\n</li>\n</ul>\n</blockquote>\n<p>所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。</p>\n<p>弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一书给出了寻找顶级设计师的三条建议：</p>\n<blockquote>\n<ul>\n<li>尽早系统地识别出顶级设计师。</li>\n<li>分配一个人作为其职业规划的导师。</li>\n<li><strong>给予机遇让成长中的设计师互相磨砺。</strong></li>\n</ul>\n</blockquote>\n<p>此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：<strong>“假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。”</strong></p>\n<p>所以，简单地买一本Java书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。</p>\n<p>原文出处：<br><a href=\"http://norvig.com/21-days.html\" target=\"_blank\" rel=\"noopener\">http://norvig.com/21-days.html</a></p>\n"},{"title":"在ubuntu14.04上建立OpenGL编译环境","date":"2017-12-20T05:58:49.000Z","_content":"\n\n学习教程[LearnOpenGL-CN][1]前先配置学习环境，对照后面编译时链接的函数库，\n\n```sh\n$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n```\n\n需要：\n> * GLEW\n> * GLFW/GLFW3\n> * libgl1-mesa\n> * libglu1-mesa\n\n`ps: 不是完全明白这里链接库的对应关系`\n\n==========\n\n参考:[Howto_Install_OpenGL_Development_Environment][2]\n\n**建立基本编译环境**\n首先不可或缺的，就是編譯器與基本的函式庫，如果系統沒有安裝的話，請依照下面的方式安裝：\n```sh\nsudo apt-get install build-essential\n```\n\n**安裝OpenGL Library**\n接下來要把我們會用到的 Library 裝上去，首先安裝 OpenGL Library\n```sh\nsudo apt-get install libgl1-mesa-dev\n```\n\n**安裝OpenGL Utilities**\nOpenGL Utilities 是一組建構於 OpenGL Library 之上的工具組，提供許多很方便的函式，使 OpenGL 更強大且更容易使用。 接下來我們安裝OpenGL Utilities\n\n> 在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，\n\n```sh\nsudo apt-get install libglu1-mesa-dev\n```\n**安裝GLFW/GLFW3**\nGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。\n\nGLFW可以从它官方网站的[下载页][6]上获取。\n\n参考网站[How to build & install GLFW 3 and use it in a Linux project][3]\n解压后,\n\n```sh\n$ sudo apt-get install cmake\n\n$ cmake -G \"Unix Makefiles\"\n\n$ sudo apt-get build-dep glfw\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.\n\n$ sudo make\n$ sudo make install\n\nInstall the project...\n-- Install configuration: \"\"\n-- Installing: /usr/local/include/GLFW\n-- Installing: /usr/local/include/GLFW/glfw3.h\n-- Installing: /usr/local/include/GLFW/glfw3native.h\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Config.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3ConfigVersion.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Targets.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Targets-noconfig.cmake\n-- Installing: /usr/local/lib/pkgconfig/glfw3.pc\n-- Installing: /usr/local/lib/libglfw3.a\n```\n\n**从[测试源码网站][4]复制案例代码测试**\n该案例中#include <GLFW/glfw3.h>\n\n\n```sh\n$ g++ -std=c++11 -c main.cpp\n\n$ ./main.o\nbash: ./main.o: cannot execute binary file: Exec format error  &lt;==执行main.o提示不是二进制可执行文件\n\n\n$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi\n/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol 'dlclose@@GLIBC_2.2.5'\n//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line\ncollect2: error: ld returned 1 exit status\n```\n\nYou may also need to add the linker options -ldl -lXinerama -lXcursor to get it to work correctly if you are getting undefined references to **dlclose**\n\n```sh\n$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n\n$ ./main.exec\n```\n\n\n-l<Library>  告訴 gcc 去連結指定 Library\n-o<file>     指定執行檔的輸出名字\n\n执行:\n\n$ ./main.exec\n\n\n~~\\**安装glut\\*\\*~~\n\n~~\\`\\`\\`sh\nsudo apt-get install libglut-dev\n\\`\\`\\`~~\n\n~~沒有libglut-dev可以改用\n\\`\\`\\`sh\nsudo apt-get install freeglut3-dev\n\\`\\`\\`~~\n\n~~設定編譯參數與編譯\n在這之前，我們需要一個測試範例，example.c~~ [如下][2]：\n\n~~有了測試範例、基礎編譯環境與各個 OpenGL 相關的函式庫之後，我們所需要做的就是告訴編譯器我們有安裝 OpenGL 函式庫，編譯程式時要連結這些函式庫。~~\n\n~~gcc example.c -o example.out -lGL -lGLU -lglut\n因為我們安裝了 OpenGL Utility Toolkit ，它是建立在 OpenGL Utilities 與 OpenGL Library 之上，因此我們可以簡單連結 OpenGL Utility Toolkit 的函式庫就可以達到我們的目地了。下面的編譯參數跟上面的是同樣效果：~~\n\n~~gcc example.c -o example.out -lglut\n下面簡單說明一下所使用的 gcc 參數~~\n\n~~-l<Library>  告訴 gcc 去連結指定 Library\n-o<file>     指定執行檔的輸出名字~~\n\n~~執行\n接下來我們就可以來看看我們的結果，如果看到右圖，代表成功了!~\n./example.out~~\n\n\n**编译和链接GLEW**\n\n对于用GCC编译的Linux用户建议使用这个命令行选项-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi。没有正确链接相应的库会产生 undefined reference(未定义的引用) 这个错误。\n\n```sh\n$ sudo apt-get build-dep glew\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.\n\n$ sudo make\n$ sudo make install\n```\n\n==========\n\n**测试教程中的案例代码**\n\n复制 [代码hello_window.cpp][https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp]\n```sh\n$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n$ ls\na.out  hello_window.cpp\n$ ./a.out\nStarting GLFW context, OpenGL 3.3\n```\n看到初始化窗口，代表成功。\n\n**编译后窗口透明问题**\n虽然窗口初始化成功, 但不知道我的窗口为什么是透明的, 难道是ubuntu的原因吗？\nRender部分再加入两行代码\n```cpp\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n```\n\n**编译后libGLEW.so.2.1: No such file or directory 问题**\n\n```sh\n..\n$ ./a.out\n./a.out: error while loading shared libraries: libGLEW.so.2.1: cannot open shared object file: No such file or directory\n```\n查询[stackoverflow libGLEW相关问题][5]\n得到libGLEW在lib64下, 于是便创建软link\n$ sudo ln -s /usr/lib64/libGLEW.so.2.1 /usr/lib/libGLEW.so.2.1\n\n==========\n\nrefwebsite:\nhttps://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\nhttps://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\nhttps://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\nhttp://www.glfw.org/docs/3.0/quick.html\nhttps://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\nhttp://www.glfw.org/download.html\n\n[1]:https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\n[2]:https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\n[3]:https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\n[4]:http://www.glfw.org/docs/3.0/quick.html\n[5]:https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\n[6]:http://www.glfw.org/download.html\n","source":"_posts/install-openGL-in-ubuntu14-04.md","raw":"---\ntitle: 在ubuntu14.04上建立OpenGL编译环境\ndate: 2017-12-20 13:58:49\ntags: OpenGL\n---\n\n\n学习教程[LearnOpenGL-CN][1]前先配置学习环境，对照后面编译时链接的函数库，\n\n```sh\n$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n```\n\n需要：\n> * GLEW\n> * GLFW/GLFW3\n> * libgl1-mesa\n> * libglu1-mesa\n\n`ps: 不是完全明白这里链接库的对应关系`\n\n==========\n\n参考:[Howto_Install_OpenGL_Development_Environment][2]\n\n**建立基本编译环境**\n首先不可或缺的，就是編譯器與基本的函式庫，如果系統沒有安裝的話，請依照下面的方式安裝：\n```sh\nsudo apt-get install build-essential\n```\n\n**安裝OpenGL Library**\n接下來要把我們會用到的 Library 裝上去，首先安裝 OpenGL Library\n```sh\nsudo apt-get install libgl1-mesa-dev\n```\n\n**安裝OpenGL Utilities**\nOpenGL Utilities 是一組建構於 OpenGL Library 之上的工具組，提供許多很方便的函式，使 OpenGL 更強大且更容易使用。 接下來我們安裝OpenGL Utilities\n\n> 在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，\n\n```sh\nsudo apt-get install libglu1-mesa-dev\n```\n**安裝GLFW/GLFW3**\nGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。\n\nGLFW可以从它官方网站的[下载页][6]上获取。\n\n参考网站[How to build & install GLFW 3 and use it in a Linux project][3]\n解压后,\n\n```sh\n$ sudo apt-get install cmake\n\n$ cmake -G \"Unix Makefiles\"\n\n$ sudo apt-get build-dep glfw\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.\n\n$ sudo make\n$ sudo make install\n\nInstall the project...\n-- Install configuration: \"\"\n-- Installing: /usr/local/include/GLFW\n-- Installing: /usr/local/include/GLFW/glfw3.h\n-- Installing: /usr/local/include/GLFW/glfw3native.h\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Config.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3ConfigVersion.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Targets.cmake\n-- Installing: /usr/local/lib/cmake/glfw3/glfw3Targets-noconfig.cmake\n-- Installing: /usr/local/lib/pkgconfig/glfw3.pc\n-- Installing: /usr/local/lib/libglfw3.a\n```\n\n**从[测试源码网站][4]复制案例代码测试**\n该案例中#include <GLFW/glfw3.h>\n\n\n```sh\n$ g++ -std=c++11 -c main.cpp\n\n$ ./main.o\nbash: ./main.o: cannot execute binary file: Exec format error  &lt;==执行main.o提示不是二进制可执行文件\n\n\n$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi\n/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol 'dlclose@@GLIBC_2.2.5'\n//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line\ncollect2: error: ld returned 1 exit status\n```\n\nYou may also need to add the linker options -ldl -lXinerama -lXcursor to get it to work correctly if you are getting undefined references to **dlclose**\n\n```sh\n$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n\n$ ./main.exec\n```\n\n\n-l<Library>  告訴 gcc 去連結指定 Library\n-o<file>     指定執行檔的輸出名字\n\n执行:\n\n$ ./main.exec\n\n\n~~\\**安装glut\\*\\*~~\n\n~~\\`\\`\\`sh\nsudo apt-get install libglut-dev\n\\`\\`\\`~~\n\n~~沒有libglut-dev可以改用\n\\`\\`\\`sh\nsudo apt-get install freeglut3-dev\n\\`\\`\\`~~\n\n~~設定編譯參數與編譯\n在這之前，我們需要一個測試範例，example.c~~ [如下][2]：\n\n~~有了測試範例、基礎編譯環境與各個 OpenGL 相關的函式庫之後，我們所需要做的就是告訴編譯器我們有安裝 OpenGL 函式庫，編譯程式時要連結這些函式庫。~~\n\n~~gcc example.c -o example.out -lGL -lGLU -lglut\n因為我們安裝了 OpenGL Utility Toolkit ，它是建立在 OpenGL Utilities 與 OpenGL Library 之上，因此我們可以簡單連結 OpenGL Utility Toolkit 的函式庫就可以達到我們的目地了。下面的編譯參數跟上面的是同樣效果：~~\n\n~~gcc example.c -o example.out -lglut\n下面簡單說明一下所使用的 gcc 參數~~\n\n~~-l<Library>  告訴 gcc 去連結指定 Library\n-o<file>     指定執行檔的輸出名字~~\n\n~~執行\n接下來我們就可以來看看我們的結果，如果看到右圖，代表成功了!~\n./example.out~~\n\n\n**编译和链接GLEW**\n\n对于用GCC编译的Linux用户建议使用这个命令行选项-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi。没有正确链接相应的库会产生 undefined reference(未定义的引用) 这个错误。\n\n```sh\n$ sudo apt-get build-dep glew\nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\n0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.\n\n$ sudo make\n$ sudo make install\n```\n\n==========\n\n**测试教程中的案例代码**\n\n复制 [代码hello_window.cpp][https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp]\n```sh\n$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor\n$ ls\na.out  hello_window.cpp\n$ ./a.out\nStarting GLFW context, OpenGL 3.3\n```\n看到初始化窗口，代表成功。\n\n**编译后窗口透明问题**\n虽然窗口初始化成功, 但不知道我的窗口为什么是透明的, 难道是ubuntu的原因吗？\nRender部分再加入两行代码\n```cpp\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);\nglClear(GL_COLOR_BUFFER_BIT);\n```\n\n**编译后libGLEW.so.2.1: No such file or directory 问题**\n\n```sh\n..\n$ ./a.out\n./a.out: error while loading shared libraries: libGLEW.so.2.1: cannot open shared object file: No such file or directory\n```\n查询[stackoverflow libGLEW相关问题][5]\n得到libGLEW在lib64下, 于是便创建软link\n$ sudo ln -s /usr/lib64/libGLEW.so.2.1 /usr/lib/libGLEW.so.2.1\n\n==========\n\nrefwebsite:\nhttps://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\nhttps://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\nhttps://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\nhttp://www.glfw.org/docs/3.0/quick.html\nhttps://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\nhttp://www.glfw.org/download.html\n\n[1]:https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\n[2]:https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\n[3]:https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\n[4]:http://www.glfw.org/docs/3.0/quick.html\n[5]:https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\n[6]:http://www.glfw.org/download.html\n","slug":"install-openGL-in-ubuntu14-04","published":1,"updated":"2018-06-19T16:15:03.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjp000ok8mfcp3ol532","content":"<p>学习教程<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\" target=\"_blank\" rel=\"noopener\">LearnOpenGL-CN</a>前先配置学习环境，对照后面编译时链接的函数库，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br></pre></td></tr></table></figure>\n<p>需要：</p>\n<blockquote>\n<ul>\n<li>GLEW</li>\n<li>GLFW/GLFW3</li>\n<li>libgl1-mesa</li>\n<li>libglu1-mesa</li>\n</ul>\n</blockquote>\n<p><code>ps: 不是完全明白这里链接库的对应关系</code></p>\n<p>==========</p>\n<p>参考:<a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">Howto_Install_OpenGL_Development_Environment</a></p>\n<p><strong>建立基本编译环境</strong><br>首先不可或缺的，就是編譯器與基本的函式庫，如果系統沒有安裝的話，請依照下面的方式安裝：<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure></p>\n<p><strong>安裝OpenGL Library</strong><br>接下來要把我們會用到的 Library 裝上去，首先安裝 OpenGL Library<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libgl1-mesa-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>安裝OpenGL Utilities</strong><br>OpenGL Utilities 是一組建構於 OpenGL Library 之上的工具組，提供許多很方便的函式，使 OpenGL 更強大且更容易使用。 接下來我們安裝OpenGL Utilities</p>\n<blockquote>\n<p>在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libglu1-mesa-dev</span><br></pre></td></tr></table></figure>\n<p><strong>安裝GLFW/GLFW3</strong><br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。</p>\n<p>GLFW可以从它官方网站的<a href=\"http://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">下载页</a>上获取。</p>\n<p>参考网站<a href=\"https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\" target=\"_blank\" rel=\"noopener\">How to build &amp; install GLFW 3 and use it in a Linux project</a><br>解压后,</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install cmake</span><br><span class=\"line\"></span><br><span class=\"line\">$ cmake -G <span class=\"string\">\"Unix Makefiles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get build-dep glfw</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree</span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo make</span><br><span class=\"line\">$ sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">Install the project...</span><br><span class=\"line\">-- Install configuration: <span class=\"string\">\"\"</span></span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW/glfw3.h</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW/glfw3native.h</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Config.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3ConfigVersion.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Targets.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Targets-noconfig.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/pkgconfig/glfw3.pc</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/libglfw3.a</span><br></pre></td></tr></table></figure>\n<p><strong>从<a href=\"http://www.glfw.org/docs/3.0/quick.html\" target=\"_blank\" rel=\"noopener\">测试源码网站</a>复制案例代码测试</strong><br>该案例中#include <glfw glfw3.h=\"\"></glfw></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 -c main.cpp</span><br><span class=\"line\"></span><br><span class=\"line\">$ ./main.o</span><br><span class=\"line\">bash: ./main.o: cannot execute binary file: Exec format error  &amp;lt;==执行main.o提示不是二进制可执行文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi</span><br><span class=\"line\">/usr/bin/ld: //usr/<span class=\"built_in\">local</span>/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol <span class=\"string\">'dlclose@@GLIBC_2.2.5'</span></span><br><span class=\"line\">//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from <span class=\"built_in\">command</span> line</span><br><span class=\"line\">collect2: error: ld returned 1 <span class=\"built_in\">exit</span> status</span><br></pre></td></tr></table></figure>\n<p>You may also need to add the linker options -ldl -lXinerama -lXcursor to get it to work correctly if you are getting undefined references to <strong>dlclose</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class=\"line\"></span><br><span class=\"line\">$ ./main.exec</span><br></pre></td></tr></table></figure>\n<p>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></p>\n<p>执行:</p>\n<p>$ ./main.exec</p>\n<p><del>*<em>安装glut\\</em>*</del></p>\n<p><del>```sh<br>sudo apt-get install libglut-dev<br>```</del></p>\n<p><del>沒有libglut-dev可以改用<br>```sh<br>sudo apt-get install freeglut3-dev<br>```</del></p>\n<p><del>設定編譯參數與編譯<br>在這之前，我們需要一個測試範例，example.c</del> <a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">如下</a>：</p>\n<p><del>有了測試範例、基礎編譯環境與各個 OpenGL 相關的函式庫之後，我們所需要做的就是告訴編譯器我們有安裝 OpenGL 函式庫，編譯程式時要連結這些函式庫。</del></p>\n<p><del>gcc example.c -o example.out -lGL -lGLU -lglut<br>因為我們安裝了 OpenGL Utility Toolkit ，它是建立在 OpenGL Utilities 與 OpenGL Library 之上，因此我們可以簡單連結 OpenGL Utility Toolkit 的函式庫就可以達到我們的目地了。下面的編譯參數跟上面的是同樣效果：</del></p>\n<p><del>gcc example.c -o example.out -lglut<br>下面簡單說明一下所使用的 gcc 參數</del></p>\n<p><del>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></del></p>\n<p><del>執行<br>接下來我們就可以來看看我們的結果，如果看到右圖，代表成功了!~<br>./example.out</del></p>\n<p><strong>编译和链接GLEW</strong></p>\n<p>对于用GCC编译的Linux用户建议使用这个命令行选项-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi。没有正确链接相应的库会产生 undefined reference(未定义的引用) 这个错误。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get build-dep glew</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo make</span><br><span class=\"line\">$ sudo make install</span><br></pre></td></tr></table></figure>\n<p>==========</p>\n<p><strong>测试教程中的案例代码</strong></p>\n<p>复制 [代码hello_window.cpp][<a href=\"https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp\" target=\"_blank\" rel=\"noopener\">https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp</a>]<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">a.out  hello_window.cpp</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">Starting GLFW context, OpenGL 3.3</span><br></pre></td></tr></table></figure></p>\n<p>看到初始化窗口，代表成功。</p>\n<p><strong>编译后窗口透明问题</strong><br>虽然窗口初始化成功, 但不知道我的窗口为什么是透明的, 难道是ubuntu的原因吗？<br>Render部分再加入两行代码<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.2f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure></p>\n<p><strong>编译后libGLEW.so.2.1: No such file or directory 问题</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">..</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">./a.out: error <span class=\"keyword\">while</span> loading shared libraries: libGLEW.so.2.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>查询<a href=\"https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\" target=\"_blank\" rel=\"noopener\">stackoverflow libGLEW相关问题</a><br>得到libGLEW在lib64下, 于是便创建软link<br>$ sudo ln -s /usr/lib64/libGLEW.so.2.1 /usr/lib/libGLEW.so.2.1</p>\n<p>==========</p>\n<p>refwebsite:<br><a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\" target=\"_blank\" rel=\"noopener\">https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/</a><br><a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment</a><br><a href=\"https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project</a><br><a href=\"http://www.glfw.org/docs/3.0/quick.html\" target=\"_blank\" rel=\"noopener\">http://www.glfw.org/docs/3.0/quick.html</a><br><a href=\"https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew</a><br><a href=\"http://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">http://www.glfw.org/download.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习教程<a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\" target=\"_blank\" rel=\"noopener\">LearnOpenGL-CN</a>前先配置学习环境，对照后面编译时链接的函数库，</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br></pre></td></tr></table></figure>\n<p>需要：</p>\n<blockquote>\n<ul>\n<li>GLEW</li>\n<li>GLFW/GLFW3</li>\n<li>libgl1-mesa</li>\n<li>libglu1-mesa</li>\n</ul>\n</blockquote>\n<p><code>ps: 不是完全明白这里链接库的对应关系</code></p>\n<p>==========</p>\n<p>参考:<a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">Howto_Install_OpenGL_Development_Environment</a></p>\n<p><strong>建立基本编译环境</strong><br>首先不可或缺的，就是編譯器與基本的函式庫，如果系統沒有安裝的話，請依照下面的方式安裝：<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure></p>\n<p><strong>安裝OpenGL Library</strong><br>接下來要把我們會用到的 Library 裝上去，首先安裝 OpenGL Library<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libgl1-mesa-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>安裝OpenGL Utilities</strong><br>OpenGL Utilities 是一組建構於 OpenGL Library 之上的工具組，提供許多很方便的函式，使 OpenGL 更強大且更容易使用。 接下來我們安裝OpenGL Utilities</p>\n<blockquote>\n<p>在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libglu1-mesa-dev</span><br></pre></td></tr></table></figure>\n<p><strong>安裝GLFW/GLFW3</strong><br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。</p>\n<p>GLFW可以从它官方网站的<a href=\"http://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">下载页</a>上获取。</p>\n<p>参考网站<a href=\"https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\" target=\"_blank\" rel=\"noopener\">How to build &amp; install GLFW 3 and use it in a Linux project</a><br>解压后,</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install cmake</span><br><span class=\"line\"></span><br><span class=\"line\">$ cmake -G <span class=\"string\">\"Unix Makefiles\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo apt-get build-dep glfw</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree</span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo make</span><br><span class=\"line\">$ sudo make install</span><br><span class=\"line\"></span><br><span class=\"line\">Install the project...</span><br><span class=\"line\">-- Install configuration: <span class=\"string\">\"\"</span></span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW/glfw3.h</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/include/GLFW/glfw3native.h</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Config.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3ConfigVersion.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Targets.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/cmake/glfw3/glfw3Targets-noconfig.cmake</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/pkgconfig/glfw3.pc</span><br><span class=\"line\">-- Installing: /usr/<span class=\"built_in\">local</span>/lib/libglfw3.a</span><br></pre></td></tr></table></figure>\n<p><strong>从<a href=\"http://www.glfw.org/docs/3.0/quick.html\" target=\"_blank\" rel=\"noopener\">测试源码网站</a>复制案例代码测试</strong><br>该案例中#include <glfw glfw3.h=\"\"></glfw></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 -c main.cpp</span><br><span class=\"line\"></span><br><span class=\"line\">$ ./main.o</span><br><span class=\"line\">bash: ./main.o: cannot execute binary file: Exec format error  &amp;lt;==执行main.o提示不是二进制可执行文件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi</span><br><span class=\"line\">/usr/bin/ld: //usr/<span class=\"built_in\">local</span>/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol <span class=\"string\">'dlclose@@GLIBC_2.2.5'</span></span><br><span class=\"line\">//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from <span class=\"built_in\">command</span> line</span><br><span class=\"line\">collect2: error: ld returned 1 <span class=\"built_in\">exit</span> status</span><br></pre></td></tr></table></figure>\n<p>You may also need to add the linker options -ldl -lXinerama -lXcursor to get it to work correctly if you are getting undefined references to <strong>dlclose</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class=\"line\"></span><br><span class=\"line\">$ ./main.exec</span><br></pre></td></tr></table></figure>\n<p>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></p>\n<p>执行:</p>\n<p>$ ./main.exec</p>\n<p><del>*<em>安装glut\\</em>*</del></p>\n<p><del>```sh<br>sudo apt-get install libglut-dev<br>```</del></p>\n<p><del>沒有libglut-dev可以改用<br>```sh<br>sudo apt-get install freeglut3-dev<br>```</del></p>\n<p><del>設定編譯參數與編譯<br>在這之前，我們需要一個測試範例，example.c</del> <a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">如下</a>：</p>\n<p><del>有了測試範例、基礎編譯環境與各個 OpenGL 相關的函式庫之後，我們所需要做的就是告訴編譯器我們有安裝 OpenGL 函式庫，編譯程式時要連結這些函式庫。</del></p>\n<p><del>gcc example.c -o example.out -lGL -lGLU -lglut<br>因為我們安裝了 OpenGL Utility Toolkit ，它是建立在 OpenGL Utilities 與 OpenGL Library 之上，因此我們可以簡單連結 OpenGL Utility Toolkit 的函式庫就可以達到我們的目地了。下面的編譯參數跟上面的是同樣效果：</del></p>\n<p><del>gcc example.c -o example.out -lglut<br>下面簡單說明一下所使用的 gcc 參數</del></p>\n<p><del>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></del></p>\n<p><del>執行<br>接下來我們就可以來看看我們的結果，如果看到右圖，代表成功了!~<br>./example.out</del></p>\n<p><strong>编译和链接GLEW</strong></p>\n<p>对于用GCC编译的Linux用户建议使用这个命令行选项-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi。没有正确链接相应的库会产生 undefined reference(未定义的引用) 这个错误。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get build-dep glew</span><br><span class=\"line\">Reading package lists... Done</span><br><span class=\"line\">Building dependency tree       </span><br><span class=\"line\">Reading state information... Done</span><br><span class=\"line\">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class=\"line\"></span><br><span class=\"line\">$ sudo make</span><br><span class=\"line\">$ sudo make install</span><br></pre></td></tr></table></figure>\n<p>==========</p>\n<p><strong>测试教程中的案例代码</strong></p>\n<p>复制 [代码hello_window.cpp][<a href=\"https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp\" target=\"_blank\" rel=\"noopener\">https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp</a>]<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">a.out  hello_window.cpp</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">Starting GLFW context, OpenGL 3.3</span><br></pre></td></tr></table></figure></p>\n<p>看到初始化窗口，代表成功。</p>\n<p><strong>编译后窗口透明问题</strong><br>虽然窗口初始化成功, 但不知道我的窗口为什么是透明的, 难道是ubuntu的原因吗？<br>Render部分再加入两行代码<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.2f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>);</span><br><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure></p>\n<p><strong>编译后libGLEW.so.2.1: No such file or directory 问题</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">..</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">./a.out: error <span class=\"keyword\">while</span> loading shared libraries: libGLEW.so.2.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<p>查询<a href=\"https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\" target=\"_blank\" rel=\"noopener\">stackoverflow libGLEW相关问题</a><br>得到libGLEW在lib64下, 于是便创建软link<br>$ sudo ln -s /usr/lib64/libGLEW.so.2.1 /usr/lib/libGLEW.so.2.1</p>\n<p>==========</p>\n<p>refwebsite:<br><a href=\"https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/\" target=\"_blank\" rel=\"noopener\">https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/</a><br><a href=\"https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment\" target=\"_blank\" rel=\"noopener\">https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment</a><br><a href=\"https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project</a><br><a href=\"http://www.glfw.org/docs/3.0/quick.html\" target=\"_blank\" rel=\"noopener\">http://www.glfw.org/docs/3.0/quick.html</a><br><a href=\"https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew</a><br><a href=\"http://www.glfw.org/download.html\" target=\"_blank\" rel=\"noopener\">http://www.glfw.org/download.html</a></p>\n"},{"title":"Markdown删除线","date":"2017-12-21T23:24:06.000Z","_content":"\\~\\~删除一句\\~\\~\n~~删除一句~~\n\n\n\\~\\~删除\n多行\\~\\~\n~~删除\n多行~~\n\n\\~\\~删除包含语法\\\\[mituh's notes\\\\]\\\\[timtingwei.github.io\\\\]\\~\\~\n~~删除包含语法\\[mituh's notes\\]\\[timtingwei.github.io\\]~~\n\n\\====\n不知道还有其他方法否？\n\n\\====\nrefwebsite:\nhttps://en.wikipedia.org/wiki/Markdown\n","source":"_posts/markdown-delete-line.md","raw":"---\ntitle: Markdown删除线\ndate: 2017-12-22 07:24:06\ntags: markdown\n---\n\\~\\~删除一句\\~\\~\n~~删除一句~~\n\n\n\\~\\~删除\n多行\\~\\~\n~~删除\n多行~~\n\n\\~\\~删除包含语法\\\\[mituh's notes\\\\]\\\\[timtingwei.github.io\\\\]\\~\\~\n~~删除包含语法\\[mituh's notes\\]\\[timtingwei.github.io\\]~~\n\n\\====\n不知道还有其他方法否？\n\n\\====\nrefwebsite:\nhttps://en.wikipedia.org/wiki/Markdown\n","slug":"markdown-delete-line","published":1,"updated":"2018-06-19T16:15:03.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjq000rk8mffvbov6fx","content":"<p>~~删除一句~~<br><del>删除一句</del></p>\n<p>~~删除<br>多行~~<br><del>删除<br>多行</del></p>\n<p>~~删除包含语法\\[mituh’s notes\\]\\[timtingwei.github.io\\]~~<br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>\n<p>\\====<br>不知道还有其他方法否？</p>\n<p>\\====<br>refwebsite:<br><a href=\"https://en.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Markdown</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>~~删除一句~~<br><del>删除一句</del></p>\n<p>~~删除<br>多行~~<br><del>删除<br>多行</del></p>\n<p>~~删除包含语法\\[mituh’s notes\\]\\[timtingwei.github.io\\]~~<br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>\n<p>\\====<br>不知道还有其他方法否？</p>\n<p>\\====<br>refwebsite:<br><a href=\"https://en.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Markdown</a></p>\n"},{"title":"中建史考试笔记","date":"2018-01-18T09:19:59.000Z","_content":"\n# 题目分配\n填空20*2 = 40\n选择4\n问答4\n画图5\n\n\n# 简答题\n## 1, 中国古代建筑的三种主要结构形式和特点? P4\n\t1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头\n\t2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁\n\t3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。\n\t\n## 2, 进行穿斗式与抬粱式木构架的优缺点比较? P5\n\t穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。\n\n## 3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6\n\ta, 斗拱是由斗、拱、昂、翘、升组成的\n\tb, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)\n\t\n## 4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19 \n\t1, 类型：\n\t\ta, 干阑式\n\t\tb, 木骨泥墙\n\t2, 实例\n\t\ta, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。\n\t\tb, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。\n\n## 5, 中国古代建筑史上的主要著作\n\t春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n\n## 6, 《考工记》匠人营国一段原文及如何理解？\n\t原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)\n\t理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）\n\n## 7, 《工程做法》的内容和评价？ \n\t内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。\n \t评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。\n\n## 8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？\n\t背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。\n\t著书人：将作监 李诫\n\t评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。\n\n## 9, 北宋是城市结构由里坊制转向厢坊制的起点\n\t北宋城市结构和布局起了根本变化。\n\t唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。\n\t到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。\n\n## 10, 宋的基本模数制度：材份制\n\t1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.\n\t2, 材分制作用\n\t\ta, 统一建筑标准，建立设计规范，把握比例尺度,\n\t\tb, 简化设计工作,\n\t\tc, 方便工料预算，便于构件预制，加快施工进度。\n\n## 11, 宋式殿堂的特点及屋面举折\n\t1, 殿堂特点\n\t\ta, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n\t\tb, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n\t2, 屋面举折\n\t\ta, 举折是我国传统建筑确定屋面曲度的一种方法\n\t\tb, 利于屋面排水和檐下采光\n\n## 12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\n\t云冈石窟, 龙门石窟\n\t石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。\n\n## 13, 唐代建筑的主要特点是什么？\n\t1, 规模宏大，规划严整\n\t2, 建筑群 处理愈加成熟\n\t3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化\n\t4, 设计与施工水平提高\n\t5, 砖石建筑发展\n\t6, 建筑艺术真实成熟\n\n## 14, 元代盛行的减柱法是什么意思？举例说明\n\t减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。\n\t元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。\n\t举例：山西洪洞 广胜寺, 山西永济 永乐宫。\n\n## 15, 进行明代建筑木构架与唐宋风格比较\n\t1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。\n\t2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。\n\t3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。\n\t4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。\n\n## 16, 明清北京城四圈城的名称是什么？\n\t外城, 永定门\n\t内城, 正阳门\n\t皇城, 天安门\n\t紫禁城, 午门\n\t\n## 17, 简述北京故宫的建筑艺术成就\n\t1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n\t2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n\n## 18, 天坛总体布局及祭祀建筑特点\n\t设计特点:\n\t1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)\n\t2, 环境处理\n\t\ta, 建筑只占1/20, 融于绿色之中\n\t\tb, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近\n\t3, 运用数字和色彩的象征\n\t\n## 19, 佛塔的主要类型是什么？\n\t中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔\n\t1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,\n\t2, 单层塔，山东济南 隋代 神通寺 四门塔,\n\t3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,\n\t4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,\n\t5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。\n\n## 20, 简述平板枋（普拍枋）的位置和作用\n\t平板枋置于阑额之上, 可以承受斗拱。\n## 21, 屋顶做法：收山、推山\n\t推山：是庑殿建筑处理屋顶的一种特殊手法\n    收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。\n\n## 22, 清式彩画常用的三大类是什么？\n\t和玺, 旋子, 苏式\n## 23, 宋式柱网布局中分心槽是什么意思？\n\t以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。\n## 24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？\n\t外5, 内9;\n\t金厢斗底槽。\n\n# 绘制简图题\n嵩岳寺塔平面和立面 P181 考\n九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图\n佛光寺大殿平立剖面 P156\n晋祠圣母殿平立剖面\n独乐寺观音阁剖面 P162\n应县木塔平面、剖面 P176 考\n北京天坛总平面图 P131\n清式抬梁式七架无廊结构示意图 P297\n宋式进深八椽屋的屋面举折做法示意图 P285\n\n------\n# 补充\n\n## 5, 中国古代建筑史上的主要著作\n\t春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n\n## 10, 宋的基本模数制度：材份制\n\t1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.\n\t2, 材分制作用\n\t\ta, 统一建筑标准，建立设计规范，把握比例尺度,\n\t\tb, 简化设计工作,\n\t\tc, 方便工料预算，便于构件预制，加快施工进度。\n\n## 11, 宋式殿堂的特点及屋面举折\n\t1, 殿堂特点\n\t\ta, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n\t\tb, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n\t2, 屋面举折\n\t\ta, 举折是我国传统建筑确定屋面曲度的一种方法\n\t\tb, 利于屋面排水和檐下采光\n\n## 17, 简述北京故宫的建筑艺术成就\n\t1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n\t2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n\n------\n# 练习题目\n## 填空\n1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的` 抬梁式 `和`穿斗式 `两种主要木结构已经形成。\n2, 北宋初年浙东木匠`  喻皓   `著有《` 木经   `》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。\n3, 北宋末年政府颁布的《营造法式》中规定，把`   材   `作为造屋的尺度标准，即将木构架建筑的用料尺寸分成`  八   ` 等，按照屋宇的大小主次量屋用材。\n4, 清式彩画分为`和玺彩画`、`旋子彩画`、`苏式彩画`\n5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧` 推出     `，从而使四条垂脊形成空间曲线，这种做法称为`  推山  ` 。\n6, 应县木塔外观`  5  ` 层，内部结构层为`  9层   `木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。\n## 选择\n1, 隋大兴城的规划设计者为：（ A ）\n\t`A宇文凯` B郭守敬 C雷发达 D蒯祥\n2, 北京故宫天安门前院落的形状为：（ D）\n\tA凹字形 B工字型 C“L型” `D“T字形”`\n3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）\n\tA八等 B九等 `C十一等` D十三等\n4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）\n\t`A唐代` B宋代 C明代 D清代\n","source":"_posts/temp-history.md","raw":"---\ntitle: 中建史考试笔记\ndate: 2018-01-18 17:19:59\ntags: \n---\n\n# 题目分配\n填空20*2 = 40\n选择4\n问答4\n画图5\n\n\n# 简答题\n## 1, 中国古代建筑的三种主要结构形式和特点? P4\n\t1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头\n\t2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁\n\t3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。\n\t\n## 2, 进行穿斗式与抬粱式木构架的优缺点比较? P5\n\t穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。\n\n## 3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6\n\ta, 斗拱是由斗、拱、昂、翘、升组成的\n\tb, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)\n\t\n## 4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19 \n\t1, 类型：\n\t\ta, 干阑式\n\t\tb, 木骨泥墙\n\t2, 实例\n\t\ta, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。\n\t\tb, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。\n\n## 5, 中国古代建筑史上的主要著作\n\t春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n\n## 6, 《考工记》匠人营国一段原文及如何理解？\n\t原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)\n\t理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）\n\n## 7, 《工程做法》的内容和评价？ \n\t内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。\n \t评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。\n\n## 8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？\n\t背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。\n\t著书人：将作监 李诫\n\t评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。\n\n## 9, 北宋是城市结构由里坊制转向厢坊制的起点\n\t北宋城市结构和布局起了根本变化。\n\t唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。\n\t到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。\n\n## 10, 宋的基本模数制度：材份制\n\t1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.\n\t2, 材分制作用\n\t\ta, 统一建筑标准，建立设计规范，把握比例尺度,\n\t\tb, 简化设计工作,\n\t\tc, 方便工料预算，便于构件预制，加快施工进度。\n\n## 11, 宋式殿堂的特点及屋面举折\n\t1, 殿堂特点\n\t\ta, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n\t\tb, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n\t2, 屋面举折\n\t\ta, 举折是我国传统建筑确定屋面曲度的一种方法\n\t\tb, 利于屋面排水和檐下采光\n\n## 12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\n\t云冈石窟, 龙门石窟\n\t石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。\n\n## 13, 唐代建筑的主要特点是什么？\n\t1, 规模宏大，规划严整\n\t2, 建筑群 处理愈加成熟\n\t3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化\n\t4, 设计与施工水平提高\n\t5, 砖石建筑发展\n\t6, 建筑艺术真实成熟\n\n## 14, 元代盛行的减柱法是什么意思？举例说明\n\t减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。\n\t元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。\n\t举例：山西洪洞 广胜寺, 山西永济 永乐宫。\n\n## 15, 进行明代建筑木构架与唐宋风格比较\n\t1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。\n\t2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。\n\t3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。\n\t4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。\n\n## 16, 明清北京城四圈城的名称是什么？\n\t外城, 永定门\n\t内城, 正阳门\n\t皇城, 天安门\n\t紫禁城, 午门\n\t\n## 17, 简述北京故宫的建筑艺术成就\n\t1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n\t2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n\n## 18, 天坛总体布局及祭祀建筑特点\n\t设计特点:\n\t1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)\n\t2, 环境处理\n\t\ta, 建筑只占1/20, 融于绿色之中\n\t\tb, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近\n\t3, 运用数字和色彩的象征\n\t\n## 19, 佛塔的主要类型是什么？\n\t中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔\n\t1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,\n\t2, 单层塔，山东济南 隋代 神通寺 四门塔,\n\t3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,\n\t4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,\n\t5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。\n\n## 20, 简述平板枋（普拍枋）的位置和作用\n\t平板枋置于阑额之上, 可以承受斗拱。\n## 21, 屋顶做法：收山、推山\n\t推山：是庑殿建筑处理屋顶的一种特殊手法\n    收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。\n\n## 22, 清式彩画常用的三大类是什么？\n\t和玺, 旋子, 苏式\n## 23, 宋式柱网布局中分心槽是什么意思？\n\t以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。\n## 24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？\n\t外5, 内9;\n\t金厢斗底槽。\n\n# 绘制简图题\n嵩岳寺塔平面和立面 P181 考\n九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图\n佛光寺大殿平立剖面 P156\n晋祠圣母殿平立剖面\n独乐寺观音阁剖面 P162\n应县木塔平面、剖面 P176 考\n北京天坛总平面图 P131\n清式抬梁式七架无廊结构示意图 P297\n宋式进深八椽屋的屋面举折做法示意图 P285\n\n------\n# 补充\n\n## 5, 中国古代建筑史上的主要著作\n\t春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n\n## 10, 宋的基本模数制度：材份制\n\t1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.\n\t2, 材分制作用\n\t\ta, 统一建筑标准，建立设计规范，把握比例尺度,\n\t\tb, 简化设计工作,\n\t\tc, 方便工料预算，便于构件预制，加快施工进度。\n\n## 11, 宋式殿堂的特点及屋面举折\n\t1, 殿堂特点\n\t\ta, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n\t\tb, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n\t2, 屋面举折\n\t\ta, 举折是我国传统建筑确定屋面曲度的一种方法\n\t\tb, 利于屋面排水和檐下采光\n\n## 17, 简述北京故宫的建筑艺术成就\n\t1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n\t2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n\n------\n# 练习题目\n## 填空\n1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的` 抬梁式 `和`穿斗式 `两种主要木结构已经形成。\n2, 北宋初年浙东木匠`  喻皓   `著有《` 木经   `》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。\n3, 北宋末年政府颁布的《营造法式》中规定，把`   材   `作为造屋的尺度标准，即将木构架建筑的用料尺寸分成`  八   ` 等，按照屋宇的大小主次量屋用材。\n4, 清式彩画分为`和玺彩画`、`旋子彩画`、`苏式彩画`\n5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧` 推出     `，从而使四条垂脊形成空间曲线，这种做法称为`  推山  ` 。\n6, 应县木塔外观`  5  ` 层，内部结构层为`  9层   `木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。\n## 选择\n1, 隋大兴城的规划设计者为：（ A ）\n\t`A宇文凯` B郭守敬 C雷发达 D蒯祥\n2, 北京故宫天安门前院落的形状为：（ D）\n\tA凹字形 B工字型 C“L型” `D“T字形”`\n3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）\n\tA八等 B九等 `C十一等` D十三等\n4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）\n\t`A唐代` B宋代 C明代 D清代\n","slug":"temp-history","published":1,"updated":"2018-06-19T16:15:03.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjr000tk8mfxs3ynwru","content":"<h1 id=\"题目分配\"><a href=\"#题目分配\" class=\"headerlink\" title=\"题目分配\"></a>题目分配</h1><p>填空20*2 = 40<br>选择4<br>问答4<br>画图5</p>\n<h1 id=\"简答题\"><a href=\"#简答题\" class=\"headerlink\" title=\"简答题\"></a>简答题</h1><h2 id=\"1-中国古代建筑的三种主要结构形式和特点-P4\"><a href=\"#1-中国古代建筑的三种主要结构形式和特点-P4\" class=\"headerlink\" title=\"1, 中国古代建筑的三种主要结构形式和特点? P4\"></a>1, 中国古代建筑的三种主要结构形式和特点? P4</h2><pre><code>1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头\n2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁\n3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。\n</code></pre><h2 id=\"2-进行穿斗式与抬粱式木构架的优缺点比较-P5\"><a href=\"#2-进行穿斗式与抬粱式木构架的优缺点比较-P5\" class=\"headerlink\" title=\"2, 进行穿斗式与抬粱式木构架的优缺点比较? P5\"></a>2, 进行穿斗式与抬粱式木构架的优缺点比较? P5</h2><pre><code>穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。\n</code></pre><h2 id=\"3-斗拱是由哪些构件组成的？每种构件的作用如何？P6\"><a href=\"#3-斗拱是由哪些构件组成的？每种构件的作用如何？P6\" class=\"headerlink\" title=\"3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6\"></a>3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6</h2><pre><code>a, 斗拱是由斗、拱、昂、翘、升组成的\nb, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)\n</code></pre><h2 id=\"4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19\"><a href=\"#4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19\" class=\"headerlink\" title=\"4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19\"></a>4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19</h2><pre><code>1, 类型：\n    a, 干阑式\n    b, 木骨泥墙\n2, 实例\n    a, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。\n    b, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。\n</code></pre><h2 id=\"5-中国古代建筑史上的主要著作\"><a href=\"#5-中国古代建筑史上的主要著作\" class=\"headerlink\" title=\"5, 中国古代建筑史上的主要著作\"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n</code></pre><h2 id=\"6-《考工记》匠人营国一段原文及如何理解？\"><a href=\"#6-《考工记》匠人营国一段原文及如何理解？\" class=\"headerlink\" title=\"6, 《考工记》匠人营国一段原文及如何理解？\"></a>6, 《考工记》匠人营国一段原文及如何理解？</h2><pre><code>原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)\n理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）\n</code></pre><h2 id=\"7-《工程做法》的内容和评价？\"><a href=\"#7-《工程做法》的内容和评价？\" class=\"headerlink\" title=\"7, 《工程做法》的内容和评价？\"></a>7, 《工程做法》的内容和评价？</h2><pre><code>内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。\n 评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。\n</code></pre><h2 id=\"8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？\"><a href=\"#8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？\" class=\"headerlink\" title=\"8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？\"></a>8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？</h2><pre><code>背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。\n著书人：将作监 李诫\n评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。\n</code></pre><h2 id=\"9-北宋是城市结构由里坊制转向厢坊制的起点\"><a href=\"#9-北宋是城市结构由里坊制转向厢坊制的起点\" class=\"headerlink\" title=\"9, 北宋是城市结构由里坊制转向厢坊制的起点\"></a>9, 北宋是城市结构由里坊制转向厢坊制的起点</h2><pre><code>北宋城市结构和布局起了根本变化。\n唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。\n到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。\n</code></pre><h2 id=\"10-宋的基本模数制度：材份制\"><a href=\"#10-宋的基本模数制度：材份制\" class=\"headerlink\" title=\"10, 宋的基本模数制度：材份制\"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.\n2, 材分制作用\n    a, 统一建筑标准，建立设计规范，把握比例尺度,\n    b, 简化设计工作,\n    c, 方便工料预算，便于构件预制，加快施工进度。\n</code></pre><h2 id=\"11-宋式殿堂的特点及屋面举折\"><a href=\"#11-宋式殿堂的特点及屋面举折\" class=\"headerlink\" title=\"11, 宋式殿堂的特点及屋面举折\"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点\n    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n2, 屋面举折\n    a, 举折是我国传统建筑确定屋面曲度的一种方法\n    b, 利于屋面排水和檐下采光\n</code></pre><h2 id=\"12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\"><a href=\"#12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\" class=\"headerlink\" title=\"12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\"></a>12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？</h2><pre><code>云冈石窟, 龙门石窟\n石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。\n</code></pre><h2 id=\"13-唐代建筑的主要特点是什么？\"><a href=\"#13-唐代建筑的主要特点是什么？\" class=\"headerlink\" title=\"13, 唐代建筑的主要特点是什么？\"></a>13, 唐代建筑的主要特点是什么？</h2><pre><code>1, 规模宏大，规划严整\n2, 建筑群 处理愈加成熟\n3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化\n4, 设计与施工水平提高\n5, 砖石建筑发展\n6, 建筑艺术真实成熟\n</code></pre><h2 id=\"14-元代盛行的减柱法是什么意思？举例说明\"><a href=\"#14-元代盛行的减柱法是什么意思？举例说明\" class=\"headerlink\" title=\"14, 元代盛行的减柱法是什么意思？举例说明\"></a>14, 元代盛行的减柱法是什么意思？举例说明</h2><pre><code>减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。\n元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。\n举例：山西洪洞 广胜寺, 山西永济 永乐宫。\n</code></pre><h2 id=\"15-进行明代建筑木构架与唐宋风格比较\"><a href=\"#15-进行明代建筑木构架与唐宋风格比较\" class=\"headerlink\" title=\"15, 进行明代建筑木构架与唐宋风格比较\"></a>15, 进行明代建筑木构架与唐宋风格比较</h2><pre><code>1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。\n2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。\n3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。\n4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。\n</code></pre><h2 id=\"16-明清北京城四圈城的名称是什么？\"><a href=\"#16-明清北京城四圈城的名称是什么？\" class=\"headerlink\" title=\"16, 明清北京城四圈城的名称是什么？\"></a>16, 明清北京城四圈城的名称是什么？</h2><pre><code>外城, 永定门\n内城, 正阳门\n皇城, 天安门\n紫禁城, 午门\n</code></pre><h2 id=\"17-简述北京故宫的建筑艺术成就\"><a href=\"#17-简述北京故宫的建筑艺术成就\" class=\"headerlink\" title=\"17, 简述北京故宫的建筑艺术成就\"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n</code></pre><h2 id=\"18-天坛总体布局及祭祀建筑特点\"><a href=\"#18-天坛总体布局及祭祀建筑特点\" class=\"headerlink\" title=\"18, 天坛总体布局及祭祀建筑特点\"></a>18, 天坛总体布局及祭祀建筑特点</h2><pre><code>设计特点:\n1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)\n2, 环境处理\n    a, 建筑只占1/20, 融于绿色之中\n    b, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近\n3, 运用数字和色彩的象征\n</code></pre><h2 id=\"19-佛塔的主要类型是什么？\"><a href=\"#19-佛塔的主要类型是什么？\" class=\"headerlink\" title=\"19, 佛塔的主要类型是什么？\"></a>19, 佛塔的主要类型是什么？</h2><pre><code>中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔\n1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,\n2, 单层塔，山东济南 隋代 神通寺 四门塔,\n3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,\n4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,\n5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。\n</code></pre><h2 id=\"20-简述平板枋（普拍枋）的位置和作用\"><a href=\"#20-简述平板枋（普拍枋）的位置和作用\" class=\"headerlink\" title=\"20, 简述平板枋（普拍枋）的位置和作用\"></a>20, 简述平板枋（普拍枋）的位置和作用</h2><pre><code>平板枋置于阑额之上, 可以承受斗拱。\n</code></pre><h2 id=\"21-屋顶做法：收山、推山\"><a href=\"#21-屋顶做法：收山、推山\" class=\"headerlink\" title=\"21, 屋顶做法：收山、推山\"></a>21, 屋顶做法：收山、推山</h2><pre><code>推山：是庑殿建筑处理屋顶的一种特殊手法\n收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。\n</code></pre><h2 id=\"22-清式彩画常用的三大类是什么？\"><a href=\"#22-清式彩画常用的三大类是什么？\" class=\"headerlink\" title=\"22, 清式彩画常用的三大类是什么？\"></a>22, 清式彩画常用的三大类是什么？</h2><pre><code>和玺, 旋子, 苏式\n</code></pre><h2 id=\"23-宋式柱网布局中分心槽是什么意思？\"><a href=\"#23-宋式柱网布局中分心槽是什么意思？\" class=\"headerlink\" title=\"23, 宋式柱网布局中分心槽是什么意思？\"></a>23, 宋式柱网布局中分心槽是什么意思？</h2><pre><code>以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。\n</code></pre><h2 id=\"24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？\"><a href=\"#24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？\" class=\"headerlink\" title=\"24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？\"></a>24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？</h2><pre><code>外5, 内9;\n金厢斗底槽。\n</code></pre><h1 id=\"绘制简图题\"><a href=\"#绘制简图题\" class=\"headerlink\" title=\"绘制简图题\"></a>绘制简图题</h1><p>嵩岳寺塔平面和立面 P181 考<br>九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图<br>佛光寺大殿平立剖面 P156<br>晋祠圣母殿平立剖面<br>独乐寺观音阁剖面 P162<br>应县木塔平面、剖面 P176 考<br>北京天坛总平面图 P131<br>清式抬梁式七架无廊结构示意图 P297<br>宋式进深八椽屋的屋面举折做法示意图 P285</p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"5-中国古代建筑史上的主要著作-1\"><a href=\"#5-中国古代建筑史上的主要著作-1\" class=\"headerlink\" title=\"5, 中国古代建筑史上的主要著作\"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n</code></pre><h2 id=\"10-宋的基本模数制度：材份制-1\"><a href=\"#10-宋的基本模数制度：材份制-1\" class=\"headerlink\" title=\"10, 宋的基本模数制度：材份制\"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.\n2, 材分制作用\n    a, 统一建筑标准，建立设计规范，把握比例尺度,\n    b, 简化设计工作,\n    c, 方便工料预算，便于构件预制，加快施工进度。\n</code></pre><h2 id=\"11-宋式殿堂的特点及屋面举折-1\"><a href=\"#11-宋式殿堂的特点及屋面举折-1\" class=\"headerlink\" title=\"11, 宋式殿堂的特点及屋面举折\"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点\n    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n2, 屋面举折\n    a, 举折是我国传统建筑确定屋面曲度的一种方法\n    b, 利于屋面排水和檐下采光\n</code></pre><h2 id=\"17-简述北京故宫的建筑艺术成就-1\"><a href=\"#17-简述北京故宫的建筑艺术成就-1\" class=\"headerlink\" title=\"17, 简述北京故宫的建筑艺术成就\"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n</code></pre><hr>\n<h1 id=\"练习题目\"><a href=\"#练习题目\" class=\"headerlink\" title=\"练习题目\"></a>练习题目</h1><h2 id=\"填空\"><a href=\"#填空\" class=\"headerlink\" title=\"填空\"></a>填空</h2><p>1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的<code>抬梁式</code>和<code>穿斗式</code>两种主要木结构已经形成。<br>2, 北宋初年浙东木匠<code>喻皓</code>著有《<code>木经</code>》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。<br>3, 北宋末年政府颁布的《营造法式》中规定，把<code>材</code>作为造屋的尺度标准，即将木构架建筑的用料尺寸分成<code>八</code> 等，按照屋宇的大小主次量屋用材。<br>4, 清式彩画分为<code>和玺彩画</code>、<code>旋子彩画</code>、<code>苏式彩画</code><br>5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧<code>推出</code>，从而使四条垂脊形成空间曲线，这种做法称为<code>推山</code> 。<br>6, 应县木塔外观<code>5</code> 层，内部结构层为<code>9层</code>木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。</p>\n<h2 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h2><p>1, 隋大兴城的规划设计者为：（ A ）<br>    <code>A宇文凯</code> B郭守敬 C雷发达 D蒯祥<br>2, 北京故宫天安门前院落的形状为：（ D）<br>    A凹字形 B工字型 C“L型” <code>D“T字形”</code><br>3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）<br>    A八等 B九等 <code>C十一等</code> D十三等<br>4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）<br>    <code>A唐代</code> B宋代 C明代 D清代</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目分配\"><a href=\"#题目分配\" class=\"headerlink\" title=\"题目分配\"></a>题目分配</h1><p>填空20*2 = 40<br>选择4<br>问答4<br>画图5</p>\n<h1 id=\"简答题\"><a href=\"#简答题\" class=\"headerlink\" title=\"简答题\"></a>简答题</h1><h2 id=\"1-中国古代建筑的三种主要结构形式和特点-P4\"><a href=\"#1-中国古代建筑的三种主要结构形式和特点-P4\" class=\"headerlink\" title=\"1, 中国古代建筑的三种主要结构形式和特点? P4\"></a>1, 中国古代建筑的三种主要结构形式和特点? P4</h2><pre><code>1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头\n2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁\n3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。\n</code></pre><h2 id=\"2-进行穿斗式与抬粱式木构架的优缺点比较-P5\"><a href=\"#2-进行穿斗式与抬粱式木构架的优缺点比较-P5\" class=\"headerlink\" title=\"2, 进行穿斗式与抬粱式木构架的优缺点比较? P5\"></a>2, 进行穿斗式与抬粱式木构架的优缺点比较? P5</h2><pre><code>穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。\n</code></pre><h2 id=\"3-斗拱是由哪些构件组成的？每种构件的作用如何？P6\"><a href=\"#3-斗拱是由哪些构件组成的？每种构件的作用如何？P6\" class=\"headerlink\" title=\"3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6\"></a>3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6</h2><pre><code>a, 斗拱是由斗、拱、昂、翘、升组成的\nb, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)\n</code></pre><h2 id=\"4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19\"><a href=\"#4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19\" class=\"headerlink\" title=\"4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19\"></a>4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19</h2><pre><code>1, 类型：\n    a, 干阑式\n    b, 木骨泥墙\n2, 实例\n    a, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。\n    b, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。\n</code></pre><h2 id=\"5-中国古代建筑史上的主要著作\"><a href=\"#5-中国古代建筑史上的主要著作\" class=\"headerlink\" title=\"5, 中国古代建筑史上的主要著作\"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n</code></pre><h2 id=\"6-《考工记》匠人营国一段原文及如何理解？\"><a href=\"#6-《考工记》匠人营国一段原文及如何理解？\" class=\"headerlink\" title=\"6, 《考工记》匠人营国一段原文及如何理解？\"></a>6, 《考工记》匠人营国一段原文及如何理解？</h2><pre><code>原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)\n理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）\n</code></pre><h2 id=\"7-《工程做法》的内容和评价？\"><a href=\"#7-《工程做法》的内容和评价？\" class=\"headerlink\" title=\"7, 《工程做法》的内容和评价？\"></a>7, 《工程做法》的内容和评价？</h2><pre><code>内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。\n 评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。\n</code></pre><h2 id=\"8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？\"><a href=\"#8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？\" class=\"headerlink\" title=\"8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？\"></a>8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？</h2><pre><code>背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。\n著书人：将作监 李诫\n评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。\n</code></pre><h2 id=\"9-北宋是城市结构由里坊制转向厢坊制的起点\"><a href=\"#9-北宋是城市结构由里坊制转向厢坊制的起点\" class=\"headerlink\" title=\"9, 北宋是城市结构由里坊制转向厢坊制的起点\"></a>9, 北宋是城市结构由里坊制转向厢坊制的起点</h2><pre><code>北宋城市结构和布局起了根本变化。\n唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。\n到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。\n</code></pre><h2 id=\"10-宋的基本模数制度：材份制\"><a href=\"#10-宋的基本模数制度：材份制\" class=\"headerlink\" title=\"10, 宋的基本模数制度：材份制\"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.\n2, 材分制作用\n    a, 统一建筑标准，建立设计规范，把握比例尺度,\n    b, 简化设计工作,\n    c, 方便工料预算，便于构件预制，加快施工进度。\n</code></pre><h2 id=\"11-宋式殿堂的特点及屋面举折\"><a href=\"#11-宋式殿堂的特点及屋面举折\" class=\"headerlink\" title=\"11, 宋式殿堂的特点及屋面举折\"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点\n    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n2, 屋面举折\n    a, 举折是我国传统建筑确定屋面曲度的一种方法\n    b, 利于屋面排水和檐下采光\n</code></pre><h2 id=\"12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\"><a href=\"#12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\" class=\"headerlink\" title=\"12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？\"></a>12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？</h2><pre><code>云冈石窟, 龙门石窟\n石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。\n</code></pre><h2 id=\"13-唐代建筑的主要特点是什么？\"><a href=\"#13-唐代建筑的主要特点是什么？\" class=\"headerlink\" title=\"13, 唐代建筑的主要特点是什么？\"></a>13, 唐代建筑的主要特点是什么？</h2><pre><code>1, 规模宏大，规划严整\n2, 建筑群 处理愈加成熟\n3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化\n4, 设计与施工水平提高\n5, 砖石建筑发展\n6, 建筑艺术真实成熟\n</code></pre><h2 id=\"14-元代盛行的减柱法是什么意思？举例说明\"><a href=\"#14-元代盛行的减柱法是什么意思？举例说明\" class=\"headerlink\" title=\"14, 元代盛行的减柱法是什么意思？举例说明\"></a>14, 元代盛行的减柱法是什么意思？举例说明</h2><pre><code>减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。\n元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。\n举例：山西洪洞 广胜寺, 山西永济 永乐宫。\n</code></pre><h2 id=\"15-进行明代建筑木构架与唐宋风格比较\"><a href=\"#15-进行明代建筑木构架与唐宋风格比较\" class=\"headerlink\" title=\"15, 进行明代建筑木构架与唐宋风格比较\"></a>15, 进行明代建筑木构架与唐宋风格比较</h2><pre><code>1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。\n2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。\n3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。\n4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。\n</code></pre><h2 id=\"16-明清北京城四圈城的名称是什么？\"><a href=\"#16-明清北京城四圈城的名称是什么？\" class=\"headerlink\" title=\"16, 明清北京城四圈城的名称是什么？\"></a>16, 明清北京城四圈城的名称是什么？</h2><pre><code>外城, 永定门\n内城, 正阳门\n皇城, 天安门\n紫禁城, 午门\n</code></pre><h2 id=\"17-简述北京故宫的建筑艺术成就\"><a href=\"#17-简述北京故宫的建筑艺术成就\" class=\"headerlink\" title=\"17, 简述北京故宫的建筑艺术成就\"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n</code></pre><h2 id=\"18-天坛总体布局及祭祀建筑特点\"><a href=\"#18-天坛总体布局及祭祀建筑特点\" class=\"headerlink\" title=\"18, 天坛总体布局及祭祀建筑特点\"></a>18, 天坛总体布局及祭祀建筑特点</h2><pre><code>设计特点:\n1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)\n2, 环境处理\n    a, 建筑只占1/20, 融于绿色之中\n    b, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近\n3, 运用数字和色彩的象征\n</code></pre><h2 id=\"19-佛塔的主要类型是什么？\"><a href=\"#19-佛塔的主要类型是什么？\" class=\"headerlink\" title=\"19, 佛塔的主要类型是什么？\"></a>19, 佛塔的主要类型是什么？</h2><pre><code>中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔\n1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,\n2, 单层塔，山东济南 隋代 神通寺 四门塔,\n3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,\n4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,\n5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。\n</code></pre><h2 id=\"20-简述平板枋（普拍枋）的位置和作用\"><a href=\"#20-简述平板枋（普拍枋）的位置和作用\" class=\"headerlink\" title=\"20, 简述平板枋（普拍枋）的位置和作用\"></a>20, 简述平板枋（普拍枋）的位置和作用</h2><pre><code>平板枋置于阑额之上, 可以承受斗拱。\n</code></pre><h2 id=\"21-屋顶做法：收山、推山\"><a href=\"#21-屋顶做法：收山、推山\" class=\"headerlink\" title=\"21, 屋顶做法：收山、推山\"></a>21, 屋顶做法：收山、推山</h2><pre><code>推山：是庑殿建筑处理屋顶的一种特殊手法\n收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。\n</code></pre><h2 id=\"22-清式彩画常用的三大类是什么？\"><a href=\"#22-清式彩画常用的三大类是什么？\" class=\"headerlink\" title=\"22, 清式彩画常用的三大类是什么？\"></a>22, 清式彩画常用的三大类是什么？</h2><pre><code>和玺, 旋子, 苏式\n</code></pre><h2 id=\"23-宋式柱网布局中分心槽是什么意思？\"><a href=\"#23-宋式柱网布局中分心槽是什么意思？\" class=\"headerlink\" title=\"23, 宋式柱网布局中分心槽是什么意思？\"></a>23, 宋式柱网布局中分心槽是什么意思？</h2><pre><code>以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。\n</code></pre><h2 id=\"24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？\"><a href=\"#24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？\" class=\"headerlink\" title=\"24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？\"></a>24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？</h2><pre><code>外5, 内9;\n金厢斗底槽。\n</code></pre><h1 id=\"绘制简图题\"><a href=\"#绘制简图题\" class=\"headerlink\" title=\"绘制简图题\"></a>绘制简图题</h1><p>嵩岳寺塔平面和立面 P181 考<br>九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图<br>佛光寺大殿平立剖面 P156<br>晋祠圣母殿平立剖面<br>独乐寺观音阁剖面 P162<br>应县木塔平面、剖面 P176 考<br>北京天坛总平面图 P131<br>清式抬梁式七架无廊结构示意图 P297<br>宋式进深八椽屋的屋面举折做法示意图 P285</p>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"5-中国古代建筑史上的主要著作-1\"><a href=\"#5-中国古代建筑史上的主要著作-1\" class=\"headerlink\" title=\"5, 中国古代建筑史上的主要著作\"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》\n</code></pre><h2 id=\"10-宋的基本模数制度：材份制-1\"><a href=\"#10-宋的基本模数制度：材份制-1\" class=\"headerlink\" title=\"10, 宋的基本模数制度：材份制\"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.\n2, 材分制作用\n    a, 统一建筑标准，建立设计规范，把握比例尺度,\n    b, 简化设计工作,\n    c, 方便工料预算，便于构件预制，加快施工进度。\n</code></pre><h2 id=\"11-宋式殿堂的特点及屋面举折-1\"><a href=\"#11-宋式殿堂的特点及屋面举折-1\" class=\"headerlink\" title=\"11, 宋式殿堂的特点及屋面举折\"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点\n    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。\n    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。\n2, 屋面举折\n    a, 举折是我国传统建筑确定屋面曲度的一种方法\n    b, 利于屋面排水和檐下采光\n</code></pre><h2 id=\"17-简述北京故宫的建筑艺术成就-1\"><a href=\"#17-简述北京故宫的建筑艺术成就-1\" class=\"headerlink\" title=\"17, 简述北京故宫的建筑艺术成就\"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)\n2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）\n</code></pre><hr>\n<h1 id=\"练习题目\"><a href=\"#练习题目\" class=\"headerlink\" title=\"练习题目\"></a>练习题目</h1><h2 id=\"填空\"><a href=\"#填空\" class=\"headerlink\" title=\"填空\"></a>填空</h2><p>1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的<code>抬梁式</code>和<code>穿斗式</code>两种主要木结构已经形成。<br>2, 北宋初年浙东木匠<code>喻皓</code>著有《<code>木经</code>》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。<br>3, 北宋末年政府颁布的《营造法式》中规定，把<code>材</code>作为造屋的尺度标准，即将木构架建筑的用料尺寸分成<code>八</code> 等，按照屋宇的大小主次量屋用材。<br>4, 清式彩画分为<code>和玺彩画</code>、<code>旋子彩画</code>、<code>苏式彩画</code><br>5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧<code>推出</code>，从而使四条垂脊形成空间曲线，这种做法称为<code>推山</code> 。<br>6, 应县木塔外观<code>5</code> 层，内部结构层为<code>9层</code>木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。</p>\n<h2 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h2><p>1, 隋大兴城的规划设计者为：（ A ）<br>    <code>A宇文凯</code> B郭守敬 C雷发达 D蒯祥<br>2, 北京故宫天安门前院落的形状为：（ D）<br>    A凹字形 B工字型 C“L型” <code>D“T字形”</code><br>3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）<br>    A八等 B九等 <code>C十一等</code> D十三等<br>4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）<br>    <code>A唐代</code> B宋代 C明代 D清代</p>\n"},{"title":"<<游戏之旅>>笔记","date":"2018-01-04T01:34:38.000Z","_content":"\n最近读了云风大大的书, 感谢云风, 对我有所帮助。 \n选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14\n\n# 对我有所启发的points\n > * 写email的建议\n > * C和C++的关系\n > * C++的开发经验\n > * 学习C++阅读次序\n > * template的技巧\n > * **开发的成功和失败的经验**\n > * 游戏编程几个反思\n > * 后记中编程实践和思考方法 \n > * 致谢中云风父亲的背景以及教育方法\n\n\n\n\n----\n# 2. 算法\n\n## 2.1 程序 = 算法+数据结构\n计算机解决的问题，看成一个需要求解的函数，\n> * 算法：将输入转化为输出的方法。\n> * 数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。\n\n#### 2.1.1 算法\n时间和空间之间寻求平衡。\n> * 空间换时间的做法，非常广泛，即预处理\n> * 时间换空间，不容忽视，即使重复计算。\n\n依赖平台特性:\n> * 非并行计算机，不考虑用并行来提速。\n> * 空间允许随机访问，不是纸带机的顺序。\n\n#### 2.1.2 数据结构\n简单定义：对数据的组织方法，还有对数据组织方式的处理方法。\nC++已经提供了常见的数据结构，为什么还要学？\n> * 学蕴含思想\n> * 根据实际情况对数据结构进行改造，更高效。\n\n##### 1. 线性表\n\n\t有限逻辑上的有序数列，有确定的前驱和后驱；\n\t分为成：数组和链表;\n\t\n\t数组:\n\t\n##### 2. 堆栈、队列和串\n\n##### 3. 树、二叉树及其他\n\n**树：**\n有层次的数据集的组织方式。\n\nGUI界面，通常用树来组织；\n游戏中的对象管理，用树来解决管理上的层次问题。\n\n**二叉树:**\n严格来说不算是树。\n表达式计算，数据压缩，排序查找方面有很多用途。\n\n**四叉树、八叉树：**\n空间状态划分，\n> * 四叉树：平面\n> * 八叉树: 空间\n\n空间: 场景空间+ 调色盘算法等（向量空间）\n\n**图：**\n节点没有父子关系，纯粹的点和边的集合。\n节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。\n节点和节点之间可以有方向，也可以无方向。\n\n**图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。**\n\n**映射表**\nstd::map,STL最复杂的容器。\n\n\n**禁忌思想，**\n> * 模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。\n>* 蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。\n\n算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。\n\n#### 2.4 优化\n> * 数学方法的改进\n> * 预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间\n> * 简化算法求得近似来取代精确解（或最有解）\n> * 改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。\n\n碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。\n\n<<C语言程序设计400例>>\n\n\n**C**\nC语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。\nC语言函数，让问题分而治理它。\n全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。\n最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。\n\n**BASIC**\n\n### 比较解释语言和C语言的不同\n\n解释型语言：\n> 1. 每运行一次，解释器就读一次，对符号进行翻译\n> 2. 中间状态以严格规定保存起来，在后面的语句需要时被重新加载\nC语言\n> 1. 在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。\n> 2. 编译器对代码同类向合并，最后的机器码会很简洁。\n\n逻辑学教育，BASIC，适合理解编程。\n\n# 3. 编程语言\n## 3.3 C++\n### C++的不同理解\n\n第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。\n\n### C对于C++的优势\n简洁，而非高效；适合做小内存的嵌入式系统开发。\n\n### 但大多数游戏平台，C++比C更适合\n\n## 3.4 汇编语言\n\n合适场合使用汇编，能让程序跑得更快。\n了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，\n在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。\n\n\n# 4. 前Windows时代\n## 4.3 保护模式下的开发工具\n\n个人主页建立之初，我罗列出了个人兴趣 ：...很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。\n>* 翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友\n>* 写关于游戏编程技术方面的小文，各处转载\n\n>* 利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。\n\n学习新的技术，翻译一本相关的英语著作可以算是捷径。\n> * 比囫囵吞枣的读一遍英文原文要有效的多。\n> * 因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。\n> * 即使对此有所了解，翻译后也能更上一层楼。\n> * 英语水平也会提高。\n\n## 4.4 闲话allegro\n\n### 4.4.4 几何图形和3D\n图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。\n\n3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。\n相关的:\n> * 透视映射\n> * 矩阵，三维空间中变换的工具, 自带一套矩阵运算。\n> * 实现了一套定点数的运算该改善游戏中需要的数学运算速度。\n\n**1,定点数**\n巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。\n\n浮点数：计算机用一种纯小数加指数的形式表示实数。\n定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。\n\n高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。\n\n精读在1/6*10^4, 十进制小数点后四位的精度。\n\n定点数的一些计算技巧和优势：\n> * 原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。\n> * 角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。\n\n## 4.5 \n \n云风关于写email的建议：\n> * 回复收到的每封email, 即使没空写， 也让对方知道自己已读。\n> * 使用纯文本，发送过大附件前请求\n> * 合适的标题，能概括内容；偏题时，修改标题。\n> * 删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。\n> * 合理分段，表达自己意见，别赞同两字多写一点。\n> * 发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确\n> * 不要随意公开转载私人信件，即使转载也注明出处。\n \n# 8. 引擎中的优化\n\n“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。\n\n只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。\n\t\n\n# 9. C和C++\n\n## 9.1 从C到C++\n1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。\n\n2, C对大块的数据，使用数据指针来表达。\n\n3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据\n\n4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。\n\n5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。\n\n`困难性的说明`，\n高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往**只能针对特定的类型**。\n\n`C++面向对象的说明`\n> * 既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。\n> * 将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。\n\n## 9.2 C vs C++， 效率至上\n\n`C++中混有C语言的好处:`\n> 1, 更广泛的移植性\n> 2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖\n> 3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事\n> 4, C简洁, 编译速度快\n\n## 9.3 优雅的C++\n\n将C细化，又不增加额外的开销;\n不对程序员有过多限制。\n\n### 9.3.1 宏\n\n`宏的作用`\n> 1, 定义常数\n> 2, 代码生成\n> 3, 内联代码\n> 4, 对编译流程作出选择\n\n1, 定义常数\n\n```c\n#define PI 3.1415926f;\n```\n\n```cpp\nconst float PI;\n```\n\nC++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。\n\n经典的如：\n```c\n#define min(a, b) ((a<b)?(a):(b))\n```\n\n\n```cpp\ntemplate <typename T> const T& min(const T &a, const T &b) {\n  return a<b ? a:b;\n}\n```\n\n### 9.3.2 const修饰以及类型转换\n\n\n#### const修饰\nconst chat* 而不是 C 的 char*\n\n将函数参数写成const;\n成员变量修饰成const, 只有在构造的时构建他们;\n为成员函数增加一个const, 表达这个函数不会修改类的成员变量\n\n\n#### 类型转换\n\nC中几乎任何类型都可以任意转换，缘于C汇编的根。\nC++用static_cast 以模板的语法表达看起来可以互相转换的类型互换\n\nconst和const之间的转换，只能通过const_cast转换。\n\n严格描述每个对象的const性质，可以帮助在编译期发生错误减少。\n\n### 9.3.3 隐藏实现\n好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。\n\n作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。\n\n### 9.3.4 引用而非指针\n\n指针是导致资源被遗忘释放的罪魁祸首。\n> * 当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。\n\n引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。\n\nC++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。\n\n### 9.3.5 命名空间\n引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。\n\n## 9.4 C++的误区\n\n自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。\n\n举例:\n> * 能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。\n\n解释：\n> * 没有完美的程序，也没有完美的原则。\n> * 不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。\n\n### 9.4.1 类层次过细\n会造成间接调用引起的损耗。\n\n### 9.4.2 滥用操作符重载\n\n为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。\n如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。\n\n### 9.4.3 滥用标准容器\n用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。\n\n`std::map可以这样子做，`\n如果只是为了创建一张key-value的对应表可供查询，完全可以用\nkey-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。\n\n\n### 9.4.5 滥用多重继承\n\n会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。\n\n### 9.4.6 忽视C++高级特性的复杂度\n\n如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。\n\n### 9.4.7 学习C++\n\n我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。\n\n因此，需要\n> 1，学\n> 2, 用\n> 3, 思考\n> 2, 回到1\n\n如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。\n\n推荐一个阅读次序:\n> 1, 先学会C，只是也是C++子集的部分。\n> 2, <<C++编程思想>>\n> 3, <<C++ Primer>> 和 <<C++ Programing Language>>\n> 4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。\n> 5, <<C++的发展和演化>>，深入了解C++设计的根源以及C++编译器实现方法入手. \n> 6, <<深度探索C++物件模型>>对追求高效的C++程序员尤为受用。\n\n进阶学习: 需要一定的开发经验才能阅读\n\n> * <<Effective C++>>, <<More Effective C++>>, <<C++沉思录>>\n> * 泛型编程<<STL 源码剖析>>，有点难，但是花上一定的时间一定有收获。\n> * <<C++设计新思维------泛型编程与设计模式之应用>>template使用自信，对泛型编程感觉良好，\n> * <<C++标准程序库>>想更精通标准库，C++程序员案头必备的参考手册。\n> * <<Effective STL 中文版>>， 与前面的effcive系列一样\n\n\n### 9.5.3 再论动态内存分配\n\n//...\n\n理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。\n\n\n### 9.6 template\n\ntemplate最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。\n\n#### 9.6.1 封装C++的成员函数的调用\n\n#### 9.6.4 避免重复代码\n\n\n`大部分程序错误的根源:`\n> * 在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。\n\n没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。\n\n举个blit()例子\n\n#### 9.6.5 选择最佳的容器\n\n很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。\n\n对于一个容器到底是保存\n> * 对象指针\n> * 对象值\n\n> * 对于体积较大的对象，保存指针, 复制很快\n> * 对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用\n\n可以利用模板在编译期间由编译器自动进行；\n\n#### 9.6.5 延迟计算\n由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。\n\n#### 9.6.7 编译时的计算游戏（未完成）\n\n三个数排序\n+\n\n### 9.7 小结\n早犯一天错误，就可以早一天改正错误。\n\n# 13. 开发方法\n\n## 13.1 失败的经验\n> 1, 过多的工作压力压到一个人身上。\n> 2, 过分的弹性工作制\n> 3, 没完没了的变化和返工\n> 4, 没有及时的测试\n> 5, 项目的主导严重偏向了某一职位上\n\n`1, 过多的工作压力压到一个人身上。`\n迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。\n\n`2, 过分的弹性工作制`\n兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。\n\n`3, 没完没了的变化和返工`\n想法太多，什么都想加入进来，导致最后漏洞很多。\n\n`> 4, 没有及时的测试`\n很少有严格的测试，而是把错误积累。 \n\n`5, 项目的主导严重偏向了某一职位上`\n程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.\n\n## 13.2 成功的经验\n> 1, 引擎和实现的分离\n> 2, 结对编程（XP 极限编程）\n> 3, 随时方便地测试\n> 4, 尽早发现结构上的问题, 并尽早重构\n> 5, 其他\n\n`1, 引擎和实现的分离`\n早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。\n许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。\n和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。\n\n其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。\n\n`2, 结对编程`\n找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。\n\n潜在问题的代码，在XP极限编程中，被称做代码的**坏味道**。\n\n好处:\n> 1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。\n> 2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。\n> 3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。\n\n`3, 随时方便地测试`\n测试应该从开发者开始，从项目一开始就开始。\n\n`4, 尽早发现结构上的问题, 并尽早重构`\n\n`5, 其他`\n\n脚本和版本控制。\n软件开发的素养。\n\n\n# 14. 编程和游戏\n\n技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。\n而忽略了一些更重要的东西。\n\n## 14.1 操作\n\n任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。\n\n## 14.2 角色设定\n\n生动的角色，RPG，增加游戏气氛\n\n## 14.3 操作技术\n\n`3D和2D`\n> * 应该由游戏本身的需要决定。\n> * 3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。\n> * 2D技术怎样控制和管理不断膨胀的图片数量\n\n## 14.4 浅谈网络游戏\n\n`社会性`\n除了传统的游戏它自身的娱乐性之外，还存在一种社会性。\n因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。\n\n看似不是程序的事情，但非程序的策划很难去做：\n> * 大规模的数字采集和统计的工作\n> * 大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。\n\n`平衡性`\n> * 传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。\n> * 程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。\n\n## 14.5 小结\n\n一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。\n\n# 后记\n\n技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。\n\n# 致谢\n记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。\n","source":"_posts/trip-of-game-notes.md","raw":"---\ntitle: <<游戏之旅>>笔记\ndate: 2018-01-04 09:34:38\ntags: [读书, 游戏, C++]\n---\n\n最近读了云风大大的书, 感谢云风, 对我有所帮助。 \n选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14\n\n# 对我有所启发的points\n > * 写email的建议\n > * C和C++的关系\n > * C++的开发经验\n > * 学习C++阅读次序\n > * template的技巧\n > * **开发的成功和失败的经验**\n > * 游戏编程几个反思\n > * 后记中编程实践和思考方法 \n > * 致谢中云风父亲的背景以及教育方法\n\n\n\n\n----\n# 2. 算法\n\n## 2.1 程序 = 算法+数据结构\n计算机解决的问题，看成一个需要求解的函数，\n> * 算法：将输入转化为输出的方法。\n> * 数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。\n\n#### 2.1.1 算法\n时间和空间之间寻求平衡。\n> * 空间换时间的做法，非常广泛，即预处理\n> * 时间换空间，不容忽视，即使重复计算。\n\n依赖平台特性:\n> * 非并行计算机，不考虑用并行来提速。\n> * 空间允许随机访问，不是纸带机的顺序。\n\n#### 2.1.2 数据结构\n简单定义：对数据的组织方法，还有对数据组织方式的处理方法。\nC++已经提供了常见的数据结构，为什么还要学？\n> * 学蕴含思想\n> * 根据实际情况对数据结构进行改造，更高效。\n\n##### 1. 线性表\n\n\t有限逻辑上的有序数列，有确定的前驱和后驱；\n\t分为成：数组和链表;\n\t\n\t数组:\n\t\n##### 2. 堆栈、队列和串\n\n##### 3. 树、二叉树及其他\n\n**树：**\n有层次的数据集的组织方式。\n\nGUI界面，通常用树来组织；\n游戏中的对象管理，用树来解决管理上的层次问题。\n\n**二叉树:**\n严格来说不算是树。\n表达式计算，数据压缩，排序查找方面有很多用途。\n\n**四叉树、八叉树：**\n空间状态划分，\n> * 四叉树：平面\n> * 八叉树: 空间\n\n空间: 场景空间+ 调色盘算法等（向量空间）\n\n**图：**\n节点没有父子关系，纯粹的点和边的集合。\n节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。\n节点和节点之间可以有方向，也可以无方向。\n\n**图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。**\n\n**映射表**\nstd::map,STL最复杂的容器。\n\n\n**禁忌思想，**\n> * 模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。\n>* 蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。\n\n算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。\n\n#### 2.4 优化\n> * 数学方法的改进\n> * 预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间\n> * 简化算法求得近似来取代精确解（或最有解）\n> * 改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。\n\n碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。\n\n<<C语言程序设计400例>>\n\n\n**C**\nC语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。\nC语言函数，让问题分而治理它。\n全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。\n最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。\n\n**BASIC**\n\n### 比较解释语言和C语言的不同\n\n解释型语言：\n> 1. 每运行一次，解释器就读一次，对符号进行翻译\n> 2. 中间状态以严格规定保存起来，在后面的语句需要时被重新加载\nC语言\n> 1. 在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。\n> 2. 编译器对代码同类向合并，最后的机器码会很简洁。\n\n逻辑学教育，BASIC，适合理解编程。\n\n# 3. 编程语言\n## 3.3 C++\n### C++的不同理解\n\n第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。\n\n### C对于C++的优势\n简洁，而非高效；适合做小内存的嵌入式系统开发。\n\n### 但大多数游戏平台，C++比C更适合\n\n## 3.4 汇编语言\n\n合适场合使用汇编，能让程序跑得更快。\n了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，\n在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。\n\n\n# 4. 前Windows时代\n## 4.3 保护模式下的开发工具\n\n个人主页建立之初，我罗列出了个人兴趣 ：...很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。\n>* 翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友\n>* 写关于游戏编程技术方面的小文，各处转载\n\n>* 利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。\n\n学习新的技术，翻译一本相关的英语著作可以算是捷径。\n> * 比囫囵吞枣的读一遍英文原文要有效的多。\n> * 因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。\n> * 即使对此有所了解，翻译后也能更上一层楼。\n> * 英语水平也会提高。\n\n## 4.4 闲话allegro\n\n### 4.4.4 几何图形和3D\n图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。\n\n3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。\n相关的:\n> * 透视映射\n> * 矩阵，三维空间中变换的工具, 自带一套矩阵运算。\n> * 实现了一套定点数的运算该改善游戏中需要的数学运算速度。\n\n**1,定点数**\n巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。\n\n浮点数：计算机用一种纯小数加指数的形式表示实数。\n定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。\n\n高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。\n\n精读在1/6*10^4, 十进制小数点后四位的精度。\n\n定点数的一些计算技巧和优势：\n> * 原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。\n> * 角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。\n\n## 4.5 \n \n云风关于写email的建议：\n> * 回复收到的每封email, 即使没空写， 也让对方知道自己已读。\n> * 使用纯文本，发送过大附件前请求\n> * 合适的标题，能概括内容；偏题时，修改标题。\n> * 删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。\n> * 合理分段，表达自己意见，别赞同两字多写一点。\n> * 发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确\n> * 不要随意公开转载私人信件，即使转载也注明出处。\n \n# 8. 引擎中的优化\n\n“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。\n\n只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。\n\t\n\n# 9. C和C++\n\n## 9.1 从C到C++\n1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。\n\n2, C对大块的数据，使用数据指针来表达。\n\n3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据\n\n4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。\n\n5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。\n\n`困难性的说明`，\n高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往**只能针对特定的类型**。\n\n`C++面向对象的说明`\n> * 既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。\n> * 将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。\n\n## 9.2 C vs C++， 效率至上\n\n`C++中混有C语言的好处:`\n> 1, 更广泛的移植性\n> 2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖\n> 3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事\n> 4, C简洁, 编译速度快\n\n## 9.3 优雅的C++\n\n将C细化，又不增加额外的开销;\n不对程序员有过多限制。\n\n### 9.3.1 宏\n\n`宏的作用`\n> 1, 定义常数\n> 2, 代码生成\n> 3, 内联代码\n> 4, 对编译流程作出选择\n\n1, 定义常数\n\n```c\n#define PI 3.1415926f;\n```\n\n```cpp\nconst float PI;\n```\n\nC++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。\n\n经典的如：\n```c\n#define min(a, b) ((a<b)?(a):(b))\n```\n\n\n```cpp\ntemplate <typename T> const T& min(const T &a, const T &b) {\n  return a<b ? a:b;\n}\n```\n\n### 9.3.2 const修饰以及类型转换\n\n\n#### const修饰\nconst chat* 而不是 C 的 char*\n\n将函数参数写成const;\n成员变量修饰成const, 只有在构造的时构建他们;\n为成员函数增加一个const, 表达这个函数不会修改类的成员变量\n\n\n#### 类型转换\n\nC中几乎任何类型都可以任意转换，缘于C汇编的根。\nC++用static_cast 以模板的语法表达看起来可以互相转换的类型互换\n\nconst和const之间的转换，只能通过const_cast转换。\n\n严格描述每个对象的const性质，可以帮助在编译期发生错误减少。\n\n### 9.3.3 隐藏实现\n好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。\n\n作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。\n\n### 9.3.4 引用而非指针\n\n指针是导致资源被遗忘释放的罪魁祸首。\n> * 当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。\n\n引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。\n\nC++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。\n\n### 9.3.5 命名空间\n引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。\n\n## 9.4 C++的误区\n\n自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。\n\n举例:\n> * 能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。\n\n解释：\n> * 没有完美的程序，也没有完美的原则。\n> * 不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。\n\n### 9.4.1 类层次过细\n会造成间接调用引起的损耗。\n\n### 9.4.2 滥用操作符重载\n\n为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。\n如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。\n\n### 9.4.3 滥用标准容器\n用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。\n\n`std::map可以这样子做，`\n如果只是为了创建一张key-value的对应表可供查询，完全可以用\nkey-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。\n\n\n### 9.4.5 滥用多重继承\n\n会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。\n\n### 9.4.6 忽视C++高级特性的复杂度\n\n如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。\n\n### 9.4.7 学习C++\n\n我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。\n\n因此，需要\n> 1，学\n> 2, 用\n> 3, 思考\n> 2, 回到1\n\n如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。\n\n推荐一个阅读次序:\n> 1, 先学会C，只是也是C++子集的部分。\n> 2, <<C++编程思想>>\n> 3, <<C++ Primer>> 和 <<C++ Programing Language>>\n> 4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。\n> 5, <<C++的发展和演化>>，深入了解C++设计的根源以及C++编译器实现方法入手. \n> 6, <<深度探索C++物件模型>>对追求高效的C++程序员尤为受用。\n\n进阶学习: 需要一定的开发经验才能阅读\n\n> * <<Effective C++>>, <<More Effective C++>>, <<C++沉思录>>\n> * 泛型编程<<STL 源码剖析>>，有点难，但是花上一定的时间一定有收获。\n> * <<C++设计新思维------泛型编程与设计模式之应用>>template使用自信，对泛型编程感觉良好，\n> * <<C++标准程序库>>想更精通标准库，C++程序员案头必备的参考手册。\n> * <<Effective STL 中文版>>， 与前面的effcive系列一样\n\n\n### 9.5.3 再论动态内存分配\n\n//...\n\n理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。\n\n\n### 9.6 template\n\ntemplate最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。\n\n#### 9.6.1 封装C++的成员函数的调用\n\n#### 9.6.4 避免重复代码\n\n\n`大部分程序错误的根源:`\n> * 在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。\n\n没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。\n\n举个blit()例子\n\n#### 9.6.5 选择最佳的容器\n\n很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。\n\n对于一个容器到底是保存\n> * 对象指针\n> * 对象值\n\n> * 对于体积较大的对象，保存指针, 复制很快\n> * 对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用\n\n可以利用模板在编译期间由编译器自动进行；\n\n#### 9.6.5 延迟计算\n由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。\n\n#### 9.6.7 编译时的计算游戏（未完成）\n\n三个数排序\n+\n\n### 9.7 小结\n早犯一天错误，就可以早一天改正错误。\n\n# 13. 开发方法\n\n## 13.1 失败的经验\n> 1, 过多的工作压力压到一个人身上。\n> 2, 过分的弹性工作制\n> 3, 没完没了的变化和返工\n> 4, 没有及时的测试\n> 5, 项目的主导严重偏向了某一职位上\n\n`1, 过多的工作压力压到一个人身上。`\n迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。\n\n`2, 过分的弹性工作制`\n兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。\n\n`3, 没完没了的变化和返工`\n想法太多，什么都想加入进来，导致最后漏洞很多。\n\n`> 4, 没有及时的测试`\n很少有严格的测试，而是把错误积累。 \n\n`5, 项目的主导严重偏向了某一职位上`\n程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.\n\n## 13.2 成功的经验\n> 1, 引擎和实现的分离\n> 2, 结对编程（XP 极限编程）\n> 3, 随时方便地测试\n> 4, 尽早发现结构上的问题, 并尽早重构\n> 5, 其他\n\n`1, 引擎和实现的分离`\n早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。\n许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。\n和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。\n\n其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。\n\n`2, 结对编程`\n找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。\n\n潜在问题的代码，在XP极限编程中，被称做代码的**坏味道**。\n\n好处:\n> 1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。\n> 2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。\n> 3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。\n\n`3, 随时方便地测试`\n测试应该从开发者开始，从项目一开始就开始。\n\n`4, 尽早发现结构上的问题, 并尽早重构`\n\n`5, 其他`\n\n脚本和版本控制。\n软件开发的素养。\n\n\n# 14. 编程和游戏\n\n技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。\n而忽略了一些更重要的东西。\n\n## 14.1 操作\n\n任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。\n\n## 14.2 角色设定\n\n生动的角色，RPG，增加游戏气氛\n\n## 14.3 操作技术\n\n`3D和2D`\n> * 应该由游戏本身的需要决定。\n> * 3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。\n> * 2D技术怎样控制和管理不断膨胀的图片数量\n\n## 14.4 浅谈网络游戏\n\n`社会性`\n除了传统的游戏它自身的娱乐性之外，还存在一种社会性。\n因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。\n\n看似不是程序的事情，但非程序的策划很难去做：\n> * 大规模的数字采集和统计的工作\n> * 大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。\n\n`平衡性`\n> * 传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。\n> * 程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。\n\n## 14.5 小结\n\n一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。\n\n# 后记\n\n技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。\n\n# 致谢\n记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。\n","slug":"trip-of-game-notes","published":1,"updated":"2018-06-19T16:15:03.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyjt000wk8mf4chwvzo9","content":"<p>最近读了云风大大的书, 感谢云风, 对我有所帮助。<br>选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14</p>\n<h1 id=\"对我有所启发的points\"><a href=\"#对我有所启发的points\" class=\"headerlink\" title=\"对我有所启发的points\"></a>对我有所启发的points</h1><blockquote>\n<ul>\n<li>写email的建议</li>\n<li>C和C++的关系</li>\n<li>C++的开发经验</li>\n<li>学习C++阅读次序</li>\n<li>template的技巧</li>\n<li><strong>开发的成功和失败的经验</strong></li>\n<li>游戏编程几个反思</li>\n<li>后记中编程实践和思考方法 </li>\n<li>致谢中云风父亲的背景以及教育方法</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2. 算法\"></a>2. 算法</h1><h2 id=\"2-1-程序-算法-数据结构\"><a href=\"#2-1-程序-算法-数据结构\" class=\"headerlink\" title=\"2.1 程序 = 算法+数据结构\"></a>2.1 程序 = 算法+数据结构</h2><p>计算机解决的问题，看成一个需要求解的函数，</p>\n<blockquote>\n<ul>\n<li>算法：将输入转化为输出的方法。</li>\n<li>数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。</li>\n</ul>\n</blockquote>\n<h4 id=\"2-1-1-算法\"><a href=\"#2-1-1-算法\" class=\"headerlink\" title=\"2.1.1 算法\"></a>2.1.1 算法</h4><p>时间和空间之间寻求平衡。</p>\n<blockquote>\n<ul>\n<li>空间换时间的做法，非常广泛，即预处理</li>\n<li>时间换空间，不容忽视，即使重复计算。</li>\n</ul>\n</blockquote>\n<p>依赖平台特性:</p>\n<blockquote>\n<ul>\n<li>非并行计算机，不考虑用并行来提速。</li>\n<li>空间允许随机访问，不是纸带机的顺序。</li>\n</ul>\n</blockquote>\n<h4 id=\"2-1-2-数据结构\"><a href=\"#2-1-2-数据结构\" class=\"headerlink\" title=\"2.1.2 数据结构\"></a>2.1.2 数据结构</h4><p>简单定义：对数据的组织方法，还有对数据组织方式的处理方法。<br>C++已经提供了常见的数据结构，为什么还要学？</p>\n<blockquote>\n<ul>\n<li>学蕴含思想</li>\n<li>根据实际情况对数据结构进行改造，更高效。</li>\n</ul>\n</blockquote>\n<h5 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1. 线性表\"></a>1. 线性表</h5><pre><code>有限逻辑上的有序数列，有确定的前驱和后驱；\n分为成：数组和链表;\n\n数组:\n</code></pre><h5 id=\"2-堆栈、队列和串\"><a href=\"#2-堆栈、队列和串\" class=\"headerlink\" title=\"2. 堆栈、队列和串\"></a>2. 堆栈、队列和串</h5><h5 id=\"3-树、二叉树及其他\"><a href=\"#3-树、二叉树及其他\" class=\"headerlink\" title=\"3. 树、二叉树及其他\"></a>3. 树、二叉树及其他</h5><p><strong>树：</strong><br>有层次的数据集的组织方式。</p>\n<p>GUI界面，通常用树来组织；<br>游戏中的对象管理，用树来解决管理上的层次问题。</p>\n<p><strong>二叉树:</strong><br>严格来说不算是树。<br>表达式计算，数据压缩，排序查找方面有很多用途。</p>\n<p><strong>四叉树、八叉树：</strong><br>空间状态划分，</p>\n<blockquote>\n<ul>\n<li>四叉树：平面</li>\n<li>八叉树: 空间</li>\n</ul>\n</blockquote>\n<p>空间: 场景空间+ 调色盘算法等（向量空间）</p>\n<p><strong>图：</strong><br>节点没有父子关系，纯粹的点和边的集合。<br>节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。<br>节点和节点之间可以有方向，也可以无方向。</p>\n<p><strong>图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。</strong></p>\n<p><strong>映射表</strong><br>std::map,STL最复杂的容器。</p>\n<p><strong>禁忌思想，</strong></p>\n<blockquote>\n<ul>\n<li>模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。</li>\n<li>蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。</li>\n</ul>\n</blockquote>\n<p>算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。</p>\n<h4 id=\"2-4-优化\"><a href=\"#2-4-优化\" class=\"headerlink\" title=\"2.4 优化\"></a>2.4 优化</h4><blockquote>\n<ul>\n<li>数学方法的改进</li>\n<li>预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间</li>\n<li>简化算法求得近似来取代精确解（或最有解）</li>\n<li>改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。</li>\n</ul>\n</blockquote>\n<p>碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。</p>\n<p>&lt;<c语言程序设计400例>&gt;</c语言程序设计400例></p>\n<p><strong>C</strong><br>C语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。<br>C语言函数，让问题分而治理它。<br>全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。<br>最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。</p>\n<p><strong>BASIC</strong></p>\n<h3 id=\"比较解释语言和C语言的不同\"><a href=\"#比较解释语言和C语言的不同\" class=\"headerlink\" title=\"比较解释语言和C语言的不同\"></a>比较解释语言和C语言的不同</h3><p>解释型语言：</p>\n<blockquote>\n<ol>\n<li>每运行一次，解释器就读一次，对符号进行翻译</li>\n<li>中间状态以严格规定保存起来，在后面的语句需要时被重新加载<br>C语言</li>\n<li>在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。</li>\n<li>编译器对代码同类向合并，最后的机器码会很简洁。</li>\n</ol>\n</blockquote>\n<p>逻辑学教育，BASIC，适合理解编程。</p>\n<h1 id=\"3-编程语言\"><a href=\"#3-编程语言\" class=\"headerlink\" title=\"3. 编程语言\"></a>3. 编程语言</h1><h2 id=\"3-3-C\"><a href=\"#3-3-C\" class=\"headerlink\" title=\"3.3 C++\"></a>3.3 C++</h2><h3 id=\"C-的不同理解\"><a href=\"#C-的不同理解\" class=\"headerlink\" title=\"C++的不同理解\"></a>C++的不同理解</h3><p>第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。</p>\n<h3 id=\"C对于C-的优势\"><a href=\"#C对于C-的优势\" class=\"headerlink\" title=\"C对于C++的优势\"></a>C对于C++的优势</h3><p>简洁，而非高效；适合做小内存的嵌入式系统开发。</p>\n<h3 id=\"但大多数游戏平台，C-比C更适合\"><a href=\"#但大多数游戏平台，C-比C更适合\" class=\"headerlink\" title=\"但大多数游戏平台，C++比C更适合\"></a>但大多数游戏平台，C++比C更适合</h3><h2 id=\"3-4-汇编语言\"><a href=\"#3-4-汇编语言\" class=\"headerlink\" title=\"3.4 汇编语言\"></a>3.4 汇编语言</h2><p>合适场合使用汇编，能让程序跑得更快。<br>了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，<br>在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。</p>\n<h1 id=\"4-前Windows时代\"><a href=\"#4-前Windows时代\" class=\"headerlink\" title=\"4. 前Windows时代\"></a>4. 前Windows时代</h1><h2 id=\"4-3-保护模式下的开发工具\"><a href=\"#4-3-保护模式下的开发工具\" class=\"headerlink\" title=\"4.3 保护模式下的开发工具\"></a>4.3 保护模式下的开发工具</h2><p>个人主页建立之初，我罗列出了个人兴趣 ：…很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。</p>\n<blockquote>\n<ul>\n<li>翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友</li>\n<li><p>写关于游戏编程技术方面的小文，各处转载</p>\n</li>\n<li><p>利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。</p>\n</li>\n</ul>\n</blockquote>\n<p>学习新的技术，翻译一本相关的英语著作可以算是捷径。</p>\n<blockquote>\n<ul>\n<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>\n<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>\n<li>即使对此有所了解，翻译后也能更上一层楼。</li>\n<li>英语水平也会提高。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-4-闲话allegro\"><a href=\"#4-4-闲话allegro\" class=\"headerlink\" title=\"4.4 闲话allegro\"></a>4.4 闲话allegro</h2><h3 id=\"4-4-4-几何图形和3D\"><a href=\"#4-4-4-几何图形和3D\" class=\"headerlink\" title=\"4.4.4 几何图形和3D\"></a>4.4.4 几何图形和3D</h3><p>图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。</p>\n<p>3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。<br>相关的:</p>\n<blockquote>\n<ul>\n<li>透视映射</li>\n<li>矩阵，三维空间中变换的工具, 自带一套矩阵运算。</li>\n<li>实现了一套定点数的运算该改善游戏中需要的数学运算速度。</li>\n</ul>\n</blockquote>\n<p><strong>1,定点数</strong><br>巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。</p>\n<p>浮点数：计算机用一种纯小数加指数的形式表示实数。<br>定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。</p>\n<p>高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。</p>\n<p>精读在1/6*10^4, 十进制小数点后四位的精度。</p>\n<p>定点数的一些计算技巧和优势：</p>\n<blockquote>\n<ul>\n<li>原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。</li>\n<li>角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-5\"><a href=\"#4-5\" class=\"headerlink\" title=\"4.5\"></a>4.5</h2><p>云风关于写email的建议：</p>\n<blockquote>\n<ul>\n<li>回复收到的每封email, 即使没空写， 也让对方知道自己已读。</li>\n<li>使用纯文本，发送过大附件前请求</li>\n<li>合适的标题，能概括内容；偏题时，修改标题。</li>\n<li>删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。</li>\n<li>合理分段，表达自己意见，别赞同两字多写一点。</li>\n<li>发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确</li>\n<li>不要随意公开转载私人信件，即使转载也注明出处。</li>\n</ul>\n</blockquote>\n<h1 id=\"8-引擎中的优化\"><a href=\"#8-引擎中的优化\" class=\"headerlink\" title=\"8. 引擎中的优化\"></a>8. 引擎中的优化</h1><p>“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。</p>\n<p>只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。</p>\n<h1 id=\"9-C和C\"><a href=\"#9-C和C\" class=\"headerlink\" title=\"9. C和C++\"></a>9. C和C++</h1><h2 id=\"9-1-从C到C\"><a href=\"#9-1-从C到C\" class=\"headerlink\" title=\"9.1 从C到C++\"></a>9.1 从C到C++</h2><p>1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。</p>\n<p>2, C对大块的数据，使用数据指针来表达。</p>\n<p>3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据</p>\n<p>4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。</p>\n<p>5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。</p>\n<p><code>困难性的说明</code>，<br>高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往<strong>只能针对特定的类型</strong>。</p>\n<p><code>C++面向对象的说明</code></p>\n<blockquote>\n<ul>\n<li>既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。</li>\n<li>将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。</li>\n</ul>\n</blockquote>\n<h2 id=\"9-2-C-vs-C-，-效率至上\"><a href=\"#9-2-C-vs-C-，-效率至上\" class=\"headerlink\" title=\"9.2 C vs C++， 效率至上\"></a>9.2 C vs C++， 效率至上</h2><p><code>C++中混有C语言的好处:</code></p>\n<blockquote>\n<p>1, 更广泛的移植性<br>2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖<br>3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事<br>4, C简洁, 编译速度快</p>\n</blockquote>\n<h2 id=\"9-3-优雅的C\"><a href=\"#9-3-优雅的C\" class=\"headerlink\" title=\"9.3 优雅的C++\"></a>9.3 优雅的C++</h2><p>将C细化，又不增加额外的开销;<br>不对程序员有过多限制。</p>\n<h3 id=\"9-3-1-宏\"><a href=\"#9-3-1-宏\" class=\"headerlink\" title=\"9.3.1 宏\"></a>9.3.1 宏</h3><p><code>宏的作用</code></p>\n<blockquote>\n<p>1, 定义常数<br>2, 代码生成<br>3, 内联代码<br>4, 对编译流程作出选择</p>\n</blockquote>\n<p>1, 定义常数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.1415926f;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> PI;</span><br></pre></td></tr></table></figure>\n<p>C++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。</p>\n<p>经典的如：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(a, b) ((a&lt;b)?(a):(b))</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;a, <span class=\"keyword\">const</span> T &amp;b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a&lt;b ? a:b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-3-2-const修饰以及类型转换\"><a href=\"#9-3-2-const修饰以及类型转换\" class=\"headerlink\" title=\"9.3.2 const修饰以及类型转换\"></a>9.3.2 const修饰以及类型转换</h3><h4 id=\"const修饰\"><a href=\"#const修饰\" class=\"headerlink\" title=\"const修饰\"></a>const修饰</h4><p>const chat<em> 而不是 C 的 char</em></p>\n<p>将函数参数写成const;<br>成员变量修饰成const, 只有在构造的时构建他们;<br>为成员函数增加一个const, 表达这个函数不会修改类的成员变量</p>\n<h4 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h4><p>C中几乎任何类型都可以任意转换，缘于C汇编的根。<br>C++用static_cast 以模板的语法表达看起来可以互相转换的类型互换</p>\n<p>const和const之间的转换，只能通过const_cast转换。</p>\n<p>严格描述每个对象的const性质，可以帮助在编译期发生错误减少。</p>\n<h3 id=\"9-3-3-隐藏实现\"><a href=\"#9-3-3-隐藏实现\" class=\"headerlink\" title=\"9.3.3 隐藏实现\"></a>9.3.3 隐藏实现</h3><p>好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。</p>\n<p>作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。</p>\n<h3 id=\"9-3-4-引用而非指针\"><a href=\"#9-3-4-引用而非指针\" class=\"headerlink\" title=\"9.3.4 引用而非指针\"></a>9.3.4 引用而非指针</h3><p>指针是导致资源被遗忘释放的罪魁祸首。</p>\n<blockquote>\n<ul>\n<li>当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。</li>\n</ul>\n</blockquote>\n<p>引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。</p>\n<p>C++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。</p>\n<h3 id=\"9-3-5-命名空间\"><a href=\"#9-3-5-命名空间\" class=\"headerlink\" title=\"9.3.5 命名空间\"></a>9.3.5 命名空间</h3><p>引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。</p>\n<h2 id=\"9-4-C-的误区\"><a href=\"#9-4-C-的误区\" class=\"headerlink\" title=\"9.4 C++的误区\"></a>9.4 C++的误区</h2><p>自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。</p>\n<p>举例:</p>\n<blockquote>\n<ul>\n<li>能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。</li>\n</ul>\n</blockquote>\n<p>解释：</p>\n<blockquote>\n<ul>\n<li>没有完美的程序，也没有完美的原则。</li>\n<li>不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。</li>\n</ul>\n</blockquote>\n<h3 id=\"9-4-1-类层次过细\"><a href=\"#9-4-1-类层次过细\" class=\"headerlink\" title=\"9.4.1 类层次过细\"></a>9.4.1 类层次过细</h3><p>会造成间接调用引起的损耗。</p>\n<h3 id=\"9-4-2-滥用操作符重载\"><a href=\"#9-4-2-滥用操作符重载\" class=\"headerlink\" title=\"9.4.2 滥用操作符重载\"></a>9.4.2 滥用操作符重载</h3><p>为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。<br>如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。</p>\n<h3 id=\"9-4-3-滥用标准容器\"><a href=\"#9-4-3-滥用标准容器\" class=\"headerlink\" title=\"9.4.3 滥用标准容器\"></a>9.4.3 滥用标准容器</h3><p>用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。</p>\n<p><code>std::map可以这样子做，</code><br>如果只是为了创建一张key-value的对应表可供查询，完全可以用<br>key-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。</p>\n<h3 id=\"9-4-5-滥用多重继承\"><a href=\"#9-4-5-滥用多重继承\" class=\"headerlink\" title=\"9.4.5 滥用多重继承\"></a>9.4.5 滥用多重继承</h3><p>会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。</p>\n<h3 id=\"9-4-6-忽视C-高级特性的复杂度\"><a href=\"#9-4-6-忽视C-高级特性的复杂度\" class=\"headerlink\" title=\"9.4.6 忽视C++高级特性的复杂度\"></a>9.4.6 忽视C++高级特性的复杂度</h3><p>如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。</p>\n<h3 id=\"9-4-7-学习C\"><a href=\"#9-4-7-学习C\" class=\"headerlink\" title=\"9.4.7 学习C++\"></a>9.4.7 学习C++</h3><p>我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。</p>\n<p>因此，需要</p>\n<blockquote>\n<p>1，学<br>2, 用<br>3, 思考<br>2, 回到1</p>\n</blockquote>\n<p>如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。</p>\n<p>推荐一个阅读次序:</p>\n<blockquote>\n<p>1, 先学会C，只是也是C++子集的部分。<br>2, &lt;<c++编程思想>&gt;<br>3, &lt;<c++ primer=\"\">&gt; 和 &lt;<c++ programing=\"\" language=\"\">&gt;<br>4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。<br>5, &lt;<c++的发展和演化>&gt;，深入了解C++设计的根源以及C++编译器实现方法入手.<br>6, &lt;&lt;深度探索C++物件模型&gt;&gt;对追求高效的C++程序员尤为受用。</c++的发展和演化></c++></c++></c++编程思想></p>\n</blockquote>\n<p>进阶学习: 需要一定的开发经验才能阅读</p>\n<blockquote>\n<ul>\n<li>&lt;<effective c++=\"\">&gt;, &lt;<more effective=\"\" c++=\"\">&gt;, &lt;<c++沉思录>&gt;</c++沉思录></more></effective></li>\n<li>泛型编程&lt;<stl 源码剖析=\"\">&gt;，有点难，但是花上一定的时间一定有收获。</stl></li>\n<li>&lt;<c++设计新思维------泛型编程与设计模式之应用>&gt;template使用自信，对泛型编程感觉良好，</c++设计新思维------泛型编程与设计模式之应用></li>\n<li>&lt;<c++标准程序库>&gt;想更精通标准库，C++程序员案头必备的参考手册。</c++标准程序库></li>\n<li>&lt;<effective stl=\"\" 中文版=\"\">&gt;， 与前面的effcive系列一样</effective></li>\n</ul>\n</blockquote>\n<h3 id=\"9-5-3-再论动态内存分配\"><a href=\"#9-5-3-再论动态内存分配\" class=\"headerlink\" title=\"9.5.3 再论动态内存分配\"></a>9.5.3 再论动态内存分配</h3><p>//…</p>\n<p>理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。</p>\n<h3 id=\"9-6-template\"><a href=\"#9-6-template\" class=\"headerlink\" title=\"9.6 template\"></a>9.6 template</h3><p>template最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。</p>\n<h4 id=\"9-6-1-封装C-的成员函数的调用\"><a href=\"#9-6-1-封装C-的成员函数的调用\" class=\"headerlink\" title=\"9.6.1 封装C++的成员函数的调用\"></a>9.6.1 封装C++的成员函数的调用</h4><h4 id=\"9-6-4-避免重复代码\"><a href=\"#9-6-4-避免重复代码\" class=\"headerlink\" title=\"9.6.4 避免重复代码\"></a>9.6.4 避免重复代码</h4><p><code>大部分程序错误的根源:</code></p>\n<blockquote>\n<ul>\n<li>在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。</li>\n</ul>\n</blockquote>\n<p>没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。</p>\n<p>举个blit()例子</p>\n<h4 id=\"9-6-5-选择最佳的容器\"><a href=\"#9-6-5-选择最佳的容器\" class=\"headerlink\" title=\"9.6.5 选择最佳的容器\"></a>9.6.5 选择最佳的容器</h4><p>很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。</p>\n<p>对于一个容器到底是保存</p>\n<blockquote>\n<ul>\n<li>对象指针</li>\n<li><p>对象值</p>\n</li>\n<li><p>对于体积较大的对象，保存指针, 复制很快</p>\n</li>\n<li>对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用</li>\n</ul>\n</blockquote>\n<p>可以利用模板在编译期间由编译器自动进行；</p>\n<h4 id=\"9-6-5-延迟计算\"><a href=\"#9-6-5-延迟计算\" class=\"headerlink\" title=\"9.6.5 延迟计算\"></a>9.6.5 延迟计算</h4><p>由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。</p>\n<h4 id=\"9-6-7-编译时的计算游戏（未完成）\"><a href=\"#9-6-7-编译时的计算游戏（未完成）\" class=\"headerlink\" title=\"9.6.7 编译时的计算游戏（未完成）\"></a>9.6.7 编译时的计算游戏（未完成）</h4><p>三个数排序<br>+</p>\n<h3 id=\"9-7-小结\"><a href=\"#9-7-小结\" class=\"headerlink\" title=\"9.7 小结\"></a>9.7 小结</h3><p>早犯一天错误，就可以早一天改正错误。</p>\n<h1 id=\"13-开发方法\"><a href=\"#13-开发方法\" class=\"headerlink\" title=\"13. 开发方法\"></a>13. 开发方法</h1><h2 id=\"13-1-失败的经验\"><a href=\"#13-1-失败的经验\" class=\"headerlink\" title=\"13.1 失败的经验\"></a>13.1 失败的经验</h2><blockquote>\n<p>1, 过多的工作压力压到一个人身上。<br>2, 过分的弹性工作制<br>3, 没完没了的变化和返工<br>4, 没有及时的测试<br>5, 项目的主导严重偏向了某一职位上</p>\n</blockquote>\n<p><code>1, 过多的工作压力压到一个人身上。</code><br>迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。</p>\n<p><code>2, 过分的弹性工作制</code><br>兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。</p>\n<p><code>3, 没完没了的变化和返工</code><br>想法太多，什么都想加入进来，导致最后漏洞很多。</p>\n<p><code>&gt; 4, 没有及时的测试</code><br>很少有严格的测试，而是把错误积累。 </p>\n<p><code>5, 项目的主导严重偏向了某一职位上</code><br>程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.</p>\n<h2 id=\"13-2-成功的经验\"><a href=\"#13-2-成功的经验\" class=\"headerlink\" title=\"13.2 成功的经验\"></a>13.2 成功的经验</h2><blockquote>\n<p>1, 引擎和实现的分离<br>2, 结对编程（XP 极限编程）<br>3, 随时方便地测试<br>4, 尽早发现结构上的问题, 并尽早重构<br>5, 其他</p>\n</blockquote>\n<p><code>1, 引擎和实现的分离</code><br>早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。<br>许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。<br>和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。</p>\n<p>其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。</p>\n<p><code>2, 结对编程</code><br>找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。</p>\n<p>潜在问题的代码，在XP极限编程中，被称做代码的<strong>坏味道</strong>。</p>\n<p>好处:</p>\n<blockquote>\n<p>1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。<br>2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。<br>3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。</p>\n</blockquote>\n<p><code>3, 随时方便地测试</code><br>测试应该从开发者开始，从项目一开始就开始。</p>\n<p><code>4, 尽早发现结构上的问题, 并尽早重构</code></p>\n<p><code>5, 其他</code></p>\n<p>脚本和版本控制。<br>软件开发的素养。</p>\n<h1 id=\"14-编程和游戏\"><a href=\"#14-编程和游戏\" class=\"headerlink\" title=\"14. 编程和游戏\"></a>14. 编程和游戏</h1><p>技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。<br>而忽略了一些更重要的东西。</p>\n<h2 id=\"14-1-操作\"><a href=\"#14-1-操作\" class=\"headerlink\" title=\"14.1 操作\"></a>14.1 操作</h2><p>任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。</p>\n<h2 id=\"14-2-角色设定\"><a href=\"#14-2-角色设定\" class=\"headerlink\" title=\"14.2 角色设定\"></a>14.2 角色设定</h2><p>生动的角色，RPG，增加游戏气氛</p>\n<h2 id=\"14-3-操作技术\"><a href=\"#14-3-操作技术\" class=\"headerlink\" title=\"14.3 操作技术\"></a>14.3 操作技术</h2><p><code>3D和2D</code></p>\n<blockquote>\n<ul>\n<li>应该由游戏本身的需要决定。</li>\n<li>3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。</li>\n<li>2D技术怎样控制和管理不断膨胀的图片数量</li>\n</ul>\n</blockquote>\n<h2 id=\"14-4-浅谈网络游戏\"><a href=\"#14-4-浅谈网络游戏\" class=\"headerlink\" title=\"14.4 浅谈网络游戏\"></a>14.4 浅谈网络游戏</h2><p><code>社会性</code><br>除了传统的游戏它自身的娱乐性之外，还存在一种社会性。<br>因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。</p>\n<p>看似不是程序的事情，但非程序的策划很难去做：</p>\n<blockquote>\n<ul>\n<li>大规模的数字采集和统计的工作</li>\n<li>大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。</li>\n</ul>\n</blockquote>\n<p><code>平衡性</code></p>\n<blockquote>\n<ul>\n<li>传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。</li>\n<li>程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。</li>\n</ul>\n</blockquote>\n<h2 id=\"14-5-小结\"><a href=\"#14-5-小结\" class=\"headerlink\" title=\"14.5 小结\"></a>14.5 小结</h2><p>一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。</p>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近读了云风大大的书, 感谢云风, 对我有所帮助。<br>选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14</p>\n<h1 id=\"对我有所启发的points\"><a href=\"#对我有所启发的points\" class=\"headerlink\" title=\"对我有所启发的points\"></a>对我有所启发的points</h1><blockquote>\n<ul>\n<li>写email的建议</li>\n<li>C和C++的关系</li>\n<li>C++的开发经验</li>\n<li>学习C++阅读次序</li>\n<li>template的技巧</li>\n<li><strong>开发的成功和失败的经验</strong></li>\n<li>游戏编程几个反思</li>\n<li>后记中编程实践和思考方法 </li>\n<li>致谢中云风父亲的背景以及教育方法</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2. 算法\"></a>2. 算法</h1><h2 id=\"2-1-程序-算法-数据结构\"><a href=\"#2-1-程序-算法-数据结构\" class=\"headerlink\" title=\"2.1 程序 = 算法+数据结构\"></a>2.1 程序 = 算法+数据结构</h2><p>计算机解决的问题，看成一个需要求解的函数，</p>\n<blockquote>\n<ul>\n<li>算法：将输入转化为输出的方法。</li>\n<li>数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。</li>\n</ul>\n</blockquote>\n<h4 id=\"2-1-1-算法\"><a href=\"#2-1-1-算法\" class=\"headerlink\" title=\"2.1.1 算法\"></a>2.1.1 算法</h4><p>时间和空间之间寻求平衡。</p>\n<blockquote>\n<ul>\n<li>空间换时间的做法，非常广泛，即预处理</li>\n<li>时间换空间，不容忽视，即使重复计算。</li>\n</ul>\n</blockquote>\n<p>依赖平台特性:</p>\n<blockquote>\n<ul>\n<li>非并行计算机，不考虑用并行来提速。</li>\n<li>空间允许随机访问，不是纸带机的顺序。</li>\n</ul>\n</blockquote>\n<h4 id=\"2-1-2-数据结构\"><a href=\"#2-1-2-数据结构\" class=\"headerlink\" title=\"2.1.2 数据结构\"></a>2.1.2 数据结构</h4><p>简单定义：对数据的组织方法，还有对数据组织方式的处理方法。<br>C++已经提供了常见的数据结构，为什么还要学？</p>\n<blockquote>\n<ul>\n<li>学蕴含思想</li>\n<li>根据实际情况对数据结构进行改造，更高效。</li>\n</ul>\n</blockquote>\n<h5 id=\"1-线性表\"><a href=\"#1-线性表\" class=\"headerlink\" title=\"1. 线性表\"></a>1. 线性表</h5><pre><code>有限逻辑上的有序数列，有确定的前驱和后驱；\n分为成：数组和链表;\n\n数组:\n</code></pre><h5 id=\"2-堆栈、队列和串\"><a href=\"#2-堆栈、队列和串\" class=\"headerlink\" title=\"2. 堆栈、队列和串\"></a>2. 堆栈、队列和串</h5><h5 id=\"3-树、二叉树及其他\"><a href=\"#3-树、二叉树及其他\" class=\"headerlink\" title=\"3. 树、二叉树及其他\"></a>3. 树、二叉树及其他</h5><p><strong>树：</strong><br>有层次的数据集的组织方式。</p>\n<p>GUI界面，通常用树来组织；<br>游戏中的对象管理，用树来解决管理上的层次问题。</p>\n<p><strong>二叉树:</strong><br>严格来说不算是树。<br>表达式计算，数据压缩，排序查找方面有很多用途。</p>\n<p><strong>四叉树、八叉树：</strong><br>空间状态划分，</p>\n<blockquote>\n<ul>\n<li>四叉树：平面</li>\n<li>八叉树: 空间</li>\n</ul>\n</blockquote>\n<p>空间: 场景空间+ 调色盘算法等（向量空间）</p>\n<p><strong>图：</strong><br>节点没有父子关系，纯粹的点和边的集合。<br>节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。<br>节点和节点之间可以有方向，也可以无方向。</p>\n<p><strong>图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。</strong></p>\n<p><strong>映射表</strong><br>std::map,STL最复杂的容器。</p>\n<p><strong>禁忌思想，</strong></p>\n<blockquote>\n<ul>\n<li>模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。</li>\n<li>蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。</li>\n</ul>\n</blockquote>\n<p>算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。</p>\n<h4 id=\"2-4-优化\"><a href=\"#2-4-优化\" class=\"headerlink\" title=\"2.4 优化\"></a>2.4 优化</h4><blockquote>\n<ul>\n<li>数学方法的改进</li>\n<li>预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间</li>\n<li>简化算法求得近似来取代精确解（或最有解）</li>\n<li>改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。</li>\n</ul>\n</blockquote>\n<p>碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。</p>\n<p>&lt;<c语言程序设计400例>&gt;</c语言程序设计400例></p>\n<p><strong>C</strong><br>C语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。<br>C语言函数，让问题分而治理它。<br>全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。<br>最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。</p>\n<p><strong>BASIC</strong></p>\n<h3 id=\"比较解释语言和C语言的不同\"><a href=\"#比较解释语言和C语言的不同\" class=\"headerlink\" title=\"比较解释语言和C语言的不同\"></a>比较解释语言和C语言的不同</h3><p>解释型语言：</p>\n<blockquote>\n<ol>\n<li>每运行一次，解释器就读一次，对符号进行翻译</li>\n<li>中间状态以严格规定保存起来，在后面的语句需要时被重新加载<br>C语言</li>\n<li>在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。</li>\n<li>编译器对代码同类向合并，最后的机器码会很简洁。</li>\n</ol>\n</blockquote>\n<p>逻辑学教育，BASIC，适合理解编程。</p>\n<h1 id=\"3-编程语言\"><a href=\"#3-编程语言\" class=\"headerlink\" title=\"3. 编程语言\"></a>3. 编程语言</h1><h2 id=\"3-3-C\"><a href=\"#3-3-C\" class=\"headerlink\" title=\"3.3 C++\"></a>3.3 C++</h2><h3 id=\"C-的不同理解\"><a href=\"#C-的不同理解\" class=\"headerlink\" title=\"C++的不同理解\"></a>C++的不同理解</h3><p>第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。</p>\n<h3 id=\"C对于C-的优势\"><a href=\"#C对于C-的优势\" class=\"headerlink\" title=\"C对于C++的优势\"></a>C对于C++的优势</h3><p>简洁，而非高效；适合做小内存的嵌入式系统开发。</p>\n<h3 id=\"但大多数游戏平台，C-比C更适合\"><a href=\"#但大多数游戏平台，C-比C更适合\" class=\"headerlink\" title=\"但大多数游戏平台，C++比C更适合\"></a>但大多数游戏平台，C++比C更适合</h3><h2 id=\"3-4-汇编语言\"><a href=\"#3-4-汇编语言\" class=\"headerlink\" title=\"3.4 汇编语言\"></a>3.4 汇编语言</h2><p>合适场合使用汇编，能让程序跑得更快。<br>了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，<br>在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。</p>\n<h1 id=\"4-前Windows时代\"><a href=\"#4-前Windows时代\" class=\"headerlink\" title=\"4. 前Windows时代\"></a>4. 前Windows时代</h1><h2 id=\"4-3-保护模式下的开发工具\"><a href=\"#4-3-保护模式下的开发工具\" class=\"headerlink\" title=\"4.3 保护模式下的开发工具\"></a>4.3 保护模式下的开发工具</h2><p>个人主页建立之初，我罗列出了个人兴趣 ：…很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。</p>\n<blockquote>\n<ul>\n<li>翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友</li>\n<li><p>写关于游戏编程技术方面的小文，各处转载</p>\n</li>\n<li><p>利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。</p>\n</li>\n</ul>\n</blockquote>\n<p>学习新的技术，翻译一本相关的英语著作可以算是捷径。</p>\n<blockquote>\n<ul>\n<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>\n<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>\n<li>即使对此有所了解，翻译后也能更上一层楼。</li>\n<li>英语水平也会提高。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-4-闲话allegro\"><a href=\"#4-4-闲话allegro\" class=\"headerlink\" title=\"4.4 闲话allegro\"></a>4.4 闲话allegro</h2><h3 id=\"4-4-4-几何图形和3D\"><a href=\"#4-4-4-几何图形和3D\" class=\"headerlink\" title=\"4.4.4 几何图形和3D\"></a>4.4.4 几何图形和3D</h3><p>图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。</p>\n<p>3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。<br>相关的:</p>\n<blockquote>\n<ul>\n<li>透视映射</li>\n<li>矩阵，三维空间中变换的工具, 自带一套矩阵运算。</li>\n<li>实现了一套定点数的运算该改善游戏中需要的数学运算速度。</li>\n</ul>\n</blockquote>\n<p><strong>1,定点数</strong><br>巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。</p>\n<p>浮点数：计算机用一种纯小数加指数的形式表示实数。<br>定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。</p>\n<p>高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。</p>\n<p>精读在1/6*10^4, 十进制小数点后四位的精度。</p>\n<p>定点数的一些计算技巧和优势：</p>\n<blockquote>\n<ul>\n<li>原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。</li>\n<li>角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-5\"><a href=\"#4-5\" class=\"headerlink\" title=\"4.5\"></a>4.5</h2><p>云风关于写email的建议：</p>\n<blockquote>\n<ul>\n<li>回复收到的每封email, 即使没空写， 也让对方知道自己已读。</li>\n<li>使用纯文本，发送过大附件前请求</li>\n<li>合适的标题，能概括内容；偏题时，修改标题。</li>\n<li>删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。</li>\n<li>合理分段，表达自己意见，别赞同两字多写一点。</li>\n<li>发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确</li>\n<li>不要随意公开转载私人信件，即使转载也注明出处。</li>\n</ul>\n</blockquote>\n<h1 id=\"8-引擎中的优化\"><a href=\"#8-引擎中的优化\" class=\"headerlink\" title=\"8. 引擎中的优化\"></a>8. 引擎中的优化</h1><p>“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。</p>\n<p>只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。</p>\n<h1 id=\"9-C和C\"><a href=\"#9-C和C\" class=\"headerlink\" title=\"9. C和C++\"></a>9. C和C++</h1><h2 id=\"9-1-从C到C\"><a href=\"#9-1-从C到C\" class=\"headerlink\" title=\"9.1 从C到C++\"></a>9.1 从C到C++</h2><p>1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。</p>\n<p>2, C对大块的数据，使用数据指针来表达。</p>\n<p>3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据</p>\n<p>4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。</p>\n<p>5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。</p>\n<p><code>困难性的说明</code>，<br>高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往<strong>只能针对特定的类型</strong>。</p>\n<p><code>C++面向对象的说明</code></p>\n<blockquote>\n<ul>\n<li>既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。</li>\n<li>将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。</li>\n</ul>\n</blockquote>\n<h2 id=\"9-2-C-vs-C-，-效率至上\"><a href=\"#9-2-C-vs-C-，-效率至上\" class=\"headerlink\" title=\"9.2 C vs C++， 效率至上\"></a>9.2 C vs C++， 效率至上</h2><p><code>C++中混有C语言的好处:</code></p>\n<blockquote>\n<p>1, 更广泛的移植性<br>2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖<br>3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事<br>4, C简洁, 编译速度快</p>\n</blockquote>\n<h2 id=\"9-3-优雅的C\"><a href=\"#9-3-优雅的C\" class=\"headerlink\" title=\"9.3 优雅的C++\"></a>9.3 优雅的C++</h2><p>将C细化，又不增加额外的开销;<br>不对程序员有过多限制。</p>\n<h3 id=\"9-3-1-宏\"><a href=\"#9-3-1-宏\" class=\"headerlink\" title=\"9.3.1 宏\"></a>9.3.1 宏</h3><p><code>宏的作用</code></p>\n<blockquote>\n<p>1, 定义常数<br>2, 代码生成<br>3, 内联代码<br>4, 对编译流程作出选择</p>\n</blockquote>\n<p>1, 定义常数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.1415926f;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> PI;</span><br></pre></td></tr></table></figure>\n<p>C++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。</p>\n<p>经典的如：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(a, b) ((a&lt;b)?(a):(b))</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">min</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;a, <span class=\"keyword\">const</span> T &amp;b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a&lt;b ? a:b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-3-2-const修饰以及类型转换\"><a href=\"#9-3-2-const修饰以及类型转换\" class=\"headerlink\" title=\"9.3.2 const修饰以及类型转换\"></a>9.3.2 const修饰以及类型转换</h3><h4 id=\"const修饰\"><a href=\"#const修饰\" class=\"headerlink\" title=\"const修饰\"></a>const修饰</h4><p>const chat<em> 而不是 C 的 char</em></p>\n<p>将函数参数写成const;<br>成员变量修饰成const, 只有在构造的时构建他们;<br>为成员函数增加一个const, 表达这个函数不会修改类的成员变量</p>\n<h4 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h4><p>C中几乎任何类型都可以任意转换，缘于C汇编的根。<br>C++用static_cast 以模板的语法表达看起来可以互相转换的类型互换</p>\n<p>const和const之间的转换，只能通过const_cast转换。</p>\n<p>严格描述每个对象的const性质，可以帮助在编译期发生错误减少。</p>\n<h3 id=\"9-3-3-隐藏实现\"><a href=\"#9-3-3-隐藏实现\" class=\"headerlink\" title=\"9.3.3 隐藏实现\"></a>9.3.3 隐藏实现</h3><p>好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。</p>\n<p>作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。</p>\n<h3 id=\"9-3-4-引用而非指针\"><a href=\"#9-3-4-引用而非指针\" class=\"headerlink\" title=\"9.3.4 引用而非指针\"></a>9.3.4 引用而非指针</h3><p>指针是导致资源被遗忘释放的罪魁祸首。</p>\n<blockquote>\n<ul>\n<li>当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。</li>\n</ul>\n</blockquote>\n<p>引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。</p>\n<p>C++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。</p>\n<h3 id=\"9-3-5-命名空间\"><a href=\"#9-3-5-命名空间\" class=\"headerlink\" title=\"9.3.5 命名空间\"></a>9.3.5 命名空间</h3><p>引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。</p>\n<h2 id=\"9-4-C-的误区\"><a href=\"#9-4-C-的误区\" class=\"headerlink\" title=\"9.4 C++的误区\"></a>9.4 C++的误区</h2><p>自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。</p>\n<p>举例:</p>\n<blockquote>\n<ul>\n<li>能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。</li>\n</ul>\n</blockquote>\n<p>解释：</p>\n<blockquote>\n<ul>\n<li>没有完美的程序，也没有完美的原则。</li>\n<li>不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。</li>\n</ul>\n</blockquote>\n<h3 id=\"9-4-1-类层次过细\"><a href=\"#9-4-1-类层次过细\" class=\"headerlink\" title=\"9.4.1 类层次过细\"></a>9.4.1 类层次过细</h3><p>会造成间接调用引起的损耗。</p>\n<h3 id=\"9-4-2-滥用操作符重载\"><a href=\"#9-4-2-滥用操作符重载\" class=\"headerlink\" title=\"9.4.2 滥用操作符重载\"></a>9.4.2 滥用操作符重载</h3><p>为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。<br>如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。</p>\n<h3 id=\"9-4-3-滥用标准容器\"><a href=\"#9-4-3-滥用标准容器\" class=\"headerlink\" title=\"9.4.3 滥用标准容器\"></a>9.4.3 滥用标准容器</h3><p>用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。</p>\n<p><code>std::map可以这样子做，</code><br>如果只是为了创建一张key-value的对应表可供查询，完全可以用<br>key-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。</p>\n<h3 id=\"9-4-5-滥用多重继承\"><a href=\"#9-4-5-滥用多重继承\" class=\"headerlink\" title=\"9.4.5 滥用多重继承\"></a>9.4.5 滥用多重继承</h3><p>会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。</p>\n<h3 id=\"9-4-6-忽视C-高级特性的复杂度\"><a href=\"#9-4-6-忽视C-高级特性的复杂度\" class=\"headerlink\" title=\"9.4.6 忽视C++高级特性的复杂度\"></a>9.4.6 忽视C++高级特性的复杂度</h3><p>如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。</p>\n<h3 id=\"9-4-7-学习C\"><a href=\"#9-4-7-学习C\" class=\"headerlink\" title=\"9.4.7 学习C++\"></a>9.4.7 学习C++</h3><p>我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。</p>\n<p>因此，需要</p>\n<blockquote>\n<p>1，学<br>2, 用<br>3, 思考<br>2, 回到1</p>\n</blockquote>\n<p>如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。</p>\n<p>推荐一个阅读次序:</p>\n<blockquote>\n<p>1, 先学会C，只是也是C++子集的部分。<br>2, &lt;<c++编程思想>&gt;<br>3, &lt;<c++ primer=\"\">&gt; 和 &lt;<c++ programing=\"\" language=\"\">&gt;<br>4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。<br>5, &lt;<c++的发展和演化>&gt;，深入了解C++设计的根源以及C++编译器实现方法入手.<br>6, &lt;&lt;深度探索C++物件模型&gt;&gt;对追求高效的C++程序员尤为受用。</c++的发展和演化></c++></c++></c++编程思想></p>\n</blockquote>\n<p>进阶学习: 需要一定的开发经验才能阅读</p>\n<blockquote>\n<ul>\n<li>&lt;<effective c++=\"\">&gt;, &lt;<more effective=\"\" c++=\"\">&gt;, &lt;<c++沉思录>&gt;</c++沉思录></more></effective></li>\n<li>泛型编程&lt;<stl 源码剖析=\"\">&gt;，有点难，但是花上一定的时间一定有收获。</stl></li>\n<li>&lt;<c++设计新思维------泛型编程与设计模式之应用>&gt;template使用自信，对泛型编程感觉良好，</c++设计新思维------泛型编程与设计模式之应用></li>\n<li>&lt;<c++标准程序库>&gt;想更精通标准库，C++程序员案头必备的参考手册。</c++标准程序库></li>\n<li>&lt;<effective stl=\"\" 中文版=\"\">&gt;， 与前面的effcive系列一样</effective></li>\n</ul>\n</blockquote>\n<h3 id=\"9-5-3-再论动态内存分配\"><a href=\"#9-5-3-再论动态内存分配\" class=\"headerlink\" title=\"9.5.3 再论动态内存分配\"></a>9.5.3 再论动态内存分配</h3><p>//…</p>\n<p>理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。</p>\n<h3 id=\"9-6-template\"><a href=\"#9-6-template\" class=\"headerlink\" title=\"9.6 template\"></a>9.6 template</h3><p>template最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。</p>\n<h4 id=\"9-6-1-封装C-的成员函数的调用\"><a href=\"#9-6-1-封装C-的成员函数的调用\" class=\"headerlink\" title=\"9.6.1 封装C++的成员函数的调用\"></a>9.6.1 封装C++的成员函数的调用</h4><h4 id=\"9-6-4-避免重复代码\"><a href=\"#9-6-4-避免重复代码\" class=\"headerlink\" title=\"9.6.4 避免重复代码\"></a>9.6.4 避免重复代码</h4><p><code>大部分程序错误的根源:</code></p>\n<blockquote>\n<ul>\n<li>在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。</li>\n</ul>\n</blockquote>\n<p>没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。</p>\n<p>举个blit()例子</p>\n<h4 id=\"9-6-5-选择最佳的容器\"><a href=\"#9-6-5-选择最佳的容器\" class=\"headerlink\" title=\"9.6.5 选择最佳的容器\"></a>9.6.5 选择最佳的容器</h4><p>很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。</p>\n<p>对于一个容器到底是保存</p>\n<blockquote>\n<ul>\n<li>对象指针</li>\n<li><p>对象值</p>\n</li>\n<li><p>对于体积较大的对象，保存指针, 复制很快</p>\n</li>\n<li>对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用</li>\n</ul>\n</blockquote>\n<p>可以利用模板在编译期间由编译器自动进行；</p>\n<h4 id=\"9-6-5-延迟计算\"><a href=\"#9-6-5-延迟计算\" class=\"headerlink\" title=\"9.6.5 延迟计算\"></a>9.6.5 延迟计算</h4><p>由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。</p>\n<h4 id=\"9-6-7-编译时的计算游戏（未完成）\"><a href=\"#9-6-7-编译时的计算游戏（未完成）\" class=\"headerlink\" title=\"9.6.7 编译时的计算游戏（未完成）\"></a>9.6.7 编译时的计算游戏（未完成）</h4><p>三个数排序<br>+</p>\n<h3 id=\"9-7-小结\"><a href=\"#9-7-小结\" class=\"headerlink\" title=\"9.7 小结\"></a>9.7 小结</h3><p>早犯一天错误，就可以早一天改正错误。</p>\n<h1 id=\"13-开发方法\"><a href=\"#13-开发方法\" class=\"headerlink\" title=\"13. 开发方法\"></a>13. 开发方法</h1><h2 id=\"13-1-失败的经验\"><a href=\"#13-1-失败的经验\" class=\"headerlink\" title=\"13.1 失败的经验\"></a>13.1 失败的经验</h2><blockquote>\n<p>1, 过多的工作压力压到一个人身上。<br>2, 过分的弹性工作制<br>3, 没完没了的变化和返工<br>4, 没有及时的测试<br>5, 项目的主导严重偏向了某一职位上</p>\n</blockquote>\n<p><code>1, 过多的工作压力压到一个人身上。</code><br>迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。</p>\n<p><code>2, 过分的弹性工作制</code><br>兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。</p>\n<p><code>3, 没完没了的变化和返工</code><br>想法太多，什么都想加入进来，导致最后漏洞很多。</p>\n<p><code>&gt; 4, 没有及时的测试</code><br>很少有严格的测试，而是把错误积累。 </p>\n<p><code>5, 项目的主导严重偏向了某一职位上</code><br>程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.</p>\n<h2 id=\"13-2-成功的经验\"><a href=\"#13-2-成功的经验\" class=\"headerlink\" title=\"13.2 成功的经验\"></a>13.2 成功的经验</h2><blockquote>\n<p>1, 引擎和实现的分离<br>2, 结对编程（XP 极限编程）<br>3, 随时方便地测试<br>4, 尽早发现结构上的问题, 并尽早重构<br>5, 其他</p>\n</blockquote>\n<p><code>1, 引擎和实现的分离</code><br>早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。<br>许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。<br>和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。</p>\n<p>其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。</p>\n<p><code>2, 结对编程</code><br>找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。</p>\n<p>潜在问题的代码，在XP极限编程中，被称做代码的<strong>坏味道</strong>。</p>\n<p>好处:</p>\n<blockquote>\n<p>1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。<br>2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。<br>3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。</p>\n</blockquote>\n<p><code>3, 随时方便地测试</code><br>测试应该从开发者开始，从项目一开始就开始。</p>\n<p><code>4, 尽早发现结构上的问题, 并尽早重构</code></p>\n<p><code>5, 其他</code></p>\n<p>脚本和版本控制。<br>软件开发的素养。</p>\n<h1 id=\"14-编程和游戏\"><a href=\"#14-编程和游戏\" class=\"headerlink\" title=\"14. 编程和游戏\"></a>14. 编程和游戏</h1><p>技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。<br>而忽略了一些更重要的东西。</p>\n<h2 id=\"14-1-操作\"><a href=\"#14-1-操作\" class=\"headerlink\" title=\"14.1 操作\"></a>14.1 操作</h2><p>任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。</p>\n<h2 id=\"14-2-角色设定\"><a href=\"#14-2-角色设定\" class=\"headerlink\" title=\"14.2 角色设定\"></a>14.2 角色设定</h2><p>生动的角色，RPG，增加游戏气氛</p>\n<h2 id=\"14-3-操作技术\"><a href=\"#14-3-操作技术\" class=\"headerlink\" title=\"14.3 操作技术\"></a>14.3 操作技术</h2><p><code>3D和2D</code></p>\n<blockquote>\n<ul>\n<li>应该由游戏本身的需要决定。</li>\n<li>3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。</li>\n<li>2D技术怎样控制和管理不断膨胀的图片数量</li>\n</ul>\n</blockquote>\n<h2 id=\"14-4-浅谈网络游戏\"><a href=\"#14-4-浅谈网络游戏\" class=\"headerlink\" title=\"14.4 浅谈网络游戏\"></a>14.4 浅谈网络游戏</h2><p><code>社会性</code><br>除了传统的游戏它自身的娱乐性之外，还存在一种社会性。<br>因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。</p>\n<p>看似不是程序的事情，但非程序的策划很难去做：</p>\n<blockquote>\n<ul>\n<li>大规模的数字采集和统计的工作</li>\n<li>大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。</li>\n</ul>\n</blockquote>\n<p><code>平衡性</code></p>\n<blockquote>\n<ul>\n<li>传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。</li>\n<li>程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。</li>\n</ul>\n</blockquote>\n<h2 id=\"14-5-小结\"><a href=\"#14-5-小结\" class=\"headerlink\" title=\"14.5 小结\"></a>14.5 小结</h2><p>一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。</p>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。</p>\n"},{"title":"C++ Zero To One 0.003","date":"2018-01-11T08:06:51.000Z","_content":"\n# 重载函数什么时候用virtual?\n源码: [source code - load_funtion.cpp](https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp)\n## 问题来源\n```cpp\n  template <typename VST> void traverse(VST visit);\n  // template <typename VST> virtual void traverse(VST visit, T* e);\n  template <typename VST> void traverse(VST visit, T* e);\n```\n\n为什么这里不需要virtual??\n\n```cpp\n// 单个T类型元素加1的类\ntemplate <typename T>\nstruct Increase {\n  virtual void operator()(T &e) {e++;}    // Increase<T>()实现函数功能  \n};\n```\n\n为什么这里又需要virtual??\n\n## 概念偏差\nvirtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。\n\n**vitual为虚函数**：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 \n\n**重载函数**：同一作用域内的几个函数名字相同但形参列表不同。\n## 使用与不使用virtual\n\n解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载\n```cpp\nstruct Base {    // 声明virtual后, 可被继承类override重载\n  virtual void print() {std::cout << \"Base\\n\";}\n};\n\nstruct Derived : Base {   // 'override'可写可不写\n  void print() override {std::cout << \"Derived\\n\";}\n};\n```\n\n\n```cpp\nstruct Base {\n  void print() {std::cout << \"Base\\n\";}\n};\n\nstruct Derived : Base {\n  void print() {std::cout << \"Derived\\n\";}\n};\n```\n\n`关键问题: 上述两者什么差别????`\n\n运行测试一下:\n```cpp\n// 注释是使用virtual结果\n  Base b;\n  Derived d;\n\n  Base& br = b;      // refer b, br的类型是Base&\n  Base& dr = d;      // dr类型也是Base&\n  br.print();        // Base\n  dr.print();        // Derived\n\n  Base* pb = &b;     // pointer to b, Base*\n  Base* pd = &d;     // Base* as well\n\n  pb->print();       // Base\n  pd->print();       // Derived\n\n  b.Base::print();   // Base\n  d.Base::print();   // Base\n\n```\n使用vitual的运行结果:\n\n```sh\nBase\nDerived\nBase\nDerived\nBase\nBase\n```\n\n不使用虚方法的运行结果: \n```sh\nBase\nBase\nBase\nBase\nBase\nBase\n```\n\nvirtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。\n\n## 解决最初问题\n### 为什么traverse函数不需要virtual\ntraverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。\n### 为什么函数对象需要virtual重载操作符函数?\n\n定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2\n```cpp\n// 函数对象用virtual声明operator()()\nstruct Increase {\n  // 重载()后, 对象可充当函数的功能\n  virtual void operator()(int* e) {(*e)++;}\n};\n\nstruct Increase_two : Increase {\n  void operator()(int* e) override {(*e)+= 2;}    // 元素+2;\n};\n```\n\n测试函数, 以及prints结果如下：\n```cpp\nvoid f_increase() {\n  Increase a;\n  Increase_two b;\n\n  Increase& ra = a;\n  Increase& rb = b;     // rb的类型为 Increase&\n\n  int e = 5; int* pe = &e;\n  ra.operator()(pe);\n  std::cout << \"e = \" << e << std::endl;    // prints \"e = 6\"\n  int e2 = 5; int* pe2 = &e2;\n  rb.operator()(pe2);   // 调用基类的引用时, 动态绑定到Increase_two中的方法\n  std::cout << \"e2 = \" << e2 << std::endl;  // prints \"e2 = 7\"\n}\n```\n\n对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。\n\n\n\n# 静态成员声明定义使用\n源码: [source code - static.cpp](https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp)\n## 静态成员的特点\n静态数据成员不属于任何类的一个对象。\n\n类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期\n## 类内static成员如何声明定义?\n> * 在类内部声明, 外部通过类名作用域访问定义\n```cpp\n{\nclass MyStatic\npublic:\n static int i_stc;   // 类内部声明\n // ...\n}\n\nint MyStatic::i_stc = 0;     // 类外部定义, 注意需要声明成员的类型\n```\n\n也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。\n## 在不同实例中被多次调用改变后的情况?\n\n```\nvoid MyStatic::increment() {++i_stc;}\n\nvoid f() {\n  MyStatic c0;\n  c0.increment();\n  std::cout << \"c0 = \" << c0.i_stc << std::endl;\n  MyStatic c1;\n  c1.increment();\n  std::cout << \"c1 = \" << c1.i_stc << std::endl;\n}\n\nvoid f1() {\n  MyStatic c2;\n  c2.increment();\n  std::cout << \"c2 = \" << c2.i_stc << std::endl;\n}\n\n```\n\n```sh\nc0 = 1\nc1 = 2\nc2 = 3\n```\n\n静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。\n\n\n","source":"_posts/cpp/cpp-notes-0003.md","raw":"---\ntitle: C++ Zero To One 0.003\ndate: 2018-01-11 16:06:51\ntags: [C++, 继承, 类, virtual, override, 函数重载, static, 静态成员, ]\n---\n\n# 重载函数什么时候用virtual?\n源码: [source code - load_funtion.cpp](https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp)\n## 问题来源\n```cpp\n  template <typename VST> void traverse(VST visit);\n  // template <typename VST> virtual void traverse(VST visit, T* e);\n  template <typename VST> void traverse(VST visit, T* e);\n```\n\n为什么这里不需要virtual??\n\n```cpp\n// 单个T类型元素加1的类\ntemplate <typename T>\nstruct Increase {\n  virtual void operator()(T &e) {e++;}    // Increase<T>()实现函数功能  \n};\n```\n\n为什么这里又需要virtual??\n\n## 概念偏差\nvirtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。\n\n**vitual为虚函数**：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 \n\n**重载函数**：同一作用域内的几个函数名字相同但形参列表不同。\n## 使用与不使用virtual\n\n解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载\n```cpp\nstruct Base {    // 声明virtual后, 可被继承类override重载\n  virtual void print() {std::cout << \"Base\\n\";}\n};\n\nstruct Derived : Base {   // 'override'可写可不写\n  void print() override {std::cout << \"Derived\\n\";}\n};\n```\n\n\n```cpp\nstruct Base {\n  void print() {std::cout << \"Base\\n\";}\n};\n\nstruct Derived : Base {\n  void print() {std::cout << \"Derived\\n\";}\n};\n```\n\n`关键问题: 上述两者什么差别????`\n\n运行测试一下:\n```cpp\n// 注释是使用virtual结果\n  Base b;\n  Derived d;\n\n  Base& br = b;      // refer b, br的类型是Base&\n  Base& dr = d;      // dr类型也是Base&\n  br.print();        // Base\n  dr.print();        // Derived\n\n  Base* pb = &b;     // pointer to b, Base*\n  Base* pd = &d;     // Base* as well\n\n  pb->print();       // Base\n  pd->print();       // Derived\n\n  b.Base::print();   // Base\n  d.Base::print();   // Base\n\n```\n使用vitual的运行结果:\n\n```sh\nBase\nDerived\nBase\nDerived\nBase\nBase\n```\n\n不使用虚方法的运行结果: \n```sh\nBase\nBase\nBase\nBase\nBase\nBase\n```\n\nvirtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。\n\n## 解决最初问题\n### 为什么traverse函数不需要virtual\ntraverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。\n### 为什么函数对象需要virtual重载操作符函数?\n\n定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2\n```cpp\n// 函数对象用virtual声明operator()()\nstruct Increase {\n  // 重载()后, 对象可充当函数的功能\n  virtual void operator()(int* e) {(*e)++;}\n};\n\nstruct Increase_two : Increase {\n  void operator()(int* e) override {(*e)+= 2;}    // 元素+2;\n};\n```\n\n测试函数, 以及prints结果如下：\n```cpp\nvoid f_increase() {\n  Increase a;\n  Increase_two b;\n\n  Increase& ra = a;\n  Increase& rb = b;     // rb的类型为 Increase&\n\n  int e = 5; int* pe = &e;\n  ra.operator()(pe);\n  std::cout << \"e = \" << e << std::endl;    // prints \"e = 6\"\n  int e2 = 5; int* pe2 = &e2;\n  rb.operator()(pe2);   // 调用基类的引用时, 动态绑定到Increase_two中的方法\n  std::cout << \"e2 = \" << e2 << std::endl;  // prints \"e2 = 7\"\n}\n```\n\n对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。\n\n\n\n# 静态成员声明定义使用\n源码: [source code - static.cpp](https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp)\n## 静态成员的特点\n静态数据成员不属于任何类的一个对象。\n\n类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期\n## 类内static成员如何声明定义?\n> * 在类内部声明, 外部通过类名作用域访问定义\n```cpp\n{\nclass MyStatic\npublic:\n static int i_stc;   // 类内部声明\n // ...\n}\n\nint MyStatic::i_stc = 0;     // 类外部定义, 注意需要声明成员的类型\n```\n\n也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。\n## 在不同实例中被多次调用改变后的情况?\n\n```\nvoid MyStatic::increment() {++i_stc;}\n\nvoid f() {\n  MyStatic c0;\n  c0.increment();\n  std::cout << \"c0 = \" << c0.i_stc << std::endl;\n  MyStatic c1;\n  c1.increment();\n  std::cout << \"c1 = \" << c1.i_stc << std::endl;\n}\n\nvoid f1() {\n  MyStatic c2;\n  c2.increment();\n  std::cout << \"c2 = \" << c2.i_stc << std::endl;\n}\n\n```\n\n```sh\nc0 = 1\nc1 = 2\nc2 = 3\n```\n\n静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。\n\n\n","slug":"cpp/cpp-notes-0003","published":1,"updated":"2018-06-19T16:15:03.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyk9001rk8mf45wil7ip","content":"<h1 id=\"重载函数什么时候用virtual\"><a href=\"#重载函数什么时候用virtual\" class=\"headerlink\" title=\"重载函数什么时候用virtual?\"></a>重载函数什么时候用virtual?</h1><p>源码: <a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp\" target=\"_blank\" rel=\"noopener\">source code - load_funtion.cpp</a></p>\n<h2 id=\"问题来源\"><a href=\"#问题来源\" class=\"headerlink\" title=\"问题来源\"></a>问题来源</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(VST visit)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// template &lt;typename VST&gt; virtual void traverse(VST visit, T* e);</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(VST visit, T* e)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>为什么这里不需要virtual??</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单个T类型元素加1的类</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T &amp;e)</span> </span>&#123;e++;&#125;    <span class=\"comment\">// Increase&lt;T&gt;()实现函数功能  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为什么这里又需要virtual??</p>\n<h2 id=\"概念偏差\"><a href=\"#概念偏差\" class=\"headerlink\" title=\"概念偏差\"></a>概念偏差</h2><p>virtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。</p>\n<p><strong>vitual为虚函数</strong>：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 </p>\n<p><strong>重载函数</strong>：同一作用域内的几个函数名字相同但形参列表不同。</p>\n<h2 id=\"使用与不使用virtual\"><a href=\"#使用与不使用virtual\" class=\"headerlink\" title=\"使用与不使用virtual\"></a>使用与不使用virtual</h2><p>解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span> &#123;</span>    <span class=\"comment\">// 声明virtual后, 可被继承类override重载</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived</span> :</span> Base &#123;   <span class=\"comment\">// 'override'可写可不写</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> override </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived</span> :</span> Base &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>关键问题: 上述两者什么差别????</code></p>\n<p>运行测试一下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释是使用virtual结果</span></span><br><span class=\"line\">  Base b;</span><br><span class=\"line\">  Derived d;</span><br><span class=\"line\"></span><br><span class=\"line\">  Base&amp; br = b;      <span class=\"comment\">// refer b, br的类型是Base&amp;</span></span><br><span class=\"line\">  Base&amp; dr = d;      <span class=\"comment\">// dr类型也是Base&amp;</span></span><br><span class=\"line\">  br.print();        <span class=\"comment\">// Base</span></span><br><span class=\"line\">  dr.print();        <span class=\"comment\">// Derived</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Base* pb = &amp;b;     <span class=\"comment\">// pointer to b, Base*</span></span><br><span class=\"line\">  Base* pd = &amp;d;     <span class=\"comment\">// Base* as well</span></span><br><span class=\"line\"></span><br><span class=\"line\">  pb-&gt;print();       <span class=\"comment\">// Base</span></span><br><span class=\"line\">  pd-&gt;print();       <span class=\"comment\">// Derived</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.Base::print();   <span class=\"comment\">// Base</span></span><br><span class=\"line\">  d.Base::print();   <span class=\"comment\">// Base</span></span><br></pre></td></tr></table></figure></p>\n<p>使用vitual的运行结果:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Base</span><br><span class=\"line\">Derived</span><br><span class=\"line\">Base</span><br><span class=\"line\">Derived</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br></pre></td></tr></table></figure>\n<p>不使用虚方法的运行结果:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br></pre></td></tr></table></figure></p>\n<p>virtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。</p>\n<h2 id=\"解决最初问题\"><a href=\"#解决最初问题\" class=\"headerlink\" title=\"解决最初问题\"></a>解决最初问题</h2><h3 id=\"为什么traverse函数不需要virtual\"><a href=\"#为什么traverse函数不需要virtual\" class=\"headerlink\" title=\"为什么traverse函数不需要virtual\"></a>为什么traverse函数不需要virtual</h3><p>traverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。</p>\n<h3 id=\"为什么函数对象需要virtual重载操作符函数\"><a href=\"#为什么函数对象需要virtual重载操作符函数\" class=\"headerlink\" title=\"为什么函数对象需要virtual重载操作符函数?\"></a>为什么函数对象需要virtual重载操作符函数?</h3><p>定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数对象用virtual声明operator()()</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 重载()后, 对象可充当函数的功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span>* e)</span> </span>&#123;(*e)++;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase_two</span> :</span> Increase &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span>* e)</span> override </span>&#123;(*e)+= <span class=\"number\">2</span>;&#125;    <span class=\"comment\">// 元素+2;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试函数, 以及prints结果如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f_increase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Increase a;</span><br><span class=\"line\">  Increase_two b;</span><br><span class=\"line\"></span><br><span class=\"line\">  Increase&amp; ra = a;</span><br><span class=\"line\">  Increase&amp; rb = b;     <span class=\"comment\">// rb的类型为 Increase&amp;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> e = <span class=\"number\">5</span>; <span class=\"keyword\">int</span>* pe = &amp;e;</span><br><span class=\"line\">  ra.<span class=\"keyword\">operator</span>()(pe);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e = \"</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// prints \"e = 6\"</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> e2 = <span class=\"number\">5</span>; <span class=\"keyword\">int</span>* pe2 = &amp;e2;</span><br><span class=\"line\">  rb.<span class=\"keyword\">operator</span>()(pe2);   <span class=\"comment\">// 调用基类的引用时, 动态绑定到Increase_two中的方法</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e2 = \"</span> &lt;&lt; e2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;  <span class=\"comment\">// prints \"e2 = 7\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。</p>\n<h1 id=\"静态成员声明定义使用\"><a href=\"#静态成员声明定义使用\" class=\"headerlink\" title=\"静态成员声明定义使用\"></a>静态成员声明定义使用</h1><p>源码: <a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp\" target=\"_blank\" rel=\"noopener\">source code - static.cpp</a></p>\n<h2 id=\"静态成员的特点\"><a href=\"#静态成员的特点\" class=\"headerlink\" title=\"静态成员的特点\"></a>静态成员的特点</h2><p>静态数据成员不属于任何类的一个对象。</p>\n<p>类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期</p>\n<h2 id=\"类内static成员如何声明定义\"><a href=\"#类内static成员如何声明定义\" class=\"headerlink\" title=\"类内static成员如何声明定义?\"></a>类内static成员如何声明定义?</h2><blockquote>\n<ul>\n<li>在类内部声明, 外部通过类名作用域访问定义<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStatic</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span>:</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i_stc;   <span class=\"comment\">// 类内部声明</span></span><br><span class=\"line\"> <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MyStatic::i_stc = <span class=\"number\">0</span>;     <span class=\"comment\">// 类外部定义, 注意需要声明成员的类型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。</p>\n<h2 id=\"在不同实例中被多次调用改变后的情况\"><a href=\"#在不同实例中被多次调用改变后的情况\" class=\"headerlink\" title=\"在不同实例中被多次调用改变后的情况?\"></a>在不同实例中被多次调用改变后的情况?</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void MyStatic::increment() &#123;++i_stc;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">  MyStatic c0;</span><br><span class=\"line\">  c0.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c0 = &quot; &lt;&lt; c0.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">  MyStatic c1;</span><br><span class=\"line\">  c1.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f1() &#123;</span><br><span class=\"line\">  MyStatic c2;</span><br><span class=\"line\">  c2.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">c0 = 1</span><br><span class=\"line\">c1 = 2</span><br><span class=\"line\">c2 = 3</span><br></pre></td></tr></table></figure>\n<p>静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"重载函数什么时候用virtual\"><a href=\"#重载函数什么时候用virtual\" class=\"headerlink\" title=\"重载函数什么时候用virtual?\"></a>重载函数什么时候用virtual?</h1><p>源码: <a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp\" target=\"_blank\" rel=\"noopener\">source code - load_funtion.cpp</a></p>\n<h2 id=\"问题来源\"><a href=\"#问题来源\" class=\"headerlink\" title=\"问题来源\"></a>问题来源</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(VST visit)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// template &lt;typename VST&gt; virtual void traverse(VST visit, T* e);</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(VST visit, T* e)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>为什么这里不需要virtual??</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单个T类型元素加1的类</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T &amp;e)</span> </span>&#123;e++;&#125;    <span class=\"comment\">// Increase&lt;T&gt;()实现函数功能  </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为什么这里又需要virtual??</p>\n<h2 id=\"概念偏差\"><a href=\"#概念偏差\" class=\"headerlink\" title=\"概念偏差\"></a>概念偏差</h2><p>virtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。</p>\n<p><strong>vitual为虚函数</strong>：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 </p>\n<p><strong>重载函数</strong>：同一作用域内的几个函数名字相同但形参列表不同。</p>\n<h2 id=\"使用与不使用virtual\"><a href=\"#使用与不使用virtual\" class=\"headerlink\" title=\"使用与不使用virtual\"></a>使用与不使用virtual</h2><p>解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span> &#123;</span>    <span class=\"comment\">// 声明virtual后, 可被继承类override重载</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived</span> :</span> Base &#123;   <span class=\"comment\">// 'override'可写可不写</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> override </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Base\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived</span> :</span> Base &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Derived\\n\"</span>;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>关键问题: 上述两者什么差别????</code></p>\n<p>运行测试一下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释是使用virtual结果</span></span><br><span class=\"line\">  Base b;</span><br><span class=\"line\">  Derived d;</span><br><span class=\"line\"></span><br><span class=\"line\">  Base&amp; br = b;      <span class=\"comment\">// refer b, br的类型是Base&amp;</span></span><br><span class=\"line\">  Base&amp; dr = d;      <span class=\"comment\">// dr类型也是Base&amp;</span></span><br><span class=\"line\">  br.print();        <span class=\"comment\">// Base</span></span><br><span class=\"line\">  dr.print();        <span class=\"comment\">// Derived</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Base* pb = &amp;b;     <span class=\"comment\">// pointer to b, Base*</span></span><br><span class=\"line\">  Base* pd = &amp;d;     <span class=\"comment\">// Base* as well</span></span><br><span class=\"line\"></span><br><span class=\"line\">  pb-&gt;print();       <span class=\"comment\">// Base</span></span><br><span class=\"line\">  pd-&gt;print();       <span class=\"comment\">// Derived</span></span><br><span class=\"line\"></span><br><span class=\"line\">  b.Base::print();   <span class=\"comment\">// Base</span></span><br><span class=\"line\">  d.Base::print();   <span class=\"comment\">// Base</span></span><br></pre></td></tr></table></figure></p>\n<p>使用vitual的运行结果:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Base</span><br><span class=\"line\">Derived</span><br><span class=\"line\">Base</span><br><span class=\"line\">Derived</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br></pre></td></tr></table></figure>\n<p>不使用虚方法的运行结果:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br><span class=\"line\">Base</span><br></pre></td></tr></table></figure></p>\n<p>virtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。</p>\n<h2 id=\"解决最初问题\"><a href=\"#解决最初问题\" class=\"headerlink\" title=\"解决最初问题\"></a>解决最初问题</h2><h3 id=\"为什么traverse函数不需要virtual\"><a href=\"#为什么traverse函数不需要virtual\" class=\"headerlink\" title=\"为什么traverse函数不需要virtual\"></a>为什么traverse函数不需要virtual</h3><p>traverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。</p>\n<h3 id=\"为什么函数对象需要virtual重载操作符函数\"><a href=\"#为什么函数对象需要virtual重载操作符函数\" class=\"headerlink\" title=\"为什么函数对象需要virtual重载操作符函数?\"></a>为什么函数对象需要virtual重载操作符函数?</h3><p>定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数对象用virtual声明operator()()</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// 重载()后, 对象可充当函数的功能</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span>* e)</span> </span>&#123;(*e)++;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Increase_two</span> :</span> Increase &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span>* e)</span> override </span>&#123;(*e)+= <span class=\"number\">2</span>;&#125;    <span class=\"comment\">// 元素+2;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>测试函数, 以及prints结果如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f_increase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Increase a;</span><br><span class=\"line\">  Increase_two b;</span><br><span class=\"line\"></span><br><span class=\"line\">  Increase&amp; ra = a;</span><br><span class=\"line\">  Increase&amp; rb = b;     <span class=\"comment\">// rb的类型为 Increase&amp;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> e = <span class=\"number\">5</span>; <span class=\"keyword\">int</span>* pe = &amp;e;</span><br><span class=\"line\">  ra.<span class=\"keyword\">operator</span>()(pe);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e = \"</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// prints \"e = 6\"</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> e2 = <span class=\"number\">5</span>; <span class=\"keyword\">int</span>* pe2 = &amp;e2;</span><br><span class=\"line\">  rb.<span class=\"keyword\">operator</span>()(pe2);   <span class=\"comment\">// 调用基类的引用时, 动态绑定到Increase_two中的方法</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e2 = \"</span> &lt;&lt; e2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;  <span class=\"comment\">// prints \"e2 = 7\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。</p>\n<h1 id=\"静态成员声明定义使用\"><a href=\"#静态成员声明定义使用\" class=\"headerlink\" title=\"静态成员声明定义使用\"></a>静态成员声明定义使用</h1><p>源码: <a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp\" target=\"_blank\" rel=\"noopener\">source code - static.cpp</a></p>\n<h2 id=\"静态成员的特点\"><a href=\"#静态成员的特点\" class=\"headerlink\" title=\"静态成员的特点\"></a>静态成员的特点</h2><p>静态数据成员不属于任何类的一个对象。</p>\n<p>类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期</p>\n<h2 id=\"类内static成员如何声明定义\"><a href=\"#类内static成员如何声明定义\" class=\"headerlink\" title=\"类内static成员如何声明定义?\"></a>类内static成员如何声明定义?</h2><blockquote>\n<ul>\n<li>在类内部声明, 外部通过类名作用域访问定义<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStatic</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span>:</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i_stc;   <span class=\"comment\">// 类内部声明</span></span><br><span class=\"line\"> <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> MyStatic::i_stc = <span class=\"number\">0</span>;     <span class=\"comment\">// 类外部定义, 注意需要声明成员的类型</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。</p>\n<h2 id=\"在不同实例中被多次调用改变后的情况\"><a href=\"#在不同实例中被多次调用改变后的情况\" class=\"headerlink\" title=\"在不同实例中被多次调用改变后的情况?\"></a>在不同实例中被多次调用改变后的情况?</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void MyStatic::increment() &#123;++i_stc;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">  MyStatic c0;</span><br><span class=\"line\">  c0.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c0 = &quot; &lt;&lt; c0.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">  MyStatic c1;</span><br><span class=\"line\">  c1.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f1() &#123;</span><br><span class=\"line\">  MyStatic c2;</span><br><span class=\"line\">  c2.increment();</span><br><span class=\"line\">  std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2.i_stc &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">c0 = 1</span><br><span class=\"line\">c1 = 2</span><br><span class=\"line\">c2 = 3</span><br></pre></td></tr></table></figure>\n<p>静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。</p>\n"},{"title":"C++ Zero To One 0.004","date":"2018-01-12T02:28:06.000Z","_content":"\n\n```\n# 1, bool和int的隐式转换\n\t[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)\n\t\n\t>* 问题起因\n\t\t======================= source code =========================\n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\tint count = 0;   // 计数器\n\t\tfor (int i = i; i < _size; i++)\n\t\t\tcount += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换\n\t\treturn count;\n\t\t}\n\t\t=============================================================\n\t\t数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。\n\t\n\t>* sizeof(bool) = 1\n  \n\t>* bool-> not bool\n\t\t布尔值转赋值给非布尔值, 初始值false时0, true时1 \t\n\t\n\t>* not bool -> bool\n\t\t非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;\n\t\n\t\t其他都没什么问题, 值得注意的是, 引用和指针\n\t\t=================== source code =============================\n\t\tvoid f_to_bool() {\n\t\tint i1 = 5, i2 = 0;\n\t\tint* pi0 = 0;       // 定义空指针\n\t\tint* pi1 = &i1;      // 指针指向i1\n\t\tint& ri0 = i2;      // 引用i2, i2的值为0\n\t\tint& ri1 = i1;      // 引用i1\n\t\t\n\t\tbool bi = i1;        // prints  bi = 1\n\t\tbool bpi0 = pi0;     // prints  bpi0 = 0\n\t\tbool bpi1 = pi1;     //         bpi1 = 1\n\t\tbool bri0 = ri0;     //         bri0 = 0\n\t\tbool bri1 = ri1;     //         bri1 = 1\n\t\t=============================================================\n----------------------------------------------------------------------------------------------------  \n# 2, 不能返回函数内部初始化的指针\n\t[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)\n\n\t>* 问题\n\t\t数据结构学习中, Rank* deduplicate_lower();\n\t\t我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。\n\t>* 错误的方法\n\t\t函数体内声明定义的指针，返回不了\n\t\t===================== source code ===========================\n\t\tint* f() {\n\t\t\tint iarr[] = {};\n\t\t\tiarr[0] = 2;\n\t\t\treturn iarr;\n\t\t}\n\t\t--------------------- ./a.out -----------------------------\n\t\twarning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]\n\t\t============================================================\n\t\t我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。\n\t\n\t>* 可行的方法\n\t\t将指针作为参数传入\n\t\t================== source code =============================\n\t\tint* f1(int* iarr) {\n\t\t\t*iarr += 1;\n\t\t\treturn iarr;\n\t\t}\n\t\t===========================================================\n\t\t另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??\n\t\t便于函数之间的调用, 还是需要的。\n\t\n\t>* 另一种可行方法: malloc返回指针\n\t\t================= source code ============================\n\t\t// 强制返回指针, 分配内存却不释放\n\t\tint* fun() {\n\t\t\tint* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存\n\t\t\tfor (int i = 0; i < sizeof(int*); i++)\n\t\t\t\t*(i_ptr+i) = 0;\n\t\t\t// free(i_ptr);  // 释放指针\n\t\t\treturn i_ptr;    // 函数返回指针\n\t\t}\n\t\t============================================================\n---------------------------------------------------------------------------------------\n# 3, malloc和free\n\t[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)\n  \n\t> * 概念\n\t\tmalloc:\n\t\tvoid* malloc (size_t size);\n\t\t在语句块中分配一个memeory, 返回一个在作用域中的指针\n\t\tfree:\n\t\tvoid free(void* ptr);\n\t\t重新分配作用域中的memeory, 给未来的分配使用\n\t\n\t> * 需要include的库\n\t\t#include <stdlib.h>\n\t\t#include <stdio.h>\n\t\n\t> * 案例\n\t\t=================== source code ===========================\n\t\tint main() {\n\t\t\tint i, n;\n\t\t\tchar* buffer;\n\n\t        printf(\"how long do you want the string?\");\n\t\t\tscanf(\"%d\", &i);\n\n\t        buffer = (char*) malloc(i+1);\n\t        if (buffer==NULL) exit(1);\n\n\t        for (n=0; n < i; n++)\n\t\t\t\tbuffer[n] = rand()%26 + 'a';\n\t\t\tbuffer[i] = '\\0';\n\n\t        printf(\"Random string: %s\\n\", buffer);\n\t        free(buffer);\n\t\t}\n\t\t------------------ ./a.out -------------------------------\n\t\thow long do you want the string?5\n\t\tRandom string: nwlrb\n\t\t===========================================================\n------------------------------------------------------------------------------------------\n# 4, 未声明大小的数组\n\t[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)\n\n\t> * 问题\n\t\t=================== source code ===========================\n\t\tint size = 5;\n\t\tint iarr[size] = {};\n\t\t------------------- ./a.out ----------------------------------\n\t\terror: variable-sized object ‘iarr1’ may not be initialized\n\t\t===========================================================\n\t\n\t> * const\n\t\t=========== source code ==========\n\t\tconst unsigned int size = 5;\n\t\tint iarr1[size] = {};\n\t\t==================================\n\t\n\t> * define\n\t\t========== source code ==============\n\t\t#define ARRAY_SIZE 5;\n\t\t// #define ARRAY_SIZE = 5;    // ERROR\n\t\tint iarr[ARRAY_SIZE] = {}\n\t\t======================================\n-------------------------------------------------------------------------------------------------\n# 5, continue 和 break 区别\n\t[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)\n\t\n\t> * 概念 \n\t\tcontinue: 跳过for, range-for, while or do-while, 循环体剩余部分 \n\t\tbreak: 闭合的for, range-for, while, do-while 循环或 switch选择终止\n\t\n\t> * continue实例:\n\t\tloop:\n\t\t=================== source code ============================\n\t\t// 跳过loop剩余部分\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 2; j <7; j++) {\n\t\t\t\tif (j - i == 2) {\n\t\t\t\tstd::cout << \"j-i = 2\" << std::endl;\n\t\t\t\tcontinue;}\n\t\t\t\t// ...\n\t\t\t\tstd::cout << \"after continue \" << std::endl;\n\t\t\t}\n\t\t}\n\t\t============================================================\n\n    > * break实例:\t\n\t\t1, loop:\n\t\t==================== source code ===========================\n\t\t// 终止循环\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 2; j <7; j++) {\n\t\t\t\tif (j - i == 2) {break;}      // 终止内存循环\n\t\t\t\tstd::cout << \"j - i = \" << j - i << std::endl;\n\t\t\t}\n\t\t}\n\t\t============================================================\n\t\n\t\t2, switch\n\t\t=================== source code ===========================\n\t\tint i = 2;\n\t\tswitch (i) {\n\t\t\tcase 1: std::cout << \"1\\n\";\n\t\t\tcase 2: std::cout << \"2\\n\";         // 选择到这里\n\t\t\tcase 3: std::cout << \"3\\n\";\n\t\t\tcase 4:\n\t\t\tcase 5: std::cout << \"45 \\n\";\n\t\t\t\tbreak;                            // 终止switch\n\t\t\tcase 6: std::cout << \"6\\n\";\n\t\t}\n\t\t------------------- ./a.out ------------------------------\n\t\t2\n\t\t3\n\t\t45\n\t\t============================================================\n-----------------------------------------------------------------------------------------------------\n# if...else 和 if...else if的区别\n\t[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)\n\t>* 问题\n\t\t==================== source code ==========================\n\t\twhile (lo < hi) {    // 区间存在\n\t\t\tRank mi =  (lo + hi) >> 1;        // 取中点\n\t\t\tif      (e < elem[mi]) hi = mi;      // 深入前半段查找\n\t\t\telse if (elem[mi] < e) lo = mi + 1;  // 深入后半段查找\n\t\t\telse                   return mi;    // 在mi命中\n\t\t}\n\t\t===========================================================\n\t\tif, else...if 和 else是什么关系？\n\t\t从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。\n\t\n\t>* if...else\n\t\t====\n\t\tint i = 6;\n\t\tif (i == 5) {std::cout << \"i = 5\" << std::endl;\n\t\t} else {\n\t\t\tif (i > 5) {std::cout << \"i > 5\" << std::endl;\n\t\t\t} else { std::cout << \"i < 5\" << std::endl;}\n\t\t}\n\t\t--------------------- ./a.out ---------------------------\n\t\ti > 5\n\t\t===\n\t>* if...else if...else if\n\t\t===\n\t\tint i = 4;\n\t\tif (i == 5) std::cout << \"i = 5\" << std::endl;\n\t\telse if (i < 5) std::cout << \"i < 5\" << std::endl;\n\t\telse if (i > 5) std::cout << \"i > 5\" << std::endl;\n\t\t-----\n\t\ti < 5\n\t\t===\n\t>* if\n\t\t===\n\t\tint i = 6;\n\t\tif (i == 6) std::cout << \"i = 6\" << std::endl;\n\t\tif (i != 7) std::cout << \"i != 7\" << std::endl;\n\t\t----------------- ./a.out --------------------------\n\t\ti =  6\n\t\ti != 7\n\t\t====================================================\n\t>* 各自的作用域辨析\n\t\t==================== source code ==========================\n\t\tbool foo = false, bar = true, baz = true;\n\t\tif (foo) {\n\t\t\t// <- this block is only executed if 'foo' is true\n\t\t\tstd::cout << \"if(foo)\\n\";\n\t\t} else if (bar) {  // <- 'bar' is only checked if 'foo' is false\n\t\t\t// <- this block only executed if 'foo' is false and 'bar' is true\n\t\t\tstd::cout << \"else if(bar)\\n\";\n\t\t} else {\n\t\t\t// <- this block only executed if 'foo' and 'bar' are both false\n\t\t\tstd::cout << \"else {}\\n\";\n\t\t}\n\t\tif (baz) {   // <- no 'else', so previous 'ifs' don't matter\n\t\t\t// <- this block only executed if 'baz' is true.   foo/bar don't matter\n\t\t\tstd::cout << \"if(baz)\\n\";\n\t\t}\n\t\t---------------------- ./a.out ----------------------------------\n\t\t// else if(bar)\n\t\t// if(baz)\n\t\t==============================================================\n\t\t我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。\n\t\t这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。\n\t>* 总结\n\t\tif(i < n), if...else(n < i), 这两个语句条件除了n = i互补。\n\t\t如果有一个true, 则不会执行接下来的else; \n\t\t如果都为false, else执行, 条件相当于(n==i)为true.\n\t\t\n\t\t因此，对于二分查找来说, \n\t\t前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。\n\t\t\n\t\t1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序\n\t\t2, if...else 多用 (cond)? expre1 : expre2; 代替\n\t\t===== source code ======\n\t\tint i = 4, count = 0;\n\t\t(i == 4) ? count++\n\t\t\t: i = 4;\n\t\t========================\n\t\t缺点是执行的语句只能为一个表达式且单行, 也不能return\n\t\t3, if, if 语句多为两个condtions没有并列关系。\n```\n","source":"_posts/cpp/cpp-notes-0004.md","raw":"---\ntitle: C++ Zero To One 0.004\ndate: 2018-01-12 10:28:06\ntags: [C++]\n---\n\n\n```\n# 1, bool和int的隐式转换\n\t[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)\n\t\n\t>* 问题起因\n\t\t======================= source code =========================\n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\tint count = 0;   // 计数器\n\t\tfor (int i = i; i < _size; i++)\n\t\t\tcount += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换\n\t\treturn count;\n\t\t}\n\t\t=============================================================\n\t\t数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。\n\t\n\t>* sizeof(bool) = 1\n  \n\t>* bool-> not bool\n\t\t布尔值转赋值给非布尔值, 初始值false时0, true时1 \t\n\t\n\t>* not bool -> bool\n\t\t非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;\n\t\n\t\t其他都没什么问题, 值得注意的是, 引用和指针\n\t\t=================== source code =============================\n\t\tvoid f_to_bool() {\n\t\tint i1 = 5, i2 = 0;\n\t\tint* pi0 = 0;       // 定义空指针\n\t\tint* pi1 = &i1;      // 指针指向i1\n\t\tint& ri0 = i2;      // 引用i2, i2的值为0\n\t\tint& ri1 = i1;      // 引用i1\n\t\t\n\t\tbool bi = i1;        // prints  bi = 1\n\t\tbool bpi0 = pi0;     // prints  bpi0 = 0\n\t\tbool bpi1 = pi1;     //         bpi1 = 1\n\t\tbool bri0 = ri0;     //         bri0 = 0\n\t\tbool bri1 = ri1;     //         bri1 = 1\n\t\t=============================================================\n----------------------------------------------------------------------------------------------------  \n# 2, 不能返回函数内部初始化的指针\n\t[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)\n\n\t>* 问题\n\t\t数据结构学习中, Rank* deduplicate_lower();\n\t\t我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。\n\t>* 错误的方法\n\t\t函数体内声明定义的指针，返回不了\n\t\t===================== source code ===========================\n\t\tint* f() {\n\t\t\tint iarr[] = {};\n\t\t\tiarr[0] = 2;\n\t\t\treturn iarr;\n\t\t}\n\t\t--------------------- ./a.out -----------------------------\n\t\twarning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]\n\t\t============================================================\n\t\t我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。\n\t\n\t>* 可行的方法\n\t\t将指针作为参数传入\n\t\t================== source code =============================\n\t\tint* f1(int* iarr) {\n\t\t\t*iarr += 1;\n\t\t\treturn iarr;\n\t\t}\n\t\t===========================================================\n\t\t另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??\n\t\t便于函数之间的调用, 还是需要的。\n\t\n\t>* 另一种可行方法: malloc返回指针\n\t\t================= source code ============================\n\t\t// 强制返回指针, 分配内存却不释放\n\t\tint* fun() {\n\t\t\tint* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存\n\t\t\tfor (int i = 0; i < sizeof(int*); i++)\n\t\t\t\t*(i_ptr+i) = 0;\n\t\t\t// free(i_ptr);  // 释放指针\n\t\t\treturn i_ptr;    // 函数返回指针\n\t\t}\n\t\t============================================================\n---------------------------------------------------------------------------------------\n# 3, malloc和free\n\t[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)\n  \n\t> * 概念\n\t\tmalloc:\n\t\tvoid* malloc (size_t size);\n\t\t在语句块中分配一个memeory, 返回一个在作用域中的指针\n\t\tfree:\n\t\tvoid free(void* ptr);\n\t\t重新分配作用域中的memeory, 给未来的分配使用\n\t\n\t> * 需要include的库\n\t\t#include <stdlib.h>\n\t\t#include <stdio.h>\n\t\n\t> * 案例\n\t\t=================== source code ===========================\n\t\tint main() {\n\t\t\tint i, n;\n\t\t\tchar* buffer;\n\n\t        printf(\"how long do you want the string?\");\n\t\t\tscanf(\"%d\", &i);\n\n\t        buffer = (char*) malloc(i+1);\n\t        if (buffer==NULL) exit(1);\n\n\t        for (n=0; n < i; n++)\n\t\t\t\tbuffer[n] = rand()%26 + 'a';\n\t\t\tbuffer[i] = '\\0';\n\n\t        printf(\"Random string: %s\\n\", buffer);\n\t        free(buffer);\n\t\t}\n\t\t------------------ ./a.out -------------------------------\n\t\thow long do you want the string?5\n\t\tRandom string: nwlrb\n\t\t===========================================================\n------------------------------------------------------------------------------------------\n# 4, 未声明大小的数组\n\t[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)\n\n\t> * 问题\n\t\t=================== source code ===========================\n\t\tint size = 5;\n\t\tint iarr[size] = {};\n\t\t------------------- ./a.out ----------------------------------\n\t\terror: variable-sized object ‘iarr1’ may not be initialized\n\t\t===========================================================\n\t\n\t> * const\n\t\t=========== source code ==========\n\t\tconst unsigned int size = 5;\n\t\tint iarr1[size] = {};\n\t\t==================================\n\t\n\t> * define\n\t\t========== source code ==============\n\t\t#define ARRAY_SIZE 5;\n\t\t// #define ARRAY_SIZE = 5;    // ERROR\n\t\tint iarr[ARRAY_SIZE] = {}\n\t\t======================================\n-------------------------------------------------------------------------------------------------\n# 5, continue 和 break 区别\n\t[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)\n\t\n\t> * 概念 \n\t\tcontinue: 跳过for, range-for, while or do-while, 循环体剩余部分 \n\t\tbreak: 闭合的for, range-for, while, do-while 循环或 switch选择终止\n\t\n\t> * continue实例:\n\t\tloop:\n\t\t=================== source code ============================\n\t\t// 跳过loop剩余部分\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 2; j <7; j++) {\n\t\t\t\tif (j - i == 2) {\n\t\t\t\tstd::cout << \"j-i = 2\" << std::endl;\n\t\t\t\tcontinue;}\n\t\t\t\t// ...\n\t\t\t\tstd::cout << \"after continue \" << std::endl;\n\t\t\t}\n\t\t}\n\t\t============================================================\n\n    > * break实例:\t\n\t\t1, loop:\n\t\t==================== source code ===========================\n\t\t// 终止循环\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 2; j <7; j++) {\n\t\t\t\tif (j - i == 2) {break;}      // 终止内存循环\n\t\t\t\tstd::cout << \"j - i = \" << j - i << std::endl;\n\t\t\t}\n\t\t}\n\t\t============================================================\n\t\n\t\t2, switch\n\t\t=================== source code ===========================\n\t\tint i = 2;\n\t\tswitch (i) {\n\t\t\tcase 1: std::cout << \"1\\n\";\n\t\t\tcase 2: std::cout << \"2\\n\";         // 选择到这里\n\t\t\tcase 3: std::cout << \"3\\n\";\n\t\t\tcase 4:\n\t\t\tcase 5: std::cout << \"45 \\n\";\n\t\t\t\tbreak;                            // 终止switch\n\t\t\tcase 6: std::cout << \"6\\n\";\n\t\t}\n\t\t------------------- ./a.out ------------------------------\n\t\t2\n\t\t3\n\t\t45\n\t\t============================================================\n-----------------------------------------------------------------------------------------------------\n# if...else 和 if...else if的区别\n\t[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)\n\t>* 问题\n\t\t==================== source code ==========================\n\t\twhile (lo < hi) {    // 区间存在\n\t\t\tRank mi =  (lo + hi) >> 1;        // 取中点\n\t\t\tif      (e < elem[mi]) hi = mi;      // 深入前半段查找\n\t\t\telse if (elem[mi] < e) lo = mi + 1;  // 深入后半段查找\n\t\t\telse                   return mi;    // 在mi命中\n\t\t}\n\t\t===========================================================\n\t\tif, else...if 和 else是什么关系？\n\t\t从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。\n\t\n\t>* if...else\n\t\t====\n\t\tint i = 6;\n\t\tif (i == 5) {std::cout << \"i = 5\" << std::endl;\n\t\t} else {\n\t\t\tif (i > 5) {std::cout << \"i > 5\" << std::endl;\n\t\t\t} else { std::cout << \"i < 5\" << std::endl;}\n\t\t}\n\t\t--------------------- ./a.out ---------------------------\n\t\ti > 5\n\t\t===\n\t>* if...else if...else if\n\t\t===\n\t\tint i = 4;\n\t\tif (i == 5) std::cout << \"i = 5\" << std::endl;\n\t\telse if (i < 5) std::cout << \"i < 5\" << std::endl;\n\t\telse if (i > 5) std::cout << \"i > 5\" << std::endl;\n\t\t-----\n\t\ti < 5\n\t\t===\n\t>* if\n\t\t===\n\t\tint i = 6;\n\t\tif (i == 6) std::cout << \"i = 6\" << std::endl;\n\t\tif (i != 7) std::cout << \"i != 7\" << std::endl;\n\t\t----------------- ./a.out --------------------------\n\t\ti =  6\n\t\ti != 7\n\t\t====================================================\n\t>* 各自的作用域辨析\n\t\t==================== source code ==========================\n\t\tbool foo = false, bar = true, baz = true;\n\t\tif (foo) {\n\t\t\t// <- this block is only executed if 'foo' is true\n\t\t\tstd::cout << \"if(foo)\\n\";\n\t\t} else if (bar) {  // <- 'bar' is only checked if 'foo' is false\n\t\t\t// <- this block only executed if 'foo' is false and 'bar' is true\n\t\t\tstd::cout << \"else if(bar)\\n\";\n\t\t} else {\n\t\t\t// <- this block only executed if 'foo' and 'bar' are both false\n\t\t\tstd::cout << \"else {}\\n\";\n\t\t}\n\t\tif (baz) {   // <- no 'else', so previous 'ifs' don't matter\n\t\t\t// <- this block only executed if 'baz' is true.   foo/bar don't matter\n\t\t\tstd::cout << \"if(baz)\\n\";\n\t\t}\n\t\t---------------------- ./a.out ----------------------------------\n\t\t// else if(bar)\n\t\t// if(baz)\n\t\t==============================================================\n\t\t我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。\n\t\t这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。\n\t>* 总结\n\t\tif(i < n), if...else(n < i), 这两个语句条件除了n = i互补。\n\t\t如果有一个true, 则不会执行接下来的else; \n\t\t如果都为false, else执行, 条件相当于(n==i)为true.\n\t\t\n\t\t因此，对于二分查找来说, \n\t\t前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。\n\t\t\n\t\t1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序\n\t\t2, if...else 多用 (cond)? expre1 : expre2; 代替\n\t\t===== source code ======\n\t\tint i = 4, count = 0;\n\t\t(i == 4) ? count++\n\t\t\t: i = 4;\n\t\t========================\n\t\t缺点是执行的语句只能为一个表达式且单行, 也不能return\n\t\t3, if, if 语句多为两个condtions没有并列关系。\n```\n","slug":"cpp/cpp-notes-0004","published":1,"updated":"2018-06-19T16:15:03.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyk9001sk8mff5tbgzxw","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 1, bool和int的隐式转换</span><br><span class=\"line\">\t[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 问题起因</span><br><span class=\"line\">\t\t======================= source code =========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\tint count = 0;   // 计数器</span><br><span class=\"line\">\t\tfor (int i = i; i &lt; _size; i++)</span><br><span class=\"line\">\t\t\tcount += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class=\"line\">\t\treturn count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* sizeof(bool) = 1</span><br><span class=\"line\">  </span><br><span class=\"line\">\t&gt;* bool-&gt; not bool</span><br><span class=\"line\">\t\t布尔值转赋值给非布尔值, 初始值false时0, true时1 \t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* not bool -&gt; bool</span><br><span class=\"line\">\t\t非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class=\"line\">\t\t=================== source code =============================</span><br><span class=\"line\">\t\tvoid f_to_bool() &#123;</span><br><span class=\"line\">\t\tint i1 = 5, i2 = 0;</span><br><span class=\"line\">\t\tint* pi0 = 0;       // 定义空指针</span><br><span class=\"line\">\t\tint* pi1 = &amp;i1;      // 指针指向i1</span><br><span class=\"line\">\t\tint&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class=\"line\">\t\tint&amp; ri1 = i1;      // 引用i1</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tbool bi = i1;        // prints  bi = 1</span><br><span class=\"line\">\t\tbool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class=\"line\">\t\tbool bpi1 = pi1;     //         bpi1 = 1</span><br><span class=\"line\">\t\tbool bri0 = ri0;     //         bri0 = 0</span><br><span class=\"line\">\t\tbool bri1 = ri1;     //         bri1 = 1</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">----------------------------------------------------------------------------------------------------  </span><br><span class=\"line\"># 2, 不能返回函数内部初始化的指针</span><br><span class=\"line\">\t[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 问题</span><br><span class=\"line\">\t\t数据结构学习中, Rank* deduplicate_lower();</span><br><span class=\"line\">\t\t我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class=\"line\">\t&gt;* 错误的方法</span><br><span class=\"line\">\t\t函数体内声明定义的指针，返回不了</span><br><span class=\"line\">\t\t===================== source code ===========================</span><br><span class=\"line\">\t\tint* f() &#123;</span><br><span class=\"line\">\t\t\tint iarr[] = &#123;&#125;;</span><br><span class=\"line\">\t\t\tiarr[0] = 2;</span><br><span class=\"line\">\t\t\treturn iarr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--------------------- ./a.out -----------------------------</span><br><span class=\"line\">\t\twarning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 可行的方法</span><br><span class=\"line\">\t\t将指针作为参数传入</span><br><span class=\"line\">\t\t================== source code =============================</span><br><span class=\"line\">\t\tint* f1(int* iarr) &#123;</span><br><span class=\"line\">\t\t\t*iarr += 1;</span><br><span class=\"line\">\t\t\treturn iarr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class=\"line\">\t\t便于函数之间的调用, 还是需要的。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 另一种可行方法: malloc返回指针</span><br><span class=\"line\">\t\t================= source code ============================</span><br><span class=\"line\">\t\t// 强制返回指针, 分配内存却不释放</span><br><span class=\"line\">\t\tint* fun() &#123;</span><br><span class=\"line\">\t\t\tint* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class=\"line\">\t\t\t\t*(i_ptr+i) = 0;</span><br><span class=\"line\">\t\t\t// free(i_ptr);  // 释放指针</span><br><span class=\"line\">\t\t\treturn i_ptr;    // 函数返回指针</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">---------------------------------------------------------------------------------------</span><br><span class=\"line\"># 3, malloc和free</span><br><span class=\"line\">\t[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class=\"line\">  </span><br><span class=\"line\">\t&gt; * 概念</span><br><span class=\"line\">\t\tmalloc:</span><br><span class=\"line\">\t\tvoid* malloc (size_t size);</span><br><span class=\"line\">\t\t在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class=\"line\">\t\tfree:</span><br><span class=\"line\">\t\tvoid free(void* ptr);</span><br><span class=\"line\">\t\t重新分配作用域中的memeory, 给未来的分配使用</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 需要include的库</span><br><span class=\"line\">\t\t#include &lt;stdlib.h&gt;</span><br><span class=\"line\">\t\t#include &lt;stdio.h&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 案例</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint main() &#123;</span><br><span class=\"line\">\t\t\tint i, n;</span><br><span class=\"line\">\t\t\tchar* buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        printf(&quot;how long do you want the string?&quot;);</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;, &amp;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        buffer = (char*) malloc(i+1);</span><br><span class=\"line\">\t        if (buffer==NULL) exit(1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        for (n=0; n &lt; i; n++)</span><br><span class=\"line\">\t\t\t\tbuffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class=\"line\">\t\t\tbuffer[i] = &apos;\\0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        printf(&quot;Random string: %s\\n&quot;, buffer);</span><br><span class=\"line\">\t        free(buffer);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t------------------ ./a.out -------------------------------</span><br><span class=\"line\">\t\thow long do you want the string?5</span><br><span class=\"line\">\t\tRandom string: nwlrb</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">------------------------------------------------------------------------------------------</span><br><span class=\"line\"># 4, 未声明大小的数组</span><br><span class=\"line\">\t[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; * 问题</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint size = 5;</span><br><span class=\"line\">\t\tint iarr[size] = &#123;&#125;;</span><br><span class=\"line\">\t\t------------------- ./a.out ----------------------------------</span><br><span class=\"line\">\t\terror: variable-sized object ‘iarr1’ may not be initialized</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * const</span><br><span class=\"line\">\t\t=========== source code ==========</span><br><span class=\"line\">\t\tconst unsigned int size = 5;</span><br><span class=\"line\">\t\tint iarr1[size] = &#123;&#125;;</span><br><span class=\"line\">\t\t==================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * define</span><br><span class=\"line\">\t\t========== source code ==============</span><br><span class=\"line\">\t\t#define ARRAY_SIZE 5;</span><br><span class=\"line\">\t\t// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class=\"line\">\t\tint iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class=\"line\">\t\t======================================</span><br><span class=\"line\">-------------------------------------------------------------------------------------------------</span><br><span class=\"line\"># 5, continue 和 break 区别</span><br><span class=\"line\">\t[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 概念 </span><br><span class=\"line\">\t\tcontinue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class=\"line\">\t\tbreak: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * continue实例:</span><br><span class=\"line\">\t\tloop:</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\t// 跳过loop剩余部分</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 2; j &lt;7; j++) &#123;</span><br><span class=\"line\">\t\t\t\tif (j - i == 2) &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t\tcontinue;&#125;</span><br><span class=\"line\">\t\t\t\t// ...</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">    &gt; * break实例:\t</span><br><span class=\"line\">\t\t1, loop:</span><br><span class=\"line\">\t\t==================== source code ===========================</span><br><span class=\"line\">\t\t// 终止循环</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 2; j &lt;7; j++) &#123;</span><br><span class=\"line\">\t\t\t\tif (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t2, switch</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint i = 2;</span><br><span class=\"line\">\t\tswitch (i) &#123;</span><br><span class=\"line\">\t\t\tcase 1: std::cout &lt;&lt; &quot;1\\n&quot;;</span><br><span class=\"line\">\t\t\tcase 2: std::cout &lt;&lt; &quot;2\\n&quot;;         // 选择到这里</span><br><span class=\"line\">\t\t\tcase 3: std::cout &lt;&lt; &quot;3\\n&quot;;</span><br><span class=\"line\">\t\t\tcase 4:</span><br><span class=\"line\">\t\t\tcase 5: std::cout &lt;&lt; &quot;45 \\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;                            // 终止switch</span><br><span class=\"line\">\t\t\tcase 6: std::cout &lt;&lt; &quot;6\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t------------------- ./a.out ------------------------------</span><br><span class=\"line\">\t\t2</span><br><span class=\"line\">\t\t3</span><br><span class=\"line\">\t\t45</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">-----------------------------------------------------------------------------------------------------</span><br><span class=\"line\"># if...else 和 if...else if的区别</span><br><span class=\"line\">\t[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class=\"line\">\t&gt;* 问题</span><br><span class=\"line\">\t\t==================== source code ==========================</span><br><span class=\"line\">\t\twhile (lo &lt; hi) &#123;    // 区间存在</span><br><span class=\"line\">\t\t\tRank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class=\"line\">\t\t\tif      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class=\"line\">\t\t\telse if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class=\"line\">\t\t\telse                   return mi;    // 在mi命中</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\tif, else...if 和 else是什么关系？</span><br><span class=\"line\">\t\t从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* if...else</span><br><span class=\"line\">\t\t====</span><br><span class=\"line\">\t\tint i = 6;</span><br><span class=\"line\">\t\tif (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tif (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--------------------- ./a.out ---------------------------</span><br><span class=\"line\">\t\ti &gt; 5</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t&gt;* if...else if...else if</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t\tint i = 4;</span><br><span class=\"line\">\t\tif (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\telse if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\telse if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t-----</span><br><span class=\"line\">\t\ti &lt; 5</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t&gt;* if</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t\tint i = 6;</span><br><span class=\"line\">\t\tif (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tif (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t----------------- ./a.out --------------------------</span><br><span class=\"line\">\t\ti =  6</span><br><span class=\"line\">\t\ti != 7</span><br><span class=\"line\">\t\t====================================================</span><br><span class=\"line\">\t&gt;* 各自的作用域辨析</span><br><span class=\"line\">\t\t==================== source code ==========================</span><br><span class=\"line\">\t\tbool foo = false, bar = true, baz = true;</span><br><span class=\"line\">\t\tif (foo) &#123;</span><br><span class=\"line\">\t\t\t// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;if(foo)\\n&quot;;</span><br><span class=\"line\">\t\t&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;else if(bar)\\n&quot;;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;else &#123;&#125;\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;if(baz)\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t---------------------- ./a.out ----------------------------------</span><br><span class=\"line\">\t\t// else if(bar)</span><br><span class=\"line\">\t\t// if(baz)</span><br><span class=\"line\">\t\t==============================================================</span><br><span class=\"line\">\t\t我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class=\"line\">\t\t这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class=\"line\">\t&gt;* 总结</span><br><span class=\"line\">\t\tif(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class=\"line\">\t\t如果有一个true, 则不会执行接下来的else; </span><br><span class=\"line\">\t\t如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t因此，对于二分查找来说, </span><br><span class=\"line\">\t\t前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class=\"line\">\t\t2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class=\"line\">\t\t===== source code ======</span><br><span class=\"line\">\t\tint i = 4, count = 0;</span><br><span class=\"line\">\t\t(i == 4) ? count++</span><br><span class=\"line\">\t\t\t: i = 4;</span><br><span class=\"line\">\t\t========================</span><br><span class=\"line\">\t\t缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class=\"line\">\t\t3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 1, bool和int的隐式转换</span><br><span class=\"line\">\t[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 问题起因</span><br><span class=\"line\">\t\t======================= source code =========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\tint count = 0;   // 计数器</span><br><span class=\"line\">\t\tfor (int i = i; i &lt; _size; i++)</span><br><span class=\"line\">\t\t\tcount += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class=\"line\">\t\treturn count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* sizeof(bool) = 1</span><br><span class=\"line\">  </span><br><span class=\"line\">\t&gt;* bool-&gt; not bool</span><br><span class=\"line\">\t\t布尔值转赋值给非布尔值, 初始值false时0, true时1 \t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* not bool -&gt; bool</span><br><span class=\"line\">\t\t非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class=\"line\">\t\t=================== source code =============================</span><br><span class=\"line\">\t\tvoid f_to_bool() &#123;</span><br><span class=\"line\">\t\tint i1 = 5, i2 = 0;</span><br><span class=\"line\">\t\tint* pi0 = 0;       // 定义空指针</span><br><span class=\"line\">\t\tint* pi1 = &amp;i1;      // 指针指向i1</span><br><span class=\"line\">\t\tint&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class=\"line\">\t\tint&amp; ri1 = i1;      // 引用i1</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tbool bi = i1;        // prints  bi = 1</span><br><span class=\"line\">\t\tbool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class=\"line\">\t\tbool bpi1 = pi1;     //         bpi1 = 1</span><br><span class=\"line\">\t\tbool bri0 = ri0;     //         bri0 = 0</span><br><span class=\"line\">\t\tbool bri1 = ri1;     //         bri1 = 1</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">----------------------------------------------------------------------------------------------------  </span><br><span class=\"line\"># 2, 不能返回函数内部初始化的指针</span><br><span class=\"line\">\t[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 问题</span><br><span class=\"line\">\t\t数据结构学习中, Rank* deduplicate_lower();</span><br><span class=\"line\">\t\t我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class=\"line\">\t&gt;* 错误的方法</span><br><span class=\"line\">\t\t函数体内声明定义的指针，返回不了</span><br><span class=\"line\">\t\t===================== source code ===========================</span><br><span class=\"line\">\t\tint* f() &#123;</span><br><span class=\"line\">\t\t\tint iarr[] = &#123;&#125;;</span><br><span class=\"line\">\t\t\tiarr[0] = 2;</span><br><span class=\"line\">\t\t\treturn iarr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--------------------- ./a.out -----------------------------</span><br><span class=\"line\">\t\twarning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 可行的方法</span><br><span class=\"line\">\t\t将指针作为参数传入</span><br><span class=\"line\">\t\t================== source code =============================</span><br><span class=\"line\">\t\tint* f1(int* iarr) &#123;</span><br><span class=\"line\">\t\t\t*iarr += 1;</span><br><span class=\"line\">\t\t\treturn iarr;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class=\"line\">\t\t便于函数之间的调用, 还是需要的。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 另一种可行方法: malloc返回指针</span><br><span class=\"line\">\t\t================= source code ============================</span><br><span class=\"line\">\t\t// 强制返回指针, 分配内存却不释放</span><br><span class=\"line\">\t\tint* fun() &#123;</span><br><span class=\"line\">\t\t\tint* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class=\"line\">\t\t\t\t*(i_ptr+i) = 0;</span><br><span class=\"line\">\t\t\t// free(i_ptr);  // 释放指针</span><br><span class=\"line\">\t\t\treturn i_ptr;    // 函数返回指针</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">---------------------------------------------------------------------------------------</span><br><span class=\"line\"># 3, malloc和free</span><br><span class=\"line\">\t[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class=\"line\">  </span><br><span class=\"line\">\t&gt; * 概念</span><br><span class=\"line\">\t\tmalloc:</span><br><span class=\"line\">\t\tvoid* malloc (size_t size);</span><br><span class=\"line\">\t\t在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class=\"line\">\t\tfree:</span><br><span class=\"line\">\t\tvoid free(void* ptr);</span><br><span class=\"line\">\t\t重新分配作用域中的memeory, 给未来的分配使用</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 需要include的库</span><br><span class=\"line\">\t\t#include &lt;stdlib.h&gt;</span><br><span class=\"line\">\t\t#include &lt;stdio.h&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 案例</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint main() &#123;</span><br><span class=\"line\">\t\t\tint i, n;</span><br><span class=\"line\">\t\t\tchar* buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        printf(&quot;how long do you want the string?&quot;);</span><br><span class=\"line\">\t\t\tscanf(&quot;%d&quot;, &amp;i);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        buffer = (char*) malloc(i+1);</span><br><span class=\"line\">\t        if (buffer==NULL) exit(1);</span><br><span class=\"line\"></span><br><span class=\"line\">\t        for (n=0; n &lt; i; n++)</span><br><span class=\"line\">\t\t\t\tbuffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class=\"line\">\t\t\tbuffer[i] = &apos;\\0&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        printf(&quot;Random string: %s\\n&quot;, buffer);</span><br><span class=\"line\">\t        free(buffer);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t------------------ ./a.out -------------------------------</span><br><span class=\"line\">\t\thow long do you want the string?5</span><br><span class=\"line\">\t\tRandom string: nwlrb</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">------------------------------------------------------------------------------------------</span><br><span class=\"line\"># 4, 未声明大小的数组</span><br><span class=\"line\">\t[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; * 问题</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint size = 5;</span><br><span class=\"line\">\t\tint iarr[size] = &#123;&#125;;</span><br><span class=\"line\">\t\t------------------- ./a.out ----------------------------------</span><br><span class=\"line\">\t\terror: variable-sized object ‘iarr1’ may not be initialized</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * const</span><br><span class=\"line\">\t\t=========== source code ==========</span><br><span class=\"line\">\t\tconst unsigned int size = 5;</span><br><span class=\"line\">\t\tint iarr1[size] = &#123;&#125;;</span><br><span class=\"line\">\t\t==================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * define</span><br><span class=\"line\">\t\t========== source code ==============</span><br><span class=\"line\">\t\t#define ARRAY_SIZE 5;</span><br><span class=\"line\">\t\t// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class=\"line\">\t\tint iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class=\"line\">\t\t======================================</span><br><span class=\"line\">-------------------------------------------------------------------------------------------------</span><br><span class=\"line\"># 5, continue 和 break 区别</span><br><span class=\"line\">\t[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 概念 </span><br><span class=\"line\">\t\tcontinue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class=\"line\">\t\tbreak: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * continue实例:</span><br><span class=\"line\">\t\tloop:</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\t// 跳过loop剩余部分</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 2; j &lt;7; j++) &#123;</span><br><span class=\"line\">\t\t\t\tif (j - i == 2) &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t\tcontinue;&#125;</span><br><span class=\"line\">\t\t\t\t// ...</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">    &gt; * break实例:\t</span><br><span class=\"line\">\t\t1, loop:</span><br><span class=\"line\">\t\t==================== source code ===========================</span><br><span class=\"line\">\t\t// 终止循环</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tfor (int j = 2; j &lt;7; j++) &#123;</span><br><span class=\"line\">\t\t\t\tif (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t2, switch</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tint i = 2;</span><br><span class=\"line\">\t\tswitch (i) &#123;</span><br><span class=\"line\">\t\t\tcase 1: std::cout &lt;&lt; &quot;1\\n&quot;;</span><br><span class=\"line\">\t\t\tcase 2: std::cout &lt;&lt; &quot;2\\n&quot;;         // 选择到这里</span><br><span class=\"line\">\t\t\tcase 3: std::cout &lt;&lt; &quot;3\\n&quot;;</span><br><span class=\"line\">\t\t\tcase 4:</span><br><span class=\"line\">\t\t\tcase 5: std::cout &lt;&lt; &quot;45 \\n&quot;;</span><br><span class=\"line\">\t\t\t\tbreak;                            // 终止switch</span><br><span class=\"line\">\t\t\tcase 6: std::cout &lt;&lt; &quot;6\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t------------------- ./a.out ------------------------------</span><br><span class=\"line\">\t\t2</span><br><span class=\"line\">\t\t3</span><br><span class=\"line\">\t\t45</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">-----------------------------------------------------------------------------------------------------</span><br><span class=\"line\"># if...else 和 if...else if的区别</span><br><span class=\"line\">\t[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class=\"line\">\t&gt;* 问题</span><br><span class=\"line\">\t\t==================== source code ==========================</span><br><span class=\"line\">\t\twhile (lo &lt; hi) &#123;    // 区间存在</span><br><span class=\"line\">\t\t\tRank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class=\"line\">\t\t\tif      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class=\"line\">\t\t\telse if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class=\"line\">\t\t\telse                   return mi;    // 在mi命中</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\tif, else...if 和 else是什么关系？</span><br><span class=\"line\">\t\t从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* if...else</span><br><span class=\"line\">\t\t====</span><br><span class=\"line\">\t\tint i = 6;</span><br><span class=\"line\">\t\tif (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tif (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t--------------------- ./a.out ---------------------------</span><br><span class=\"line\">\t\ti &gt; 5</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t&gt;* if...else if...else if</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t\tint i = 4;</span><br><span class=\"line\">\t\tif (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\telse if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\telse if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t-----</span><br><span class=\"line\">\t\ti &lt; 5</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t&gt;* if</span><br><span class=\"line\">\t\t===</span><br><span class=\"line\">\t\tint i = 6;</span><br><span class=\"line\">\t\tif (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tif (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t----------------- ./a.out --------------------------</span><br><span class=\"line\">\t\ti =  6</span><br><span class=\"line\">\t\ti != 7</span><br><span class=\"line\">\t\t====================================================</span><br><span class=\"line\">\t&gt;* 各自的作用域辨析</span><br><span class=\"line\">\t\t==================== source code ==========================</span><br><span class=\"line\">\t\tbool foo = false, bar = true, baz = true;</span><br><span class=\"line\">\t\tif (foo) &#123;</span><br><span class=\"line\">\t\t\t// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;if(foo)\\n&quot;;</span><br><span class=\"line\">\t\t&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;else if(bar)\\n&quot;;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;else &#123;&#125;\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class=\"line\">\t\t\t// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;if(baz)\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t---------------------- ./a.out ----------------------------------</span><br><span class=\"line\">\t\t// else if(bar)</span><br><span class=\"line\">\t\t// if(baz)</span><br><span class=\"line\">\t\t==============================================================</span><br><span class=\"line\">\t\t我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class=\"line\">\t\t这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class=\"line\">\t&gt;* 总结</span><br><span class=\"line\">\t\tif(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class=\"line\">\t\t如果有一个true, 则不会执行接下来的else; </span><br><span class=\"line\">\t\t如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t因此，对于二分查找来说, </span><br><span class=\"line\">\t\t前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class=\"line\">\t\t2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class=\"line\">\t\t===== source code ======</span><br><span class=\"line\">\t\tint i = 4, count = 0;</span><br><span class=\"line\">\t\t(i == 4) ? count++</span><br><span class=\"line\">\t\t\t: i = 4;</span><br><span class=\"line\">\t\t========================</span><br><span class=\"line\">\t\t缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class=\"line\">\t\t3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>\n"},{"title":"C++ Zero To One 0.005","date":"2018-01-13T13:42:33.000Z","_content":"```\n1, protected能否被实例对象访问\n\n\t>* 发现问题\t\n\t\t重新实现Vector中, 要对ADT的access进行区别。\n\t\tprotected能否被实例对象访问?\n\t\tprotected能否被继承类访问?\n\t>* 尝试\n\t\t=================== source code ===========================\n\t\tclass Base {\n\t\tprivate:\n\t\t\tint i = 0;\n\t\t\tvoid f_priv() {std::cout << \"calling f_priv() in private\" << std::endl;}\n\t\tprotected:\n\t\t\tvoid f_prot() {std::cout << \"calling f_prot() in protected\" << std::endl;}\n\t\tpublic:\n\t\t\tvoid f() {\n\t\t\t\tstd::cout << \"calling f() in public\" << std::endl;\n\t\t\t\tf_prot();\n\t\t\t}\n\t\t};\n\t\t\n\t\tclass Derived : Base {\n\t\tpublic:\n\t\t\tvoid call_f_prot() {f_prot();}\n\t\t\t// void call_f_priv() {f_priv();}    // private不能被继承类直接访问\n\t\t};\n\t\t\n\t\tint main() {\n\t\t\tBase b;\n\t\t\tDerived d;\n\t\t\t// b.f_prot();      // protected成员不能被实例对象直接访问\n\t\t\td.call_f_prot();    // 通过继承类的public成员, 访问基类的protected\n\t\t\t// d.call_f_priv();\n\t\t\treturn 0;\n\t\t}\n\t\t=============================================================\n\t\t\n\t>* 特点\n\t\tprotected不会被实例访问, 会被继承类在类中进行访问。\n\t\t\n\t\t希望用户不能访问到protected中的成员, 但继承类能够访问到。\n\t\t而private让用户和继承类都不能访问到, 只有友元能访问到。\n---------------------------------------------------------------------------------------------\n\n2, for循环语句的简单写法\n\t\n\t>* 发现问题\n\tfor语句的三个表达式如何写?\n\tVector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)\n\t{_elem = new T[_capacity = c];\n\t\tfor (_size = 0; _size < s; _elem[size++] = v)}     // 默认\n\t\t\n\t>* 利用for的参数\n\t\tfor ( declaration-or-expression(optional) ; \n\t\t\tdeclaration-or-expression(optional) ; \n\t\t\texpression(optional) )\n\t\t=================== source code ============================\n\t\tconst int s = 8;\n\t\tint size = 0;\n\t\tint elem[s] = {};\n\t\t/*\n\t\tfor (size = 0; size < s; size++) {\n\t\t\telem[size] = 2;\n\t\t}\n\t\t*/\n\t\t// 第三个参数, 递增size的同时, 给修改elem\n\t\tfor (size = 0; size < s; elem[size++] = 2) {}\n\t\t// 第三个参数, 修改i的同时, 打印elem[i]对应的元素\n\t\tfor (int i = 0; i < size; std::cout << elem[i++] << std::endl) {}\n\t\t============================================================\n\t>* 反思\n\t\t某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。\n----------------------------------------------------------------------------------------------\n\n3, T const&, const T&, T& const, T const*, const T*, T* const 辨析\n\t\n\t>* 发现问题\n\t\t=================== source code ============================\n\t\tVector(T* const A, Rank lo, Rank hi)           // 数组区间复制\n\t\tVector(Vector<T> const& V, Rank lo, Rank hi)   // 向量区间复制\n\t\t============================================================\n\t\t对上述代码中的 Vector<T> const& V不理解, 为什么const& 跟在type之后? 它是否表达常量引用?\n\n\t>* 常量引用\n\t\ttype const&, type& const之间是什么区别 ?\n\t\t先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.\n\t\t\n\t\t让测试代码跑跑。\n\t\t=================== source code =============================\n\t\tint f() {\n\t\tint a = 0, b = 1;\n\t\tconst int ca = 0, cb = 1;\n\t\t\n\t\tint& ref_a = a;      // ref_a是整数a的引用类型\n\t\tint* ptr_a = &a;     // ptr_a是指向整数a的指针\n\t\tconst int* ptr_ca = &ca;           // ptr_ca是指向常量整型的指针\n\t\tconst int* const cptr_ca = &ca;    // cptr_ca是指向常量整型的常量指针\n\t\tint const& cref_a = a;             // cref_a是对整型的常量引用?\n\t\tconst int& cref_a_1 = ca;          // cref_a_1是对整型常量引用?\n\t\t// const int& const cref_a_2 = ca;    // 对整型常量的常量引用?\n\t\t// const int const& cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?\n\t\t// 引用不能duplicate const\n\t\tf1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&匹配\n\t\t// cref_a++;      // read-only    // 两者都是常量引用\n\t\t// cref_a_1++;    // read-only\n\t\t\n\t\t// 引用指针\n\t\tint* const& cref_ptra = ptr_a;            // 对整型指针的常量引用\n\t\t// int const& cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*\n\t\tconst int* const& cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用\n\t\t// int* const& cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*\n\t\tconst int* const& cref_cptrca = cptr_ca;\n\t\t\n\t\t(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型\n\t\t// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)\n\t\t}\n\t\t\n\t\tvoid f1(int const& ic) {\n\t\t\tstd::cout << \"calling f1()...\\n\";\n\t\t}\n\t\t=============================================================\n\t\t\n\t\t常量引用的写法. 所引用的对象类型为type\n\t\t(type) const& ref_t;\n\t\t// const&写在右边是因为侧重于表明其常量指针\n\t\t\n\t\t另外, 这一type可以是int, const int, int*, const int*等等\n\t\t\n\t>* 常量指针\n\t\t===================== source code ===========================\n\t\tint a = 0, b = 0, c = 0, d = 0;\n\t\tint* p_a = &a;                 // 指向int的指针\n\t\t// 指针地址可变, 指向的a可变\n\t\t(*p_a)++; p_a = &b;\n\t\tstd::cout << \"*p_a = \" << *p_a << \", a = \" << a << std::endl;\n\t\tconst int* p_b = &b;          // 指向const int的指针\n\t\t// 指针地址可变, 指向的元素转换成const不可变\n\t\t// (*p_b)++;\n\t\tp_b = &c;\n\t\tstd::cout << \"*p_b = \" << *p_b << \", b = \" << b << std::endl;\n\t\tint* const cp_c = &c;          // 指向int的const指针\n\t\t// 指针地址不可变, 指向的元素可以变\n\t\t(*cp_c)++;\n\t\t// cp_c = &d;\n\t\tstd::cout << \"*cp_c = \" << *cp_c << \", c = \" << c << std::endl;\n\t\t// int const* cp_c1 = &c;         // 指向const int的指针, 仍采用上种方法\n\t\tconst int* const cp_cd = &d;   // 指向const int的const指针\n\t\t// 指针地址不可变, 指向值不可变\n\t\t// (*cp_cd)++;\n\t\t// cp_cd = &a;\n\t\tstd::cout << \"*cp_cd = \" << *cp_cd << \", d = \" << d << std::endl;\n\t\t------------------------ ./a.out ---------------------------\n\t\t*p_a = 0, a = 1\n\t\t*p_b = 0, b = 0\n\t\t*cp_c = 1, c = 1\n\t\t*cp_cd = 0, d = 0\n\t\t============================================================\n\t\tT*               = &a;      // 指针\n\t\tconst T*         = &ca;     // 指向常量的指针\n\t\tT* const         = &a;      // 常量指针, 指针地址不可变\n\t\tconst T* const   = &ca;     // 指向常量的常量指针, 指向值和指针地址都不可变\n\t\t\n\t>* const_cast<type>();\n\t\t=======\n\t\tint b = 0;\n\t\tconst int* p_b= &b;\n\t\t*(const_cast<int*>(p_b))+=1;   // 这种方式可以让b递增1\n\t\t// (*p_b)++                    // const_cast只是一个临时操作\n\t\t==========\n\t\t一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。\n\t\t我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。\n\t\n\t>*  最初的辨析\n\t\tT const& : 引用, T类型的常量引用, 该引用不会被修改\n\t\tconst T& : 同上, 只是不同写法。现在偏向用上面那种\n\t\tT& const : 非法 \n\t\tT const* : 指针, 指向常量T的指针, const T*相同 \n\t\tconst T* : 指针, 指向常量T的指针, 我偏向用这种\n\t\tT* const : 指针, 指向T的常量指针\n---------------------------------------------------------------------------------------\n\n```\n","source":"_posts/cpp/cpp-notes-0005.md","raw":"---\ntitle: C++ Zero To One 0.005\ndate: 2018-01-13 21:42:33\ntags: [C++, const, 常量指针, 常量引用, protected, for]\n---\n```\n1, protected能否被实例对象访问\n\n\t>* 发现问题\t\n\t\t重新实现Vector中, 要对ADT的access进行区别。\n\t\tprotected能否被实例对象访问?\n\t\tprotected能否被继承类访问?\n\t>* 尝试\n\t\t=================== source code ===========================\n\t\tclass Base {\n\t\tprivate:\n\t\t\tint i = 0;\n\t\t\tvoid f_priv() {std::cout << \"calling f_priv() in private\" << std::endl;}\n\t\tprotected:\n\t\t\tvoid f_prot() {std::cout << \"calling f_prot() in protected\" << std::endl;}\n\t\tpublic:\n\t\t\tvoid f() {\n\t\t\t\tstd::cout << \"calling f() in public\" << std::endl;\n\t\t\t\tf_prot();\n\t\t\t}\n\t\t};\n\t\t\n\t\tclass Derived : Base {\n\t\tpublic:\n\t\t\tvoid call_f_prot() {f_prot();}\n\t\t\t// void call_f_priv() {f_priv();}    // private不能被继承类直接访问\n\t\t};\n\t\t\n\t\tint main() {\n\t\t\tBase b;\n\t\t\tDerived d;\n\t\t\t// b.f_prot();      // protected成员不能被实例对象直接访问\n\t\t\td.call_f_prot();    // 通过继承类的public成员, 访问基类的protected\n\t\t\t// d.call_f_priv();\n\t\t\treturn 0;\n\t\t}\n\t\t=============================================================\n\t\t\n\t>* 特点\n\t\tprotected不会被实例访问, 会被继承类在类中进行访问。\n\t\t\n\t\t希望用户不能访问到protected中的成员, 但继承类能够访问到。\n\t\t而private让用户和继承类都不能访问到, 只有友元能访问到。\n---------------------------------------------------------------------------------------------\n\n2, for循环语句的简单写法\n\t\n\t>* 发现问题\n\tfor语句的三个表达式如何写?\n\tVector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)\n\t{_elem = new T[_capacity = c];\n\t\tfor (_size = 0; _size < s; _elem[size++] = v)}     // 默认\n\t\t\n\t>* 利用for的参数\n\t\tfor ( declaration-or-expression(optional) ; \n\t\t\tdeclaration-or-expression(optional) ; \n\t\t\texpression(optional) )\n\t\t=================== source code ============================\n\t\tconst int s = 8;\n\t\tint size = 0;\n\t\tint elem[s] = {};\n\t\t/*\n\t\tfor (size = 0; size < s; size++) {\n\t\t\telem[size] = 2;\n\t\t}\n\t\t*/\n\t\t// 第三个参数, 递增size的同时, 给修改elem\n\t\tfor (size = 0; size < s; elem[size++] = 2) {}\n\t\t// 第三个参数, 修改i的同时, 打印elem[i]对应的元素\n\t\tfor (int i = 0; i < size; std::cout << elem[i++] << std::endl) {}\n\t\t============================================================\n\t>* 反思\n\t\t某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。\n----------------------------------------------------------------------------------------------\n\n3, T const&, const T&, T& const, T const*, const T*, T* const 辨析\n\t\n\t>* 发现问题\n\t\t=================== source code ============================\n\t\tVector(T* const A, Rank lo, Rank hi)           // 数组区间复制\n\t\tVector(Vector<T> const& V, Rank lo, Rank hi)   // 向量区间复制\n\t\t============================================================\n\t\t对上述代码中的 Vector<T> const& V不理解, 为什么const& 跟在type之后? 它是否表达常量引用?\n\n\t>* 常量引用\n\t\ttype const&, type& const之间是什么区别 ?\n\t\t先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.\n\t\t\n\t\t让测试代码跑跑。\n\t\t=================== source code =============================\n\t\tint f() {\n\t\tint a = 0, b = 1;\n\t\tconst int ca = 0, cb = 1;\n\t\t\n\t\tint& ref_a = a;      // ref_a是整数a的引用类型\n\t\tint* ptr_a = &a;     // ptr_a是指向整数a的指针\n\t\tconst int* ptr_ca = &ca;           // ptr_ca是指向常量整型的指针\n\t\tconst int* const cptr_ca = &ca;    // cptr_ca是指向常量整型的常量指针\n\t\tint const& cref_a = a;             // cref_a是对整型的常量引用?\n\t\tconst int& cref_a_1 = ca;          // cref_a_1是对整型常量引用?\n\t\t// const int& const cref_a_2 = ca;    // 对整型常量的常量引用?\n\t\t// const int const& cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?\n\t\t// 引用不能duplicate const\n\t\tf1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&匹配\n\t\t// cref_a++;      // read-only    // 两者都是常量引用\n\t\t// cref_a_1++;    // read-only\n\t\t\n\t\t// 引用指针\n\t\tint* const& cref_ptra = ptr_a;            // 对整型指针的常量引用\n\t\t// int const& cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*\n\t\tconst int* const& cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用\n\t\t// int* const& cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*\n\t\tconst int* const& cref_cptrca = cptr_ca;\n\t\t\n\t\t(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型\n\t\t// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)\n\t\t}\n\t\t\n\t\tvoid f1(int const& ic) {\n\t\t\tstd::cout << \"calling f1()...\\n\";\n\t\t}\n\t\t=============================================================\n\t\t\n\t\t常量引用的写法. 所引用的对象类型为type\n\t\t(type) const& ref_t;\n\t\t// const&写在右边是因为侧重于表明其常量指针\n\t\t\n\t\t另外, 这一type可以是int, const int, int*, const int*等等\n\t\t\n\t>* 常量指针\n\t\t===================== source code ===========================\n\t\tint a = 0, b = 0, c = 0, d = 0;\n\t\tint* p_a = &a;                 // 指向int的指针\n\t\t// 指针地址可变, 指向的a可变\n\t\t(*p_a)++; p_a = &b;\n\t\tstd::cout << \"*p_a = \" << *p_a << \", a = \" << a << std::endl;\n\t\tconst int* p_b = &b;          // 指向const int的指针\n\t\t// 指针地址可变, 指向的元素转换成const不可变\n\t\t// (*p_b)++;\n\t\tp_b = &c;\n\t\tstd::cout << \"*p_b = \" << *p_b << \", b = \" << b << std::endl;\n\t\tint* const cp_c = &c;          // 指向int的const指针\n\t\t// 指针地址不可变, 指向的元素可以变\n\t\t(*cp_c)++;\n\t\t// cp_c = &d;\n\t\tstd::cout << \"*cp_c = \" << *cp_c << \", c = \" << c << std::endl;\n\t\t// int const* cp_c1 = &c;         // 指向const int的指针, 仍采用上种方法\n\t\tconst int* const cp_cd = &d;   // 指向const int的const指针\n\t\t// 指针地址不可变, 指向值不可变\n\t\t// (*cp_cd)++;\n\t\t// cp_cd = &a;\n\t\tstd::cout << \"*cp_cd = \" << *cp_cd << \", d = \" << d << std::endl;\n\t\t------------------------ ./a.out ---------------------------\n\t\t*p_a = 0, a = 1\n\t\t*p_b = 0, b = 0\n\t\t*cp_c = 1, c = 1\n\t\t*cp_cd = 0, d = 0\n\t\t============================================================\n\t\tT*               = &a;      // 指针\n\t\tconst T*         = &ca;     // 指向常量的指针\n\t\tT* const         = &a;      // 常量指针, 指针地址不可变\n\t\tconst T* const   = &ca;     // 指向常量的常量指针, 指向值和指针地址都不可变\n\t\t\n\t>* const_cast<type>();\n\t\t=======\n\t\tint b = 0;\n\t\tconst int* p_b= &b;\n\t\t*(const_cast<int*>(p_b))+=1;   // 这种方式可以让b递增1\n\t\t// (*p_b)++                    // const_cast只是一个临时操作\n\t\t==========\n\t\t一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。\n\t\t我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。\n\t\n\t>*  最初的辨析\n\t\tT const& : 引用, T类型的常量引用, 该引用不会被修改\n\t\tconst T& : 同上, 只是不同写法。现在偏向用上面那种\n\t\tT& const : 非法 \n\t\tT const* : 指针, 指向常量T的指针, const T*相同 \n\t\tconst T* : 指针, 指向常量T的指针, 我偏向用这种\n\t\tT* const : 指针, 指向T的常量指针\n---------------------------------------------------------------------------------------\n\n```\n","slug":"cpp/cpp-notes-0005","published":1,"updated":"2018-06-19T16:15:03.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykb001uk8mfaa6sgpim","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1, protected能否被实例对象访问</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 发现问题\t</span><br><span class=\"line\">\t\t重新实现Vector中, 要对ADT的access进行区别。</span><br><span class=\"line\">\t\tprotected能否被实例对象访问?</span><br><span class=\"line\">\t\tprotected能否被继承类访问?</span><br><span class=\"line\">\t&gt;* 尝试</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tclass Base &#123;</span><br><span class=\"line\">\t\tprivate:</span><br><span class=\"line\">\t\t\tint i = 0;</span><br><span class=\"line\">\t\t\tvoid f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\tprotected:</span><br><span class=\"line\">\t\t\tvoid f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t\tvoid f() &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t\tf_prot();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tclass Derived : Base &#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t\tvoid call_f_prot() &#123;f_prot();&#125;</span><br><span class=\"line\">\t\t\t// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tint main() &#123;</span><br><span class=\"line\">\t\t\tBase b;</span><br><span class=\"line\">\t\t\tDerived d;</span><br><span class=\"line\">\t\t\t// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class=\"line\">\t\t\td.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class=\"line\">\t\t\t// d.call_f_priv();</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 特点</span><br><span class=\"line\">\t\tprotected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class=\"line\">\t\t而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class=\"line\">---------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">2, for循环语句的简单写法</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\tfor语句的三个表达式如何写?</span><br><span class=\"line\">\tVector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class=\"line\">\t&#123;_elem = new T[_capacity = c];</span><br><span class=\"line\">\t\tfor (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 利用for的参数</span><br><span class=\"line\">\t\tfor ( declaration-or-expression(optional) ; </span><br><span class=\"line\">\t\t\tdeclaration-or-expression(optional) ; </span><br><span class=\"line\">\t\t\texpression(optional) )</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\tconst int s = 8;</span><br><span class=\"line\">\t\tint size = 0;</span><br><span class=\"line\">\t\tint elem[s] = &#123;&#125;;</span><br><span class=\"line\">\t\t/*</span><br><span class=\"line\">\t\tfor (size = 0; size &lt; s; size++) &#123;</span><br><span class=\"line\">\t\t\telem[size] = 2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t// 第三个参数, 递增size的同时, 给修改elem</span><br><span class=\"line\">\t\tfor (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class=\"line\">\t\t// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t&gt;* 反思</span><br><span class=\"line\">\t\t某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class=\"line\">----------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\tVector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class=\"line\">\t\tVector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 常量引用</span><br><span class=\"line\">\t\ttype const&amp;, type&amp; const之间是什么区别 ?</span><br><span class=\"line\">\t\t先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t让测试代码跑跑。</span><br><span class=\"line\">\t\t=================== source code =============================</span><br><span class=\"line\">\t\tint f() &#123;</span><br><span class=\"line\">\t\tint a = 0, b = 1;</span><br><span class=\"line\">\t\tconst int ca = 0, cb = 1;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tint&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class=\"line\">\t\tint* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class=\"line\">\t\tconst int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class=\"line\">\t\tconst int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class=\"line\">\t\tint const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class=\"line\">\t\tconst int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class=\"line\">\t\t// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class=\"line\">\t\t// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class=\"line\">\t\t// 引用不能duplicate const</span><br><span class=\"line\">\t\tf1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class=\"line\">\t\t// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class=\"line\">\t\t// cref_a_1++;    // read-only</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 引用指针</span><br><span class=\"line\">\t\tint* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class=\"line\">\t\t// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class=\"line\">\t\tconst int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class=\"line\">\t\t// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class=\"line\">\t\tconst int* const&amp; cref_cptrca = cptr_ca;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class=\"line\">\t\t// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid f1(int const&amp; ic) &#123;</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;calling f1()...\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t常量引用的写法. 所引用的对象类型为type</span><br><span class=\"line\">\t\t(type) const&amp; ref_t;</span><br><span class=\"line\">\t\t// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 常量指针</span><br><span class=\"line\">\t\t===================== source code ===========================</span><br><span class=\"line\">\t\tint a = 0, b = 0, c = 0, d = 0;</span><br><span class=\"line\">\t\tint* p_a = &amp;a;                 // 指向int的指针</span><br><span class=\"line\">\t\t// 指针地址可变, 指向的a可变</span><br><span class=\"line\">\t\t(*p_a)++; p_a = &amp;b;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tconst int* p_b = &amp;b;          // 指向const int的指针</span><br><span class=\"line\">\t\t// 指针地址可变, 指向的元素转换成const不可变</span><br><span class=\"line\">\t\t// (*p_b)++;</span><br><span class=\"line\">\t\tp_b = &amp;c;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tint* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class=\"line\">\t\t// 指针地址不可变, 指向的元素可以变</span><br><span class=\"line\">\t\t(*cp_c)++;</span><br><span class=\"line\">\t\t// cp_c = &amp;d;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class=\"line\">\t\tconst int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class=\"line\">\t\t// 指针地址不可变, 指向值不可变</span><br><span class=\"line\">\t\t// (*cp_cd)++;</span><br><span class=\"line\">\t\t// cp_cd = &amp;a;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t------------------------ ./a.out ---------------------------</span><br><span class=\"line\">\t\t*p_a = 0, a = 1</span><br><span class=\"line\">\t\t*p_b = 0, b = 0</span><br><span class=\"line\">\t\t*cp_c = 1, c = 1</span><br><span class=\"line\">\t\t*cp_cd = 0, d = 0</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\tT*               = &amp;a;      // 指针</span><br><span class=\"line\">\t\tconst T*         = &amp;ca;     // 指向常量的指针</span><br><span class=\"line\">\t\tT* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class=\"line\">\t\tconst T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* const_cast&lt;type&gt;();</span><br><span class=\"line\">\t\t=======</span><br><span class=\"line\">\t\tint b = 0;</span><br><span class=\"line\">\t\tconst int* p_b= &amp;b;</span><br><span class=\"line\">\t\t*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class=\"line\">\t\t// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class=\"line\">\t\t==========</span><br><span class=\"line\">\t\t一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class=\"line\">\t\t我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;*  最初的辨析</span><br><span class=\"line\">\t\tT const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class=\"line\">\t\tconst T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class=\"line\">\t\tT&amp; const : 非法 </span><br><span class=\"line\">\t\tT const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class=\"line\">\t\tconst T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class=\"line\">\t\tT* const : 指针, 指向T的常量指针</span><br><span class=\"line\">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1, protected能否被实例对象访问</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 发现问题\t</span><br><span class=\"line\">\t\t重新实现Vector中, 要对ADT的access进行区别。</span><br><span class=\"line\">\t\tprotected能否被实例对象访问?</span><br><span class=\"line\">\t\tprotected能否被继承类访问?</span><br><span class=\"line\">\t&gt;* 尝试</span><br><span class=\"line\">\t\t=================== source code ===========================</span><br><span class=\"line\">\t\tclass Base &#123;</span><br><span class=\"line\">\t\tprivate:</span><br><span class=\"line\">\t\t\tint i = 0;</span><br><span class=\"line\">\t\t\tvoid f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\tprotected:</span><br><span class=\"line\">\t\t\tvoid f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t\tvoid f() &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t\tf_prot();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tclass Derived : Base &#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t\tvoid call_f_prot() &#123;f_prot();&#125;</span><br><span class=\"line\">\t\t\t// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tint main() &#123;</span><br><span class=\"line\">\t\t\tBase b;</span><br><span class=\"line\">\t\t\tDerived d;</span><br><span class=\"line\">\t\t\t// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class=\"line\">\t\t\td.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class=\"line\">\t\t\t// d.call_f_priv();</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 特点</span><br><span class=\"line\">\t\tprotected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class=\"line\">\t\t而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class=\"line\">---------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">2, for循环语句的简单写法</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\tfor语句的三个表达式如何写?</span><br><span class=\"line\">\tVector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class=\"line\">\t&#123;_elem = new T[_capacity = c];</span><br><span class=\"line\">\t\tfor (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 利用for的参数</span><br><span class=\"line\">\t\tfor ( declaration-or-expression(optional) ; </span><br><span class=\"line\">\t\t\tdeclaration-or-expression(optional) ; </span><br><span class=\"line\">\t\t\texpression(optional) )</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\tconst int s = 8;</span><br><span class=\"line\">\t\tint size = 0;</span><br><span class=\"line\">\t\tint elem[s] = &#123;&#125;;</span><br><span class=\"line\">\t\t/*</span><br><span class=\"line\">\t\tfor (size = 0; size &lt; s; size++) &#123;</span><br><span class=\"line\">\t\t\telem[size] = 2;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t// 第三个参数, 递增size的同时, 给修改elem</span><br><span class=\"line\">\t\tfor (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class=\"line\">\t\t// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t&gt;* 反思</span><br><span class=\"line\">\t\t某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class=\"line\">----------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\t\t=================== source code ============================</span><br><span class=\"line\">\t\tVector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class=\"line\">\t\tVector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 常量引用</span><br><span class=\"line\">\t\ttype const&amp;, type&amp; const之间是什么区别 ?</span><br><span class=\"line\">\t\t先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t让测试代码跑跑。</span><br><span class=\"line\">\t\t=================== source code =============================</span><br><span class=\"line\">\t\tint f() &#123;</span><br><span class=\"line\">\t\tint a = 0, b = 1;</span><br><span class=\"line\">\t\tconst int ca = 0, cb = 1;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tint&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class=\"line\">\t\tint* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class=\"line\">\t\tconst int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class=\"line\">\t\tconst int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class=\"line\">\t\tint const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class=\"line\">\t\tconst int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class=\"line\">\t\t// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class=\"line\">\t\t// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class=\"line\">\t\t// 引用不能duplicate const</span><br><span class=\"line\">\t\tf1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class=\"line\">\t\t// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class=\"line\">\t\t// cref_a_1++;    // read-only</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 引用指针</span><br><span class=\"line\">\t\tint* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class=\"line\">\t\t// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class=\"line\">\t\tconst int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class=\"line\">\t\t// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class=\"line\">\t\tconst int* const&amp; cref_cptrca = cptr_ca;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class=\"line\">\t\t// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tvoid f1(int const&amp; ic) &#123;</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;calling f1()...\\n&quot;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t常量引用的写法. 所引用的对象类型为type</span><br><span class=\"line\">\t\t(type) const&amp; ref_t;</span><br><span class=\"line\">\t\t// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 常量指针</span><br><span class=\"line\">\t\t===================== source code ===========================</span><br><span class=\"line\">\t\tint a = 0, b = 0, c = 0, d = 0;</span><br><span class=\"line\">\t\tint* p_a = &amp;a;                 // 指向int的指针</span><br><span class=\"line\">\t\t// 指针地址可变, 指向的a可变</span><br><span class=\"line\">\t\t(*p_a)++; p_a = &amp;b;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tconst int* p_b = &amp;b;          // 指向const int的指针</span><br><span class=\"line\">\t\t// 指针地址可变, 指向的元素转换成const不可变</span><br><span class=\"line\">\t\t// (*p_b)++;</span><br><span class=\"line\">\t\tp_b = &amp;c;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class=\"line\">\t\tint* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class=\"line\">\t\t// 指针地址不可变, 指向的元素可以变</span><br><span class=\"line\">\t\t(*cp_c)++;</span><br><span class=\"line\">\t\t// cp_c = &amp;d;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class=\"line\">\t\tconst int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class=\"line\">\t\t// 指针地址不可变, 指向值不可变</span><br><span class=\"line\">\t\t// (*cp_cd)++;</span><br><span class=\"line\">\t\t// cp_cd = &amp;a;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t------------------------ ./a.out ---------------------------</span><br><span class=\"line\">\t\t*p_a = 0, a = 1</span><br><span class=\"line\">\t\t*p_b = 0, b = 0</span><br><span class=\"line\">\t\t*cp_c = 1, c = 1</span><br><span class=\"line\">\t\t*cp_cd = 0, d = 0</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\tT*               = &amp;a;      // 指针</span><br><span class=\"line\">\t\tconst T*         = &amp;ca;     // 指向常量的指针</span><br><span class=\"line\">\t\tT* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class=\"line\">\t\tconst T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* const_cast&lt;type&gt;();</span><br><span class=\"line\">\t\t=======</span><br><span class=\"line\">\t\tint b = 0;</span><br><span class=\"line\">\t\tconst int* p_b= &amp;b;</span><br><span class=\"line\">\t\t*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class=\"line\">\t\t// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class=\"line\">\t\t==========</span><br><span class=\"line\">\t\t一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class=\"line\">\t\t我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;*  最初的辨析</span><br><span class=\"line\">\t\tT const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class=\"line\">\t\tconst T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class=\"line\">\t\tT&amp; const : 非法 </span><br><span class=\"line\">\t\tT const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class=\"line\">\t\tconst T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class=\"line\">\t\tT* const : 指针, 指向T的常量指针</span><br><span class=\"line\">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n"},{"title":"C++ Zero To One 0.006","date":"2018-01-16T14:30:14.000Z","_content":"\n```\n1, 局部变量的销毁顺序\n\t================= source code ===============================\n\tvoid f(int i) {\n\t\tTable aa(1);\n\t\tTable bb(2);\n\t\tif (i > 0) {\n\t\t\tTable cc(3);\n\t\t}\n\t\tTable dd(4);\n\t}\n\t-------------- ./a.out ----------------\n\tin Table() sz = 1\n\tin Table() sz = 2\n\tin Table() sz = 3\n\tin ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前\n\tin Table() sz = 4\n\tin ~Table() sz = 4        // a, b, c构造; c, b, a析构\n\tin ~Table() sz = 2\n\tin ~Table() sz = 1\n\t=============================================================\n-------------------------------------------------------------------------------------\n\n2, 构造函数复制\n\n\t>* 直接复制\n\t\t======= source code ========\n\t\tvoid h() {\n\t\t\tTable t1;\n\t\t\t// Table t2 = t1;    // ERROR: 复制初始化\n\t\t\tTable t3;\n\t\t\t\n\t\t\t// t3 = t2;          // ERROR: 复制赋值\n\t\t}\n\t\t==============================\n\t\t\n\t\tt1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。\n\t\t所导致结果是无意义的\n\n\n\t>* 清楚定义复制构造函数\n\t\t================ source code =======================\n\t\tTable::Table(const Table& t) {\n\t\t\tp = new Name[sz = t.sz];\n\t\t\tfor (int i = 0; i < sz; i++) {\n\t\t\t\tp[i] = t.p[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tTable& Table::operator=(const Table& t) {\n\t\t\tif (this != &t) {         // 防止自复制\n\t\t\t\tdelete[] p;\n\t\t\t\tp = new Name[sz = t.sz];\n\t\t\t\tfor (int i = 0; i < sz; i++) {p[i] = t.p[i];}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\tvoid f() {\n\t\t\tTable t1(2);\n\t\t\tTable t2 = t1;\n\t\t\tTable t3(t1);\n\t\t}\n\t\t----------- ./a.out --------------------\n\t\tin Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\t===================================================\n\t\n\t>* 原因\n\t\t在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。\n\t\t\n\t\t而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。\n----------------------------------------------------------------------------------------\n\t\t\n3, 类和数组的关系\n\t>* 发现问题\n\t\t为什么能对指针类型使用索引?\n\t\n\t>* 测试\n\t\t========= source code =====================\n\t\tclass Name {\n\t\t\tconst char* s;\n\t\t};\n\t\n\t\tvoid test_array() {\n\t\t\tName* t;\n\t\t\tt[0];          // t是指针也是数组\n\t\t\t\n\t\t\tint i = 5;\n\t\t\tint* ptr_i = &i;\n\t\t\tint r = ptr_i[0];     // ptr_i是指针也是数组\n\t\t\tstd::cout << \"r = \" << r << std::endl;    // prints r = 5\n\t\t}\n\t\t=========================================\n\t\t\n\t>* 某一类型的指针, 也同样是指向某一类型的数组。\n\t\t到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? \n\t\t========= source code ===========\n\t\tint a = 2, b = 3, c = 4;\n\t\tint table_v[] = {a, b, c};\n\t\tstd::cout << *table_v << std::endl;\n\t\t-------./a.out---------------------\n\t\t2\n\t\t=================================\n\t\t\n\t\t\n```\n","source":"_posts/cpp/cpp-notes-0006.md","raw":"---\ntitle: C++ Zero To One 0.006\ndate: 2018-01-16 22:30:14\ntags:\n---\n\n```\n1, 局部变量的销毁顺序\n\t================= source code ===============================\n\tvoid f(int i) {\n\t\tTable aa(1);\n\t\tTable bb(2);\n\t\tif (i > 0) {\n\t\t\tTable cc(3);\n\t\t}\n\t\tTable dd(4);\n\t}\n\t-------------- ./a.out ----------------\n\tin Table() sz = 1\n\tin Table() sz = 2\n\tin Table() sz = 3\n\tin ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前\n\tin Table() sz = 4\n\tin ~Table() sz = 4        // a, b, c构造; c, b, a析构\n\tin ~Table() sz = 2\n\tin ~Table() sz = 1\n\t=============================================================\n-------------------------------------------------------------------------------------\n\n2, 构造函数复制\n\n\t>* 直接复制\n\t\t======= source code ========\n\t\tvoid h() {\n\t\t\tTable t1;\n\t\t\t// Table t2 = t1;    // ERROR: 复制初始化\n\t\t\tTable t3;\n\t\t\t\n\t\t\t// t3 = t2;          // ERROR: 复制赋值\n\t\t}\n\t\t==============================\n\t\t\n\t\tt1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。\n\t\t所导致结果是无意义的\n\n\n\t>* 清楚定义复制构造函数\n\t\t================ source code =======================\n\t\tTable::Table(const Table& t) {\n\t\t\tp = new Name[sz = t.sz];\n\t\t\tfor (int i = 0; i < sz; i++) {\n\t\t\t\tp[i] = t.p[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tTable& Table::operator=(const Table& t) {\n\t\t\tif (this != &t) {         // 防止自复制\n\t\t\t\tdelete[] p;\n\t\t\t\tp = new Name[sz = t.sz];\n\t\t\t\tfor (int i = 0; i < sz; i++) {p[i] = t.p[i];}\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\t\tvoid f() {\n\t\t\tTable t1(2);\n\t\t\tTable t2 = t1;\n\t\t\tTable t3(t1);\n\t\t}\n\t\t----------- ./a.out --------------------\n\t\tin Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\tin ~Table() sz = 2\n\t\t===================================================\n\t\n\t>* 原因\n\t\t在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。\n\t\t\n\t\t而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。\n----------------------------------------------------------------------------------------\n\t\t\n3, 类和数组的关系\n\t>* 发现问题\n\t\t为什么能对指针类型使用索引?\n\t\n\t>* 测试\n\t\t========= source code =====================\n\t\tclass Name {\n\t\t\tconst char* s;\n\t\t};\n\t\n\t\tvoid test_array() {\n\t\t\tName* t;\n\t\t\tt[0];          // t是指针也是数组\n\t\t\t\n\t\t\tint i = 5;\n\t\t\tint* ptr_i = &i;\n\t\t\tint r = ptr_i[0];     // ptr_i是指针也是数组\n\t\t\tstd::cout << \"r = \" << r << std::endl;    // prints r = 5\n\t\t}\n\t\t=========================================\n\t\t\n\t>* 某一类型的指针, 也同样是指向某一类型的数组。\n\t\t到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? \n\t\t========= source code ===========\n\t\tint a = 2, b = 3, c = 4;\n\t\tint table_v[] = {a, b, c};\n\t\tstd::cout << *table_v << std::endl;\n\t\t-------./a.out---------------------\n\t\t2\n\t\t=================================\n\t\t\n\t\t\n```\n","slug":"cpp/cpp-notes-0006","published":1,"updated":"2018-06-19T16:15:03.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykc001wk8mftbwplr8n","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1, 局部变量的销毁顺序</span><br><span class=\"line\">\t================= source code ===============================</span><br><span class=\"line\">\tvoid f(int i) &#123;</span><br><span class=\"line\">\t\tTable aa(1);</span><br><span class=\"line\">\t\tTable bb(2);</span><br><span class=\"line\">\t\tif (i &gt; 0) &#123;</span><br><span class=\"line\">\t\t\tTable cc(3);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTable dd(4);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t-------------- ./a.out ----------------</span><br><span class=\"line\">\tin Table() sz = 1</span><br><span class=\"line\">\tin Table() sz = 2</span><br><span class=\"line\">\tin Table() sz = 3</span><br><span class=\"line\">\tin ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class=\"line\">\tin Table() sz = 4</span><br><span class=\"line\">\tin ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class=\"line\">\tin ~Table() sz = 2</span><br><span class=\"line\">\tin ~Table() sz = 1</span><br><span class=\"line\">\t=============================================================</span><br><span class=\"line\">-------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">2, 构造函数复制</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 直接复制</span><br><span class=\"line\">\t\t======= source code ========</span><br><span class=\"line\">\t\tvoid h() &#123;</span><br><span class=\"line\">\t\t\tTable t1;</span><br><span class=\"line\">\t\t\t// Table t2 = t1;    // ERROR: 复制初始化</span><br><span class=\"line\">\t\t\tTable t3;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// t3 = t2;          // ERROR: 复制赋值</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t==============================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tt1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。</span><br><span class=\"line\">\t\t所导致结果是无意义的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 清楚定义复制构造函数</span><br><span class=\"line\">\t\t================ source code =======================</span><br><span class=\"line\">\t\tTable::Table(const Table&amp; t) &#123;</span><br><span class=\"line\">\t\t\tp = new Name[sz = t.sz];</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; sz; i++) &#123;</span><br><span class=\"line\">\t\t\t\tp[i] = t.p[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTable&amp; Table::operator=(const Table&amp; t) &#123;</span><br><span class=\"line\">\t\t\tif (this != &amp;t) &#123;         // 防止自复制</span><br><span class=\"line\">\t\t\t\tdelete[] p;</span><br><span class=\"line\">\t\t\t\tp = new Name[sz = t.sz];</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; sz; i++) &#123;p[i] = t.p[i];&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn *this;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tvoid f() &#123;</span><br><span class=\"line\">\t\t\tTable t1(2);</span><br><span class=\"line\">\t\t\tTable t2 = t1;</span><br><span class=\"line\">\t\t\tTable t3(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t----------- ./a.out --------------------</span><br><span class=\"line\">\t\tin Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\t===================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 原因</span><br><span class=\"line\">\t\t在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。</span><br><span class=\"line\">----------------------------------------------------------------------------------------</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">3, 类和数组的关系</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\t\t为什么能对指针类型使用索引?</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 测试</span><br><span class=\"line\">\t\t========= source code =====================</span><br><span class=\"line\">\t\tclass Name &#123;</span><br><span class=\"line\">\t\t\tconst char* s;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tvoid test_array() &#123;</span><br><span class=\"line\">\t\t\tName* t;</span><br><span class=\"line\">\t\t\tt[0];          // t是指针也是数组</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tint i = 5;</span><br><span class=\"line\">\t\t\tint* ptr_i = &amp;i;</span><br><span class=\"line\">\t\t\tint r = ptr_i[0];     // ptr_i是指针也是数组</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; std::endl;    // prints r = 5</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=========================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 某一类型的指针, 也同样是指向某一类型的数组。</span><br><span class=\"line\">\t\t到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? </span><br><span class=\"line\">\t\t========= source code ===========</span><br><span class=\"line\">\t\tint a = 2, b = 3, c = 4;</span><br><span class=\"line\">\t\tint table_v[] = &#123;a, b, c&#125;;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; *table_v &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t-------./a.out---------------------</span><br><span class=\"line\">\t\t2</span><br><span class=\"line\">\t\t=================================</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1, 局部变量的销毁顺序</span><br><span class=\"line\">\t================= source code ===============================</span><br><span class=\"line\">\tvoid f(int i) &#123;</span><br><span class=\"line\">\t\tTable aa(1);</span><br><span class=\"line\">\t\tTable bb(2);</span><br><span class=\"line\">\t\tif (i &gt; 0) &#123;</span><br><span class=\"line\">\t\t\tTable cc(3);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTable dd(4);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t-------------- ./a.out ----------------</span><br><span class=\"line\">\tin Table() sz = 1</span><br><span class=\"line\">\tin Table() sz = 2</span><br><span class=\"line\">\tin Table() sz = 3</span><br><span class=\"line\">\tin ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class=\"line\">\tin Table() sz = 4</span><br><span class=\"line\">\tin ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class=\"line\">\tin ~Table() sz = 2</span><br><span class=\"line\">\tin ~Table() sz = 1</span><br><span class=\"line\">\t=============================================================</span><br><span class=\"line\">-------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">2, 构造函数复制</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 直接复制</span><br><span class=\"line\">\t\t======= source code ========</span><br><span class=\"line\">\t\tvoid h() &#123;</span><br><span class=\"line\">\t\t\tTable t1;</span><br><span class=\"line\">\t\t\t// Table t2 = t1;    // ERROR: 复制初始化</span><br><span class=\"line\">\t\t\tTable t3;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// t3 = t2;          // ERROR: 复制赋值</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t==============================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tt1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。</span><br><span class=\"line\">\t\t所导致结果是无意义的</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 清楚定义复制构造函数</span><br><span class=\"line\">\t\t================ source code =======================</span><br><span class=\"line\">\t\tTable::Table(const Table&amp; t) &#123;</span><br><span class=\"line\">\t\t\tp = new Name[sz = t.sz];</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; sz; i++) &#123;</span><br><span class=\"line\">\t\t\t\tp[i] = t.p[i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tTable&amp; Table::operator=(const Table&amp; t) &#123;</span><br><span class=\"line\">\t\t\tif (this != &amp;t) &#123;         // 防止自复制</span><br><span class=\"line\">\t\t\t\tdelete[] p;</span><br><span class=\"line\">\t\t\t\tp = new Name[sz = t.sz];</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; sz; i++) &#123;p[i] = t.p[i];&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn *this;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tvoid f() &#123;</span><br><span class=\"line\">\t\t\tTable t1(2);</span><br><span class=\"line\">\t\t\tTable t2 = t1;</span><br><span class=\"line\">\t\t\tTable t3(t1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t----------- ./a.out --------------------</span><br><span class=\"line\">\t\tin Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\tin ~Table() sz = 2</span><br><span class=\"line\">\t\t===================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 原因</span><br><span class=\"line\">\t\t在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。</span><br><span class=\"line\">----------------------------------------------------------------------------------------</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">3, 类和数组的关系</span><br><span class=\"line\">\t&gt;* 发现问题</span><br><span class=\"line\">\t\t为什么能对指针类型使用索引?</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 测试</span><br><span class=\"line\">\t\t========= source code =====================</span><br><span class=\"line\">\t\tclass Name &#123;</span><br><span class=\"line\">\t\t\tconst char* s;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tvoid test_array() &#123;</span><br><span class=\"line\">\t\t\tName* t;</span><br><span class=\"line\">\t\t\tt[0];          // t是指针也是数组</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tint i = 5;</span><br><span class=\"line\">\t\t\tint* ptr_i = &amp;i;</span><br><span class=\"line\">\t\t\tint r = ptr_i[0];     // ptr_i是指针也是数组</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; std::endl;    // prints r = 5</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=========================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 某一类型的指针, 也同样是指向某一类型的数组。</span><br><span class=\"line\">\t\t到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? </span><br><span class=\"line\">\t\t========= source code ===========</span><br><span class=\"line\">\t\tint a = 2, b = 3, c = 4;</span><br><span class=\"line\">\t\tint table_v[] = &#123;a, b, c&#125;;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; *table_v &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t-------./a.out---------------------</span><br><span class=\"line\">\t\t2</span><br><span class=\"line\">\t\t=================================</span><br></pre></td></tr></table></figure>\n"},{"title":"C++ Zero To One 0.001","date":"2018-01-09T22:45:50.000Z","_content":"\n接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。\n\n这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。\n\n\n## 右移，左移\n```\n_capacity >>= 1;     // _capacity *= 0.5;\n_capacity <<= 1;     // _capacity *= 2;\n```\n## new delete\n要先new一个新的, 才能delete旧的\n```cpp\ntemplate <typename T>\nvoid Vector<T>::shrunk() {\n  if (_size > (_capacity/2)) return;   // 规模大于1/2不必缩容\n  _capacity = std::max(_capacity, DEAFAULT_CAPACITY);\n  // 储存一份旧元素, 创建新的数据空间\n  T* old_elem = _elem; _elem = new T[_capacity >>= 1];\n  for (Rank r = 0; r < _size; r++) {\n    _elem[r] = old_elem[r];\n  }\n  // 删除旧元素的内存空间\n  delete [] old_elem;\n}\n```\n\n\nnew分配空间\n```cpp\nvoid copyFrom(T* tarr, int lo, int hi) {\n    _elem = new T[_capacity = 2*(hi - lo)];\n    _size = hi - lo;\n    std::cout << \"*tarr = \" << tarr[1] << std::endl;\n    std::cout << \"*_elem = \" << *_elem << std::endl;\n    // for (int i = 0; i < _size; i++) {*(_elem+i) = tarr[i];}\n  }\n\n```\n\n```cpp\nvoid copyFrom(T* tarr, int lo, int hi) {\n    \n    _size = hi - lo;\n    std::cout << \"*tarr = \" << tarr[1] << std::endl;\n    std::cout << \"*_elem = \" << *_elem << std::endl;\n    // for (int i = 0; i < _size; i++) {*(_elem+i) = tarr[i];}\n  }\n```\n\n为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习\n\n## 同一if语句, 同一行中的后置递增\n```cpp\nvoid f() {\n  std::cout << \"---- test in same if statement----\" << std::endl;\n  int i = 1;\n  int arr[] = {0, 1, 2, 3, 4};\n  // 在同if, for, while中, 对某一变量i后置递增, i前后不变\n  if (equal(i++, arr[i])) std::cout << \"equal\\n\"\n                                    << \"now i = \" << i << std::endl;\n}\n```\n同一if, for, while语句中, 后置递增返回当前值\n同一行, 不同语句, 当然会让值产生变化\n## 重载后置++操作符号\n前置递增 operator++()\n后置递增, 以前置递增为基础 operator++(int i)\nincrement_and_decrement_operators.cpp\n\n递增运算符重载的返回类型:\n`为什么返回*_elem 而不是 *this??`\n递减运算符重载函数的返回类型是int&\n\\*this的类型为Vector<int>, 而*_elem 的类型是int\n\n```cpp\ntemplate <typename T>\nT& Vector<T>::operator--() {          // 重载前置--操作符\n  for (int i = 0; i < _size; i++)\n    _elem[i]--;                    // 对每个元素-1\n  return *_elem;                    // 返回当前 *this or *_elem\n}\n\ntemplate <typename T>\nT* Vector<T>::operator--(int i) {          // 重载后置--操作符\n  T* e = _elem;\n  --*this;                         // 调用前置递减\n  return e;\n}\n```\n\n`<<C++ Primer 5th>> P502, P421`\n\n\n## 函数指针 和 函数对象\n\n对无序向量的遍历操作中, 统一对各个元素分别实施visit操作\n\n**函数指针**, 只读或者<span style=\"color:red\">**局部性修改**</span>\n\n```cpp\ntemplate <typename T>\nvoid Vector<T>::traverse(void (*visit)(T&))      // 函数指针\n  {for (int i = 0; i < _size; i++) visit(_elem[i]);}\n\n```\n\n\n**函数对象**, 可<span style=\"color:red\">**全局性修改**</span>\n\n```cpp\ntemplate <typename T> <template VST>\nvoid Vector<T>::traverse(VST & visit) {        // 函数对象\n  for (int i = 0; i < _size; i++) visit(_elem[i];)\n}\n```\n\n\n### <span style=\"color:red\">**函数指针**</span>\n\n```cpp\nint getLarger(const int& i1, const int& i2) {\n  return i1 < i2 ? i2: i1;            // 返回两者较大\n}\n```\n\n#### 声明定义\n声明和定义分离:\n```cpp\nint (*pf1)(const int&, const int&);\n\npf1 = getLarget;\npf1 = &getLarget;       // 等价,\n```\n\n个人认为&表达出pf1是个指针的语义明确点。\n\n声明并定义:\n```cpp\nint (*pf1)(const int&, const int&) = &getLarger;  \n```\n\n#### 使用\n使用\n```cpp\nint i_pf1 = (*pf1)(3, 5);\nint i_pf1_2 = (pf1)(3, 5);           // 等价\nint i_pf1_3 = getLarget(3, 5);       // 等价 调用原函数\n```\n\n\n#### 赋值, 指向新的函数?\n```cpp\nbool compareInt(const int& i1, const int& i2) {\n  return i1 < i2 ? true : false;      // i1 < i2, 返回true\n}\n\n// 声明并定义\nbool (*pf)(const int&, const int&) = &compareInt;\n\n// 赋nullptr:指针没有指向任何一个函数\npf = 0;\npf = getLarger;     // error: pf已经被声明成bool(*)(const int&, const int&)\npf = increment;     // error: 同上\n```\n\n能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。\n\n`但如果是一个类型相同的函数, 便可以重新指向该函数。`\n\n```cpp\nbool otherCompare(const int& i1, const int&) {return 0;}\n\npf = otherCompare;\n```\n\n#### 重载函数的指针\n\n函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配\n\n```cpp\nvoid ff(int*);\nvoid ff(unsigned int);\n\n// 重载\nvoid (*pff1)(int *) = &ff;      // pff1指向ff的 void (int*)版本\n\nvoid (*pff2)(int) = &ff;        // Error\nint (*pff3)(unsigned) = &ff;    // Error\n```\n\n\n#### 函数指针作为形参(调用函数指针)\n\n```cpp\n// 第三个参数是函数指针类型\nvoid useBigger(const int&, const int&, bool (*pf)(const int&, const int&));\n\n// 调用时, 传入指向compareInt的指针\nuseBigger(i1, i2, &compareInt);\n```\n\n\n可以用别名的方法简化定义\n\n```cpp\ntypedef decltype(compareInt) *FuncP2;    // FuncP2是指向函数的指针类型\ntypedef decltype(compareInt) Func;       // decltype()返回函数类型, Func是函数类型\n\nvoid useBigger(const int&, const int&, FuncP2);\nvoid useBigger(const int&, const int&, Func2);   // 编译器将Func2函数类型自动转换为了函数的指针类型\n```\n\n\n#### 返回指向函数的指针\n\n一般, 别名\n\n```cpp\nusing PF = bool(*)(const int&, const int&);      // PF是函数的指针类型\nusing F = bool(const int&, const int&);          // F是指针类型\n\nPF f1(int);          // 返回函数的指针类型\nF *f1(int);          // 显式f1返回的是一个指针类型\nF f2(int);           // Error:F是函数类型, 无法返回一个函数\n\n```\n\n\n尾置\n```cpp\nauto f1(int) -> int(*)(int*, int)\n```\n\n### <span style=\"color:red\">**函数对象**</span>\n\n#### 重载()\n说明这个对象, 他可以当作函数来使用。因此需要重载\"()\"\n\n\n```cpp\n// 定义一个函数对象\nclass Sum{\n public:\n  int sum = 0;\n  void operator()(int iarr[], int n) {\n    for (int i = 0; i < n; i++)\n      sum += iarr[i];\n    std::cout << \"sum = \" << sum << std::endl;\n  }\n};\n```\n\n#### 使用这个函数对象\n\n```cpp\nSum s;\nint iarr[] = {1, 2, 3, 4, 5, 6};\nint n = 6;\ns(iarr, n);      // sum = 21\n```\n\n#### 作为其他函数的参数\n\n```cpp\n// 函数对象作为另一个函数的形参\ntemplate <typename CLS>\nvoid f(CLS & c) {\n  int iarr[] = {3, 6, 9};\n  int n = 3;\n  c(iarr, n);\n}\n\n\n// 调用\nSum s1;\nf(s1);       // sum = 18\n```\n\n#### 回顾一下数据结构中的用法\n\n\n\n```cpp\ntemplate <typename T> template <typename VST>\nvoid Vector<T>::traverse(VST visit) {\n  // 对每个元素执行visit操作\n  for (int i = 0; i < _size; i++) {visit(_elem[i]);}\n}\n\n// 为什么不能用引用类型?\n// no known conversion for argument 1 from ‘Increase<int>’ to ‘Increase<int>&’\n```\n\n```cpp\n/* my error test\ntemplate <typename T>\nvoid increase(Vector<T> V) {\n  V.traverse(Increase(T& e));\n}\n*/\ntemplate <typename T>\nvoid increase(Vector<T> V) {\n  V.traverse(Increase<T>());\n}\n\n// 为什么不用实例化, 带入参数便可直接调用??\n```\n","source":"_posts/cpp/cpp-notes-01.md","raw":"---\ntitle: C++ Zero To One 0.001\ndate: 2018-01-10 06:45:50\ntags: [C++, 位操作, new, delete, 运算符重载, 函数指针, 函数对象]\n---\n\n接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。\n\n这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。\n\n\n## 右移，左移\n```\n_capacity >>= 1;     // _capacity *= 0.5;\n_capacity <<= 1;     // _capacity *= 2;\n```\n## new delete\n要先new一个新的, 才能delete旧的\n```cpp\ntemplate <typename T>\nvoid Vector<T>::shrunk() {\n  if (_size > (_capacity/2)) return;   // 规模大于1/2不必缩容\n  _capacity = std::max(_capacity, DEAFAULT_CAPACITY);\n  // 储存一份旧元素, 创建新的数据空间\n  T* old_elem = _elem; _elem = new T[_capacity >>= 1];\n  for (Rank r = 0; r < _size; r++) {\n    _elem[r] = old_elem[r];\n  }\n  // 删除旧元素的内存空间\n  delete [] old_elem;\n}\n```\n\n\nnew分配空间\n```cpp\nvoid copyFrom(T* tarr, int lo, int hi) {\n    _elem = new T[_capacity = 2*(hi - lo)];\n    _size = hi - lo;\n    std::cout << \"*tarr = \" << tarr[1] << std::endl;\n    std::cout << \"*_elem = \" << *_elem << std::endl;\n    // for (int i = 0; i < _size; i++) {*(_elem+i) = tarr[i];}\n  }\n\n```\n\n```cpp\nvoid copyFrom(T* tarr, int lo, int hi) {\n    \n    _size = hi - lo;\n    std::cout << \"*tarr = \" << tarr[1] << std::endl;\n    std::cout << \"*_elem = \" << *_elem << std::endl;\n    // for (int i = 0; i < _size; i++) {*(_elem+i) = tarr[i];}\n  }\n```\n\n为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习\n\n## 同一if语句, 同一行中的后置递增\n```cpp\nvoid f() {\n  std::cout << \"---- test in same if statement----\" << std::endl;\n  int i = 1;\n  int arr[] = {0, 1, 2, 3, 4};\n  // 在同if, for, while中, 对某一变量i后置递增, i前后不变\n  if (equal(i++, arr[i])) std::cout << \"equal\\n\"\n                                    << \"now i = \" << i << std::endl;\n}\n```\n同一if, for, while语句中, 后置递增返回当前值\n同一行, 不同语句, 当然会让值产生变化\n## 重载后置++操作符号\n前置递增 operator++()\n后置递增, 以前置递增为基础 operator++(int i)\nincrement_and_decrement_operators.cpp\n\n递增运算符重载的返回类型:\n`为什么返回*_elem 而不是 *this??`\n递减运算符重载函数的返回类型是int&\n\\*this的类型为Vector<int>, 而*_elem 的类型是int\n\n```cpp\ntemplate <typename T>\nT& Vector<T>::operator--() {          // 重载前置--操作符\n  for (int i = 0; i < _size; i++)\n    _elem[i]--;                    // 对每个元素-1\n  return *_elem;                    // 返回当前 *this or *_elem\n}\n\ntemplate <typename T>\nT* Vector<T>::operator--(int i) {          // 重载后置--操作符\n  T* e = _elem;\n  --*this;                         // 调用前置递减\n  return e;\n}\n```\n\n`<<C++ Primer 5th>> P502, P421`\n\n\n## 函数指针 和 函数对象\n\n对无序向量的遍历操作中, 统一对各个元素分别实施visit操作\n\n**函数指针**, 只读或者<span style=\"color:red\">**局部性修改**</span>\n\n```cpp\ntemplate <typename T>\nvoid Vector<T>::traverse(void (*visit)(T&))      // 函数指针\n  {for (int i = 0; i < _size; i++) visit(_elem[i]);}\n\n```\n\n\n**函数对象**, 可<span style=\"color:red\">**全局性修改**</span>\n\n```cpp\ntemplate <typename T> <template VST>\nvoid Vector<T>::traverse(VST & visit) {        // 函数对象\n  for (int i = 0; i < _size; i++) visit(_elem[i];)\n}\n```\n\n\n### <span style=\"color:red\">**函数指针**</span>\n\n```cpp\nint getLarger(const int& i1, const int& i2) {\n  return i1 < i2 ? i2: i1;            // 返回两者较大\n}\n```\n\n#### 声明定义\n声明和定义分离:\n```cpp\nint (*pf1)(const int&, const int&);\n\npf1 = getLarget;\npf1 = &getLarget;       // 等价,\n```\n\n个人认为&表达出pf1是个指针的语义明确点。\n\n声明并定义:\n```cpp\nint (*pf1)(const int&, const int&) = &getLarger;  \n```\n\n#### 使用\n使用\n```cpp\nint i_pf1 = (*pf1)(3, 5);\nint i_pf1_2 = (pf1)(3, 5);           // 等价\nint i_pf1_3 = getLarget(3, 5);       // 等价 调用原函数\n```\n\n\n#### 赋值, 指向新的函数?\n```cpp\nbool compareInt(const int& i1, const int& i2) {\n  return i1 < i2 ? true : false;      // i1 < i2, 返回true\n}\n\n// 声明并定义\nbool (*pf)(const int&, const int&) = &compareInt;\n\n// 赋nullptr:指针没有指向任何一个函数\npf = 0;\npf = getLarger;     // error: pf已经被声明成bool(*)(const int&, const int&)\npf = increment;     // error: 同上\n```\n\n能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。\n\n`但如果是一个类型相同的函数, 便可以重新指向该函数。`\n\n```cpp\nbool otherCompare(const int& i1, const int&) {return 0;}\n\npf = otherCompare;\n```\n\n#### 重载函数的指针\n\n函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配\n\n```cpp\nvoid ff(int*);\nvoid ff(unsigned int);\n\n// 重载\nvoid (*pff1)(int *) = &ff;      // pff1指向ff的 void (int*)版本\n\nvoid (*pff2)(int) = &ff;        // Error\nint (*pff3)(unsigned) = &ff;    // Error\n```\n\n\n#### 函数指针作为形参(调用函数指针)\n\n```cpp\n// 第三个参数是函数指针类型\nvoid useBigger(const int&, const int&, bool (*pf)(const int&, const int&));\n\n// 调用时, 传入指向compareInt的指针\nuseBigger(i1, i2, &compareInt);\n```\n\n\n可以用别名的方法简化定义\n\n```cpp\ntypedef decltype(compareInt) *FuncP2;    // FuncP2是指向函数的指针类型\ntypedef decltype(compareInt) Func;       // decltype()返回函数类型, Func是函数类型\n\nvoid useBigger(const int&, const int&, FuncP2);\nvoid useBigger(const int&, const int&, Func2);   // 编译器将Func2函数类型自动转换为了函数的指针类型\n```\n\n\n#### 返回指向函数的指针\n\n一般, 别名\n\n```cpp\nusing PF = bool(*)(const int&, const int&);      // PF是函数的指针类型\nusing F = bool(const int&, const int&);          // F是指针类型\n\nPF f1(int);          // 返回函数的指针类型\nF *f1(int);          // 显式f1返回的是一个指针类型\nF f2(int);           // Error:F是函数类型, 无法返回一个函数\n\n```\n\n\n尾置\n```cpp\nauto f1(int) -> int(*)(int*, int)\n```\n\n### <span style=\"color:red\">**函数对象**</span>\n\n#### 重载()\n说明这个对象, 他可以当作函数来使用。因此需要重载\"()\"\n\n\n```cpp\n// 定义一个函数对象\nclass Sum{\n public:\n  int sum = 0;\n  void operator()(int iarr[], int n) {\n    for (int i = 0; i < n; i++)\n      sum += iarr[i];\n    std::cout << \"sum = \" << sum << std::endl;\n  }\n};\n```\n\n#### 使用这个函数对象\n\n```cpp\nSum s;\nint iarr[] = {1, 2, 3, 4, 5, 6};\nint n = 6;\ns(iarr, n);      // sum = 21\n```\n\n#### 作为其他函数的参数\n\n```cpp\n// 函数对象作为另一个函数的形参\ntemplate <typename CLS>\nvoid f(CLS & c) {\n  int iarr[] = {3, 6, 9};\n  int n = 3;\n  c(iarr, n);\n}\n\n\n// 调用\nSum s1;\nf(s1);       // sum = 18\n```\n\n#### 回顾一下数据结构中的用法\n\n\n\n```cpp\ntemplate <typename T> template <typename VST>\nvoid Vector<T>::traverse(VST visit) {\n  // 对每个元素执行visit操作\n  for (int i = 0; i < _size; i++) {visit(_elem[i]);}\n}\n\n// 为什么不能用引用类型?\n// no known conversion for argument 1 from ‘Increase<int>’ to ‘Increase<int>&’\n```\n\n```cpp\n/* my error test\ntemplate <typename T>\nvoid increase(Vector<T> V) {\n  V.traverse(Increase(T& e));\n}\n*/\ntemplate <typename T>\nvoid increase(Vector<T> V) {\n  V.traverse(Increase<T>());\n}\n\n// 为什么不用实例化, 带入参数便可直接调用??\n```\n","slug":"cpp/cpp-notes-01","published":1,"updated":"2018-06-19T16:15:03.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyke001xk8mfm7ldw1zg","content":"<p>接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。</p>\n<p>这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。</p>\n<h2 id=\"右移，左移\"><a href=\"#右移，左移\" class=\"headerlink\" title=\"右移，左移\"></a>右移，左移</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">_capacity &gt;&gt;= 1;     // _capacity *= 0.5;</span><br><span class=\"line\">_capacity &lt;&lt;= 1;     // _capacity *= 2;</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-delete\"><a href=\"#new-delete\" class=\"headerlink\" title=\"new delete\"></a>new delete</h2><p>要先new一个新的, 才能delete旧的<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::shrunk() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_size &gt; (_capacity/<span class=\"number\">2</span>)) <span class=\"keyword\">return</span>;   <span class=\"comment\">// 规模大于1/2不必缩容</span></span><br><span class=\"line\">  _capacity = <span class=\"built_in\">std</span>::max(_capacity, DEAFAULT_CAPACITY);</span><br><span class=\"line\">  <span class=\"comment\">// 储存一份旧元素, 创建新的数据空间</span></span><br><span class=\"line\">  T* old_elem = _elem; _elem = <span class=\"keyword\">new</span> T[_capacity &gt;&gt;= <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Rank r = <span class=\"number\">0</span>; r &lt; _size; r++) &#123;</span><br><span class=\"line\">    _elem[r] = old_elem[r];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除旧元素的内存空间</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> [] old_elem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>new分配空间<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* tarr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    _elem = <span class=\"keyword\">new</span> T[_capacity = <span class=\"number\">2</span>*(hi - lo)];</span><br><span class=\"line\">    _size = hi - lo;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*tarr = \"</span> &lt;&lt; tarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*_elem = \"</span> &lt;&lt; *_elem &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* tarr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _size = hi - lo;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*tarr = \"</span> &lt;&lt; tarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*_elem = \"</span> &lt;&lt; *_elem &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习</p>\n<h2 id=\"同一if语句-同一行中的后置递增\"><a href=\"#同一if语句-同一行中的后置递增\" class=\"headerlink\" title=\"同一if语句, 同一行中的后置递增\"></a>同一if语句, 同一行中的后置递增</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---- test in same if statement----\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 在同if, for, while中, 对某一变量i后置递增, i前后不变</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (equal(i++, arr[i])) <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"equal\\n\"</span></span><br><span class=\"line\">                                    &lt;&lt; <span class=\"string\">\"now i = \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同一if, for, while语句中, 后置递增返回当前值<br>同一行, 不同语句, 当然会让值产生变化</p>\n<h2 id=\"重载后置-操作符号\"><a href=\"#重载后置-操作符号\" class=\"headerlink\" title=\"重载后置++操作符号\"></a>重载后置++操作符号</h2><p>前置递增 operator++()<br>后置递增, 以前置递增为基础 operator++(int i)<br>increment_and_decrement_operators.cpp</p>\n<p>递增运算符重载的返回类型:<br><code>为什么返回*_elem 而不是 *this??</code><br>递减运算符重载函数的返回类型是int&amp;<br>*this的类型为Vector<int>, 而*_elem 的类型是int</int></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>--() &#123;          <span class=\"comment\">// 重载前置--操作符</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++)</span><br><span class=\"line\">    _elem[i]--;                    <span class=\"comment\">// 对每个元素-1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *_elem;                    <span class=\"comment\">// 返回当前 *this or *_elem</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Vector&lt;T&gt;::<span class=\"keyword\">operator</span>--(<span class=\"keyword\">int</span> i) &#123;          <span class=\"comment\">// 重载后置--操作符</span></span><br><span class=\"line\">  T* e = _elem;</span><br><span class=\"line\">  --*<span class=\"keyword\">this</span>;                         <span class=\"comment\">// 调用前置递减</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P502, P421</code></p>\n<h2 id=\"函数指针-和-函数对象\"><a href=\"#函数指针-和-函数对象\" class=\"headerlink\" title=\"函数指针 和 函数对象\"></a>函数指针 和 函数对象</h2><p>对无序向量的遍历操作中, 统一对各个元素分别实施visit操作</p>\n<p><strong>函数指针</strong>, 只读或者<span style=\"color:red\"><strong>局部性修改</strong></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(<span class=\"keyword\">void</span> (*visit)(T&amp;))      <span class=\"comment\">// 函数指针</span></span><br><span class=\"line\">  &#123;<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) visit(_elem[i]);&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>函数对象</strong>, 可<span style=\"color:red\"><strong>全局性修改</strong></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; &lt;<span class=\"keyword\">template</span> VST&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(VST &amp; visit) &#123;        <span class=\"comment\">// 函数对象</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) visit(_elem[i];)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a><span style=\"color:red\"><strong>函数指针</strong></span></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLarger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i1 &lt; i2 ? i2: i1;            <span class=\"comment\">// 返回两者较大</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"声明定义\"><a href=\"#声明定义\" class=\"headerlink\" title=\"声明定义\"></a>声明定义</h4><p>声明和定义分离:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*pf1)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);</span><br><span class=\"line\"></span><br><span class=\"line\">pf1 = getLarget;</span><br><span class=\"line\">pf1 = &amp;getLarget;       <span class=\"comment\">// 等价,</span></span><br></pre></td></tr></table></figure></p>\n<p>个人认为&amp;表达出pf1是个指针的语义明确点。</p>\n<p>声明并定义:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*pf1)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;) = &amp;getLarger;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>使用<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i_pf1 = (*pf1)(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> i_pf1_2 = (pf1)(<span class=\"number\">3</span>, <span class=\"number\">5</span>);           <span class=\"comment\">// 等价</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i_pf1_3 = getLarget(<span class=\"number\">3</span>, <span class=\"number\">5</span>);       <span class=\"comment\">// 等价 调用原函数</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"赋值-指向新的函数\"><a href=\"#赋值-指向新的函数\" class=\"headerlink\" title=\"赋值, 指向新的函数?\"></a>赋值, 指向新的函数?</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compareInt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i1 &lt; i2 ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;      <span class=\"comment\">// i1 &lt; i2, 返回true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明并定义</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> (*pf)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;) = &amp;compareInt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 赋nullptr:指针没有指向任何一个函数</span></span><br><span class=\"line\">pf = <span class=\"number\">0</span>;</span><br><span class=\"line\">pf = getLarger;     <span class=\"comment\">// error: pf已经被声明成bool(*)(const int&amp;, const int&amp;)</span></span><br><span class=\"line\">pf = increment;     <span class=\"comment\">// error: 同上</span></span><br></pre></td></tr></table></figure>\n<p>能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。</p>\n<p><code>但如果是一个类型相同的函数, 便可以重新指向该函数。</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">otherCompare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;)</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pf = otherCompare;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载函数的指针\"><a href=\"#重载函数的指针\" class=\"headerlink\" title=\"重载函数的指针\"></a>重载函数的指针</h4><p>函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span>*)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重载</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*pff1)(<span class=\"keyword\">int</span> *) = &amp;ff;      <span class=\"comment\">// pff1指向ff的 void (int*)版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*pff2)(<span class=\"keyword\">int</span>) = &amp;ff;        <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*pff3)(<span class=\"keyword\">unsigned</span>) = &amp;ff;    <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数指针作为形参-调用函数指针\"><a href=\"#函数指针作为形参-调用函数指针\" class=\"headerlink\" title=\"函数指针作为形参(调用函数指针)\"></a>函数指针作为形参(调用函数指针)</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三个参数是函数指针类型</span></span><br><span class=\"line\">void useBigger(const int&amp;, const int&amp;, bool (*pf)(const int&amp;, const int&amp;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用时, 传入指向compareInt的指针</span></span><br><span class=\"line\">useBigger(i1, i2, &amp;compareInt);</span><br></pre></td></tr></table></figure>\n<p>可以用别名的方法简化定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(compareInt)</span> *FuncP2</span>;    <span class=\"comment\">// FuncP2是指向函数的指针类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(compareInt)</span> Func</span>;       <span class=\"comment\">// decltype()返回函数类型, Func是函数类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useBigger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, FuncP2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useBigger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, Func2)</span></span>;   <span class=\"comment\">// 编译器将Func2函数类型自动转换为了函数的指针类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"返回指向函数的指针\"><a href=\"#返回指向函数的指针\" class=\"headerlink\" title=\"返回指向函数的指针\"></a>返回指向函数的指针</h4><p>一般, 别名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> PF = <span class=\"keyword\">bool</span>(*)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);      <span class=\"comment\">// PF是函数的指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> F = <span class=\"keyword\">bool</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);          <span class=\"comment\">// F是指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PF <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;          <span class=\"comment\">// 返回函数的指针类型</span></span><br><span class=\"line\"><span class=\"function\">F *<span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;          <span class=\"comment\">// 显式f1返回的是一个指针类型</span></span><br><span class=\"line\"><span class=\"function\">F <span class=\"title\">f2</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;           <span class=\"comment\">// Error:F是函数类型, 无法返回一个函数</span></span><br></pre></td></tr></table></figure>\n<p>尾置<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">auto f1(int) -&gt; int(*)(int*, int)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a><span style=\"color:red\"><strong>函数对象</strong></span></h3><h4 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载()\"></a>重载()</h4><p>说明这个对象, 他可以当作函数来使用。因此需要重载”()”</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个函数对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> iarr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">      sum += iarr[i];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用这个函数对象\"><a href=\"#使用这个函数对象\" class=\"headerlink\" title=\"使用这个函数对象\"></a>使用这个函数对象</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sum s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">6</span>;</span><br><span class=\"line\">s(iarr, n);      <span class=\"comment\">// sum = 21</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为其他函数的参数\"><a href=\"#作为其他函数的参数\" class=\"headerlink\" title=\"作为其他函数的参数\"></a>作为其他函数的参数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数对象作为另一个函数的形参</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> CLS&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(CLS &amp; c)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">3</span>;</span><br><span class=\"line\">  c(iarr, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">Sum s1;</span><br><span class=\"line\">f(s1);       <span class=\"comment\">// sum = 18</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"回顾一下数据结构中的用法\"><a href=\"#回顾一下数据结构中的用法\" class=\"headerlink\" title=\"回顾一下数据结构中的用法\"></a>回顾一下数据结构中的用法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(VST visit) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对每个元素执行visit操作</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) &#123;visit(_elem[i]);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为什么不能用引用类型?</span></span><br><span class=\"line\"><span class=\"comment\">// no known conversion for argument 1 from ‘Increase&lt;int&gt;’ to ‘Increase&lt;int&gt;&amp;’</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* my error test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void increase(Vector&lt;T&gt; V) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  V.traverse(Increase(T&amp; e));</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Increase&lt;T&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为什么不用实例化, 带入参数便可直接调用??</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。</p>\n<p>这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。</p>\n<h2 id=\"右移，左移\"><a href=\"#右移，左移\" class=\"headerlink\" title=\"右移，左移\"></a>右移，左移</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">_capacity &gt;&gt;= 1;     // _capacity *= 0.5;</span><br><span class=\"line\">_capacity &lt;&lt;= 1;     // _capacity *= 2;</span><br></pre></td></tr></table></figure>\n<h2 id=\"new-delete\"><a href=\"#new-delete\" class=\"headerlink\" title=\"new delete\"></a>new delete</h2><p>要先new一个新的, 才能delete旧的<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::shrunk() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_size &gt; (_capacity/<span class=\"number\">2</span>)) <span class=\"keyword\">return</span>;   <span class=\"comment\">// 规模大于1/2不必缩容</span></span><br><span class=\"line\">  _capacity = <span class=\"built_in\">std</span>::max(_capacity, DEAFAULT_CAPACITY);</span><br><span class=\"line\">  <span class=\"comment\">// 储存一份旧元素, 创建新的数据空间</span></span><br><span class=\"line\">  T* old_elem = _elem; _elem = <span class=\"keyword\">new</span> T[_capacity &gt;&gt;= <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Rank r = <span class=\"number\">0</span>; r &lt; _size; r++) &#123;</span><br><span class=\"line\">    _elem[r] = old_elem[r];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除旧元素的内存空间</span></span><br><span class=\"line\">  <span class=\"keyword\">delete</span> [] old_elem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>new分配空间<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* tarr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    _elem = <span class=\"keyword\">new</span> T[_capacity = <span class=\"number\">2</span>*(hi - lo)];</span><br><span class=\"line\">    _size = hi - lo;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*tarr = \"</span> &lt;&lt; tarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*_elem = \"</span> &lt;&lt; *_elem &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* tarr, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _size = hi - lo;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*tarr = \"</span> &lt;&lt; tarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*_elem = \"</span> &lt;&lt; *_elem &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习</p>\n<h2 id=\"同一if语句-同一行中的后置递增\"><a href=\"#同一if语句-同一行中的后置递增\" class=\"headerlink\" title=\"同一if语句, 同一行中的后置递增\"></a>同一if语句, 同一行中的后置递增</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"---- test in same if statement----\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 在同if, for, while中, 对某一变量i后置递增, i前后不变</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (equal(i++, arr[i])) <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"equal\\n\"</span></span><br><span class=\"line\">                                    &lt;&lt; <span class=\"string\">\"now i = \"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同一if, for, while语句中, 后置递增返回当前值<br>同一行, 不同语句, 当然会让值产生变化</p>\n<h2 id=\"重载后置-操作符号\"><a href=\"#重载后置-操作符号\" class=\"headerlink\" title=\"重载后置++操作符号\"></a>重载后置++操作符号</h2><p>前置递增 operator++()<br>后置递增, 以前置递增为基础 operator++(int i)<br>increment_and_decrement_operators.cpp</p>\n<p>递增运算符重载的返回类型:<br><code>为什么返回*_elem 而不是 *this??</code><br>递减运算符重载函数的返回类型是int&amp;<br>*this的类型为Vector<int>, 而*_elem 的类型是int</int></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>--() &#123;          <span class=\"comment\">// 重载前置--操作符</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++)</span><br><span class=\"line\">    _elem[i]--;                    <span class=\"comment\">// 对每个元素-1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> *_elem;                    <span class=\"comment\">// 返回当前 *this or *_elem</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Vector&lt;T&gt;::<span class=\"keyword\">operator</span>--(<span class=\"keyword\">int</span> i) &#123;          <span class=\"comment\">// 重载后置--操作符</span></span><br><span class=\"line\">  T* e = _elem;</span><br><span class=\"line\">  --*<span class=\"keyword\">this</span>;                         <span class=\"comment\">// 调用前置递减</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P502, P421</code></p>\n<h2 id=\"函数指针-和-函数对象\"><a href=\"#函数指针-和-函数对象\" class=\"headerlink\" title=\"函数指针 和 函数对象\"></a>函数指针 和 函数对象</h2><p>对无序向量的遍历操作中, 统一对各个元素分别实施visit操作</p>\n<p><strong>函数指针</strong>, 只读或者<span style=\"color:red\"><strong>局部性修改</strong></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(<span class=\"keyword\">void</span> (*visit)(T&amp;))      <span class=\"comment\">// 函数指针</span></span><br><span class=\"line\">  &#123;<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) visit(_elem[i]);&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>函数对象</strong>, 可<span style=\"color:red\"><strong>全局性修改</strong></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; &lt;<span class=\"keyword\">template</span> VST&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(VST &amp; visit) &#123;        <span class=\"comment\">// 函数对象</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) visit(_elem[i];)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a><span style=\"color:red\"><strong>函数指针</strong></span></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLarger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i1 &lt; i2 ? i2: i1;            <span class=\"comment\">// 返回两者较大</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"声明定义\"><a href=\"#声明定义\" class=\"headerlink\" title=\"声明定义\"></a>声明定义</h4><p>声明和定义分离:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*pf1)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);</span><br><span class=\"line\"></span><br><span class=\"line\">pf1 = getLarget;</span><br><span class=\"line\">pf1 = &amp;getLarget;       <span class=\"comment\">// 等价,</span></span><br></pre></td></tr></table></figure></p>\n<p>个人认为&amp;表达出pf1是个指针的语义明确点。</p>\n<p>声明并定义:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*pf1)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;) = &amp;getLarger;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>使用<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i_pf1 = (*pf1)(<span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> i_pf1_2 = (pf1)(<span class=\"number\">3</span>, <span class=\"number\">5</span>);           <span class=\"comment\">// 等价</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i_pf1_3 = getLarget(<span class=\"number\">3</span>, <span class=\"number\">5</span>);       <span class=\"comment\">// 等价 调用原函数</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"赋值-指向新的函数\"><a href=\"#赋值-指向新的函数\" class=\"headerlink\" title=\"赋值, 指向新的函数?\"></a>赋值, 指向新的函数?</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compareInt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i1 &lt; i2 ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;      <span class=\"comment\">// i1 &lt; i2, 返回true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明并定义</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> (*pf)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;) = &amp;compareInt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 赋nullptr:指针没有指向任何一个函数</span></span><br><span class=\"line\">pf = <span class=\"number\">0</span>;</span><br><span class=\"line\">pf = getLarger;     <span class=\"comment\">// error: pf已经被声明成bool(*)(const int&amp;, const int&amp;)</span></span><br><span class=\"line\">pf = increment;     <span class=\"comment\">// error: 同上</span></span><br></pre></td></tr></table></figure>\n<p>能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。</p>\n<p><code>但如果是一个类型相同的函数, 便可以重新指向该函数。</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">otherCompare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; i1, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;)</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pf = otherCompare;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载函数的指针\"><a href=\"#重载函数的指针\" class=\"headerlink\" title=\"重载函数的指针\"></a>重载函数的指针</h4><p>函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span>*)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重载</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*pff1)(<span class=\"keyword\">int</span> *) = &amp;ff;      <span class=\"comment\">// pff1指向ff的 void (int*)版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (*pff2)(<span class=\"keyword\">int</span>) = &amp;ff;        <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*pff3)(<span class=\"keyword\">unsigned</span>) = &amp;ff;    <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"函数指针作为形参-调用函数指针\"><a href=\"#函数指针作为形参-调用函数指针\" class=\"headerlink\" title=\"函数指针作为形参(调用函数指针)\"></a>函数指针作为形参(调用函数指针)</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三个参数是函数指针类型</span></span><br><span class=\"line\">void useBigger(const int&amp;, const int&amp;, bool (*pf)(const int&amp;, const int&amp;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用时, 传入指向compareInt的指针</span></span><br><span class=\"line\">useBigger(i1, i2, &amp;compareInt);</span><br></pre></td></tr></table></figure>\n<p>可以用别名的方法简化定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(compareInt)</span> *FuncP2</span>;    <span class=\"comment\">// FuncP2是指向函数的指针类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">decltype</span><span class=\"params\">(compareInt)</span> Func</span>;       <span class=\"comment\">// decltype()返回函数类型, Func是函数类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useBigger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, FuncP2)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useBigger</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, Func2)</span></span>;   <span class=\"comment\">// 编译器将Func2函数类型自动转换为了函数的指针类型</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"返回指向函数的指针\"><a href=\"#返回指向函数的指针\" class=\"headerlink\" title=\"返回指向函数的指针\"></a>返回指向函数的指针</h4><p>一般, 别名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> PF = <span class=\"keyword\">bool</span>(*)(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);      <span class=\"comment\">// PF是函数的指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> F = <span class=\"keyword\">bool</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp;);          <span class=\"comment\">// F是指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">PF <span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;          <span class=\"comment\">// 返回函数的指针类型</span></span><br><span class=\"line\"><span class=\"function\">F *<span class=\"title\">f1</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;          <span class=\"comment\">// 显式f1返回的是一个指针类型</span></span><br><span class=\"line\"><span class=\"function\">F <span class=\"title\">f2</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;           <span class=\"comment\">// Error:F是函数类型, 无法返回一个函数</span></span><br></pre></td></tr></table></figure>\n<p>尾置<br><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">auto f1(int) -&gt; int(*)(int*, int)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a><span style=\"color:red\"><strong>函数对象</strong></span></h3><h4 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载()\"></a>重载()</h4><p>说明这个对象, 他可以当作函数来使用。因此需要重载”()”</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个函数对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum</span>&#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> iarr[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">      sum += iarr[i];</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用这个函数对象\"><a href=\"#使用这个函数对象\" class=\"headerlink\" title=\"使用这个函数对象\"></a>使用这个函数对象</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sum s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">6</span>;</span><br><span class=\"line\">s(iarr, n);      <span class=\"comment\">// sum = 21</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为其他函数的参数\"><a href=\"#作为其他函数的参数\" class=\"headerlink\" title=\"作为其他函数的参数\"></a>作为其他函数的参数</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数对象作为另一个函数的形参</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> CLS&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(CLS &amp; c)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">3</span>;</span><br><span class=\"line\">  c(iarr, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">Sum s1;</span><br><span class=\"line\">f(s1);       <span class=\"comment\">// sum = 18</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"回顾一下数据结构中的用法\"><a href=\"#回顾一下数据结构中的用法\" class=\"headerlink\" title=\"回顾一下数据结构中的用法\"></a>回顾一下数据结构中的用法</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> VST&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::traverse(VST visit) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 对每个元素执行visit操作</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) &#123;visit(_elem[i]);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为什么不能用引用类型?</span></span><br><span class=\"line\"><span class=\"comment\">// no known conversion for argument 1 from ‘Increase&lt;int&gt;’ to ‘Increase&lt;int&gt;&amp;’</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* my error test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void increase(Vector&lt;T&gt; V) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  V.traverse(Increase(T&amp; e));</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Increase&lt;T&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为什么不用实例化, 带入参数便可直接调用??</span></span><br></pre></td></tr></table></figure>\n"},{"title":"C++ Zero To One 0.002","date":"2018-01-10T05:01:23.000Z","_content":"\n# 数组, 指针数组, 指向指针的指针的数组, ....\n在逛[Cplusplus Forum - Beginner](http://www.cplusplus.com/forum/beginner/)的时候发现了一个看上去看简单的[问题](http://www.cplusplus.com/forum/beginner/228196/)\n\n**How do I receive two numbers from the keyboard, save them in an array of two element?**\n\n## **第一次尝试**\n```cpp\nvoid f0() {     // ERROR: 先存放再输入不会修改数组中的数据\n  int a, b;\n  int iarr[2] = {a, b};\n  std::cin >> a >> b;   // 不合理:先存放, 再输入\n  std::cout << iarr[0] << ' ' << iarr[1] << std::endl;\n  // 4197661 0\n}\n```\n\n我想得太简单了。不能在标准输入中, 直接对数据进行修改。\n\n## **下面给出的答案**\n\n1, \n```cpp\nvoid f1() {\n  int iarr[2] = {};\n  std::cin >> iarr[0] >> iarr[1];     // 直接输入到数组中\n}\n```\n\n2, \n```cpp\nvoid f2() {\n  int a, b;\n  std::cin >> a >> b;     // 先输入, 再存放\n  int iarr[2] = {a, b};\n}\n```\n\n## **但是我仍然考虑我思路实现的可能性？**\n\n对已经放置在数组中的值进行修改的思路如何实现？\n\n### 第一个想到的就是指针。\n\n```cpp\nvoid f3() {  // BUG: 为什么不能通过数组中保存的指针修改数组??\n  int *pa, *pb;\n  int* iarr[2] = {pa, pb};\n  int tmp_a, tmp_b;\n  std::cin >> tmp_a >> tmp_b;        // 存放到临时变量\n  pa = &tmp_a; pb = &tmp_b;\n  std::cout << \"*pa = \" << *pa << std::endl;    // *pa = 1\n  std::cout << *(*iarr) << std::endl;\n  std::cout << *(iarr[0]) << ' ' << *(iarr[1]) << std::endl;\n}\n```\n\n```sh\n$ ./a.out\n1\n2\n*pa = 1\nSegmentation fault (core dumped)\n```\n\n很气, 我得出结论。不能通过数组中保存的指针修改数组。\n\n### 数组作为函数形参\n接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：\n**创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回**\n\n```cpp\nvoid revise_value_int(int* arr, int n) {\n  // 索引为n指向的整数递增1\n  (*(arr+n)) += 1;\n}\n\nvoid call_revise() {\n  int iarr[] = {0, 1, 2};\n  revise_value_int(iarr, 2);\n  std::cout << \"iarr[2] = \" << iarr[2] << std::endl;\n}\n\ncall_revise();\n```\n可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。\n\n### 函数形参为存放指针的数组\n\n接着，我改变了数组，用于存放指针\n```cpp\nint* pa, *pb, *pc;\nint ptrArr[] = {pa, pb, pc};\n```\n\n编译时就出现了错误,.*error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]*\n**因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\\***\n\n\n\n修改\n```cpp\nint* pa, *pb, *pc;\nint* ptrArr[] = {pa, pb, pc};\n```\n\n写修改指针所指向整数的函数, 注意, 这个形参类型是`int**`, **ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。**\n```cpp\nvoid revise_value_ptr(int** ptrArr, int n) {\n  // 索引为n的指向的指针所指向的整数递增1\n  (**(ptrArr+n))+=1;\n}\n```\n\n### Segmentation fault (core dumped) \n再次编译\n```sh\nSegmentation fault (core dumped)\n```\n\n\n出现 Segmentation fault (core dumped) 的原因， 参考[http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html]\n#### 1 内存访问越界\n\n  a) 由于使用错误的下标，导致数组访问越界\n\n  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符\n\n  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。\n \n\n#### 2 多线程程序使用了线程不安全的函数。\n\n#### 3 多线程读写的数据未加锁保护。\n\n对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump\n\n \n\n#### 非法指针\n  a) 使用空指针\n  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.\n\n#### 堆栈溢出\n\n不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。\n\n### 非法指针\n我的代码是:\n```cpp\nint* pa, *pb, *pc;\nint* ptrArr[] = {pa, pb, pc};\n```\n这里我使用了非法的指针, 这个指针没有指向任何\n\n修改,\n\n\n```cpp\nvoid call_revise() {\n  int a = 1, b = 2, c = 3;\n  int* pa = &a, *pb = &b, *pc = &c;\n  int* ptrArr[] = {pa, pb, pc};\n  another_revise_value_ptr(ptrArr, 2);\n  std::cout << \"**(ptrArr)   = \" << **(ptrArr)   << '\\n'\n            << \"**(ptrArr+1) = \" << **(ptrArr+1) << '\\n'\n            << \"**(ptrArr+2) = \" << **(ptrArr+2) << std::endl;\n}\n\ncall_revise()\n```\n编译得到\n```sh\n**(ptrArr)   = 1\n**(ptrArr+1) = 2\n**(ptrArr+2) = 4\n```\n\n### 解决最开始问题并总结\n\n**修改后的代码**\n```cpp\nvoid f4() {     // DEBUG: 先存放再输入不会修改数组中的数据\n  int a, b;\n  int* pa = &a, int* pb = &b;     // 注意: 不要定义空指针\n  int* iarr[2] = {pa, pb};        // 注意数组的类型是数组中元素的类型\n  std::cin >> a >> b;   // 也能合理:先存放, 再输入\n  std::cout << **iarr << ' ' << **(iarr+1) << std::endl; // 解引用\n  // 4197661 0\n}\n```\n\n#### 不要定义空指针\n\n如这样 \n```cpp\nint* pa;\n```\n即使要定义也要\n```\nint *pa = 0;\nint *pb = nullptr;\n```\n尽量让指针指向某个对象\n```cpp\nint *pa = &a;\n```\n\n#### 数组的类型 \n数组的类型是数组中元素的类型\n```cpp\nint* iarr[2] = {pa, pb};        // 类型为 int*\n```\n\n#### 解引用数组\n\n```cpp\nint* iarr[2] = {pa, pb};        // 如果数组这样定义\niarr;                           // iarr是指向数组首个元素的指针\n*iarr;                          // 因为pa是指针, 所以解引用数组头指针, 得到pa地址\n**iarr;                         // 再次解引用得到pa指向的int\n```\n\n标准输出它们得到\n```sh\niarr = 0x7ffed5caa560\n*iarr = 0x7ffed5caa548\n**iarr = 1\n```\n\n\n## **更多的尝试**\n\n### 数组中存放对象\n```cpp\ntemplate <typename T>\nclass Name {\n  char* _c; int _length; int _capacity;\n public:\n  Name(char* c, int length): _c(c), _length(length) {}\n  char* getName() const;\n  int getLength() const;\n};\n\ntemplate <typename T>\nchar* Name<T>::getName() const {\n  return _c;\n}\n\ntemplate <typename T>\nint Name<T>::getLength() const {\n  return _length;\n}\n\n\n\nvoid class_array() {\n  char c1[] = {'t', 'i', 'm'};\n  char c2[] = {'h', 'u'};\n  int length1 = 3, length2 = 2;\n  Name<int> name1(c1, length1), name2(c2, length2);\n  Name<int> nArr[] = {name1, name2};\n  int size = 2;\n  print_instance_data_in_array(nArr, size);\n}\n\nvoid f() {\n  char c[] = {'t', 'i', 'm'};\n  int length = 3;\n  Name<int> n(c, length);\n}\n\nvoid print_instance_data_in_array(Name<int>* nArr, int size) {\n  for (int i = 0; i < size; i++) {\n    std::cout << \"Name = \";\n    for (int j = 0; j < nArr[i].getLength(); j++) {\n      std::cout << *((nArr[i].getName())+j);\n    }\n    std::cout << \"\\n\";\n  }\n}\n```\n\n```sh\nName = tim\nName = hu\n```\n\n面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。\n\n### 数组中存放长度不同的数组\n\n```cpp\nvoid f_array() {\n  int a = 3, b = 5, c = 7;\n  int* pa = &a, *pb = &b, *pc = &c;\n  int _size_pa = 1, _size_pb = 1, _size_pc = 1;\n  int* pArr1[] = {pa};    // pArr1数组存放pa, pb指针\n  int _size_pArr1 = 1;\n  int* pArr2[] = {pa, pb, pc};    // pArr2数组存放pa, pb, pc指针\n  int _size_pArr2 = 3;\n  int* pArr3[] = {pa, pc};\n  int _size_pArr3 = 2;\n  int size_pArr[] = {1, 3, 2};\n  int** ppArr[] = {pArr1, pArr2, pArr3};   // ppArr存放3个指针数组\n  int _size_ppArr = 3;\n  int size_ppArr[] = {3};\n  int* size_arr[] = {size_ppArr, size_pArr};\n  // convert_size_structor(size_arr);\n  print_arr_b(ppArr);\n}\n\nvoid print_arr_b(int*** ppArr) {\n  // 解引用并打印ppArr数组中依次数组中的pa, pb, pc\n  std::cout << \"a0 = \" << ***ppArr<< \" in pArr1[0]\" << '\\n'\n            << \"b0 = \" << **(*(ppArr+1)+1)<< \" in pArr2[1]\" << '\\n'\n            << \"c0 = \" << **(*(ppArr+2)+1)<< \" in pArr3[1]\" << '\\n'\n            << std::endl;\n}\n```\n\n对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。\n## **感想**\n即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。\n\n\n# 常量成员函数\n\n```cpp\nclass MyClass {\n  int x = 0;\n public:\n  int c = 5;\n  MyClass(int v) :x(v) {}\n  const int& get() const {return x;}   // 常量成员函数在是否为常量上可以重载\n  int& get() {return --x;}\n};\n```\n\n\n## 声明时引用符号总最靠近变量名\n## 为什么可以对a.get()赋值\nget()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。\n\n## 在是否为成员函数上重载后如何匹配?\n成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。\n\n## const int& get() const {return x;} 为什么返回类型需要const?\n常量函数返回数据成员, 编译器会将数据成员声明成const类型;\n\n## 什么是数据成员?\nMyClass类public中定义新成员测试是否为数据成员。\n\n```cpp\n//..\nint a = 5\nconst int& get() const {return --a;}    // 错误：改变a的值, \n```\n\n改变a的值无法通过编译, a为数据成员。\n\n在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。\n\n\n\n# template基础用法\n\n## typename T 和 class T的区别\n在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class\n\n`<<C++ Primer 5th>> P580 模板与泛型编程`\n\n## 特殊化模板 \n\n```cpp\ntemplate <typename T>\nclass mycontainer {\n  T element;\n public:\n  mycontainer(const T e) : element(e) {}\n  T increase() {return ++element;}    // 递增element\n  T getElement() const {return element;}   // 返回element数据\n};\n```\n\n对char类型, 有特定的方法uppercase()大写化字母\n```cpp\ntemplate <>\nclass mycontainer<char> {\n  char element;\n public:\n  mycontainer(const char e): element(e) {}\n  char increase() {return ++element;}    // 递增char\n  char getElement() const {return element;}   // 返回element数据\n  char uppercase() {\n    if (element <= 'z' && element >= 'a') {   // 是小写字母\n      element += 'A' - 'a'; return element;\n    }  // 返回元素\n    std::cout << \"element \" << element << \"is not lower\" << std::endl;\n    return element;\n  }\n};\n```\n\n格式如下\n```cpp\n template <typename T> class mycontainer {...}\n template <> class mycontainer<char> {...}\n ```\n \n","source":"_posts/cpp/cpp-notes-02.md","raw":"---\ntitle: C++ Zero To One 0.002\ndate: 2018-01-10 13:01:23\ntags: [C++, 指针, 数组, 常量成员函数, 模板]\n---\n\n# 数组, 指针数组, 指向指针的指针的数组, ....\n在逛[Cplusplus Forum - Beginner](http://www.cplusplus.com/forum/beginner/)的时候发现了一个看上去看简单的[问题](http://www.cplusplus.com/forum/beginner/228196/)\n\n**How do I receive two numbers from the keyboard, save them in an array of two element?**\n\n## **第一次尝试**\n```cpp\nvoid f0() {     // ERROR: 先存放再输入不会修改数组中的数据\n  int a, b;\n  int iarr[2] = {a, b};\n  std::cin >> a >> b;   // 不合理:先存放, 再输入\n  std::cout << iarr[0] << ' ' << iarr[1] << std::endl;\n  // 4197661 0\n}\n```\n\n我想得太简单了。不能在标准输入中, 直接对数据进行修改。\n\n## **下面给出的答案**\n\n1, \n```cpp\nvoid f1() {\n  int iarr[2] = {};\n  std::cin >> iarr[0] >> iarr[1];     // 直接输入到数组中\n}\n```\n\n2, \n```cpp\nvoid f2() {\n  int a, b;\n  std::cin >> a >> b;     // 先输入, 再存放\n  int iarr[2] = {a, b};\n}\n```\n\n## **但是我仍然考虑我思路实现的可能性？**\n\n对已经放置在数组中的值进行修改的思路如何实现？\n\n### 第一个想到的就是指针。\n\n```cpp\nvoid f3() {  // BUG: 为什么不能通过数组中保存的指针修改数组??\n  int *pa, *pb;\n  int* iarr[2] = {pa, pb};\n  int tmp_a, tmp_b;\n  std::cin >> tmp_a >> tmp_b;        // 存放到临时变量\n  pa = &tmp_a; pb = &tmp_b;\n  std::cout << \"*pa = \" << *pa << std::endl;    // *pa = 1\n  std::cout << *(*iarr) << std::endl;\n  std::cout << *(iarr[0]) << ' ' << *(iarr[1]) << std::endl;\n}\n```\n\n```sh\n$ ./a.out\n1\n2\n*pa = 1\nSegmentation fault (core dumped)\n```\n\n很气, 我得出结论。不能通过数组中保存的指针修改数组。\n\n### 数组作为函数形参\n接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：\n**创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回**\n\n```cpp\nvoid revise_value_int(int* arr, int n) {\n  // 索引为n指向的整数递增1\n  (*(arr+n)) += 1;\n}\n\nvoid call_revise() {\n  int iarr[] = {0, 1, 2};\n  revise_value_int(iarr, 2);\n  std::cout << \"iarr[2] = \" << iarr[2] << std::endl;\n}\n\ncall_revise();\n```\n可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。\n\n### 函数形参为存放指针的数组\n\n接着，我改变了数组，用于存放指针\n```cpp\nint* pa, *pb, *pc;\nint ptrArr[] = {pa, pb, pc};\n```\n\n编译时就出现了错误,.*error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]*\n**因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\\***\n\n\n\n修改\n```cpp\nint* pa, *pb, *pc;\nint* ptrArr[] = {pa, pb, pc};\n```\n\n写修改指针所指向整数的函数, 注意, 这个形参类型是`int**`, **ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。**\n```cpp\nvoid revise_value_ptr(int** ptrArr, int n) {\n  // 索引为n的指向的指针所指向的整数递增1\n  (**(ptrArr+n))+=1;\n}\n```\n\n### Segmentation fault (core dumped) \n再次编译\n```sh\nSegmentation fault (core dumped)\n```\n\n\n出现 Segmentation fault (core dumped) 的原因， 参考[http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html]\n#### 1 内存访问越界\n\n  a) 由于使用错误的下标，导致数组访问越界\n\n  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符\n\n  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。\n \n\n#### 2 多线程程序使用了线程不安全的函数。\n\n#### 3 多线程读写的数据未加锁保护。\n\n对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump\n\n \n\n#### 非法指针\n  a) 使用空指针\n  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.\n\n#### 堆栈溢出\n\n不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。\n\n### 非法指针\n我的代码是:\n```cpp\nint* pa, *pb, *pc;\nint* ptrArr[] = {pa, pb, pc};\n```\n这里我使用了非法的指针, 这个指针没有指向任何\n\n修改,\n\n\n```cpp\nvoid call_revise() {\n  int a = 1, b = 2, c = 3;\n  int* pa = &a, *pb = &b, *pc = &c;\n  int* ptrArr[] = {pa, pb, pc};\n  another_revise_value_ptr(ptrArr, 2);\n  std::cout << \"**(ptrArr)   = \" << **(ptrArr)   << '\\n'\n            << \"**(ptrArr+1) = \" << **(ptrArr+1) << '\\n'\n            << \"**(ptrArr+2) = \" << **(ptrArr+2) << std::endl;\n}\n\ncall_revise()\n```\n编译得到\n```sh\n**(ptrArr)   = 1\n**(ptrArr+1) = 2\n**(ptrArr+2) = 4\n```\n\n### 解决最开始问题并总结\n\n**修改后的代码**\n```cpp\nvoid f4() {     // DEBUG: 先存放再输入不会修改数组中的数据\n  int a, b;\n  int* pa = &a, int* pb = &b;     // 注意: 不要定义空指针\n  int* iarr[2] = {pa, pb};        // 注意数组的类型是数组中元素的类型\n  std::cin >> a >> b;   // 也能合理:先存放, 再输入\n  std::cout << **iarr << ' ' << **(iarr+1) << std::endl; // 解引用\n  // 4197661 0\n}\n```\n\n#### 不要定义空指针\n\n如这样 \n```cpp\nint* pa;\n```\n即使要定义也要\n```\nint *pa = 0;\nint *pb = nullptr;\n```\n尽量让指针指向某个对象\n```cpp\nint *pa = &a;\n```\n\n#### 数组的类型 \n数组的类型是数组中元素的类型\n```cpp\nint* iarr[2] = {pa, pb};        // 类型为 int*\n```\n\n#### 解引用数组\n\n```cpp\nint* iarr[2] = {pa, pb};        // 如果数组这样定义\niarr;                           // iarr是指向数组首个元素的指针\n*iarr;                          // 因为pa是指针, 所以解引用数组头指针, 得到pa地址\n**iarr;                         // 再次解引用得到pa指向的int\n```\n\n标准输出它们得到\n```sh\niarr = 0x7ffed5caa560\n*iarr = 0x7ffed5caa548\n**iarr = 1\n```\n\n\n## **更多的尝试**\n\n### 数组中存放对象\n```cpp\ntemplate <typename T>\nclass Name {\n  char* _c; int _length; int _capacity;\n public:\n  Name(char* c, int length): _c(c), _length(length) {}\n  char* getName() const;\n  int getLength() const;\n};\n\ntemplate <typename T>\nchar* Name<T>::getName() const {\n  return _c;\n}\n\ntemplate <typename T>\nint Name<T>::getLength() const {\n  return _length;\n}\n\n\n\nvoid class_array() {\n  char c1[] = {'t', 'i', 'm'};\n  char c2[] = {'h', 'u'};\n  int length1 = 3, length2 = 2;\n  Name<int> name1(c1, length1), name2(c2, length2);\n  Name<int> nArr[] = {name1, name2};\n  int size = 2;\n  print_instance_data_in_array(nArr, size);\n}\n\nvoid f() {\n  char c[] = {'t', 'i', 'm'};\n  int length = 3;\n  Name<int> n(c, length);\n}\n\nvoid print_instance_data_in_array(Name<int>* nArr, int size) {\n  for (int i = 0; i < size; i++) {\n    std::cout << \"Name = \";\n    for (int j = 0; j < nArr[i].getLength(); j++) {\n      std::cout << *((nArr[i].getName())+j);\n    }\n    std::cout << \"\\n\";\n  }\n}\n```\n\n```sh\nName = tim\nName = hu\n```\n\n面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。\n\n### 数组中存放长度不同的数组\n\n```cpp\nvoid f_array() {\n  int a = 3, b = 5, c = 7;\n  int* pa = &a, *pb = &b, *pc = &c;\n  int _size_pa = 1, _size_pb = 1, _size_pc = 1;\n  int* pArr1[] = {pa};    // pArr1数组存放pa, pb指针\n  int _size_pArr1 = 1;\n  int* pArr2[] = {pa, pb, pc};    // pArr2数组存放pa, pb, pc指针\n  int _size_pArr2 = 3;\n  int* pArr3[] = {pa, pc};\n  int _size_pArr3 = 2;\n  int size_pArr[] = {1, 3, 2};\n  int** ppArr[] = {pArr1, pArr2, pArr3};   // ppArr存放3个指针数组\n  int _size_ppArr = 3;\n  int size_ppArr[] = {3};\n  int* size_arr[] = {size_ppArr, size_pArr};\n  // convert_size_structor(size_arr);\n  print_arr_b(ppArr);\n}\n\nvoid print_arr_b(int*** ppArr) {\n  // 解引用并打印ppArr数组中依次数组中的pa, pb, pc\n  std::cout << \"a0 = \" << ***ppArr<< \" in pArr1[0]\" << '\\n'\n            << \"b0 = \" << **(*(ppArr+1)+1)<< \" in pArr2[1]\" << '\\n'\n            << \"c0 = \" << **(*(ppArr+2)+1)<< \" in pArr3[1]\" << '\\n'\n            << std::endl;\n}\n```\n\n对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。\n## **感想**\n即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。\n\n\n# 常量成员函数\n\n```cpp\nclass MyClass {\n  int x = 0;\n public:\n  int c = 5;\n  MyClass(int v) :x(v) {}\n  const int& get() const {return x;}   // 常量成员函数在是否为常量上可以重载\n  int& get() {return --x;}\n};\n```\n\n\n## 声明时引用符号总最靠近变量名\n## 为什么可以对a.get()赋值\nget()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。\n\n## 在是否为成员函数上重载后如何匹配?\n成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。\n\n## const int& get() const {return x;} 为什么返回类型需要const?\n常量函数返回数据成员, 编译器会将数据成员声明成const类型;\n\n## 什么是数据成员?\nMyClass类public中定义新成员测试是否为数据成员。\n\n```cpp\n//..\nint a = 5\nconst int& get() const {return --a;}    // 错误：改变a的值, \n```\n\n改变a的值无法通过编译, a为数据成员。\n\n在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。\n\n\n\n# template基础用法\n\n## typename T 和 class T的区别\n在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class\n\n`<<C++ Primer 5th>> P580 模板与泛型编程`\n\n## 特殊化模板 \n\n```cpp\ntemplate <typename T>\nclass mycontainer {\n  T element;\n public:\n  mycontainer(const T e) : element(e) {}\n  T increase() {return ++element;}    // 递增element\n  T getElement() const {return element;}   // 返回element数据\n};\n```\n\n对char类型, 有特定的方法uppercase()大写化字母\n```cpp\ntemplate <>\nclass mycontainer<char> {\n  char element;\n public:\n  mycontainer(const char e): element(e) {}\n  char increase() {return ++element;}    // 递增char\n  char getElement() const {return element;}   // 返回element数据\n  char uppercase() {\n    if (element <= 'z' && element >= 'a') {   // 是小写字母\n      element += 'A' - 'a'; return element;\n    }  // 返回元素\n    std::cout << \"element \" << element << \"is not lower\" << std::endl;\n    return element;\n  }\n};\n```\n\n格式如下\n```cpp\n template <typename T> class mycontainer {...}\n template <> class mycontainer<char> {...}\n ```\n \n","slug":"cpp/cpp-notes-02","published":1,"updated":"2018-06-19T16:15:03.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykf001zk8mfbzmtfykh","content":"<h1 id=\"数组-指针数组-指向指针的指针的数组-…\"><a href=\"#数组-指针数组-指向指针的指针的数组-…\" class=\"headerlink\" title=\"数组, 指针数组, 指向指针的指针的数组, ….\"></a>数组, 指针数组, 指向指针的指针的数组, ….</h1><p>在逛<a href=\"http://www.cplusplus.com/forum/beginner/\" target=\"_blank\" rel=\"noopener\">Cplusplus Forum - Beginner</a>的时候发现了一个看上去看简单的<a href=\"http://www.cplusplus.com/forum/beginner/228196/\" target=\"_blank\" rel=\"noopener\">问题</a></p>\n<p><strong>How do I receive two numbers from the keyboard, save them in an array of two element?</strong></p>\n<h2 id=\"第一次尝试\"><a href=\"#第一次尝试\" class=\"headerlink\" title=\"第一次尝试\"></a><strong>第一次尝试</strong></h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f0</span><span class=\"params\">()</span> </span>&#123;     <span class=\"comment\">// ERROR: 先存放再输入不会修改数组中的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;a, b&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;   <span class=\"comment\">// 不合理:先存放, 再输入</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; iarr[<span class=\"number\">0</span>] &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; iarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 4197661 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我想得太简单了。不能在标准输入中, 直接对数据进行修改。</p>\n<h2 id=\"下面给出的答案\"><a href=\"#下面给出的答案\" class=\"headerlink\" title=\"下面给出的答案\"></a><strong>下面给出的答案</strong></h2><p>1,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; iarr[<span class=\"number\">0</span>] &gt;&gt; iarr[<span class=\"number\">1</span>];     <span class=\"comment\">// 直接输入到数组中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;     <span class=\"comment\">// 先输入, 再存放</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;a, b&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"但是我仍然考虑我思路实现的可能性？\"><a href=\"#但是我仍然考虑我思路实现的可能性？\" class=\"headerlink\" title=\"但是我仍然考虑我思路实现的可能性？\"></a><strong>但是我仍然考虑我思路实现的可能性？</strong></h2><p>对已经放置在数组中的值进行修改的思路如何实现？</p>\n<h3 id=\"第一个想到的就是指针。\"><a href=\"#第一个想到的就是指针。\" class=\"headerlink\" title=\"第一个想到的就是指针。\"></a>第一个想到的就是指针。</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// <span class=\"doctag\">BUG:</span> 为什么不能通过数组中保存的指针修改数组??</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *pa, *pb;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> tmp_a, tmp_b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; tmp_a &gt;&gt; tmp_b;        <span class=\"comment\">// 存放到临时变量</span></span><br><span class=\"line\">  pa = &amp;tmp_a; pb = &amp;tmp_b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*pa = \"</span> &lt;&lt; *pa &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// *pa = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *(*iarr) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *(iarr[<span class=\"number\">0</span>]) &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; *(iarr[<span class=\"number\">1</span>]) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./a.out</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">*pa = 1</span><br><span class=\"line\">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>\n<p>很气, 我得出结论。不能通过数组中保存的指针修改数组。</p>\n<h3 id=\"数组作为函数形参\"><a href=\"#数组作为函数形参\" class=\"headerlink\" title=\"数组作为函数形参\"></a>数组作为函数形参</h3><p>接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：<br><strong>创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revise_value_int</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 索引为n指向的整数递增1</span></span><br><span class=\"line\">  (*(arr+n)) += <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_revise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  revise_value_int(iarr, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"iarr[2] = \"</span> &lt;&lt; iarr[<span class=\"number\">2</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call_revise();</span><br></pre></td></tr></table></figure>\n<p>可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。</p>\n<h3 id=\"函数形参为存放指针的数组\"><a href=\"#函数形参为存放指针的数组\" class=\"headerlink\" title=\"函数形参为存放指针的数组\"></a>函数形参为存放指针的数组</h3><p>接着，我改变了数组，用于存放指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>编译时就出现了错误,.<em>error: invalid conversion from ‘int</em>’ to ‘int’ [-fpermissive]<em><br><strong>因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\\</strong></em></p>\n<p>修改<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>写修改指针所指向整数的函数, 注意, 这个形参类型是<code>int**</code>, <strong>ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revise_value_ptr</span><span class=\"params\">(<span class=\"keyword\">int</span>** ptrArr, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 索引为n的指向的指针所指向的整数递增1</span></span><br><span class=\"line\">  (**(ptrArr+n))+=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Segmentation-fault-core-dumped\"><a href=\"#Segmentation-fault-core-dumped\" class=\"headerlink\" title=\"Segmentation fault (core dumped)\"></a>Segmentation fault (core dumped)</h3><p>再次编译<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>\n<p>出现 Segmentation fault (core dumped) 的原因， 参考[<a href=\"http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html</a>]</p>\n<h4 id=\"1-内存访问越界\"><a href=\"#1-内存访问越界\" class=\"headerlink\" title=\"1 内存访问越界\"></a>1 内存访问越界</h4><p>  a) 由于使用错误的下标，导致数组访问越界</p>\n<p>  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>\n<p>  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>\n<h4 id=\"2-多线程程序使用了线程不安全的函数。\"><a href=\"#2-多线程程序使用了线程不安全的函数。\" class=\"headerlink\" title=\"2 多线程程序使用了线程不安全的函数。\"></a>2 多线程程序使用了线程不安全的函数。</h4><h4 id=\"3-多线程读写的数据未加锁保护。\"><a href=\"#3-多线程读写的数据未加锁保护。\" class=\"headerlink\" title=\"3 多线程读写的数据未加锁保护。\"></a>3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>\n<h4 id=\"非法指针\"><a href=\"#非法指针\" class=\"headerlink\" title=\"非法指针\"></a>非法指针</h4><p>  a) 使用空指针<br>  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>\n<h4 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a>堆栈溢出</h4><p>不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>\n<h3 id=\"非法指针-1\"><a href=\"#非法指针-1\" class=\"headerlink\" title=\"非法指针\"></a>非法指针</h3><p>我的代码是:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这里我使用了非法的指针, 这个指针没有指向任何</p>\n<p>修改,</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_revise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br><span class=\"line\">  another_revise_value_ptr(ptrArr, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"**(ptrArr)   = \"</span> &lt;&lt; **(ptrArr)   &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"**(ptrArr+1) = \"</span> &lt;&lt; **(ptrArr+<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"**(ptrArr+2) = \"</span> &lt;&lt; **(ptrArr+<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call_revise()</span><br></pre></td></tr></table></figure>\n<p>编译得到<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">**(ptrArr)   = 1</span><br><span class=\"line\">**(ptrArr+1) = 2</span><br><span class=\"line\">**(ptrArr+2) = 4</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决最开始问题并总结\"><a href=\"#解决最开始问题并总结\" class=\"headerlink\" title=\"解决最开始问题并总结\"></a>解决最开始问题并总结</h3><p><strong>修改后的代码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> </span>&#123;     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span> 先存放再输入不会修改数组中的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, <span class=\"keyword\">int</span>* pb = &amp;b;     <span class=\"comment\">// 注意: 不要定义空指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 注意数组的类型是数组中元素的类型</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;   <span class=\"comment\">// 也能合理:先存放, 再输入</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; **iarr &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; **(iarr+<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// 解引用</span></span><br><span class=\"line\">  <span class=\"comment\">// 4197661 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"不要定义空指针\"><a href=\"#不要定义空指针\" class=\"headerlink\" title=\"不要定义空指针\"></a>不要定义空指针</h4><p>如这样<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa;</span><br></pre></td></tr></table></figure></p>\n<p>即使要定义也要<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int *pa = 0;</span><br><span class=\"line\">int *pb = nullptr;</span><br></pre></td></tr></table></figure></p>\n<p>尽量让指针指向某个对象<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h4><p>数组的类型是数组中元素的类型<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 类型为 int*</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"解引用数组\"><a href=\"#解引用数组\" class=\"headerlink\" title=\"解引用数组\"></a>解引用数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 如果数组这样定义</span></span><br><span class=\"line\">iarr;                           <span class=\"comment\">// iarr是指向数组首个元素的指针</span></span><br><span class=\"line\">*iarr;                          <span class=\"comment\">// 因为pa是指针, 所以解引用数组头指针, 得到pa地址</span></span><br><span class=\"line\">**iarr;                         <span class=\"comment\">// 再次解引用得到pa指向的int</span></span><br></pre></td></tr></table></figure>\n<p>标准输出它们得到<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">iarr = 0x7ffed5caa560</span><br><span class=\"line\">*iarr = 0x7ffed5caa548</span><br><span class=\"line\">**iarr = 1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"更多的尝试\"><a href=\"#更多的尝试\" class=\"headerlink\" title=\"更多的尝试\"></a><strong>更多的尝试</strong></h2><h3 id=\"数组中存放对象\"><a href=\"#数组中存放对象\" class=\"headerlink\" title=\"数组中存放对象\"></a>数组中存放对象</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _c; <span class=\"keyword\">int</span> _length; <span class=\"keyword\">int</span> _capacity;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Name(<span class=\"keyword\">char</span>* c, <span class=\"keyword\">int</span> length): _c(c), _length(length) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">char</span>* Name&lt;T&gt;::getName() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Name&lt;T&gt;::getLength() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">class_array</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c1[] = &#123;<span class=\"string\">'t'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'m'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c2[] = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'u'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length1 = <span class=\"number\">3</span>, length2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; name1(c1, length1), name2(c2, length2);</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; nArr[] = &#123;name1, name2&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size = <span class=\"number\">2</span>;</span><br><span class=\"line\">  print_instance_data_in_array(nArr, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c[] = &#123;<span class=\"string\">'t'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'m'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = <span class=\"number\">3</span>;</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; n(c, length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_instance_data_in_array</span><span class=\"params\">(Name&lt;<span class=\"keyword\">int</span>&gt;* nArr, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name = \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; nArr[i].getLength(); j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *((nArr[i].getName())+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Name = tim</span><br><span class=\"line\">Name = hu</span><br></pre></td></tr></table></figure>\n<p>面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。</p>\n<h3 id=\"数组中存放长度不同的数组\"><a href=\"#数组中存放长度不同的数组\" class=\"headerlink\" title=\"数组中存放长度不同的数组\"></a>数组中存放长度不同的数组</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f_array</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">5</span>, c = <span class=\"number\">7</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pa = <span class=\"number\">1</span>, _size_pb = <span class=\"number\">1</span>, _size_pc = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr1[] = &#123;pa&#125;;    <span class=\"comment\">// pArr1数组存放pa, pb指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr2[] = &#123;pa, pb, pc&#125;;    <span class=\"comment\">// pArr2数组存放pa, pb, pc指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr2 = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr3[] = &#123;pa, pc&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr3 = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size_pArr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>** ppArr[] = &#123;pArr1, pArr2, pArr3&#125;;   <span class=\"comment\">// ppArr存放3个指针数组</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_ppArr = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size_ppArr[] = &#123;<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* size_arr[] = &#123;size_ppArr, size_pArr&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// convert_size_structor(size_arr);</span></span><br><span class=\"line\">  print_arr_b(ppArr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_arr_b</span><span class=\"params\">(<span class=\"keyword\">int</span>*** ppArr)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解引用并打印ppArr数组中依次数组中的pa, pb, pc</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a0 = \"</span> &lt;&lt; ***ppArr&lt;&lt; <span class=\"string\">\" in pArr1[0]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"b0 = \"</span> &lt;&lt; **(*(ppArr+<span class=\"number\">1</span>)+<span class=\"number\">1</span>)&lt;&lt; <span class=\"string\">\" in pArr2[1]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"c0 = \"</span> &lt;&lt; **(*(ppArr+<span class=\"number\">2</span>)+<span class=\"number\">1</span>)&lt;&lt; <span class=\"string\">\" in pArr3[1]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a><strong>感想</strong></h2><p>即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。</p>\n<h1 id=\"常量成员函数\"><a href=\"#常量成员函数\" class=\"headerlink\" title=\"常量成员函数\"></a>常量成员函数</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = <span class=\"number\">5</span>;</span><br><span class=\"line\">  MyClass(<span class=\"keyword\">int</span> v) :x(v) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> x;&#125;   <span class=\"comment\">// 常量成员函数在是否为常量上可以重载</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> --x;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明时引用符号总最靠近变量名\"><a href=\"#声明时引用符号总最靠近变量名\" class=\"headerlink\" title=\"声明时引用符号总最靠近变量名\"></a>声明时引用符号总最靠近变量名</h2><h2 id=\"为什么可以对a-get-赋值\"><a href=\"#为什么可以对a-get-赋值\" class=\"headerlink\" title=\"为什么可以对a.get()赋值\"></a>为什么可以对a.get()赋值</h2><p>get()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。</p>\n<h2 id=\"在是否为成员函数上重载后如何匹配\"><a href=\"#在是否为成员函数上重载后如何匹配\" class=\"headerlink\" title=\"在是否为成员函数上重载后如何匹配?\"></a>在是否为成员函数上重载后如何匹配?</h2><p>成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。</p>\n<h2 id=\"const-int-amp-get-const-return-x-为什么返回类型需要const\"><a href=\"#const-int-amp-get-const-return-x-为什么返回类型需要const\" class=\"headerlink\" title=\"const int&amp; get() const {return x;} 为什么返回类型需要const?\"></a>const int&amp; get() const {return x;} 为什么返回类型需要const?</h2><p>常量函数返回数据成员, 编译器会将数据成员声明成const类型;</p>\n<h2 id=\"什么是数据成员\"><a href=\"#什么是数据成员\" class=\"headerlink\" title=\"什么是数据成员?\"></a>什么是数据成员?</h2><p>MyClass类public中定义新成员测试是否为数据成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//..</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; get() <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> --a;&#125;    <span class=\"comment\">// 错误：改变a的值,</span></span><br></pre></td></tr></table></figure>\n<p>改变a的值无法通过编译, a为数据成员。</p>\n<p>在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。</p>\n<h1 id=\"template基础用法\"><a href=\"#template基础用法\" class=\"headerlink\" title=\"template基础用法\"></a>template基础用法</h1><h2 id=\"typename-T-和-class-T的区别\"><a href=\"#typename-T-和-class-T的区别\" class=\"headerlink\" title=\"typename T 和 class T的区别\"></a>typename T 和 class T的区别</h2><p>在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class</p>\n<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P580 模板与泛型编程</code></p>\n<h2 id=\"特殊化模板\"><a href=\"#特殊化模板\" class=\"headerlink\" title=\"特殊化模板\"></a>特殊化模板</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span> &#123;</span></span><br><span class=\"line\">  T element;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  mycontainer(<span class=\"keyword\">const</span> T e) : element(e) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\">T <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> ++element;&#125;    <span class=\"comment\">// 递增element</span></span><br><span class=\"line\">  <span class=\"function\">T <span class=\"title\">getElement</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> element;&#125;   <span class=\"comment\">// 返回element数据</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对char类型, 有特定的方法uppercase()大写化字母<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span>&lt;char&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> element;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  mycontainer(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> e): element(e) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> ++element;&#125;    <span class=\"comment\">// 递增char</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">getElement</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> element;&#125;   <span class=\"comment\">// 返回element数据</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">uppercase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &lt;= <span class=\"string\">'z'</span> &amp;&amp; element &gt;= <span class=\"string\">'a'</span>) &#123;   <span class=\"comment\">// 是小写字母</span></span><br><span class=\"line\">      element += <span class=\"string\">'A'</span> - <span class=\"string\">'a'</span>; <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;  <span class=\"comment\">// 返回元素</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"element \"</span> &lt;&lt; element &lt;&lt; <span class=\"string\">\"is not lower\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>格式如下<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span> &#123;</span>...&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span>&lt;char&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组-指针数组-指向指针的指针的数组-…\"><a href=\"#数组-指针数组-指向指针的指针的数组-…\" class=\"headerlink\" title=\"数组, 指针数组, 指向指针的指针的数组, ….\"></a>数组, 指针数组, 指向指针的指针的数组, ….</h1><p>在逛<a href=\"http://www.cplusplus.com/forum/beginner/\" target=\"_blank\" rel=\"noopener\">Cplusplus Forum - Beginner</a>的时候发现了一个看上去看简单的<a href=\"http://www.cplusplus.com/forum/beginner/228196/\" target=\"_blank\" rel=\"noopener\">问题</a></p>\n<p><strong>How do I receive two numbers from the keyboard, save them in an array of two element?</strong></p>\n<h2 id=\"第一次尝试\"><a href=\"#第一次尝试\" class=\"headerlink\" title=\"第一次尝试\"></a><strong>第一次尝试</strong></h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f0</span><span class=\"params\">()</span> </span>&#123;     <span class=\"comment\">// ERROR: 先存放再输入不会修改数组中的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;a, b&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;   <span class=\"comment\">// 不合理:先存放, 再输入</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; iarr[<span class=\"number\">0</span>] &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; iarr[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 4197661 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我想得太简单了。不能在标准输入中, 直接对数据进行修改。</p>\n<h2 id=\"下面给出的答案\"><a href=\"#下面给出的答案\" class=\"headerlink\" title=\"下面给出的答案\"></a><strong>下面给出的答案</strong></h2><p>1,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; iarr[<span class=\"number\">0</span>] &gt;&gt; iarr[<span class=\"number\">1</span>];     <span class=\"comment\">// 直接输入到数组中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2,<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;     <span class=\"comment\">// 先输入, 再存放</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[<span class=\"number\">2</span>] = &#123;a, b&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"但是我仍然考虑我思路实现的可能性？\"><a href=\"#但是我仍然考虑我思路实现的可能性？\" class=\"headerlink\" title=\"但是我仍然考虑我思路实现的可能性？\"></a><strong>但是我仍然考虑我思路实现的可能性？</strong></h2><p>对已经放置在数组中的值进行修改的思路如何实现？</p>\n<h3 id=\"第一个想到的就是指针。\"><a href=\"#第一个想到的就是指针。\" class=\"headerlink\" title=\"第一个想到的就是指针。\"></a>第一个想到的就是指针。</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f3</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">// <span class=\"doctag\">BUG:</span> 为什么不能通过数组中保存的指针修改数组??</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> *pa, *pb;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> tmp_a, tmp_b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; tmp_a &gt;&gt; tmp_b;        <span class=\"comment\">// 存放到临时变量</span></span><br><span class=\"line\">  pa = &amp;tmp_a; pb = &amp;tmp_b;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*pa = \"</span> &lt;&lt; *pa &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// *pa = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *(*iarr) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *(iarr[<span class=\"number\">0</span>]) &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; *(iarr[<span class=\"number\">1</span>]) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./a.out</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">*pa = 1</span><br><span class=\"line\">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>\n<p>很气, 我得出结论。不能通过数组中保存的指针修改数组。</p>\n<h3 id=\"数组作为函数形参\"><a href=\"#数组作为函数形参\" class=\"headerlink\" title=\"数组作为函数形参\"></a>数组作为函数形参</h3><p>接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：<br><strong>创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revise_value_int</span><span class=\"params\">(<span class=\"keyword\">int</span>* arr, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 索引为n指向的整数递增1</span></span><br><span class=\"line\">  (*(arr+n)) += <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_revise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> iarr[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  revise_value_int(iarr, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"iarr[2] = \"</span> &lt;&lt; iarr[<span class=\"number\">2</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call_revise();</span><br></pre></td></tr></table></figure>\n<p>可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。</p>\n<h3 id=\"函数形参为存放指针的数组\"><a href=\"#函数形参为存放指针的数组\" class=\"headerlink\" title=\"函数形参为存放指针的数组\"></a>函数形参为存放指针的数组</h3><p>接着，我改变了数组，用于存放指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>编译时就出现了错误,.<em>error: invalid conversion from ‘int</em>’ to ‘int’ [-fpermissive]<em><br><strong>因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\\</strong></em></p>\n<p>修改<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>写修改指针所指向整数的函数, 注意, 这个形参类型是<code>int**</code>, <strong>ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">revise_value_ptr</span><span class=\"params\">(<span class=\"keyword\">int</span>** ptrArr, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 索引为n的指向的指针所指向的整数递增1</span></span><br><span class=\"line\">  (**(ptrArr+n))+=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Segmentation-fault-core-dumped\"><a href=\"#Segmentation-fault-core-dumped\" class=\"headerlink\" title=\"Segmentation fault (core dumped)\"></a>Segmentation fault (core dumped)</h3><p>再次编译<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>\n<p>出现 Segmentation fault (core dumped) 的原因， 参考[<a href=\"http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html</a>]</p>\n<h4 id=\"1-内存访问越界\"><a href=\"#1-内存访问越界\" class=\"headerlink\" title=\"1 内存访问越界\"></a>1 内存访问越界</h4><p>  a) 由于使用错误的下标，导致数组访问越界</p>\n<p>  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>\n<p>  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>\n<h4 id=\"2-多线程程序使用了线程不安全的函数。\"><a href=\"#2-多线程程序使用了线程不安全的函数。\" class=\"headerlink\" title=\"2 多线程程序使用了线程不安全的函数。\"></a>2 多线程程序使用了线程不安全的函数。</h4><h4 id=\"3-多线程读写的数据未加锁保护。\"><a href=\"#3-多线程读写的数据未加锁保护。\" class=\"headerlink\" title=\"3 多线程读写的数据未加锁保护。\"></a>3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>\n<h4 id=\"非法指针\"><a href=\"#非法指针\" class=\"headerlink\" title=\"非法指针\"></a>非法指针</h4><p>  a) 使用空指针<br>  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>\n<h4 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a>堆栈溢出</h4><p>不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>\n<h3 id=\"非法指针-1\"><a href=\"#非法指针-1\" class=\"headerlink\" title=\"非法指针\"></a>非法指针</h3><p>我的代码是:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa, *pb, *pc;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这里我使用了非法的指针, 这个指针没有指向任何</p>\n<p>修改,</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">call_revise</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>, c = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br><span class=\"line\">  another_revise_value_ptr(ptrArr, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"**(ptrArr)   = \"</span> &lt;&lt; **(ptrArr)   &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"**(ptrArr+1) = \"</span> &lt;&lt; **(ptrArr+<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"**(ptrArr+2) = \"</span> &lt;&lt; **(ptrArr+<span class=\"number\">2</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">call_revise()</span><br></pre></td></tr></table></figure>\n<p>编译得到<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">**(ptrArr)   = 1</span><br><span class=\"line\">**(ptrArr+1) = 2</span><br><span class=\"line\">**(ptrArr+2) = 4</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决最开始问题并总结\"><a href=\"#解决最开始问题并总结\" class=\"headerlink\" title=\"解决最开始问题并总结\"></a>解决最开始问题并总结</h3><p><strong>修改后的代码</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f4</span><span class=\"params\">()</span> </span>&#123;     <span class=\"comment\">// DE<span class=\"doctag\">BUG:</span> 先存放再输入不会修改数组中的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, <span class=\"keyword\">int</span>* pb = &amp;b;     <span class=\"comment\">// 注意: 不要定义空指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 注意数组的类型是数组中元素的类型</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b;   <span class=\"comment\">// 也能合理:先存放, 再输入</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; **iarr &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; **(iarr+<span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">// 解引用</span></span><br><span class=\"line\">  <span class=\"comment\">// 4197661 0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"不要定义空指针\"><a href=\"#不要定义空指针\" class=\"headerlink\" title=\"不要定义空指针\"></a>不要定义空指针</h4><p>如这样<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* pa;</span><br></pre></td></tr></table></figure></p>\n<p>即使要定义也要<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int *pa = 0;</span><br><span class=\"line\">int *pb = nullptr;</span><br></pre></td></tr></table></figure></p>\n<p>尽量让指针指向某个对象<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h4><p>数组的类型是数组中元素的类型<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 类型为 int*</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"解引用数组\"><a href=\"#解引用数组\" class=\"headerlink\" title=\"解引用数组\"></a>解引用数组</h4><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>* iarr[<span class=\"number\">2</span>] = &#123;pa, pb&#125;;        <span class=\"comment\">// 如果数组这样定义</span></span><br><span class=\"line\">iarr;                           <span class=\"comment\">// iarr是指向数组首个元素的指针</span></span><br><span class=\"line\">*iarr;                          <span class=\"comment\">// 因为pa是指针, 所以解引用数组头指针, 得到pa地址</span></span><br><span class=\"line\">**iarr;                         <span class=\"comment\">// 再次解引用得到pa指向的int</span></span><br></pre></td></tr></table></figure>\n<p>标准输出它们得到<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">iarr = 0x7ffed5caa560</span><br><span class=\"line\">*iarr = 0x7ffed5caa548</span><br><span class=\"line\">**iarr = 1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"更多的尝试\"><a href=\"#更多的尝试\" class=\"headerlink\" title=\"更多的尝试\"></a><strong>更多的尝试</strong></h2><h3 id=\"数组中存放对象\"><a href=\"#数组中存放对象\" class=\"headerlink\" title=\"数组中存放对象\"></a>数组中存放对象</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _c; <span class=\"keyword\">int</span> _length; <span class=\"keyword\">int</span> _capacity;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Name(<span class=\"keyword\">char</span>* c, <span class=\"keyword\">int</span> length): _c(c), _length(length) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">char</span>* Name&lt;T&gt;::getName() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Name&lt;T&gt;::getLength() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">class_array</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c1[] = &#123;<span class=\"string\">'t'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'m'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c2[] = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'u'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length1 = <span class=\"number\">3</span>, length2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; name1(c1, length1), name2(c2, length2);</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; nArr[] = &#123;name1, name2&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size = <span class=\"number\">2</span>;</span><br><span class=\"line\">  print_instance_data_in_array(nArr, size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> c[] = &#123;<span class=\"string\">'t'</span>, <span class=\"string\">'i'</span>, <span class=\"string\">'m'</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = <span class=\"number\">3</span>;</span><br><span class=\"line\">  Name&lt;<span class=\"keyword\">int</span>&gt; n(c, length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_instance_data_in_array</span><span class=\"params\">(Name&lt;<span class=\"keyword\">int</span>&gt;* nArr, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name = \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; nArr[i].getLength(); j++) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *((nArr[i].getName())+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Name = tim</span><br><span class=\"line\">Name = hu</span><br></pre></td></tr></table></figure>\n<p>面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。</p>\n<h3 id=\"数组中存放长度不同的数组\"><a href=\"#数组中存放长度不同的数组\" class=\"headerlink\" title=\"数组中存放长度不同的数组\"></a>数组中存放长度不同的数组</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f_array</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">5</span>, c = <span class=\"number\">7</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pa = <span class=\"number\">1</span>, _size_pb = <span class=\"number\">1</span>, _size_pc = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr1[] = &#123;pa&#125;;    <span class=\"comment\">// pArr1数组存放pa, pb指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr2[] = &#123;pa, pb, pc&#125;;    <span class=\"comment\">// pArr2数组存放pa, pb, pc指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr2 = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* pArr3[] = &#123;pa, pc&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_pArr3 = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size_pArr[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>** ppArr[] = &#123;pArr1, pArr2, pArr3&#125;;   <span class=\"comment\">// ppArr存放3个指针数组</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _size_ppArr = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> size_ppArr[] = &#123;<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* size_arr[] = &#123;size_ppArr, size_pArr&#125;;</span><br><span class=\"line\">  <span class=\"comment\">// convert_size_structor(size_arr);</span></span><br><span class=\"line\">  print_arr_b(ppArr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_arr_b</span><span class=\"params\">(<span class=\"keyword\">int</span>*** ppArr)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解引用并打印ppArr数组中依次数组中的pa, pb, pc</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a0 = \"</span> &lt;&lt; ***ppArr&lt;&lt; <span class=\"string\">\" in pArr1[0]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"b0 = \"</span> &lt;&lt; **(*(ppArr+<span class=\"number\">1</span>)+<span class=\"number\">1</span>)&lt;&lt; <span class=\"string\">\" in pArr2[1]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\"c0 = \"</span> &lt;&lt; **(*(ppArr+<span class=\"number\">2</span>)+<span class=\"number\">1</span>)&lt;&lt; <span class=\"string\">\" in pArr3[1]\"</span> &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a><strong>感想</strong></h2><p>即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。</p>\n<h1 id=\"常量成员函数\"><a href=\"#常量成员函数\" class=\"headerlink\" title=\"常量成员函数\"></a>常量成员函数</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = <span class=\"number\">5</span>;</span><br><span class=\"line\">  MyClass(<span class=\"keyword\">int</span> v) :x(v) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> x;&#125;   <span class=\"comment\">// 常量成员函数在是否为常量上可以重载</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> --x;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明时引用符号总最靠近变量名\"><a href=\"#声明时引用符号总最靠近变量名\" class=\"headerlink\" title=\"声明时引用符号总最靠近变量名\"></a>声明时引用符号总最靠近变量名</h2><h2 id=\"为什么可以对a-get-赋值\"><a href=\"#为什么可以对a-get-赋值\" class=\"headerlink\" title=\"为什么可以对a.get()赋值\"></a>为什么可以对a.get()赋值</h2><p>get()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。</p>\n<h2 id=\"在是否为成员函数上重载后如何匹配\"><a href=\"#在是否为成员函数上重载后如何匹配\" class=\"headerlink\" title=\"在是否为成员函数上重载后如何匹配?\"></a>在是否为成员函数上重载后如何匹配?</h2><p>成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。</p>\n<h2 id=\"const-int-amp-get-const-return-x-为什么返回类型需要const\"><a href=\"#const-int-amp-get-const-return-x-为什么返回类型需要const\" class=\"headerlink\" title=\"const int&amp; get() const {return x;} 为什么返回类型需要const?\"></a>const int&amp; get() const {return x;} 为什么返回类型需要const?</h2><p>常量函数返回数据成员, 编译器会将数据成员声明成const类型;</p>\n<h2 id=\"什么是数据成员\"><a href=\"#什么是数据成员\" class=\"headerlink\" title=\"什么是数据成员?\"></a>什么是数据成员?</h2><p>MyClass类public中定义新成员测试是否为数据成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//..</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; get() <span class=\"keyword\">const</span> &#123;<span class=\"keyword\">return</span> --a;&#125;    <span class=\"comment\">// 错误：改变a的值,</span></span><br></pre></td></tr></table></figure>\n<p>改变a的值无法通过编译, a为数据成员。</p>\n<p>在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。</p>\n<h1 id=\"template基础用法\"><a href=\"#template基础用法\" class=\"headerlink\" title=\"template基础用法\"></a>template基础用法</h1><h2 id=\"typename-T-和-class-T的区别\"><a href=\"#typename-T-和-class-T的区别\" class=\"headerlink\" title=\"typename T 和 class T的区别\"></a>typename T 和 class T的区别</h2><p>在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class</p>\n<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P580 模板与泛型编程</code></p>\n<h2 id=\"特殊化模板\"><a href=\"#特殊化模板\" class=\"headerlink\" title=\"特殊化模板\"></a>特殊化模板</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span> &#123;</span></span><br><span class=\"line\">  T element;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  mycontainer(<span class=\"keyword\">const</span> T e) : element(e) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\">T <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> ++element;&#125;    <span class=\"comment\">// 递增element</span></span><br><span class=\"line\">  <span class=\"function\">T <span class=\"title\">getElement</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> element;&#125;   <span class=\"comment\">// 返回element数据</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对char类型, 有特定的方法uppercase()大写化字母<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span>&lt;char&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> element;</span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  mycontainer(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> e): element(e) &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> ++element;&#125;    <span class=\"comment\">// 递增char</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">getElement</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> element;&#125;   <span class=\"comment\">// 返回element数据</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">uppercase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element &lt;= <span class=\"string\">'z'</span> &amp;&amp; element &gt;= <span class=\"string\">'a'</span>) &#123;   <span class=\"comment\">// 是小写字母</span></span><br><span class=\"line\">      element += <span class=\"string\">'A'</span> - <span class=\"string\">'a'</span>; <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125;  <span class=\"comment\">// 返回元素</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"element \"</span> &lt;&lt; element &lt;&lt; <span class=\"string\">\"is not lower\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>格式如下<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span> &#123;</span>...&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">mycontainer</span>&lt;char&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-01-B","date":"2018-01-09T16:07:54.000Z","_content":"\n功能：\n算法:\n规范：图灵机复位h的原因。 => 在软件中叫做接口\n\nRAM: Random Access Machine\n共同之处：无限的空间。\n寄存器：\n> * 常数赋值给RAM             \n> * RAM之间直接赋值 R[i] < R[j]\n> * RAM之间间接赋值 R[i] <- R[R[j]]\n> * RAM+-\n> * 判断0跳转      IF R[i] = 0 GOTO l\n> * 判断正跳转             > 0\n> * 跳转\n> * 停止           STOP\n\n概括:\n对计算工具抽象后的简化。\n独立于环境和平台，可评判效率。\n> * 将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数\n> * 这个次数是清晰的，可度量的。\n==========\n\nRAM实例:Floor\n向下取整除法, 0 <= c, 0 < d\nc%d = max {x | d*c <= c}\n    = max {x | d*x < 1+c}\n\nR[0] = c+1, R[1] = d\n---------------------\n\n0, R[0] <- c                 // int c = c;\n1, R[1] <- d                 // int d = d;\n2, R[2] <- 0                 // int x = 0;\n3, R[3] <- 1                 // int a = 1;\n4, R[0] <- R[0] + R[2]       // c++ \n6, R[0] <- R[0] - R[1]       // c-=d\n7, R[2] <- R[2] + R[3]       // x++\n8, IF R[0] > 0 GOTO 4        // if c > 0 goto 4\n9, R[0] <- R[2] - R[3]       // else x-- and;\n9, STOP                      // return R[0] = x\n\nsrc:\n","source":"_posts/dsacpp/01-B.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-01-B\ndate: 2018-01-10 00:07:54\ntags: 数据结构\n---\n\n功能：\n算法:\n规范：图灵机复位h的原因。 => 在软件中叫做接口\n\nRAM: Random Access Machine\n共同之处：无限的空间。\n寄存器：\n> * 常数赋值给RAM             \n> * RAM之间直接赋值 R[i] < R[j]\n> * RAM之间间接赋值 R[i] <- R[R[j]]\n> * RAM+-\n> * 判断0跳转      IF R[i] = 0 GOTO l\n> * 判断正跳转             > 0\n> * 跳转\n> * 停止           STOP\n\n概括:\n对计算工具抽象后的简化。\n独立于环境和平台，可评判效率。\n> * 将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数\n> * 这个次数是清晰的，可度量的。\n==========\n\nRAM实例:Floor\n向下取整除法, 0 <= c, 0 < d\nc%d = max {x | d*c <= c}\n    = max {x | d*x < 1+c}\n\nR[0] = c+1, R[1] = d\n---------------------\n\n0, R[0] <- c                 // int c = c;\n1, R[1] <- d                 // int d = d;\n2, R[2] <- 0                 // int x = 0;\n3, R[3] <- 1                 // int a = 1;\n4, R[0] <- R[0] + R[2]       // c++ \n6, R[0] <- R[0] - R[1]       // c-=d\n7, R[2] <- R[2] + R[3]       // x++\n8, IF R[0] > 0 GOTO 4        // if c > 0 goto 4\n9, R[0] <- R[2] - R[3]       // else x-- and;\n9, STOP                      // return R[0] = x\n\nsrc:\n","slug":"dsacpp/01-B","published":1,"updated":"2018-06-19T16:15:03.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykh0020k8mfuug580ki","content":"<p>功能：<br>算法:<br>规范：图灵机复位h的原因。 =&gt; 在软件中叫做接口</p>\n<p>RAM: Random Access Machine<br>共同之处：无限的空间。<br>寄存器：</p>\n<blockquote>\n<ul>\n<li>常数赋值给RAM             </li>\n<li>RAM之间直接赋值 R[i] &lt; R[j]</li>\n<li>RAM之间间接赋值 R[i] &lt;- R[R[j]]</li>\n<li>RAM+-</li>\n<li>判断0跳转      IF R[i] = 0 GOTO l</li>\n<li>判断正跳转             &gt; 0</li>\n<li>跳转</li>\n<li>停止           STOP</li>\n</ul>\n</blockquote>\n<p>概括:<br>对计算工具抽象后的简化。<br>独立于环境和平台，可评判效率。</p>\n<blockquote>\n<ul>\n<li>将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数</li>\n<li><h1 id=\"这个次数是清晰的，可度量的。\"><a href=\"#这个次数是清晰的，可度量的。\" class=\"headerlink\" title=\"这个次数是清晰的，可度量的。\"></a>这个次数是清晰的，可度量的。</h1></li>\n</ul>\n</blockquote>\n<p>RAM实例:Floor<br>向下取整除法, 0 &lt;= c, 0 &lt; d<br>c%d = max {x | d<em>c &lt;= c}<br>    = max {x | d</em>x &lt; 1+c}</p>\n<h2 id=\"R-0-c-1-R-1-d\"><a href=\"#R-0-c-1-R-1-d\" class=\"headerlink\" title=\"R[0] = c+1, R[1] = d\"></a>R[0] = c+1, R[1] = d</h2><p>0, R[0] &lt;- c                 // int c = c;<br>1, R[1] &lt;- d                 // int d = d;<br>2, R[2] &lt;- 0                 // int x = 0;<br>3, R[3] &lt;- 1                 // int a = 1;<br>4, R[0] &lt;- R[0] + R[2]       // c++<br>6, R[0] &lt;- R[0] - R[1]       // c-=d<br>7, R[2] &lt;- R[2] + R[3]       // x++<br>8, IF R[0] &gt; 0 GOTO 4        // if c &gt; 0 goto 4<br>9, R[0] &lt;- R[2] - R[3]       // else x– and;<br>9, STOP                      // return R[0] = x</p>\n<p>src:</p>\n","site":{"data":{}},"excerpt":"","more":"<p>功能：<br>算法:<br>规范：图灵机复位h的原因。 =&gt; 在软件中叫做接口</p>\n<p>RAM: Random Access Machine<br>共同之处：无限的空间。<br>寄存器：</p>\n<blockquote>\n<ul>\n<li>常数赋值给RAM             </li>\n<li>RAM之间直接赋值 R[i] &lt; R[j]</li>\n<li>RAM之间间接赋值 R[i] &lt;- R[R[j]]</li>\n<li>RAM+-</li>\n<li>判断0跳转      IF R[i] = 0 GOTO l</li>\n<li>判断正跳转             &gt; 0</li>\n<li>跳转</li>\n<li>停止           STOP</li>\n</ul>\n</blockquote>\n<p>概括:<br>对计算工具抽象后的简化。<br>独立于环境和平台，可评判效率。</p>\n<blockquote>\n<ul>\n<li>将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数</li>\n<li><h1 id=\"这个次数是清晰的，可度量的。\"><a href=\"#这个次数是清晰的，可度量的。\" class=\"headerlink\" title=\"这个次数是清晰的，可度量的。\"></a>这个次数是清晰的，可度量的。</h1></li>\n</ul>\n</blockquote>\n<p>RAM实例:Floor<br>向下取整除法, 0 &lt;= c, 0 &lt; d<br>c%d = max {x | d<em>c &lt;= c}<br>    = max {x | d</em>x &lt; 1+c}</p>\n<h2 id=\"R-0-c-1-R-1-d\"><a href=\"#R-0-c-1-R-1-d\" class=\"headerlink\" title=\"R[0] = c+1, R[1] = d\"></a>R[0] = c+1, R[1] = d</h2><p>0, R[0] &lt;- c                 // int c = c;<br>1, R[1] &lt;- d                 // int d = d;<br>2, R[2] &lt;- 0                 // int x = 0;<br>3, R[3] &lt;- 1                 // int a = 1;<br>4, R[0] &lt;- R[0] + R[2]       // c++<br>6, R[0] &lt;- R[0] - R[1]       // c-=d<br>7, R[2] &lt;- R[2] + R[3]       // x++<br>8, IF R[0] &gt; 0 GOTO 4        // if c &gt; 0 goto 4<br>9, R[0] &lt;- R[2] - R[3]       // else x– and;<br>9, STOP                      // return R[0] = x</p>\n<p>src:</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-01-C","date":"2018-01-09T16:08:22.000Z","_content":"\n\n渐进分析: 大O记号 \n\n好读书不求甚解。\n\n考察DSA（考察人）:\n> * 长远\n> * 主流,\n\n渐进分析(Asymptotic Analysis) n >> 2, 对于规模为n输入，算法\n  - 需要执行的基本操作数: T(n) = ?\n  -          ..存储单元: S(n) = ?       // 通常不考虑？**教材**\n\n**教材P33**\n> * 空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。\n> * 但两种情况下会有意义:\n    - 对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)\n    - 数据的输入规模大。\n\nbig-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)\n> * 常系数可忽略(主流):O(f(n)) = O(c*f(n))\n> * 低次项可忽略(主流)\n\nO(1)\n常数\n  > * 2 = 2013 = 2013*2013 = O(1)\n  > * 效率: 最高效\n  > * 出现的情况，需要具体分析\n      不含循环，不含分支转向，一定不能有(递归)调用？\n  **教材**\n\nO(logn)\n对数\n  > * 常底数无所谓\n  > * 常数次幂无所谓\n  > * 多项式\n  > * 效率: 接近于常数\n\nO(n^c)\n多项式\n  > * 一般 取最高次\n线性：所有O(n)函数\n从O(n)到O(n^2):编程习题主要覆盖范围\n> 效率: 已经可令人满意。\n\nO(2^n)\n指数\n效率: 算法成本增长极快，通常不可忍受。\nn^x->2^n, 是从有效算法到无效算法的分水岭。\n\n2-Subset\n直觉算法：逐一枚举S的每一个子集，并统计其中元素总和\n定理:2-Subset is NP-complete\n意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。\n     除非，添加条件：分布规律啦, 票的总数啦，\n\n复杂度增长速度表格。\n","source":"_posts/dsacpp/01-C.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-01-C\ndate: 2018-01-10 00:08:22\ntags: 数据结构\n---\n\n\n渐进分析: 大O记号 \n\n好读书不求甚解。\n\n考察DSA（考察人）:\n> * 长远\n> * 主流,\n\n渐进分析(Asymptotic Analysis) n >> 2, 对于规模为n输入，算法\n  - 需要执行的基本操作数: T(n) = ?\n  -          ..存储单元: S(n) = ?       // 通常不考虑？**教材**\n\n**教材P33**\n> * 空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。\n> * 但两种情况下会有意义:\n    - 对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)\n    - 数据的输入规模大。\n\nbig-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)\n> * 常系数可忽略(主流):O(f(n)) = O(c*f(n))\n> * 低次项可忽略(主流)\n\nO(1)\n常数\n  > * 2 = 2013 = 2013*2013 = O(1)\n  > * 效率: 最高效\n  > * 出现的情况，需要具体分析\n      不含循环，不含分支转向，一定不能有(递归)调用？\n  **教材**\n\nO(logn)\n对数\n  > * 常底数无所谓\n  > * 常数次幂无所谓\n  > * 多项式\n  > * 效率: 接近于常数\n\nO(n^c)\n多项式\n  > * 一般 取最高次\n线性：所有O(n)函数\n从O(n)到O(n^2):编程习题主要覆盖范围\n> 效率: 已经可令人满意。\n\nO(2^n)\n指数\n效率: 算法成本增长极快，通常不可忍受。\nn^x->2^n, 是从有效算法到无效算法的分水岭。\n\n2-Subset\n直觉算法：逐一枚举S的每一个子集，并统计其中元素总和\n定理:2-Subset is NP-complete\n意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。\n     除非，添加条件：分布规律啦, 票的总数啦，\n\n复杂度增长速度表格。\n","slug":"dsacpp/01-C","published":1,"updated":"2018-06-19T16:15:03.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyki0022k8mfhq1xg5vh","content":"<p>渐进分析: 大O记号 </p>\n<p>好读书不求甚解。</p>\n<p>考察DSA（考察人）:</p>\n<blockquote>\n<ul>\n<li>长远</li>\n<li>主流,</li>\n</ul>\n</blockquote>\n<p>渐进分析(Asymptotic Analysis) n &gt;&gt; 2, 对于规模为n输入，算法</p>\n<ul>\n<li>需要执行的基本操作数: T(n) = ?</li>\n<li>..存储单元: S(n) = ?       // 通常不考虑？<strong>教材</strong></li>\n</ul>\n<p><strong>教材P33</strong></p>\n<blockquote>\n<ul>\n<li>空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。</li>\n<li>但两种情况下会有意义:<ul>\n<li>对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)</li>\n<li>数据的输入规模大。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>big-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)</p>\n<blockquote>\n<ul>\n<li>常系数可忽略(主流):O(f(n)) = O(c*f(n))</li>\n<li>低次项可忽略(主流)</li>\n</ul>\n</blockquote>\n<p>O(1)<br>常数</p>\n<blockquote>\n<ul>\n<li>2 = 2013 = 2013*2013 = O(1)</li>\n<li>效率: 最高效</li>\n<li>出现的情况，需要具体分析<pre><code>不含循环，不含分支转向，一定不能有(递归)调用？\n</code></pre><strong>教材</strong></li>\n</ul>\n</blockquote>\n<p>O(logn)<br>对数</p>\n<blockquote>\n<ul>\n<li>常底数无所谓</li>\n<li>常数次幂无所谓</li>\n<li>多项式</li>\n<li>效率: 接近于常数</li>\n</ul>\n</blockquote>\n<p>O(n^c)<br>多项式</p>\n<blockquote>\n<ul>\n<li>一般 取最高次<br>线性：所有O(n)函数<br>从O(n)到O(n^2):编程习题主要覆盖范围<br>效率: 已经可令人满意。</li>\n</ul>\n</blockquote>\n<p>O(2^n)<br>指数<br>效率: 算法成本增长极快，通常不可忍受。<br>n^x-&gt;2^n, 是从有效算法到无效算法的分水岭。</p>\n<p>2-Subset<br>直觉算法：逐一枚举S的每一个子集，并统计其中元素总和<br>定理:2-Subset is NP-complete<br>意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。<br>     除非，添加条件：分布规律啦, 票的总数啦，</p>\n<p>复杂度增长速度表格。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>渐进分析: 大O记号 </p>\n<p>好读书不求甚解。</p>\n<p>考察DSA（考察人）:</p>\n<blockquote>\n<ul>\n<li>长远</li>\n<li>主流,</li>\n</ul>\n</blockquote>\n<p>渐进分析(Asymptotic Analysis) n &gt;&gt; 2, 对于规模为n输入，算法</p>\n<ul>\n<li>需要执行的基本操作数: T(n) = ?</li>\n<li>..存储单元: S(n) = ?       // 通常不考虑？<strong>教材</strong></li>\n</ul>\n<p><strong>教材P33</strong></p>\n<blockquote>\n<ul>\n<li>空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。</li>\n<li>但两种情况下会有意义:<ul>\n<li>对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)</li>\n<li>数据的输入规模大。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>big-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)</p>\n<blockquote>\n<ul>\n<li>常系数可忽略(主流):O(f(n)) = O(c*f(n))</li>\n<li>低次项可忽略(主流)</li>\n</ul>\n</blockquote>\n<p>O(1)<br>常数</p>\n<blockquote>\n<ul>\n<li>2 = 2013 = 2013*2013 = O(1)</li>\n<li>效率: 最高效</li>\n<li>出现的情况，需要具体分析<pre><code>不含循环，不含分支转向，一定不能有(递归)调用？\n</code></pre><strong>教材</strong></li>\n</ul>\n</blockquote>\n<p>O(logn)<br>对数</p>\n<blockquote>\n<ul>\n<li>常底数无所谓</li>\n<li>常数次幂无所谓</li>\n<li>多项式</li>\n<li>效率: 接近于常数</li>\n</ul>\n</blockquote>\n<p>O(n^c)<br>多项式</p>\n<blockquote>\n<ul>\n<li>一般 取最高次<br>线性：所有O(n)函数<br>从O(n)到O(n^2):编程习题主要覆盖范围<br>效率: 已经可令人满意。</li>\n</ul>\n</blockquote>\n<p>O(2^n)<br>指数<br>效率: 算法成本增长极快，通常不可忍受。<br>n^x-&gt;2^n, 是从有效算法到无效算法的分水岭。</p>\n<p>2-Subset<br>直觉算法：逐一枚举S的每一个子集，并统计其中元素总和<br>定理:2-Subset is NP-complete<br>意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。<br>     除非，添加条件：分布规律啦, 票的总数啦，</p>\n<p>复杂度增长速度表格。</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-01-D","date":"2017-12-28T03:14:53.000Z","_content":"\n<span style=\"color:blue\">*我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.*</span>\n\n\n# 算法分析\n\n运用DSA\n\n算法分析的两个任务\n> * 正确性(不变性 * 单调性)\n> * 复杂度增长速度表格\n\nC++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当\n  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏\n  迭代循环:for(), while()..   // 本质上 \"if+goto\"\n  调用+递归                   // 本质上也是 \"goto\"\n\n复杂度分析方法:\n> 1. 迭代: 级数求和\n> 2. 递归: 递归跟踪 + 递推方程\n> 猜测 + 验证\n\n# 级数\n\n## 算术级数：与**末项平方**同阶\n\n## 幂方级数：比幂次高出一阶\n\n## 几何级数（a > 1）:与末项同阶\n\n## 收敛级数:O(1)\n\n## 未必收敛，但长度有限\nh(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn)            // 调和级数\nlog1 + log2 + log3 + ... + logn = log(n!) = O(nlogn)  // 对数级数\n\n## 推荐书籍\n`<<Concrete Math>>` 具体数学\n\n# 循环 vs 级数\n\n\n## 没有耦合的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < n; j++)\n    O1Operation(i, j);\n```\n\n算术级数:  n * n = O(n^2)\n等效：矩形被填充的过程，时间复杂度等于矩形面积。\n\n## 耦合的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < i; j++)\n    O1Operation(i, j);\n```\n\n算术级数: n(n-1) / 2 = O(n^2)\n等效：三角形被填充，复杂度等于矩形面积。\n\n## 递增不为1的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < i; j += 2013)\n    O1Operation(i, j);\n```\n\n算术级数：O(n^2)\n\n## 外循环左移一位(加倍)\n```cpp\nfor (int i = 1; i < n; i <<= 1)\nfor (int j = 0; j < i; j++)\n    O1peration(i, j);\n```\n\n几何级数：O(n)     // ??\n\n## 更复杂的实例\n```cpp\nfor (int i = 0; i <= n; i++)\nfor (int j = 1; j <  i; j += j)\n    O1peration(i, j);\n```\n\n## 习题解析\n\n# 取非极端元素、冒泡排序\n\n## 取非极端元素 \n\n算法： \n> 1, 从S中取出三个元素{x, y, z}\n> 2, 确定并排除其中的最小值和最大值\n> 3, 输出剩下的元素z\n\n```cpp\nint ordinaryElements(int A[], int n) {\n  // 从n >= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”\n  // 先比较a,b;再确定c对于(a,b)区间的关系\n  int a = A[0], b = A[1], c = A[2];    // 从特定单元读取元素O(3)\n  // 统一成区间(a, b), 用于c对其判断\n  if (a < b) { } else {\n    swap(&a, &b);\n  }\n  if (c < a) return a;\n  else if (c > b) return b;\n  else\n    return c;\n  // return 输出非极端数O(1)\n\n  // =======================================\n  // T(n) = O(3) + O(3) + O(1) = O(7) = O(1)\n}\n```\n\n结论:无论输入规模有多大，所需执行该算法的执行时间都不变。\n\n## 起泡排序问题\n```cpp\nvoid bubblesort(int A[], int n) {\n  for (bool sorted = false; sorted = !sorted; n--)\n    for (int i = 1; i < n+1; i++) {  // 自左向右逐对检查[0,n)各相邻元素\n      if (A[i-1] > A[i]) {         // 若逆序,则\n        swap(&A[i-1], &A[i]);      // 令其交换位置\n        sorted = false;            // 消除全局有序标记\n      }\n    }\n}\n```\n\n# 算法分析\n\n\n不变性：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描交换后，问题的规模缩减至n-k\n正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案\n\n基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性\n\n# 封底估计 Back-Of-The-Envelope Calculation\n\n不需要工具\n\n787km 占据整个周长的1/50 => 整个周长4wkm\n\n抓住问题的主要方面，简洁得出总体规律\n\n在复杂度分析中，对象是时间。\n\n# 封底估计实例\n> * 一天: = 24hr * 60min * 60sec = 25 * 4000 = 10^5 sec\n> * 一生: = 1世纪 = 100yr * 365 = 3 * 10^4 = 3 * 10^9 sec\n> * \"50年\" = 1.6 * 10^9 sec\n> * 三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec\n> * 宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec \n三生三世是10^10s\n三生三世中的一天，相当于在一天中的1s\n整个宇宙中的三生三世，就是在三生三世中的0.1s\n\n1亿 = 10^9\n\n复杂度和浮点运算能力flops相除，能得到某算法的时间。\n\n人口普查 n = 10^9\n\\=====================\n普通PC 1Ghz 10^9 flops\nBullesort: O(n^2) ==> (10^9)^2 = 10^18 \n\n时间: 10^18 / 10^9  = 10^9\n3*10^9 = 100yr, 10^9 = 30年\n\\=====================\n普通PC  10^9 flops\nMergesort: O(n\\*logn) => (10^9)\\*log(10^9) = 30 * 10^9\n\n时间; 30 * 10^9 / 10^9 = 30s\n\\=====================\n天河1A 10^15 flops\nBullesort:\n\n时间:20min: 10^3s\n\\=====================\n","source":"_posts/dsacpp/01-D.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-01-D\ndate: 2017-12-28 11:14:53\ntags: [数据结构, 复杂度]\n---\n\n<span style=\"color:blue\">*我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.*</span>\n\n\n# 算法分析\n\n运用DSA\n\n算法分析的两个任务\n> * 正确性(不变性 * 单调性)\n> * 复杂度增长速度表格\n\nC++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当\n  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏\n  迭代循环:for(), while()..   // 本质上 \"if+goto\"\n  调用+递归                   // 本质上也是 \"goto\"\n\n复杂度分析方法:\n> 1. 迭代: 级数求和\n> 2. 递归: 递归跟踪 + 递推方程\n> 猜测 + 验证\n\n# 级数\n\n## 算术级数：与**末项平方**同阶\n\n## 幂方级数：比幂次高出一阶\n\n## 几何级数（a > 1）:与末项同阶\n\n## 收敛级数:O(1)\n\n## 未必收敛，但长度有限\nh(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn)            // 调和级数\nlog1 + log2 + log3 + ... + logn = log(n!) = O(nlogn)  // 对数级数\n\n## 推荐书籍\n`<<Concrete Math>>` 具体数学\n\n# 循环 vs 级数\n\n\n## 没有耦合的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < n; j++)\n    O1Operation(i, j);\n```\n\n算术级数:  n * n = O(n^2)\n等效：矩形被填充的过程，时间复杂度等于矩形面积。\n\n## 耦合的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < i; j++)\n    O1Operation(i, j);\n```\n\n算术级数: n(n-1) / 2 = O(n^2)\n等效：三角形被填充，复杂度等于矩形面积。\n\n## 递增不为1的二层循环\n```cpp\nfor (int i = 0; i < n; i++)\nfor (int j = 0; j < i; j += 2013)\n    O1Operation(i, j);\n```\n\n算术级数：O(n^2)\n\n## 外循环左移一位(加倍)\n```cpp\nfor (int i = 1; i < n; i <<= 1)\nfor (int j = 0; j < i; j++)\n    O1peration(i, j);\n```\n\n几何级数：O(n)     // ??\n\n## 更复杂的实例\n```cpp\nfor (int i = 0; i <= n; i++)\nfor (int j = 1; j <  i; j += j)\n    O1peration(i, j);\n```\n\n## 习题解析\n\n# 取非极端元素、冒泡排序\n\n## 取非极端元素 \n\n算法： \n> 1, 从S中取出三个元素{x, y, z}\n> 2, 确定并排除其中的最小值和最大值\n> 3, 输出剩下的元素z\n\n```cpp\nint ordinaryElements(int A[], int n) {\n  // 从n >= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”\n  // 先比较a,b;再确定c对于(a,b)区间的关系\n  int a = A[0], b = A[1], c = A[2];    // 从特定单元读取元素O(3)\n  // 统一成区间(a, b), 用于c对其判断\n  if (a < b) { } else {\n    swap(&a, &b);\n  }\n  if (c < a) return a;\n  else if (c > b) return b;\n  else\n    return c;\n  // return 输出非极端数O(1)\n\n  // =======================================\n  // T(n) = O(3) + O(3) + O(1) = O(7) = O(1)\n}\n```\n\n结论:无论输入规模有多大，所需执行该算法的执行时间都不变。\n\n## 起泡排序问题\n```cpp\nvoid bubblesort(int A[], int n) {\n  for (bool sorted = false; sorted = !sorted; n--)\n    for (int i = 1; i < n+1; i++) {  // 自左向右逐对检查[0,n)各相邻元素\n      if (A[i-1] > A[i]) {         // 若逆序,则\n        swap(&A[i-1], &A[i]);      // 令其交换位置\n        sorted = false;            // 消除全局有序标记\n      }\n    }\n}\n```\n\n# 算法分析\n\n\n不变性：经k轮扫描交换后，最大的k个元素必然就位\n单调性：经k轮扫描交换后，问题的规模缩减至n-k\n正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案\n\n基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性\n\n# 封底估计 Back-Of-The-Envelope Calculation\n\n不需要工具\n\n787km 占据整个周长的1/50 => 整个周长4wkm\n\n抓住问题的主要方面，简洁得出总体规律\n\n在复杂度分析中，对象是时间。\n\n# 封底估计实例\n> * 一天: = 24hr * 60min * 60sec = 25 * 4000 = 10^5 sec\n> * 一生: = 1世纪 = 100yr * 365 = 3 * 10^4 = 3 * 10^9 sec\n> * \"50年\" = 1.6 * 10^9 sec\n> * 三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec\n> * 宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec \n三生三世是10^10s\n三生三世中的一天，相当于在一天中的1s\n整个宇宙中的三生三世，就是在三生三世中的0.1s\n\n1亿 = 10^9\n\n复杂度和浮点运算能力flops相除，能得到某算法的时间。\n\n人口普查 n = 10^9\n\\=====================\n普通PC 1Ghz 10^9 flops\nBullesort: O(n^2) ==> (10^9)^2 = 10^18 \n\n时间: 10^18 / 10^9  = 10^9\n3*10^9 = 100yr, 10^9 = 30年\n\\=====================\n普通PC  10^9 flops\nMergesort: O(n\\*logn) => (10^9)\\*log(10^9) = 30 * 10^9\n\n时间; 30 * 10^9 / 10^9 = 30s\n\\=====================\n天河1A 10^15 flops\nBullesort:\n\n时间:20min: 10^3s\n\\=====================\n","slug":"dsacpp/01-D","published":1,"updated":"2018-06-19T16:15:03.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykj0023k8mffrkbnaav","content":"<p><span style=\"color:blue\"><em>我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.</em></span></p>\n<h1 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h1><p>运用DSA</p>\n<p>算法分析的两个任务</p>\n<blockquote>\n<ul>\n<li>正确性(不变性 * 单调性)</li>\n<li>复杂度增长速度表格</li>\n</ul>\n</blockquote>\n<p>C++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当<br>  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏<br>  迭代循环:for(), while()..   // 本质上 “if+goto”<br>  调用+递归                   // 本质上也是 “goto”</p>\n<p>复杂度分析方法:</p>\n<blockquote>\n<ol>\n<li>迭代: 级数求和</li>\n<li>递归: 递归跟踪 + 递推方程<br>猜测 + 验证</li>\n</ol>\n</blockquote>\n<h1 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h1><h2 id=\"算术级数：与末项平方同阶\"><a href=\"#算术级数：与末项平方同阶\" class=\"headerlink\" title=\"算术级数：与末项平方同阶\"></a>算术级数：与<strong>末项平方</strong>同阶</h2><h2 id=\"幂方级数：比幂次高出一阶\"><a href=\"#幂方级数：比幂次高出一阶\" class=\"headerlink\" title=\"幂方级数：比幂次高出一阶\"></a>幂方级数：比幂次高出一阶</h2><h2 id=\"几何级数（a-gt-1）-与末项同阶\"><a href=\"#几何级数（a-gt-1）-与末项同阶\" class=\"headerlink\" title=\"几何级数（a &gt; 1）:与末项同阶\"></a>几何级数（a &gt; 1）:与末项同阶</h2><h2 id=\"收敛级数-O-1\"><a href=\"#收敛级数-O-1\" class=\"headerlink\" title=\"收敛级数:O(1)\"></a>收敛级数:O(1)</h2><h2 id=\"未必收敛，但长度有限\"><a href=\"#未必收敛，但长度有限\" class=\"headerlink\" title=\"未必收敛，但长度有限\"></a>未必收敛，但长度有限</h2><p>h(n) = 1 + 1/2 + 1/3 + … + 1/n = O(logn)            // 调和级数<br>log1 + log2 + log3 + … + logn = log(n!) = O(nlogn)  // 对数级数</p>\n<h2 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h2><p><code>&lt;&lt;Concrete Math&gt;&gt;</code> 具体数学</p>\n<h1 id=\"循环-vs-级数\"><a href=\"#循环-vs-级数\" class=\"headerlink\" title=\"循环 vs 级数\"></a>循环 vs 级数</h1><h2 id=\"没有耦合的二层循环\"><a href=\"#没有耦合的二层循环\" class=\"headerlink\" title=\"没有耦合的二层循环\"></a>没有耦合的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数:  n * n = O(n^2)<br>等效：矩形被填充的过程，时间复杂度等于矩形面积。</p>\n<h2 id=\"耦合的二层循环\"><a href=\"#耦合的二层循环\" class=\"headerlink\" title=\"耦合的二层循环\"></a>耦合的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数: n(n-1) / 2 = O(n^2)<br>等效：三角形被填充，复杂度等于矩形面积。</p>\n<h2 id=\"递增不为1的二层循环\"><a href=\"#递增不为1的二层循环\" class=\"headerlink\" title=\"递增不为1的二层循环\"></a>递增不为1的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j += <span class=\"number\">2013</span>)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数：O(n^2)</p>\n<h2 id=\"外循环左移一位-加倍\"><a href=\"#外循环左移一位-加倍\" class=\"headerlink\" title=\"外循环左移一位(加倍)\"></a>外循环左移一位(加倍)</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i &lt;&lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">    O1peration(i, j);</span><br></pre></td></tr></table></figure>\n<p>几何级数：O(n)     // ??</p>\n<h2 id=\"更复杂的实例\"><a href=\"#更复杂的实例\" class=\"headerlink\" title=\"更复杂的实例\"></a>更复杂的实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;  i; j += j)</span><br><span class=\"line\">    O1peration(i, j);</span><br></pre></td></tr></table></figure>\n<h2 id=\"习题解析\"><a href=\"#习题解析\" class=\"headerlink\" title=\"习题解析\"></a>习题解析</h2><h1 id=\"取非极端元素、冒泡排序\"><a href=\"#取非极端元素、冒泡排序\" class=\"headerlink\" title=\"取非极端元素、冒泡排序\"></a>取非极端元素、冒泡排序</h1><h2 id=\"取非极端元素\"><a href=\"#取非极端元素\" class=\"headerlink\" title=\"取非极端元素\"></a>取非极端元素</h2><p>算法： </p>\n<blockquote>\n<p>1, 从S中取出三个元素{x, y, z}<br>2, 确定并排除其中的最小值和最大值<br>3, 输出剩下的元素z</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ordinaryElements</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从n &gt;= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”</span></span><br><span class=\"line\">  <span class=\"comment\">// 先比较a,b;再确定c对于(a,b)区间的关系</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = A[<span class=\"number\">0</span>], b = A[<span class=\"number\">1</span>], c = A[<span class=\"number\">2</span>];    <span class=\"comment\">// 从特定单元读取元素O(3)</span></span><br><span class=\"line\">  <span class=\"comment\">// 统一成区间(a, b), 用于c对其判断</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a &lt; b) &#123; &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    swap(&amp;a, &amp;b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c &lt; a) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c &gt; b) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">  <span class=\"comment\">// return 输出非极端数O(1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// =======================================</span></span><br><span class=\"line\">  <span class=\"comment\">// T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结论:无论输入规模有多大，所需执行该算法的执行时间都不变。</p>\n<h2 id=\"起泡排序问题\"><a href=\"#起泡排序问题\" class=\"headerlink\" title=\"起泡排序问题\"></a>起泡排序问题</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubblesort</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">bool</span> sorted = <span class=\"literal\">false</span>; sorted = !sorted; n--)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n+<span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">// 自左向右逐对检查[0,n)各相邻元素</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[i<span class=\"number\">-1</span>] &gt; A[i]) &#123;         <span class=\"comment\">// 若逆序,则</span></span><br><span class=\"line\">        swap(&amp;A[i<span class=\"number\">-1</span>], &amp;A[i]);      <span class=\"comment\">// 令其交换位置</span></span><br><span class=\"line\">        sorted = <span class=\"literal\">false</span>;            <span class=\"comment\">// 消除全局有序标记</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h1><p>不变性：经k轮扫描交换后，最大的k个元素必然就位<br>单调性：经k轮扫描交换后，问题的规模缩减至n-k<br>正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案</p>\n<p>基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性</p>\n<h1 id=\"封底估计-Back-Of-The-Envelope-Calculation\"><a href=\"#封底估计-Back-Of-The-Envelope-Calculation\" class=\"headerlink\" title=\"封底估计 Back-Of-The-Envelope Calculation\"></a>封底估计 Back-Of-The-Envelope Calculation</h1><p>不需要工具</p>\n<p>787km 占据整个周长的1/50 =&gt; 整个周长4wkm</p>\n<p>抓住问题的主要方面，简洁得出总体规律</p>\n<p>在复杂度分析中，对象是时间。</p>\n<h1 id=\"封底估计实例\"><a href=\"#封底估计实例\" class=\"headerlink\" title=\"封底估计实例\"></a>封底估计实例</h1><blockquote>\n<ul>\n<li>一天: = 24hr <em> 60min </em> 60sec = 25 * 4000 = 10^5 sec</li>\n<li>一生: = 1世纪 = 100yr <em> 365 = 3 </em> 10^4 = 3 * 10^9 sec</li>\n<li>“50年” = 1.6 * 10^9 sec</li>\n<li>三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec</li>\n<li>宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec<br>三生三世是10^10s<br>三生三世中的一天，相当于在一天中的1s<br>整个宇宙中的三生三世，就是在三生三世中的0.1s</li>\n</ul>\n</blockquote>\n<p>1亿 = 10^9</p>\n<p>复杂度和浮点运算能力flops相除，能得到某算法的时间。</p>\n<p>人口普查 n = 10^9<br>\\=====================<br>普通PC 1Ghz 10^9 flops<br>Bullesort: O(n^2) ==&gt; (10^9)^2 = 10^18 </p>\n<p>时间: 10^18 / 10^9  = 10^9<br>3<em>10^9 = 100yr, 10^9 = 30年<br>\\=====================<br>普通PC  10^9 flops<br>Mergesort: O(n\\</em>logn) =&gt; (10^9)*log(10^9) = 30 * 10^9</p>\n<p>时间; 30 * 10^9 / 10^9 = 30s<br>\\=====================<br>天河1A 10^15 flops<br>Bullesort:</p>\n<p>时间:20min: 10^3s<br>\\=====================</p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color:blue\"><em>我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.</em></span></p>\n<h1 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h1><p>运用DSA</p>\n<p>算法分析的两个任务</p>\n<blockquote>\n<ul>\n<li>正确性(不变性 * 单调性)</li>\n<li>复杂度增长速度表格</li>\n</ul>\n</blockquote>\n<p>C++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当<br>  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏<br>  迭代循环:for(), while()..   // 本质上 “if+goto”<br>  调用+递归                   // 本质上也是 “goto”</p>\n<p>复杂度分析方法:</p>\n<blockquote>\n<ol>\n<li>迭代: 级数求和</li>\n<li>递归: 递归跟踪 + 递推方程<br>猜测 + 验证</li>\n</ol>\n</blockquote>\n<h1 id=\"级数\"><a href=\"#级数\" class=\"headerlink\" title=\"级数\"></a>级数</h1><h2 id=\"算术级数：与末项平方同阶\"><a href=\"#算术级数：与末项平方同阶\" class=\"headerlink\" title=\"算术级数：与末项平方同阶\"></a>算术级数：与<strong>末项平方</strong>同阶</h2><h2 id=\"幂方级数：比幂次高出一阶\"><a href=\"#幂方级数：比幂次高出一阶\" class=\"headerlink\" title=\"幂方级数：比幂次高出一阶\"></a>幂方级数：比幂次高出一阶</h2><h2 id=\"几何级数（a-gt-1）-与末项同阶\"><a href=\"#几何级数（a-gt-1）-与末项同阶\" class=\"headerlink\" title=\"几何级数（a &gt; 1）:与末项同阶\"></a>几何级数（a &gt; 1）:与末项同阶</h2><h2 id=\"收敛级数-O-1\"><a href=\"#收敛级数-O-1\" class=\"headerlink\" title=\"收敛级数:O(1)\"></a>收敛级数:O(1)</h2><h2 id=\"未必收敛，但长度有限\"><a href=\"#未必收敛，但长度有限\" class=\"headerlink\" title=\"未必收敛，但长度有限\"></a>未必收敛，但长度有限</h2><p>h(n) = 1 + 1/2 + 1/3 + … + 1/n = O(logn)            // 调和级数<br>log1 + log2 + log3 + … + logn = log(n!) = O(nlogn)  // 对数级数</p>\n<h2 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h2><p><code>&lt;&lt;Concrete Math&gt;&gt;</code> 具体数学</p>\n<h1 id=\"循环-vs-级数\"><a href=\"#循环-vs-级数\" class=\"headerlink\" title=\"循环 vs 级数\"></a>循环 vs 级数</h1><h2 id=\"没有耦合的二层循环\"><a href=\"#没有耦合的二层循环\" class=\"headerlink\" title=\"没有耦合的二层循环\"></a>没有耦合的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数:  n * n = O(n^2)<br>等效：矩形被填充的过程，时间复杂度等于矩形面积。</p>\n<h2 id=\"耦合的二层循环\"><a href=\"#耦合的二层循环\" class=\"headerlink\" title=\"耦合的二层循环\"></a>耦合的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数: n(n-1) / 2 = O(n^2)<br>等效：三角形被填充，复杂度等于矩形面积。</p>\n<h2 id=\"递增不为1的二层循环\"><a href=\"#递增不为1的二层循环\" class=\"headerlink\" title=\"递增不为1的二层循环\"></a>递增不为1的二层循环</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j += <span class=\"number\">2013</span>)</span><br><span class=\"line\">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>\n<p>算术级数：O(n^2)</p>\n<h2 id=\"外循环左移一位-加倍\"><a href=\"#外循环左移一位-加倍\" class=\"headerlink\" title=\"外循环左移一位(加倍)\"></a>外循环左移一位(加倍)</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i &lt;&lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">    O1peration(i, j);</span><br></pre></td></tr></table></figure>\n<p>几何级数：O(n)     // ??</p>\n<h2 id=\"更复杂的实例\"><a href=\"#更复杂的实例\" class=\"headerlink\" title=\"更复杂的实例\"></a>更复杂的实例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;  i; j += j)</span><br><span class=\"line\">    O1peration(i, j);</span><br></pre></td></tr></table></figure>\n<h2 id=\"习题解析\"><a href=\"#习题解析\" class=\"headerlink\" title=\"习题解析\"></a>习题解析</h2><h1 id=\"取非极端元素、冒泡排序\"><a href=\"#取非极端元素、冒泡排序\" class=\"headerlink\" title=\"取非极端元素、冒泡排序\"></a>取非极端元素、冒泡排序</h1><h2 id=\"取非极端元素\"><a href=\"#取非极端元素\" class=\"headerlink\" title=\"取非极端元素\"></a>取非极端元素</h2><p>算法： </p>\n<blockquote>\n<p>1, 从S中取出三个元素{x, y, z}<br>2, 确定并排除其中的最小值和最大值<br>3, 输出剩下的元素z</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ordinaryElements</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 从n &gt;= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”</span></span><br><span class=\"line\">  <span class=\"comment\">// 先比较a,b;再确定c对于(a,b)区间的关系</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a = A[<span class=\"number\">0</span>], b = A[<span class=\"number\">1</span>], c = A[<span class=\"number\">2</span>];    <span class=\"comment\">// 从特定单元读取元素O(3)</span></span><br><span class=\"line\">  <span class=\"comment\">// 统一成区间(a, b), 用于c对其判断</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a &lt; b) &#123; &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    swap(&amp;a, &amp;b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c &lt; a) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c &gt; b) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">  <span class=\"comment\">// return 输出非极端数O(1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// =======================================</span></span><br><span class=\"line\">  <span class=\"comment\">// T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结论:无论输入规模有多大，所需执行该算法的执行时间都不变。</p>\n<h2 id=\"起泡排序问题\"><a href=\"#起泡排序问题\" class=\"headerlink\" title=\"起泡排序问题\"></a>起泡排序问题</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubblesort</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">bool</span> sorted = <span class=\"literal\">false</span>; sorted = !sorted; n--)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n+<span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">// 自左向右逐对检查[0,n)各相邻元素</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[i<span class=\"number\">-1</span>] &gt; A[i]) &#123;         <span class=\"comment\">// 若逆序,则</span></span><br><span class=\"line\">        swap(&amp;A[i<span class=\"number\">-1</span>], &amp;A[i]);      <span class=\"comment\">// 令其交换位置</span></span><br><span class=\"line\">        sorted = <span class=\"literal\">false</span>;            <span class=\"comment\">// 消除全局有序标记</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h1><p>不变性：经k轮扫描交换后，最大的k个元素必然就位<br>单调性：经k轮扫描交换后，问题的规模缩减至n-k<br>正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案</p>\n<p>基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性</p>\n<h1 id=\"封底估计-Back-Of-The-Envelope-Calculation\"><a href=\"#封底估计-Back-Of-The-Envelope-Calculation\" class=\"headerlink\" title=\"封底估计 Back-Of-The-Envelope Calculation\"></a>封底估计 Back-Of-The-Envelope Calculation</h1><p>不需要工具</p>\n<p>787km 占据整个周长的1/50 =&gt; 整个周长4wkm</p>\n<p>抓住问题的主要方面，简洁得出总体规律</p>\n<p>在复杂度分析中，对象是时间。</p>\n<h1 id=\"封底估计实例\"><a href=\"#封底估计实例\" class=\"headerlink\" title=\"封底估计实例\"></a>封底估计实例</h1><blockquote>\n<ul>\n<li>一天: = 24hr <em> 60min </em> 60sec = 25 * 4000 = 10^5 sec</li>\n<li>一生: = 1世纪 = 100yr <em> 365 = 3 </em> 10^4 = 3 * 10^9 sec</li>\n<li>“50年” = 1.6 * 10^9 sec</li>\n<li>三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec</li>\n<li>宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec<br>三生三世是10^10s<br>三生三世中的一天，相当于在一天中的1s<br>整个宇宙中的三生三世，就是在三生三世中的0.1s</li>\n</ul>\n</blockquote>\n<p>1亿 = 10^9</p>\n<p>复杂度和浮点运算能力flops相除，能得到某算法的时间。</p>\n<p>人口普查 n = 10^9<br>\\=====================<br>普通PC 1Ghz 10^9 flops<br>Bullesort: O(n^2) ==&gt; (10^9)^2 = 10^18 </p>\n<p>时间: 10^18 / 10^9  = 10^9<br>3<em>10^9 = 100yr, 10^9 = 30年<br>\\=====================<br>普通PC  10^9 flops<br>Mergesort: O(n\\</em>logn) =&gt; (10^9)*log(10^9) = 30 * 10^9</p>\n<p>时间; 30 * 10^9 / 10^9 = 30s<br>\\=====================<br>天河1A 10^15 flops<br>Bullesort:</p>\n<p>时间:20min: 10^3s<br>\\=====================</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-01-E","date":"2018-01-09T16:08:41.000Z","_content":"\n\n# 迭代与递归\n\n分而治之：分解成子问题，递归式的求解。\n\n空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。\n\n# 减而治之\n\n```\n   合                合并\n  ---->    问题   --------\n  ^      /      \\        ^\n  | 缩减/        \\ 平凡   |\n  |\t   /          \\       |\n   -> 子问题     子问题 <---\n   !     !         !    !\n   -------         ------\n     治              治\n\t \n```\n\n\\----例子1-----\n`求n个总数之和`\n\n```cpp\nint sum(int A[], int n) {\n  // A为整数数组, n为问题规模, 返回数组中整数的总和\n  return\n      (n < 1) ?\n      0 : sum(A, n-1) + A[n-1];\n}\n```\n\n**分析:**\n> * 该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]\n> * 最后规模小到一定程度时， 缩减问题变为 平凡问题\n> * 将两个问题合并得到结果\n\n**复杂度如何？**\n\n`递归跟踪(recursion trace)`分析 (用于简单的递归)\n- 检查每个<span style=\"color:red\">**递归实例**\n-  累积所需要时间（调用语句本身抹去，计入递归实例）\n- 其总和是算法执行时间\n||          ||\nvv          vv\n`线性递归`：得出上述递归是线性递归，复杂度渐进O(n)\n\n`递推方程`分析 (用于复杂的递归)\n上述例子中:\nT(n) = T(n-1) + O(1)         // recurrence\nT(0) = O(1)                  // base\n\n```\nT(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...\n         = T(2) - 2\n\t\t = T(1) - 1\n\t\t = T(0) - 0 = O(1)\n\nT(n) = O(1) + n = O(n)\n```\n\n\\-------例子2-----------------\n`任给数组A[0,n), 将其前后颠倒`            // 更一般的子区间[lo, hi]\n**统一接口** : void reverse(int * A, int lo, int hi);\n\n`递归版`\n\n规模缩小两个单位。\n\n```cpp\nvoid reverse(int* A, int lo, int hi) {\n  // 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo\n  // 无返回值，改变指针A所指向的数组, 使其倒序\n  if (lo < hi) {\n    swap(&(A[lo]), &(A[hi]));\n    if (((hi-lo) == 1) || ((hi - lo) == 0)) return;\n    reverse(A, lo + 1, hi - 1);\n  }\n}\n```\n\n分析时间复杂度：\n\n`递归跟踪(recursion trace)`\n```\nint main();\nreverse(A[n], lo, hi);\nreverse(A[n-2], lo+1, hi-1);\nreverse(A[n-4], lo+2, hi-2);\n...\n\nreverse(A[1], lo+(n-1)/2, hi+(n-1)/2);\nor\nreverse(A[0], lo + n/2, hi+ n/2);\n      (n-1)/2 , n是奇数\n     /                   \nO(1)*                    = O(n)\n     \\n / 2,    n是偶数\n```\n\n`递推方程`\n```\nT(n) = T(n) + O(1);\nT(n) - n = T(n-1) - (n-1)\nT(n) - n = T(2) - 2\n         = T(0) - 0\nT(n) = T(0) + n = O(n)\n```\n<span style=\"color\":blue\">*感觉不怎么正确??*</span>\n\n课后推敲:\n\n`迭代原始版本`\n\n```cpp\nvoid reverse_iterate_original(int* A, int lo, int hi) {\n  // 迭代原始版本\nnext:\n  if (lo < hi)\n  {swap(&A[lo], &A[hi]); lo++; hi--; goto next;}\n}\n```\n\n<span style=\"color:blue\">*使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过*</span>\n\n`迭代精简版`\n```cpp\nvoid reverse_iterate(int* A, int lo, int hi) {\n  // 迭代版本\n  while (lo < hi) swap(&A[lo++], &A[hi--]);\n}\n```\n\n# 分而治之(divide-and-conquer)\n\n分解为多个或两个子问题，得到解后归并。\n\\------二分递归----------\n\n```cpp\nint mid_sum(int A[], int lo, int hi) {\n  // 数组求和 :二分递归\n  if (lo == hi) return A[lo];\n  int mid = (lo + hi) >> 1;\n  return mid_sum(A, lo, mid) + mid_sum(A, mid + 1, hi);\n}\n\t```\n\n<span style=\"color:red\">**注意 mid + 1**</span>\n\n// 分析:\n// 被分解成两个相似问题，mid_sum(n/2)\n// 规模每次缩减一半，最后到达递归基\n// 将多个问题结果合并\n\n分析复杂度:\n\n`递归跟踪(几何归纳)`\n\n以2为倍数的**几何级数**，总和与**末项同阶**。\n\n`递推方程(代数运算)`\n\n两个问题都是n/2\n累加O(1)时间\n递归基O(1)时间返回\n\n递推关系\nT(n) = 2* T(n/2) + O(1)\nT(1) = O(1)\n\n\n..\nT(n) = O(n)\n\n\n\n# Max2: 迭代1\n\n从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] > A[x2]\n比较次数要尽可能的少\n\n```cpp\nint max2_three_iters(int A[], int lo, int hi) {   // 1 < n = hi - lo\n  int max1 = 0, max2 = 0;\n  int x1, x2;\n  if (hi < lo) return -1;\n  for (int i = lo; i <= hi; i++)\n    if (max1 < A[i]) {max1 = A[i]; x1 = i;}       // hi-lo-1 = n-1\n\n  if (x1 != lo) {\n    for (int i_lo  = lo; i_lo < x1; i_lo++)\n      if (max2 < A[i_lo]) {max2 = A[i_lo]; x2 = i_lo;} // x1-lo-1\n  }\n  if (x1 != hi) {\n    for (int i_hi = x1+1; i_hi <= hi; i_hi++)\n      if (max2 < A[i_hi]) {max2 = A[i_hi]; x2 = i_hi;} // hi-x1-1\n  }\n  int max_array[2] = {max1, max2};\n  std::cout << \" A[x1] = \" << A[x1] << '\\n'\n            << \" A[x2] = \" << A[x2] << std::endl;\n}\n```\n\n总共比较n-1+n-2 =2n-3 \n\n```cpp\nint max2(int A[], int lo, int hi) {\n  // 遍历一次，改变指针\n  int* x1 = &lo;\n  int lo_next = lo + 1;\n  int* x2 = &lo_next;\n  if (A[*x1] < A[*x2]) {x1 = &lo_next; x2 = &lo;}\n  for (int i = lo + 2; i <= hi; i++) {\n    if (A[*x2] < A[i]) {      // 索引i的对象比较小的值大\n      if (A[*x1] < A[i]) {    // 索引i的对象甚至超过了较大值\n        x2 = &(*x1); x1 = &i;\n        break;\n      }\n      *x2 = i;                // x1指针指向的元素赋值成i\n    }\n  }\n  std::cout << \" A[*x1] \"  << A[*x1] << '\\n'\n            << \" A[*x2] \"  << A[*x2] << std::endl;\n}\n\n```\n\n最好情况: 1 + (n-2)*1 = n-1\n最坏情况: 1+ (n-2) *2 = 2n-3\n\n\n`即使在最坏情况，也更高效的改进算法`\n\n> * 分而治之\n> * 实现退化情况\n\n```cpp\nvoid max2(int A[], int lo, int hi, int & x1, int & x2) {     // [lo, hi)\n  if (lo + 2 == hi) {\n    if (A[lo] < A[lo+1]) {\n      x1 = A[lo+1]; x2 = A[lo];\n    } else {\n      x2 = A[lo+1]; x1 = A[lo];\n    }\n    return;\n  }                         // T(2) = 1\n  if (lo + 3 == hi) {       // lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;\n    x1 = lo, x2 = lo+1;\n    if (A[x1] < A[x2]) {x1 = lo+1; x2 = lo;}\n    for (int i = lo+2; i < hi+1; i++) {\n      if (A[i] > A[x2]) {\n        if (A[i] > A[x1]) {\n          int tmp = x1;\n          x1 = i; x2 = tmp;\n          break;\n        }\n        x2 = i;\n      }\n    }\n    return;\n  }                         // T(3) <= 3\n  int mid = (lo + hi) >> 1;\n  int x1L, x2L; max2(A, lo, mid, x1L, x2L);\n  int x1R, x2R; max2(A, mid+1, hi, x1R, x2R);\n  if (A[x1L] > A[x1R]) {\n    x1 = x1L; x2 = (x2L < x1R) ? x1R:x2L;\n  } else {\n    x1 = x1R; x2 = (x2R < x1L) ? x1L:x2R;\n  }\n} // 1 + 1 = 2\n```\n\n\n最坏情况: T(n) = 2 * T(n/2) + 2 <= 5n/3 -2\n\n`递推方程推导过程:` ? \n\n`最好情况复杂度:` ?\n\n\n# 总结\n\n两种重要算法策略：减而治之，分而治之\n\n两种分析方法：递归跟踪和递推方程\n","source":"_posts/dsacpp/01-E.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-01-E\ndate: 2018-01-10 00:08:41\ntags: 数据结构\n---\n\n\n# 迭代与递归\n\n分而治之：分解成子问题，递归式的求解。\n\n空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。\n\n# 减而治之\n\n```\n   合                合并\n  ---->    问题   --------\n  ^      /      \\        ^\n  | 缩减/        \\ 平凡   |\n  |\t   /          \\       |\n   -> 子问题     子问题 <---\n   !     !         !    !\n   -------         ------\n     治              治\n\t \n```\n\n\\----例子1-----\n`求n个总数之和`\n\n```cpp\nint sum(int A[], int n) {\n  // A为整数数组, n为问题规模, 返回数组中整数的总和\n  return\n      (n < 1) ?\n      0 : sum(A, n-1) + A[n-1];\n}\n```\n\n**分析:**\n> * 该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]\n> * 最后规模小到一定程度时， 缩减问题变为 平凡问题\n> * 将两个问题合并得到结果\n\n**复杂度如何？**\n\n`递归跟踪(recursion trace)`分析 (用于简单的递归)\n- 检查每个<span style=\"color:red\">**递归实例**\n-  累积所需要时间（调用语句本身抹去，计入递归实例）\n- 其总和是算法执行时间\n||          ||\nvv          vv\n`线性递归`：得出上述递归是线性递归，复杂度渐进O(n)\n\n`递推方程`分析 (用于复杂的递归)\n上述例子中:\nT(n) = T(n-1) + O(1)         // recurrence\nT(0) = O(1)                  // base\n\n```\nT(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...\n         = T(2) - 2\n\t\t = T(1) - 1\n\t\t = T(0) - 0 = O(1)\n\nT(n) = O(1) + n = O(n)\n```\n\n\\-------例子2-----------------\n`任给数组A[0,n), 将其前后颠倒`            // 更一般的子区间[lo, hi]\n**统一接口** : void reverse(int * A, int lo, int hi);\n\n`递归版`\n\n规模缩小两个单位。\n\n```cpp\nvoid reverse(int* A, int lo, int hi) {\n  // 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo\n  // 无返回值，改变指针A所指向的数组, 使其倒序\n  if (lo < hi) {\n    swap(&(A[lo]), &(A[hi]));\n    if (((hi-lo) == 1) || ((hi - lo) == 0)) return;\n    reverse(A, lo + 1, hi - 1);\n  }\n}\n```\n\n分析时间复杂度：\n\n`递归跟踪(recursion trace)`\n```\nint main();\nreverse(A[n], lo, hi);\nreverse(A[n-2], lo+1, hi-1);\nreverse(A[n-4], lo+2, hi-2);\n...\n\nreverse(A[1], lo+(n-1)/2, hi+(n-1)/2);\nor\nreverse(A[0], lo + n/2, hi+ n/2);\n      (n-1)/2 , n是奇数\n     /                   \nO(1)*                    = O(n)\n     \\n / 2,    n是偶数\n```\n\n`递推方程`\n```\nT(n) = T(n) + O(1);\nT(n) - n = T(n-1) - (n-1)\nT(n) - n = T(2) - 2\n         = T(0) - 0\nT(n) = T(0) + n = O(n)\n```\n<span style=\"color\":blue\">*感觉不怎么正确??*</span>\n\n课后推敲:\n\n`迭代原始版本`\n\n```cpp\nvoid reverse_iterate_original(int* A, int lo, int hi) {\n  // 迭代原始版本\nnext:\n  if (lo < hi)\n  {swap(&A[lo], &A[hi]); lo++; hi--; goto next;}\n}\n```\n\n<span style=\"color:blue\">*使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过*</span>\n\n`迭代精简版`\n```cpp\nvoid reverse_iterate(int* A, int lo, int hi) {\n  // 迭代版本\n  while (lo < hi) swap(&A[lo++], &A[hi--]);\n}\n```\n\n# 分而治之(divide-and-conquer)\n\n分解为多个或两个子问题，得到解后归并。\n\\------二分递归----------\n\n```cpp\nint mid_sum(int A[], int lo, int hi) {\n  // 数组求和 :二分递归\n  if (lo == hi) return A[lo];\n  int mid = (lo + hi) >> 1;\n  return mid_sum(A, lo, mid) + mid_sum(A, mid + 1, hi);\n}\n\t```\n\n<span style=\"color:red\">**注意 mid + 1**</span>\n\n// 分析:\n// 被分解成两个相似问题，mid_sum(n/2)\n// 规模每次缩减一半，最后到达递归基\n// 将多个问题结果合并\n\n分析复杂度:\n\n`递归跟踪(几何归纳)`\n\n以2为倍数的**几何级数**，总和与**末项同阶**。\n\n`递推方程(代数运算)`\n\n两个问题都是n/2\n累加O(1)时间\n递归基O(1)时间返回\n\n递推关系\nT(n) = 2* T(n/2) + O(1)\nT(1) = O(1)\n\n\n..\nT(n) = O(n)\n\n\n\n# Max2: 迭代1\n\n从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] > A[x2]\n比较次数要尽可能的少\n\n```cpp\nint max2_three_iters(int A[], int lo, int hi) {   // 1 < n = hi - lo\n  int max1 = 0, max2 = 0;\n  int x1, x2;\n  if (hi < lo) return -1;\n  for (int i = lo; i <= hi; i++)\n    if (max1 < A[i]) {max1 = A[i]; x1 = i;}       // hi-lo-1 = n-1\n\n  if (x1 != lo) {\n    for (int i_lo  = lo; i_lo < x1; i_lo++)\n      if (max2 < A[i_lo]) {max2 = A[i_lo]; x2 = i_lo;} // x1-lo-1\n  }\n  if (x1 != hi) {\n    for (int i_hi = x1+1; i_hi <= hi; i_hi++)\n      if (max2 < A[i_hi]) {max2 = A[i_hi]; x2 = i_hi;} // hi-x1-1\n  }\n  int max_array[2] = {max1, max2};\n  std::cout << \" A[x1] = \" << A[x1] << '\\n'\n            << \" A[x2] = \" << A[x2] << std::endl;\n}\n```\n\n总共比较n-1+n-2 =2n-3 \n\n```cpp\nint max2(int A[], int lo, int hi) {\n  // 遍历一次，改变指针\n  int* x1 = &lo;\n  int lo_next = lo + 1;\n  int* x2 = &lo_next;\n  if (A[*x1] < A[*x2]) {x1 = &lo_next; x2 = &lo;}\n  for (int i = lo + 2; i <= hi; i++) {\n    if (A[*x2] < A[i]) {      // 索引i的对象比较小的值大\n      if (A[*x1] < A[i]) {    // 索引i的对象甚至超过了较大值\n        x2 = &(*x1); x1 = &i;\n        break;\n      }\n      *x2 = i;                // x1指针指向的元素赋值成i\n    }\n  }\n  std::cout << \" A[*x1] \"  << A[*x1] << '\\n'\n            << \" A[*x2] \"  << A[*x2] << std::endl;\n}\n\n```\n\n最好情况: 1 + (n-2)*1 = n-1\n最坏情况: 1+ (n-2) *2 = 2n-3\n\n\n`即使在最坏情况，也更高效的改进算法`\n\n> * 分而治之\n> * 实现退化情况\n\n```cpp\nvoid max2(int A[], int lo, int hi, int & x1, int & x2) {     // [lo, hi)\n  if (lo + 2 == hi) {\n    if (A[lo] < A[lo+1]) {\n      x1 = A[lo+1]; x2 = A[lo];\n    } else {\n      x2 = A[lo+1]; x1 = A[lo];\n    }\n    return;\n  }                         // T(2) = 1\n  if (lo + 3 == hi) {       // lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;\n    x1 = lo, x2 = lo+1;\n    if (A[x1] < A[x2]) {x1 = lo+1; x2 = lo;}\n    for (int i = lo+2; i < hi+1; i++) {\n      if (A[i] > A[x2]) {\n        if (A[i] > A[x1]) {\n          int tmp = x1;\n          x1 = i; x2 = tmp;\n          break;\n        }\n        x2 = i;\n      }\n    }\n    return;\n  }                         // T(3) <= 3\n  int mid = (lo + hi) >> 1;\n  int x1L, x2L; max2(A, lo, mid, x1L, x2L);\n  int x1R, x2R; max2(A, mid+1, hi, x1R, x2R);\n  if (A[x1L] > A[x1R]) {\n    x1 = x1L; x2 = (x2L < x1R) ? x1R:x2L;\n  } else {\n    x1 = x1R; x2 = (x2R < x1L) ? x1L:x2R;\n  }\n} // 1 + 1 = 2\n```\n\n\n最坏情况: T(n) = 2 * T(n/2) + 2 <= 5n/3 -2\n\n`递推方程推导过程:` ? \n\n`最好情况复杂度:` ?\n\n\n# 总结\n\n两种重要算法策略：减而治之，分而治之\n\n两种分析方法：递归跟踪和递推方程\n","slug":"dsacpp/01-E","published":1,"updated":"2018-06-19T16:15:03.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykl0025k8mfsichlyma","content":"<h1 id=\"迭代与递归\"><a href=\"#迭代与递归\" class=\"headerlink\" title=\"迭代与递归\"></a>迭代与递归</h1><p>分而治之：分解成子问题，递归式的求解。</p>\n<p>空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。</p>\n<h1 id=\"减而治之\"><a href=\"#减而治之\" class=\"headerlink\" title=\"减而治之\"></a>减而治之</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 合                合并</span><br><span class=\"line\">----&gt;    问题   --------</span><br><span class=\"line\">^      /      \\        ^</span><br><span class=\"line\">| 缩减/        \\ 平凡   |</span><br><span class=\"line\">|\t   /          \\       |</span><br><span class=\"line\"> -&gt; 子问题     子问题 &lt;---</span><br><span class=\"line\"> !     !         !    !</span><br><span class=\"line\"> -------         ------</span><br><span class=\"line\">   治              治</span><br></pre></td></tr></table></figure>\n<p>-—例子1—–<br><code>求n个总数之和</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A为整数数组, n为问题规模, 返回数组中整数的总和</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">      (n &lt; <span class=\"number\">1</span>) ?</span><br><span class=\"line\">      <span class=\"number\">0</span> : sum(A, n<span class=\"number\">-1</span>) + A[n<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析:</strong></p>\n<blockquote>\n<ul>\n<li>该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]</li>\n<li>最后规模小到一定程度时， 缩减问题变为 平凡问题</li>\n<li>将两个问题合并得到结果</li>\n</ul>\n</blockquote>\n<p><strong>复杂度如何？</strong></p>\n<p><code>递归跟踪(recursion trace)</code>分析 (用于简单的递归)</p>\n<ul>\n<li>检查每个<span style=\"color:red\"><strong>递归实例</strong></span></li>\n<li>累积所需要时间（调用语句本身抹去，计入递归实例）</li>\n<li>其总和是算法执行时间<br>||          ||<br>vv          vv<br><code>线性递归</code>：得出上述递归是线性递归，复杂度渐进O(n)</li>\n</ul>\n<p><code>递推方程</code>分析 (用于复杂的递归)<br>上述例子中:<br>T(n) = T(n-1) + O(1)         // recurrence<br>T(0) = O(1)                  // base</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...</span><br><span class=\"line\">         = T(2) - 2</span><br><span class=\"line\">\t\t = T(1) - 1</span><br><span class=\"line\">\t\t = T(0) - 0 = O(1)</span><br><span class=\"line\"></span><br><span class=\"line\">T(n) = O(1) + n = O(n)</span><br></pre></td></tr></table></figure>\n<p>-——例子2—————–<br><code>任给数组A[0,n), 将其前后颠倒</code>            // 更一般的子区间[lo, hi]<br><strong>统一接口</strong> : void reverse(int * A, int lo, int hi);</p>\n<p><code>递归版</code></p>\n<p>规模缩小两个单位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo</span></span><br><span class=\"line\">  <span class=\"comment\">// 无返回值，改变指针A所指向的数组, 使其倒序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">    swap(&amp;(A[lo]), &amp;(A[hi]));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((hi-lo) == <span class=\"number\">1</span>) || ((hi - lo) == <span class=\"number\">0</span>)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    reverse(A, lo + <span class=\"number\">1</span>, hi - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析时间复杂度：</p>\n<p><code>递归跟踪(recursion trace)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main();</span><br><span class=\"line\">reverse(A[n], lo, hi);</span><br><span class=\"line\">reverse(A[n-2], lo+1, hi-1);</span><br><span class=\"line\">reverse(A[n-4], lo+2, hi-2);</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">reverse(A[1], lo+(n-1)/2, hi+(n-1)/2);</span><br><span class=\"line\">or</span><br><span class=\"line\">reverse(A[0], lo + n/2, hi+ n/2);</span><br><span class=\"line\">      (n-1)/2 , n是奇数</span><br><span class=\"line\">     /                   </span><br><span class=\"line\">O(1)*                    = O(n)</span><br><span class=\"line\">     \\n / 2,    n是偶数</span><br></pre></td></tr></table></figure></p>\n<p><code>递推方程</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T(n) = T(n) + O(1);</span><br><span class=\"line\">T(n) - n = T(n-1) - (n-1)</span><br><span class=\"line\">T(n) - n = T(2) - 2</span><br><span class=\"line\">         = T(0) - 0</span><br><span class=\"line\">T(n) = T(0) + n = O(n)</span><br></pre></td></tr></table></figure></p>\n<p>&lt;span style=”color”:blue”&gt;<em>感觉不怎么正确??</em></p>\n<p>课后推敲:</p>\n<p><code>迭代原始版本</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse_iterate_original</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代原始版本</span></span><br><span class=\"line\">next:</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo &lt; hi)</span><br><span class=\"line\">  &#123;swap(&amp;A[lo], &amp;A[hi]); lo++; hi--; <span class=\"keyword\">goto</span> next;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color:blue\"><em>使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过</em></span></p>\n<p><code>迭代精简版</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse_iterate</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代版本</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi) swap(&amp;A[lo++], &amp;A[hi--]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"分而治之-divide-and-conquer\"><a href=\"#分而治之-divide-and-conquer\" class=\"headerlink\" title=\"分而治之(divide-and-conquer)\"></a>分而治之(divide-and-conquer)</h1><p>分解为多个或两个子问题，得到解后归并。<br>-—–二分递归———-</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数组求和 :二分递归</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo == hi) <span class=\"keyword\">return</span> A[lo];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mid_sum(A, lo, mid) + mid_sum(A, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color:red\"><strong>注意 mid + 1</strong></span></p>\n<p>// 分析:<br>// 被分解成两个相似问题，mid_sum(n/2)<br>// 规模每次缩减一半，最后到达递归基<br>// 将多个问题结果合并</p>\n<p>分析复杂度:</p>\n<p><code>递归跟踪(几何归纳)</code></p>\n<p>以2为倍数的<strong>几何级数</strong>，总和与<strong>末项同阶</strong>。</p>\n<p><code>递推方程(代数运算)</code></p>\n<p>两个问题都是n/2<br>累加O(1)时间<br>递归基O(1)时间返回</p>\n<p>递推关系<br>T(n) = 2* T(n/2) + O(1)<br>T(1) = O(1)</p>\n<p>..<br>T(n) = O(n)</p>\n<h1 id=\"Max2-迭代1\"><a href=\"#Max2-迭代1\" class=\"headerlink\" title=\"Max2: 迭代1\"></a>Max2: 迭代1</h1><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] &gt; A[x2]<br>比较次数要尽可能的少</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max2_three_iters</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;   <span class=\"comment\">// 1 &lt; n = hi - lo</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> max1 = <span class=\"number\">0</span>, max2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1, x2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hi &lt; lo) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo; i &lt;= hi; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max1 &lt; A[i]) &#123;max1 = A[i]; x1 = i;&#125;       <span class=\"comment\">// hi-lo-1 = n-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x1 != lo) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i_lo  = lo; i_lo &lt; x1; i_lo++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (max2 &lt; A[i_lo]) &#123;max2 = A[i_lo]; x2 = i_lo;&#125; <span class=\"comment\">// x1-lo-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x1 != hi) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i_hi = x1+<span class=\"number\">1</span>; i_hi &lt;= hi; i_hi++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (max2 &lt; A[i_hi]) &#123;max2 = A[i_hi]; x2 = i_hi;&#125; <span class=\"comment\">// hi-x1-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> max_array[<span class=\"number\">2</span>] = &#123;max1, max2&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" A[x1] = \"</span> &lt;&lt; A[x1] &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" A[x2] = \"</span> &lt;&lt; A[x2] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总共比较n-1+n-2 =2n-3 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历一次，改变指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>* x1 = &amp;lo;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> lo_next = lo + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* x2 = &amp;lo_next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (A[*x1] &lt; A[*x2]) &#123;x1 = &amp;lo_next; x2 = &amp;lo;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo + <span class=\"number\">2</span>; i &lt;= hi; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[*x2] &lt; A[i]) &#123;      <span class=\"comment\">// 索引i的对象比较小的值大</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[*x1] &lt; A[i]) &#123;    <span class=\"comment\">// 索引i的对象甚至超过了较大值</span></span><br><span class=\"line\">        x2 = &amp;(*x1); x1 = &amp;i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *x2 = i;                <span class=\"comment\">// x1指针指向的元素赋值成i</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" A[*x1] \"</span>  &lt;&lt; A[*x1] &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" A[*x2] \"</span>  &lt;&lt; A[*x2] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最好情况: 1 + (n-2)<em>1 = n-1<br>最坏情况: 1+ (n-2) </em>2 = 2n-3</p>\n<p><code>即使在最坏情况，也更高效的改进算法</code></p>\n<blockquote>\n<ul>\n<li>分而治之</li>\n<li>实现退化情况</li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> &amp; x1, <span class=\"keyword\">int</span> &amp; x2)</span> </span>&#123;     <span class=\"comment\">// [lo, hi)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo + <span class=\"number\">2</span> == hi) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[lo] &lt; A[lo+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      x1 = A[lo+<span class=\"number\">1</span>]; x2 = A[lo];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x2 = A[lo+<span class=\"number\">1</span>]; x1 = A[lo];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;                         <span class=\"comment\">// T(2) = 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo + <span class=\"number\">3</span> == hi) &#123;       <span class=\"comment\">// lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;</span></span><br><span class=\"line\">    x1 = lo, x2 = lo+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[x1] &lt; A[x2]) &#123;x1 = lo+<span class=\"number\">1</span>; x2 = lo;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo+<span class=\"number\">2</span>; i &lt; hi+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[i] &gt; A[x2]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] &gt; A[x1]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> tmp = x1;</span><br><span class=\"line\">          x1 = i; x2 = tmp;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x2 = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;                         <span class=\"comment\">// T(3) &lt;= 3</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1L, x2L; max2(A, lo, mid, x1L, x2L);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1R, x2R; max2(A, mid+<span class=\"number\">1</span>, hi, x1R, x2R);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class=\"line\">    x1 = x1L; x2 = (x2L &lt; x1R) ? x1R:x2L;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x1 = x1R; x2 = (x2R &lt; x1L) ? x1L:x2R;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 1 + 1 = 2</span></span><br></pre></td></tr></table></figure>\n<p>最坏情况: T(n) = 2 * T(n/2) + 2 &lt;= 5n/3 -2</p>\n<p><code>递推方程推导过程:</code> ? </p>\n<p><code>最好情况复杂度:</code> ?</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>两种重要算法策略：减而治之，分而治之</p>\n<p>两种分析方法：递归跟踪和递推方程</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"迭代与递归\"><a href=\"#迭代与递归\" class=\"headerlink\" title=\"迭代与递归\"></a>迭代与递归</h1><p>分而治之：分解成子问题，递归式的求解。</p>\n<p>空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。</p>\n<h1 id=\"减而治之\"><a href=\"#减而治之\" class=\"headerlink\" title=\"减而治之\"></a>减而治之</h1><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 合                合并</span><br><span class=\"line\">----&gt;    问题   --------</span><br><span class=\"line\">^      /      \\        ^</span><br><span class=\"line\">| 缩减/        \\ 平凡   |</span><br><span class=\"line\">|\t   /          \\       |</span><br><span class=\"line\"> -&gt; 子问题     子问题 &lt;---</span><br><span class=\"line\"> !     !         !    !</span><br><span class=\"line\"> -------         ------</span><br><span class=\"line\">   治              治</span><br></pre></td></tr></table></figure>\n<p>-—例子1—–<br><code>求n个总数之和</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// A为整数数组, n为问题规模, 返回数组中整数的总和</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">      (n &lt; <span class=\"number\">1</span>) ?</span><br><span class=\"line\">      <span class=\"number\">0</span> : sum(A, n<span class=\"number\">-1</span>) + A[n<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析:</strong></p>\n<blockquote>\n<ul>\n<li>该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]</li>\n<li>最后规模小到一定程度时， 缩减问题变为 平凡问题</li>\n<li>将两个问题合并得到结果</li>\n</ul>\n</blockquote>\n<p><strong>复杂度如何？</strong></p>\n<p><code>递归跟踪(recursion trace)</code>分析 (用于简单的递归)</p>\n<ul>\n<li>检查每个<span style=\"color:red\"><strong>递归实例</strong></span></li>\n<li>累积所需要时间（调用语句本身抹去，计入递归实例）</li>\n<li>其总和是算法执行时间<br>||          ||<br>vv          vv<br><code>线性递归</code>：得出上述递归是线性递归，复杂度渐进O(n)</li>\n</ul>\n<p><code>递推方程</code>分析 (用于复杂的递归)<br>上述例子中:<br>T(n) = T(n-1) + O(1)         // recurrence<br>T(0) = O(1)                  // base</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...</span><br><span class=\"line\">         = T(2) - 2</span><br><span class=\"line\">\t\t = T(1) - 1</span><br><span class=\"line\">\t\t = T(0) - 0 = O(1)</span><br><span class=\"line\"></span><br><span class=\"line\">T(n) = O(1) + n = O(n)</span><br></pre></td></tr></table></figure>\n<p>-——例子2—————–<br><code>任给数组A[0,n), 将其前后颠倒</code>            // 更一般的子区间[lo, hi]<br><strong>统一接口</strong> : void reverse(int * A, int lo, int hi);</p>\n<p><code>递归版</code></p>\n<p>规模缩小两个单位。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo</span></span><br><span class=\"line\">  <span class=\"comment\">// 无返回值，改变指针A所指向的数组, 使其倒序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">    swap(&amp;(A[lo]), &amp;(A[hi]));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((hi-lo) == <span class=\"number\">1</span>) || ((hi - lo) == <span class=\"number\">0</span>)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    reverse(A, lo + <span class=\"number\">1</span>, hi - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析时间复杂度：</p>\n<p><code>递归跟踪(recursion trace)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int main();</span><br><span class=\"line\">reverse(A[n], lo, hi);</span><br><span class=\"line\">reverse(A[n-2], lo+1, hi-1);</span><br><span class=\"line\">reverse(A[n-4], lo+2, hi-2);</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">reverse(A[1], lo+(n-1)/2, hi+(n-1)/2);</span><br><span class=\"line\">or</span><br><span class=\"line\">reverse(A[0], lo + n/2, hi+ n/2);</span><br><span class=\"line\">      (n-1)/2 , n是奇数</span><br><span class=\"line\">     /                   </span><br><span class=\"line\">O(1)*                    = O(n)</span><br><span class=\"line\">     \\n / 2,    n是偶数</span><br></pre></td></tr></table></figure></p>\n<p><code>递推方程</code><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">T(n) = T(n) + O(1);</span><br><span class=\"line\">T(n) - n = T(n-1) - (n-1)</span><br><span class=\"line\">T(n) - n = T(2) - 2</span><br><span class=\"line\">         = T(0) - 0</span><br><span class=\"line\">T(n) = T(0) + n = O(n)</span><br></pre></td></tr></table></figure></p>\n<p>&lt;span style=”color”:blue”&gt;<em>感觉不怎么正确??</em></p>\n<p>课后推敲:</p>\n<p><code>迭代原始版本</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse_iterate_original</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代原始版本</span></span><br><span class=\"line\">next:</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo &lt; hi)</span><br><span class=\"line\">  &#123;swap(&amp;A[lo], &amp;A[hi]); lo++; hi--; <span class=\"keyword\">goto</span> next;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color:blue\"><em>使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过</em></span></p>\n<p><code>迭代精简版</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse_iterate</span><span class=\"params\">(<span class=\"keyword\">int</span>* A, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 迭代版本</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi) swap(&amp;A[lo++], &amp;A[hi--]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"分而治之-divide-and-conquer\"><a href=\"#分而治之-divide-and-conquer\" class=\"headerlink\" title=\"分而治之(divide-and-conquer)\"></a>分而治之(divide-and-conquer)</h1><p>分解为多个或两个子问题，得到解后归并。<br>-—–二分递归———-</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mid_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数组求和 :二分递归</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo == hi) <span class=\"keyword\">return</span> A[lo];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mid_sum(A, lo, mid) + mid_sum(A, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span style=\"color:red\"><strong>注意 mid + 1</strong></span></p>\n<p>// 分析:<br>// 被分解成两个相似问题，mid_sum(n/2)<br>// 规模每次缩减一半，最后到达递归基<br>// 将多个问题结果合并</p>\n<p>分析复杂度:</p>\n<p><code>递归跟踪(几何归纳)</code></p>\n<p>以2为倍数的<strong>几何级数</strong>，总和与<strong>末项同阶</strong>。</p>\n<p><code>递推方程(代数运算)</code></p>\n<p>两个问题都是n/2<br>累加O(1)时间<br>递归基O(1)时间返回</p>\n<p>递推关系<br>T(n) = 2* T(n/2) + O(1)<br>T(1) = O(1)</p>\n<p>..<br>T(n) = O(n)</p>\n<h1 id=\"Max2-迭代1\"><a href=\"#Max2-迭代1\" class=\"headerlink\" title=\"Max2: 迭代1\"></a>Max2: 迭代1</h1><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] &gt; A[x2]<br>比较次数要尽可能的少</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max2_three_iters</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;   <span class=\"comment\">// 1 &lt; n = hi - lo</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> max1 = <span class=\"number\">0</span>, max2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1, x2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hi &lt; lo) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo; i &lt;= hi; i++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max1 &lt; A[i]) &#123;max1 = A[i]; x1 = i;&#125;       <span class=\"comment\">// hi-lo-1 = n-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x1 != lo) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i_lo  = lo; i_lo &lt; x1; i_lo++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (max2 &lt; A[i_lo]) &#123;max2 = A[i_lo]; x2 = i_lo;&#125; <span class=\"comment\">// x1-lo-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x1 != hi) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i_hi = x1+<span class=\"number\">1</span>; i_hi &lt;= hi; i_hi++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (max2 &lt; A[i_hi]) &#123;max2 = A[i_hi]; x2 = i_hi;&#125; <span class=\"comment\">// hi-x1-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> max_array[<span class=\"number\">2</span>] = &#123;max1, max2&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" A[x1] = \"</span> &lt;&lt; A[x1] &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" A[x2] = \"</span> &lt;&lt; A[x2] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总共比较n-1+n-2 =2n-3 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历一次，改变指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>* x1 = &amp;lo;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> lo_next = lo + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>* x2 = &amp;lo_next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (A[*x1] &lt; A[*x2]) &#123;x1 = &amp;lo_next; x2 = &amp;lo;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo + <span class=\"number\">2</span>; i &lt;= hi; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[*x2] &lt; A[i]) &#123;      <span class=\"comment\">// 索引i的对象比较小的值大</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[*x1] &lt; A[i]) &#123;    <span class=\"comment\">// 索引i的对象甚至超过了较大值</span></span><br><span class=\"line\">        x2 = &amp;(*x1); x1 = &amp;i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *x2 = i;                <span class=\"comment\">// x1指针指向的元素赋值成i</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" A[*x1] \"</span>  &lt;&lt; A[*x1] &lt;&lt; <span class=\"string\">'\\n'</span></span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" A[*x2] \"</span>  &lt;&lt; A[*x2] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最好情况: 1 + (n-2)<em>1 = n-1<br>最坏情况: 1+ (n-2) </em>2 = 2n-3</p>\n<p><code>即使在最坏情况，也更高效的改进算法</code></p>\n<blockquote>\n<ul>\n<li>分而治之</li>\n<li>实现退化情况</li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">max2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi, <span class=\"keyword\">int</span> &amp; x1, <span class=\"keyword\">int</span> &amp; x2)</span> </span>&#123;     <span class=\"comment\">// [lo, hi)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo + <span class=\"number\">2</span> == hi) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[lo] &lt; A[lo+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      x1 = A[lo+<span class=\"number\">1</span>]; x2 = A[lo];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      x2 = A[lo+<span class=\"number\">1</span>]; x1 = A[lo];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;                         <span class=\"comment\">// T(2) = 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo + <span class=\"number\">3</span> == hi) &#123;       <span class=\"comment\">// lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;</span></span><br><span class=\"line\">    x1 = lo, x2 = lo+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A[x1] &lt; A[x2]) &#123;x1 = lo+<span class=\"number\">1</span>; x2 = lo;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = lo+<span class=\"number\">2</span>; i &lt; hi+<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (A[i] &gt; A[x2]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (A[i] &gt; A[x1]) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> tmp = x1;</span><br><span class=\"line\">          x1 = i; x2 = tmp;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x2 = i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;                         <span class=\"comment\">// T(3) &lt;= 3</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1L, x2L; max2(A, lo, mid, x1L, x2L);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> x1R, x2R; max2(A, mid+<span class=\"number\">1</span>, hi, x1R, x2R);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class=\"line\">    x1 = x1L; x2 = (x2L &lt; x1R) ? x1R:x2L;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    x1 = x1R; x2 = (x2R &lt; x1L) ? x1L:x2R;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 1 + 1 = 2</span></span><br></pre></td></tr></table></figure>\n<p>最坏情况: T(n) = 2 * T(n/2) + 2 &lt;= 5n/3 -2</p>\n<p><code>递推方程推导过程:</code> ? </p>\n<p><code>最好情况复杂度:</code> ?</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>两种重要算法策略：减而治之，分而治之</p>\n<p>两种分析方法：递归跟踪和递推方程</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-01-F","date":"2018-01-09T16:08:52.000Z","_content":"\n# 动态规划\n\nMake it work  \\\nMake it right - 递归\nMake it fast  - 迭代\n     -- Kent Beck\n\n`动态规划`: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式\n\n```cpp\nint fib(int n) {\n  return (2 > n) ? n : fib(n-1) + fib(n-2);\n}\n```\n\nwork, right, but not fast.\n\n# 封底估算\n\n\n$^36 = 2^25,  ==> $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec\n$^5 = 10,     ==> $^67 = 10^14 flo = 10^5 sec = 1 day\n\n# 递归跟踪\n\n效率低的原因是递归实例被重复调用。\n\n`解决方法A(记忆:memoization)`\n```cpp\nint fib_memoization(int n, int mem_lst[]) {\n  // 将已经计算的结果, 制成表备查\n  if (is_exist(mem_lst[n])) {\n    return mem_lst[n];\n  } else {\n    if (2 > n) {mem_lst[n] = n;} else {\n      mem_lst[n] = fib_memoization(n-1, mem_lst) +\n          fib_memoization(n-2, mem_lst);\n      return mem_lst[n];\n    }\n  }\n}\n```\n\n\n`解决方法B 动态规划`\n上楼梯。\n\n```cpp\n\nint fib_dynamic(int n) {\n  int f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;\n  while (0 < n--) {\n    g = g + f;\n    f = g - f;\n  }\n  return g;\n}\n```\n\n不太能理解, 先放着\n\n# 最长公共子序列\n\n`子序列(Subsequence)`: 有序列中若干字符，按原相对次序构成\n\n`最长公共子序列(Longest common subsequence)`，两个序列公共子序列的最长者\n\n可能有多个，可能有歧义\n\n`实现`\n\n暂时还实现不了\n\n\n## 动态规划\n\n理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。\n","source":"_posts/dsacpp/01-F.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-01-F\ndate: 2018-01-10 00:08:52\ntags: [数据结构, 动态规划]\n---\n\n# 动态规划\n\nMake it work  \\\nMake it right - 递归\nMake it fast  - 迭代\n     -- Kent Beck\n\n`动态规划`: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式\n\n```cpp\nint fib(int n) {\n  return (2 > n) ? n : fib(n-1) + fib(n-2);\n}\n```\n\nwork, right, but not fast.\n\n# 封底估算\n\n\n$^36 = 2^25,  ==> $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec\n$^5 = 10,     ==> $^67 = 10^14 flo = 10^5 sec = 1 day\n\n# 递归跟踪\n\n效率低的原因是递归实例被重复调用。\n\n`解决方法A(记忆:memoization)`\n```cpp\nint fib_memoization(int n, int mem_lst[]) {\n  // 将已经计算的结果, 制成表备查\n  if (is_exist(mem_lst[n])) {\n    return mem_lst[n];\n  } else {\n    if (2 > n) {mem_lst[n] = n;} else {\n      mem_lst[n] = fib_memoization(n-1, mem_lst) +\n          fib_memoization(n-2, mem_lst);\n      return mem_lst[n];\n    }\n  }\n}\n```\n\n\n`解决方法B 动态规划`\n上楼梯。\n\n```cpp\n\nint fib_dynamic(int n) {\n  int f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;\n  while (0 < n--) {\n    g = g + f;\n    f = g - f;\n  }\n  return g;\n}\n```\n\n不太能理解, 先放着\n\n# 最长公共子序列\n\n`子序列(Subsequence)`: 有序列中若干字符，按原相对次序构成\n\n`最长公共子序列(Longest common subsequence)`，两个序列公共子序列的最长者\n\n可能有多个，可能有歧义\n\n`实现`\n\n暂时还实现不了\n\n\n## 动态规划\n\n理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。\n","slug":"dsacpp/01-F","published":1,"updated":"2018-06-19T16:15:03.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykn0026k8mfuzmvhzs2","content":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>Make it work  \\<br>Make it right - 递归<br>Make it fast  - 迭代<br>     – Kent Beck</p>\n<p><code>动态规划</code>: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"number\">2</span> &gt; n) ? n : fib(n<span class=\"number\">-1</span>) + fib(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>work, right, but not fast.</p>\n<h1 id=\"封底估算\"><a href=\"#封底估算\" class=\"headerlink\" title=\"封底估算\"></a>封底估算</h1><p>$^36 = 2^25,  ==&gt; $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec<br>$^5 = 10,     ==&gt; $^67 = 10^14 flo = 10^5 sec = 1 day</p>\n<h1 id=\"递归跟踪\"><a href=\"#递归跟踪\" class=\"headerlink\" title=\"递归跟踪\"></a>递归跟踪</h1><p>效率低的原因是递归实例被重复调用。</p>\n<p><code>解决方法A(记忆:memoization)</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib_memoization</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> mem_lst[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将已经计算的结果, 制成表备查</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_exist(mem_lst[n])) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mem_lst[n];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span> &gt; n) &#123;mem_lst[n] = n;&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mem_lst[n] = fib_memoization(n<span class=\"number\">-1</span>, mem_lst) +</span><br><span class=\"line\">          fib_memoization(n<span class=\"number\">-2</span>, mem_lst);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mem_lst[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>解决方法B 动态规划</code><br>上楼梯。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib_dynamic</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> f = <span class=\"number\">0</span>, g = <span class=\"number\">1</span>;          <span class=\"comment\">// fib(0) = 0; fib(1) = 1;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">0</span> &lt; n--) &#123;</span><br><span class=\"line\">    g = g + f;</span><br><span class=\"line\">    f = g - f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不太能理解, 先放着</p>\n<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p><code>子序列(Subsequence)</code>: 有序列中若干字符，按原相对次序构成</p>\n<p><code>最长公共子序列(Longest common subsequence)</code>，两个序列公共子序列的最长者</p>\n<p>可能有多个，可能有歧义</p>\n<p><code>实现</code></p>\n<p>暂时还实现不了</p>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>Make it work  \\<br>Make it right - 递归<br>Make it fast  - 迭代<br>     – Kent Beck</p>\n<p><code>动态规划</code>: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"number\">2</span> &gt; n) ? n : fib(n<span class=\"number\">-1</span>) + fib(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>work, right, but not fast.</p>\n<h1 id=\"封底估算\"><a href=\"#封底估算\" class=\"headerlink\" title=\"封底估算\"></a>封底估算</h1><p>$^36 = 2^25,  ==&gt; $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec<br>$^5 = 10,     ==&gt; $^67 = 10^14 flo = 10^5 sec = 1 day</p>\n<h1 id=\"递归跟踪\"><a href=\"#递归跟踪\" class=\"headerlink\" title=\"递归跟踪\"></a>递归跟踪</h1><p>效率低的原因是递归实例被重复调用。</p>\n<p><code>解决方法A(记忆:memoization)</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib_memoization</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> mem_lst[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将已经计算的结果, 制成表备查</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (is_exist(mem_lst[n])) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mem_lst[n];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span> &gt; n) &#123;mem_lst[n] = n;&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      mem_lst[n] = fib_memoization(n<span class=\"number\">-1</span>, mem_lst) +</span><br><span class=\"line\">          fib_memoization(n<span class=\"number\">-2</span>, mem_lst);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mem_lst[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>解决方法B 动态规划</code><br>上楼梯。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fib_dynamic</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> f = <span class=\"number\">0</span>, g = <span class=\"number\">1</span>;          <span class=\"comment\">// fib(0) = 0; fib(1) = 1;</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">0</span> &lt; n--) &#123;</span><br><span class=\"line\">    g = g + f;</span><br><span class=\"line\">    f = g - f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不太能理解, 先放着</p>\n<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p><code>子序列(Subsequence)</code>: 有序列中若干字符，按原相对次序构成</p>\n<p><code>最长公共子序列(Longest common subsequence)</code>，两个序列公共子序列的最长者</p>\n<p>可能有多个，可能有歧义</p>\n<p><code>实现</code></p>\n<p>暂时还实现不了</p>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-A","date":"2018-01-09T16:08:58.000Z","_content":"\n# 接口与实现\n\n如何根据同一接口规范，定制ADT和实现implementation一个数据结构?\n如何通过更有效的算法，使得对外接口更高效的工作?\n - search \n - sort\n \n `Abstract Data Type vs. Data Structure`\n \n 抽象数据类型 = 数据模型 + 定义在该模型上的一组操作\n 数据结构     = 基于某种特定语言，实现ADT的一套算法\n \n \n# 向量ADT\n\n## 数组到向量 \n\n数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的**编号一一对应**\n\nA[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)\n\n向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成\n与[0, n)内的**秩(rank)**一一对应    // 循秩访问(call-by-rank)\n元素类型不限于基本类型\n操作，管理维护更加简化安全。\n可更为简便的参与更复杂的数据结构的定制。\n\n# 操作实例\n\n## Vector模板类\n\n```cpp\ntypedef int Rank;             // 秩\n#define DEAFAULT_CAPACITY 3   // 默认初始容量\n\ntemplate <typename T> class Vector {   // 向量模板类\n private:\n  Rank _size; int _capacity; T* _elem;   // 规模, 容量, 数据区\n protected:\n  /* ... 内部函数*/\n public:\n  /* ... 构造函数*/\n  /* ... 析构函数*/\n  /* ... 只读函数*/\n  /* ... 可写函数*/\n  /* ... 遍历函数*/\n};\n```\n\n应用和实现相互分离;\n实现对内部数据项的封装。\n\n## 构造和析构\n\n```cpp\ntemplate <typename T> class Vector {   // 向量模板类\n private:\n  Rank _size; int _capacity; T* _elem;   // 规模, 容量, 数据区\n protected:\n  /* ... 内部函数*/\n public:\n  // /* ... 构造函数\n  void copyFrom(T* const A, Rank lo, Rank hi);\n  Vector(int c = DEAFAULT_CAPACITY)\n  {_elem = new T[_capacity = c]; _size = 0;}     // 默认\n  Vector(T* const A, Rank lo, Rank hi)          // 数组区间复制\n  {copyFrom(A, lo, hi);}\n  Vector(Vector<T> const& V, Rank lo, Rank hi)   // 向量区间复制\n  {copyFrom(V, lo, hi);}\n  Vector(Vector<T> const& V)                     // 向量整体复制\n  {copyFrom(V._elem, 0, V._size);}\n  //  */\n  // /* ... 析构函数\n  ~Vector() {delete [] _elem;}                   // 释放内部空间\n  // */\n  /* ... 只读函数*/\n  /* ... 可写函数*/\n  /* ... 遍历函数*/\n};\n\ntemplate <typename T>\nvoid Vector<T>::copyFrom(T* const A, Rank lo, Rank hi) {\n  _elem = new T[_capacity = 2*(hi- lo)];      // 分配空间\n  _size = 0;  // 清零规模\n  while (lo < hi)   // A[lo, hi)中的元素逐一\n    _elem[_size++] = A[lo++];\n}\n```\n","source":"_posts/dsacpp/02-A.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-A\ndate: 2018-01-10 00:08:58\ntags: [数据结构, 向量]\n---\n\n# 接口与实现\n\n如何根据同一接口规范，定制ADT和实现implementation一个数据结构?\n如何通过更有效的算法，使得对外接口更高效的工作?\n - search \n - sort\n \n `Abstract Data Type vs. Data Structure`\n \n 抽象数据类型 = 数据模型 + 定义在该模型上的一组操作\n 数据结构     = 基于某种特定语言，实现ADT的一套算法\n \n \n# 向量ADT\n\n## 数组到向量 \n\n数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的**编号一一对应**\n\nA[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)\n\n向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成\n与[0, n)内的**秩(rank)**一一对应    // 循秩访问(call-by-rank)\n元素类型不限于基本类型\n操作，管理维护更加简化安全。\n可更为简便的参与更复杂的数据结构的定制。\n\n# 操作实例\n\n## Vector模板类\n\n```cpp\ntypedef int Rank;             // 秩\n#define DEAFAULT_CAPACITY 3   // 默认初始容量\n\ntemplate <typename T> class Vector {   // 向量模板类\n private:\n  Rank _size; int _capacity; T* _elem;   // 规模, 容量, 数据区\n protected:\n  /* ... 内部函数*/\n public:\n  /* ... 构造函数*/\n  /* ... 析构函数*/\n  /* ... 只读函数*/\n  /* ... 可写函数*/\n  /* ... 遍历函数*/\n};\n```\n\n应用和实现相互分离;\n实现对内部数据项的封装。\n\n## 构造和析构\n\n```cpp\ntemplate <typename T> class Vector {   // 向量模板类\n private:\n  Rank _size; int _capacity; T* _elem;   // 规模, 容量, 数据区\n protected:\n  /* ... 内部函数*/\n public:\n  // /* ... 构造函数\n  void copyFrom(T* const A, Rank lo, Rank hi);\n  Vector(int c = DEAFAULT_CAPACITY)\n  {_elem = new T[_capacity = c]; _size = 0;}     // 默认\n  Vector(T* const A, Rank lo, Rank hi)          // 数组区间复制\n  {copyFrom(A, lo, hi);}\n  Vector(Vector<T> const& V, Rank lo, Rank hi)   // 向量区间复制\n  {copyFrom(V, lo, hi);}\n  Vector(Vector<T> const& V)                     // 向量整体复制\n  {copyFrom(V._elem, 0, V._size);}\n  //  */\n  // /* ... 析构函数\n  ~Vector() {delete [] _elem;}                   // 释放内部空间\n  // */\n  /* ... 只读函数*/\n  /* ... 可写函数*/\n  /* ... 遍历函数*/\n};\n\ntemplate <typename T>\nvoid Vector<T>::copyFrom(T* const A, Rank lo, Rank hi) {\n  _elem = new T[_capacity = 2*(hi- lo)];      // 分配空间\n  _size = 0;  // 清零规模\n  while (lo < hi)   // A[lo, hi)中的元素逐一\n    _elem[_size++] = A[lo++];\n}\n```\n","slug":"dsacpp/02-A","published":1,"updated":"2018-06-19T16:15:03.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykp0028k8mf4n61zm7z","content":"<h1 id=\"接口与实现\"><a href=\"#接口与实现\" class=\"headerlink\" title=\"接口与实现\"></a>接口与实现</h1><p>如何根据同一接口规范，定制ADT和实现implementation一个数据结构?<br>如何通过更有效的算法，使得对外接口更高效的工作?</p>\n<ul>\n<li>search </li>\n<li><p>sort</p>\n<p><code>Abstract Data Type vs. Data Structure</code></p>\n<p>抽象数据类型 = 数据模型 + 定义在该模型上的一组操作<br>数据结构     = 基于某种特定语言，实现ADT的一套算法</p>\n</li>\n</ul>\n<h1 id=\"向量ADT\"><a href=\"#向量ADT\" class=\"headerlink\" title=\"向量ADT\"></a>向量ADT</h1><h2 id=\"数组到向量\"><a href=\"#数组到向量\" class=\"headerlink\" title=\"数组到向量\"></a>数组到向量</h2><p>数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的<strong>编号一一对应</strong></p>\n<p>A[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)</p>\n<p>向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成<br>与[0, n)内的<strong>秩(rank)</strong>一一对应    // 循秩访问(call-by-rank)<br>元素类型不限于基本类型<br>操作，管理维护更加简化安全。<br>可更为简便的参与更复杂的数据结构的定制。</p>\n<h1 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h1><h2 id=\"Vector模板类\"><a href=\"#Vector模板类\" class=\"headerlink\" title=\"Vector模板类\"></a>Vector模板类</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Rank;             <span class=\"comment\">// 秩</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEAFAULT_CAPACITY 3   <span class=\"comment\">// 默认初始容量</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>   <span class=\"comment\">// 向量模板类</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Rank _size; <span class=\"keyword\">int</span> _capacity; T* _elem;   <span class=\"comment\">// 规模, 容量, 数据区</span></span><br><span class=\"line\"> <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 内部函数*/</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 构造函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 析构函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 只读函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 可写函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 遍历函数*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>应用和实现相互分离;<br>实现对内部数据项的封装。</p>\n<h2 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>   <span class=\"comment\">// 向量模板类</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Rank _size; <span class=\"keyword\">int</span> _capacity; T* _elem;   <span class=\"comment\">// 规模, 容量, 数据区</span></span><br><span class=\"line\"> <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 内部函数*/</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// /* ... 构造函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi)</span></span>;</span><br><span class=\"line\">  Vector(<span class=\"keyword\">int</span> c = DEAFAULT_CAPACITY)</span><br><span class=\"line\">  &#123;_elem = <span class=\"keyword\">new</span> T[_capacity = c]; _size = <span class=\"number\">0</span>;&#125;     <span class=\"comment\">// 默认</span></span><br><span class=\"line\">  Vector(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi)          <span class=\"comment\">// 数组区间复制</span></span><br><span class=\"line\">  &#123;copyFrom(A, lo, hi);&#125;</span><br><span class=\"line\">  Vector(Vector&lt;T&gt; <span class=\"keyword\">const</span>&amp; V, Rank lo, Rank hi)   <span class=\"comment\">// 向量区间复制</span></span><br><span class=\"line\">  &#123;copyFrom(V, lo, hi);&#125;</span><br><span class=\"line\">  Vector(Vector&lt;T&gt; <span class=\"keyword\">const</span>&amp; V)                     <span class=\"comment\">// 向量整体复制</span></span><br><span class=\"line\">  &#123;copyFrom(V._elem, <span class=\"number\">0</span>, V._size);&#125;</span><br><span class=\"line\">  <span class=\"comment\">//  */</span></span><br><span class=\"line\">  <span class=\"comment\">// /* ... 析构函数</span></span><br><span class=\"line\">  ~Vector() &#123;<span class=\"keyword\">delete</span> [] _elem;&#125;                   <span class=\"comment\">// 释放内部空间</span></span><br><span class=\"line\">  <span class=\"comment\">// */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 只读函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 可写函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 遍历函数*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::copyFrom(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi) &#123;</span><br><span class=\"line\">  _elem = <span class=\"keyword\">new</span> T[_capacity = <span class=\"number\">2</span>*(hi- lo)];      <span class=\"comment\">// 分配空间</span></span><br><span class=\"line\">  _size = <span class=\"number\">0</span>;  <span class=\"comment\">// 清零规模</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi)   <span class=\"comment\">// A[lo, hi)中的元素逐一</span></span><br><span class=\"line\">    _elem[_size++] = A[lo++];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"接口与实现\"><a href=\"#接口与实现\" class=\"headerlink\" title=\"接口与实现\"></a>接口与实现</h1><p>如何根据同一接口规范，定制ADT和实现implementation一个数据结构?<br>如何通过更有效的算法，使得对外接口更高效的工作?</p>\n<ul>\n<li>search </li>\n<li><p>sort</p>\n<p><code>Abstract Data Type vs. Data Structure</code></p>\n<p>抽象数据类型 = 数据模型 + 定义在该模型上的一组操作<br>数据结构     = 基于某种特定语言，实现ADT的一套算法</p>\n</li>\n</ul>\n<h1 id=\"向量ADT\"><a href=\"#向量ADT\" class=\"headerlink\" title=\"向量ADT\"></a>向量ADT</h1><h2 id=\"数组到向量\"><a href=\"#数组到向量\" class=\"headerlink\" title=\"数组到向量\"></a>数组到向量</h2><p>数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的<strong>编号一一对应</strong></p>\n<p>A[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)</p>\n<p>向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成<br>与[0, n)内的<strong>秩(rank)</strong>一一对应    // 循秩访问(call-by-rank)<br>元素类型不限于基本类型<br>操作，管理维护更加简化安全。<br>可更为简便的参与更复杂的数据结构的定制。</p>\n<h1 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h1><h2 id=\"Vector模板类\"><a href=\"#Vector模板类\" class=\"headerlink\" title=\"Vector模板类\"></a>Vector模板类</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> Rank;             <span class=\"comment\">// 秩</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEAFAULT_CAPACITY 3   <span class=\"comment\">// 默认初始容量</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>   <span class=\"comment\">// 向量模板类</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Rank _size; <span class=\"keyword\">int</span> _capacity; T* _elem;   <span class=\"comment\">// 规模, 容量, 数据区</span></span><br><span class=\"line\"> <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 内部函数*/</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 构造函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 析构函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 只读函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 可写函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 遍历函数*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>应用和实现相互分离;<br>实现对内部数据项的封装。</p>\n<h2 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>   <span class=\"comment\">// 向量模板类</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  Rank _size; <span class=\"keyword\">int</span> _capacity; T* _elem;   <span class=\"comment\">// 规模, 容量, 数据区</span></span><br><span class=\"line\"> <span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  <span class=\"comment\">/* ... 内部函数*/</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// /* ... 构造函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyFrom</span><span class=\"params\">(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi)</span></span>;</span><br><span class=\"line\">  Vector(<span class=\"keyword\">int</span> c = DEAFAULT_CAPACITY)</span><br><span class=\"line\">  &#123;_elem = <span class=\"keyword\">new</span> T[_capacity = c]; _size = <span class=\"number\">0</span>;&#125;     <span class=\"comment\">// 默认</span></span><br><span class=\"line\">  Vector(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi)          <span class=\"comment\">// 数组区间复制</span></span><br><span class=\"line\">  &#123;copyFrom(A, lo, hi);&#125;</span><br><span class=\"line\">  Vector(Vector&lt;T&gt; <span class=\"keyword\">const</span>&amp; V, Rank lo, Rank hi)   <span class=\"comment\">// 向量区间复制</span></span><br><span class=\"line\">  &#123;copyFrom(V, lo, hi);&#125;</span><br><span class=\"line\">  Vector(Vector&lt;T&gt; <span class=\"keyword\">const</span>&amp; V)                     <span class=\"comment\">// 向量整体复制</span></span><br><span class=\"line\">  &#123;copyFrom(V._elem, <span class=\"number\">0</span>, V._size);&#125;</span><br><span class=\"line\">  <span class=\"comment\">//  */</span></span><br><span class=\"line\">  <span class=\"comment\">// /* ... 析构函数</span></span><br><span class=\"line\">  ~Vector() &#123;<span class=\"keyword\">delete</span> [] _elem;&#125;                   <span class=\"comment\">// 释放内部空间</span></span><br><span class=\"line\">  <span class=\"comment\">// */</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 只读函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 可写函数*/</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... 遍历函数*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::copyFrom(T* <span class=\"keyword\">const</span> A, Rank lo, Rank hi) &#123;</span><br><span class=\"line\">  _elem = <span class=\"keyword\">new</span> T[_capacity = <span class=\"number\">2</span>*(hi- lo)];      <span class=\"comment\">// 分配空间</span></span><br><span class=\"line\">  _size = <span class=\"number\">0</span>;  <span class=\"comment\">// 清零规模</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi)   <span class=\"comment\">// A[lo, hi)中的元素逐一</span></span><br><span class=\"line\">    _elem[_size++] = A[lo++];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-B","date":"2018-01-09T16:09:07.000Z","_content":"\n# 可扩充向量\n\n## 静态管理空间\n\n_capacity固定, 存在不足:\n> 1, 上溢(overflow）, _elem[]不足以存放元素\n> 2, 下溢(underflow), _elem[]中元素寥寥无几\n装填因子(load factor) = _size/ _ capacity << 50% 空间利用率低\n\n# 动态管理空间\n\n蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。\n\n即将发生**上溢**，适当扩展容量\n\n## 扩容算法实现\n\n最终的扩容代码如下: \n\n```cpp\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size < _capacity) return;    // 容量未到达不必扩容\n  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量\n  // 存储旧元素, 新数组容量扩大\n  T* old_elem = _elem; _elem = new T[_capacity <<= 1];\n  for (int i = 0; i < _size; i++) {\n    _elem[i] = old_elem[i];   // 复制原数组到新数组的对应位置\n  }\n  delete [] old_elem;    // 释放原数组的对应空间，归还系统\n}\n```\n\n另外尝试两种出现BUG的代码：\n```cpp\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size == _capacity) {   // 规模到达最大容量时\n    // 创建一个容量更大的数组\n    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个\n    Rank _tmp_size = _size;\n    _size = 0;\n    // 复制原数组到新数组的对应位置\n    copyFrom(this->_elem, 0, _tmp_size);\n    // 释放原数组的对应空间，归还系统\n    delete [] _elem;\n  }\n}\n*/\n\n/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size < _capacity) return;    // 容量未到达不必扩容\n  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量\n  // 存储旧元素, 新数组容量扩大\n  T* new_elem = new T[_capacity <<= 1];\n  for (int i = 0; i < _size; i++) {\n    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置\n  }\n  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则\n  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()\n  delete [] new_elem;    // 释放临时数组的对应空间，归还系统\n}\n*/\n```\n\n第二种错误代码分析：\n> * 备份一份旧的, 把当前的刷成新的。\n> * 创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。\n\n封装的好处\n> * `得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针`, 封装后，上述通过_elem统一的指示器标记起点.\n\n为何必须采用容量加倍\n> * 递增式扩容\n> * 加倍式扩容\n\n# 递增式扩容\n```cpp\n_elem = new[T = _capacity + INCREMENT];     // 追加固定大小量\n```\n每次扩容, 复制原向量的成本\nI, 2I, 3I, ... (m-1)I           // 算术级数\n\n<span style=\"color:red\">**算术级数**</span>:从某个数开始, 以固定间隔为\n单位, 不断的线性递增，总和成为算术级数。**总和和末项成平方关系**\n\n总耗时 = I * (m-1) * m/2 = O(n^2), 每次O(n)\n\n# 加倍式扩容\n1, 2, 4, 8, 16...2^m 次扩容           // 几何级数\n几何级数与末项等阶, O(n)\n\n总耗时O(n), 每次扩容分摊成本为O(1)\n\n空间上的牺牲, 在时间上获得巨大的收益。\n\n# 分摊复杂度 \n\n## 平均分析 vs 分摊分析\n`平均分析(average/ expected complexity)`\n独立事件, 割裂相关性\n往往不能准确反应。\n\n\n`分摊分析(amortized complexity)`\n连续的, 足够多的操作。\n实际可行，整体考量。\n更为真实反应。\n","source":"_posts/dsacpp/02-B.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-B\ndate: 2018-01-10 00:09:07\ntags: [数据结构, 复杂度]\n---\n\n# 可扩充向量\n\n## 静态管理空间\n\n_capacity固定, 存在不足:\n> 1, 上溢(overflow）, _elem[]不足以存放元素\n> 2, 下溢(underflow), _elem[]中元素寥寥无几\n装填因子(load factor) = _size/ _ capacity << 50% 空间利用率低\n\n# 动态管理空间\n\n蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。\n\n即将发生**上溢**，适当扩展容量\n\n## 扩容算法实现\n\n最终的扩容代码如下: \n\n```cpp\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size < _capacity) return;    // 容量未到达不必扩容\n  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量\n  // 存储旧元素, 新数组容量扩大\n  T* old_elem = _elem; _elem = new T[_capacity <<= 1];\n  for (int i = 0; i < _size; i++) {\n    _elem[i] = old_elem[i];   // 复制原数组到新数组的对应位置\n  }\n  delete [] old_elem;    // 释放原数组的对应空间，归还系统\n}\n```\n\n另外尝试两种出现BUG的代码：\n```cpp\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size == _capacity) {   // 规模到达最大容量时\n    // 创建一个容量更大的数组\n    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个\n    Rank _tmp_size = _size;\n    _size = 0;\n    // 复制原数组到新数组的对应位置\n    copyFrom(this->_elem, 0, _tmp_size);\n    // 释放原数组的对应空间，归还系统\n    delete [] _elem;\n  }\n}\n*/\n\n/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组\ntemplate <typename T>\nvoid Vector<T>::expand() {\n  if (_size < _capacity) return;    // 容量未到达不必扩容\n  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量\n  // 存储旧元素, 新数组容量扩大\n  T* new_elem = new T[_capacity <<= 1];\n  for (int i = 0; i < _size; i++) {\n    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置\n  }\n  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则\n  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()\n  delete [] new_elem;    // 释放临时数组的对应空间，归还系统\n}\n*/\n```\n\n第二种错误代码分析：\n> * 备份一份旧的, 把当前的刷成新的。\n> * 创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。\n\n封装的好处\n> * `得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针`, 封装后，上述通过_elem统一的指示器标记起点.\n\n为何必须采用容量加倍\n> * 递增式扩容\n> * 加倍式扩容\n\n# 递增式扩容\n```cpp\n_elem = new[T = _capacity + INCREMENT];     // 追加固定大小量\n```\n每次扩容, 复制原向量的成本\nI, 2I, 3I, ... (m-1)I           // 算术级数\n\n<span style=\"color:red\">**算术级数**</span>:从某个数开始, 以固定间隔为\n单位, 不断的线性递增，总和成为算术级数。**总和和末项成平方关系**\n\n总耗时 = I * (m-1) * m/2 = O(n^2), 每次O(n)\n\n# 加倍式扩容\n1, 2, 4, 8, 16...2^m 次扩容           // 几何级数\n几何级数与末项等阶, O(n)\n\n总耗时O(n), 每次扩容分摊成本为O(1)\n\n空间上的牺牲, 在时间上获得巨大的收益。\n\n# 分摊复杂度 \n\n## 平均分析 vs 分摊分析\n`平均分析(average/ expected complexity)`\n独立事件, 割裂相关性\n往往不能准确反应。\n\n\n`分摊分析(amortized complexity)`\n连续的, 足够多的操作。\n实际可行，整体考量。\n更为真实反应。\n","slug":"dsacpp/02-B","published":1,"updated":"2018-06-19T16:15:03.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykq0029k8mf45zdna9f","content":"<h1 id=\"可扩充向量\"><a href=\"#可扩充向量\" class=\"headerlink\" title=\"可扩充向量\"></a>可扩充向量</h1><h2 id=\"静态管理空间\"><a href=\"#静态管理空间\" class=\"headerlink\" title=\"静态管理空间\"></a>静态管理空间</h2><p>_capacity固定, 存在不足:</p>\n<blockquote>\n<p>1, 上溢(overflow）, _elem[]不足以存放元素<br>2, 下溢(underflow), _elem[]中元素寥寥无几<br>装填因子(load factor) = <em>size/ </em> capacity &lt;&lt; 50% 空间利用率低</p>\n</blockquote>\n<h1 id=\"动态管理空间\"><a href=\"#动态管理空间\" class=\"headerlink\" title=\"动态管理空间\"></a>动态管理空间</h1><p>蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。</p>\n<p>即将发生<strong>上溢</strong>，适当扩展容量</p>\n<h2 id=\"扩容算法实现\"><a href=\"#扩容算法实现\" class=\"headerlink\" title=\"扩容算法实现\"></a>扩容算法实现</h2><p>最终的扩容代码如下: </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::expand() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_size &lt; _capacity) <span class=\"keyword\">return</span>;    <span class=\"comment\">// 容量未到达不必扩容</span></span><br><span class=\"line\">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    <span class=\"comment\">// 不小于最小容量</span></span><br><span class=\"line\">  <span class=\"comment\">// 存储旧元素, 新数组容量扩大</span></span><br><span class=\"line\">  T* old_elem = _elem; _elem = <span class=\"keyword\">new</span> T[_capacity &lt;&lt;= <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) &#123;</span><br><span class=\"line\">    _elem[i] = old_elem[i];   <span class=\"comment\">// 复制原数组到新数组的对应位置</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> [] old_elem;    <span class=\"comment\">// 释放原数组的对应空间，归还系统</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外尝试两种出现BUG的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  if (_size == _capacity) &#123;   // 规模到达最大容量时</span></span><br><span class=\"line\"><span class=\"comment\">    // 创建一个容量更大的数组</span></span><br><span class=\"line\"><span class=\"comment\">    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个</span></span><br><span class=\"line\"><span class=\"comment\">    Rank _tmp_size = _size;</span></span><br><span class=\"line\"><span class=\"comment\">    _size = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    // 复制原数组到新数组的对应位置</span></span><br><span class=\"line\"><span class=\"comment\">    copyFrom(this-&gt;_elem, 0, _tmp_size);</span></span><br><span class=\"line\"><span class=\"comment\">    // 释放原数组的对应空间，归还系统</span></span><br><span class=\"line\"><span class=\"comment\">    delete [] _elem;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  if (_size &lt; _capacity) return;    // 容量未到达不必扩容</span></span><br><span class=\"line\"><span class=\"comment\">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量</span></span><br><span class=\"line\"><span class=\"comment\">  // 存储旧元素, 新数组容量扩大</span></span><br><span class=\"line\"><span class=\"comment\">  T* new_elem = new T[_capacity &lt;&lt;= 1];</span></span><br><span class=\"line\"><span class=\"comment\">  for (int i = 0; i &lt; _size; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则</span></span><br><span class=\"line\"><span class=\"comment\">  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()</span></span><br><span class=\"line\"><span class=\"comment\">  delete [] new_elem;    // 释放临时数组的对应空间，归还系统</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>第二种错误代码分析：</p>\n<blockquote>\n<ul>\n<li>备份一份旧的, 把当前的刷成新的。</li>\n<li>创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。</li>\n</ul>\n</blockquote>\n<p>封装的好处</p>\n<blockquote>\n<ul>\n<li><code>得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针</code>, 封装后，上述通过_elem统一的指示器标记起点.</li>\n</ul>\n</blockquote>\n<p>为何必须采用容量加倍</p>\n<blockquote>\n<ul>\n<li>递增式扩容</li>\n<li>加倍式扩容</li>\n</ul>\n</blockquote>\n<h1 id=\"递增式扩容\"><a href=\"#递增式扩容\" class=\"headerlink\" title=\"递增式扩容\"></a>递增式扩容</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">_elem = <span class=\"keyword\">new</span>[T = _capacity + INCREMENT];     <span class=\"comment\">// 追加固定大小量</span></span><br></pre></td></tr></table></figure>\n<p>每次扩容, 复制原向量的成本<br>I, 2I, 3I, … (m-1)I           // 算术级数</p>\n<p><span style=\"color:red\"><strong>算术级数</strong></span>:从某个数开始, 以固定间隔为<br>单位, 不断的线性递增，总和成为算术级数。<strong>总和和末项成平方关系</strong></p>\n<p>总耗时 = I <em> (m-1) </em> m/2 = O(n^2), 每次O(n)</p>\n<h1 id=\"加倍式扩容\"><a href=\"#加倍式扩容\" class=\"headerlink\" title=\"加倍式扩容\"></a>加倍式扩容</h1><p>1, 2, 4, 8, 16…2^m 次扩容           // 几何级数<br>几何级数与末项等阶, O(n)</p>\n<p>总耗时O(n), 每次扩容分摊成本为O(1)</p>\n<p>空间上的牺牲, 在时间上获得巨大的收益。</p>\n<h1 id=\"分摊复杂度\"><a href=\"#分摊复杂度\" class=\"headerlink\" title=\"分摊复杂度\"></a>分摊复杂度</h1><h2 id=\"平均分析-vs-分摊分析\"><a href=\"#平均分析-vs-分摊分析\" class=\"headerlink\" title=\"平均分析 vs 分摊分析\"></a>平均分析 vs 分摊分析</h2><p><code>平均分析(average/ expected complexity)</code><br>独立事件, 割裂相关性<br>往往不能准确反应。</p>\n<p><code>分摊分析(amortized complexity)</code><br>连续的, 足够多的操作。<br>实际可行，整体考量。<br>更为真实反应。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"可扩充向量\"><a href=\"#可扩充向量\" class=\"headerlink\" title=\"可扩充向量\"></a>可扩充向量</h1><h2 id=\"静态管理空间\"><a href=\"#静态管理空间\" class=\"headerlink\" title=\"静态管理空间\"></a>静态管理空间</h2><p>_capacity固定, 存在不足:</p>\n<blockquote>\n<p>1, 上溢(overflow）, _elem[]不足以存放元素<br>2, 下溢(underflow), _elem[]中元素寥寥无几<br>装填因子(load factor) = <em>size/ </em> capacity &lt;&lt; 50% 空间利用率低</p>\n</blockquote>\n<h1 id=\"动态管理空间\"><a href=\"#动态管理空间\" class=\"headerlink\" title=\"动态管理空间\"></a>动态管理空间</h1><p>蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。</p>\n<p>即将发生<strong>上溢</strong>，适当扩展容量</p>\n<h2 id=\"扩容算法实现\"><a href=\"#扩容算法实现\" class=\"headerlink\" title=\"扩容算法实现\"></a>扩容算法实现</h2><p>最终的扩容代码如下: </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::expand() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_size &lt; _capacity) <span class=\"keyword\">return</span>;    <span class=\"comment\">// 容量未到达不必扩容</span></span><br><span class=\"line\">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    <span class=\"comment\">// 不小于最小容量</span></span><br><span class=\"line\">  <span class=\"comment\">// 存储旧元素, 新数组容量扩大</span></span><br><span class=\"line\">  T* old_elem = _elem; _elem = <span class=\"keyword\">new</span> T[_capacity &lt;&lt;= <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; _size; i++) &#123;</span><br><span class=\"line\">    _elem[i] = old_elem[i];   <span class=\"comment\">// 复制原数组到新数组的对应位置</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> [] old_elem;    <span class=\"comment\">// 释放原数组的对应空间，归还系统</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外尝试两种出现BUG的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  if (_size == _capacity) &#123;   // 规模到达最大容量时</span></span><br><span class=\"line\"><span class=\"comment\">    // 创建一个容量更大的数组</span></span><br><span class=\"line\"><span class=\"comment\">    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个</span></span><br><span class=\"line\"><span class=\"comment\">    Rank _tmp_size = _size;</span></span><br><span class=\"line\"><span class=\"comment\">    _size = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    // 复制原数组到新数组的对应位置</span></span><br><span class=\"line\"><span class=\"comment\">    copyFrom(this-&gt;_elem, 0, _tmp_size);</span></span><br><span class=\"line\"><span class=\"comment\">    // 释放原数组的对应空间，归还系统</span></span><br><span class=\"line\"><span class=\"comment\">    delete [] _elem;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  if (_size &lt; _capacity) return;    // 容量未到达不必扩容</span></span><br><span class=\"line\"><span class=\"comment\">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量</span></span><br><span class=\"line\"><span class=\"comment\">  // 存储旧元素, 新数组容量扩大</span></span><br><span class=\"line\"><span class=\"comment\">  T* new_elem = new T[_capacity &lt;&lt;= 1];</span></span><br><span class=\"line\"><span class=\"comment\">  for (int i = 0; i &lt; _size; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则</span></span><br><span class=\"line\"><span class=\"comment\">  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()</span></span><br><span class=\"line\"><span class=\"comment\">  delete [] new_elem;    // 释放临时数组的对应空间，归还系统</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>第二种错误代码分析：</p>\n<blockquote>\n<ul>\n<li>备份一份旧的, 把当前的刷成新的。</li>\n<li>创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。</li>\n</ul>\n</blockquote>\n<p>封装的好处</p>\n<blockquote>\n<ul>\n<li><code>得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针</code>, 封装后，上述通过_elem统一的指示器标记起点.</li>\n</ul>\n</blockquote>\n<p>为何必须采用容量加倍</p>\n<blockquote>\n<ul>\n<li>递增式扩容</li>\n<li>加倍式扩容</li>\n</ul>\n</blockquote>\n<h1 id=\"递增式扩容\"><a href=\"#递增式扩容\" class=\"headerlink\" title=\"递增式扩容\"></a>递增式扩容</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">_elem = <span class=\"keyword\">new</span>[T = _capacity + INCREMENT];     <span class=\"comment\">// 追加固定大小量</span></span><br></pre></td></tr></table></figure>\n<p>每次扩容, 复制原向量的成本<br>I, 2I, 3I, … (m-1)I           // 算术级数</p>\n<p><span style=\"color:red\"><strong>算术级数</strong></span>:从某个数开始, 以固定间隔为<br>单位, 不断的线性递增，总和成为算术级数。<strong>总和和末项成平方关系</strong></p>\n<p>总耗时 = I <em> (m-1) </em> m/2 = O(n^2), 每次O(n)</p>\n<h1 id=\"加倍式扩容\"><a href=\"#加倍式扩容\" class=\"headerlink\" title=\"加倍式扩容\"></a>加倍式扩容</h1><p>1, 2, 4, 8, 16…2^m 次扩容           // 几何级数<br>几何级数与末项等阶, O(n)</p>\n<p>总耗时O(n), 每次扩容分摊成本为O(1)</p>\n<p>空间上的牺牲, 在时间上获得巨大的收益。</p>\n<h1 id=\"分摊复杂度\"><a href=\"#分摊复杂度\" class=\"headerlink\" title=\"分摊复杂度\"></a>分摊复杂度</h1><h2 id=\"平均分析-vs-分摊分析\"><a href=\"#平均分析-vs-分摊分析\" class=\"headerlink\" title=\"平均分析 vs 分摊分析\"></a>平均分析 vs 分摊分析</h2><p><code>平均分析(average/ expected complexity)</code><br>独立事件, 割裂相关性<br>往往不能准确反应。</p>\n<p><code>分摊分析(amortized complexity)</code><br>连续的, 足够多的操作。<br>实际可行，整体考量。<br>更为真实反应。</p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-C","date":"2018-01-09T16:09:15.000Z","_content":"\n# 无序向量\n```cpp\ntemplate <typename T> class Vector {};    // template定义方式\n```\n\n模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合\n\n```cpp\ntemplate <typename T> class Vector {\n};\nclass BinTree {\n};\ntemplate <typename T> class Tree {\n};\n\nint main() {\n  // ..\n  Vector<int> myVector;    // Right\n\n  Vector<float> myfVector;\n\n  Vector<BinTree> binForest;       // Combine with other class;\n  Vector<Tree<int>> binForest;     // Combine with template;\n  return 0;\n}\n```\n\n无序向量: 没有顺序, 甚至不可能排成顺序。\n\t\n## 元素访问(寻秩访问)\n\nv.get(r), v.put(e)\n\nA[r]\n\n重载下标运算符\"[]\"\n```cpp\n// 寻秩访问\n/* // my test\ntemplate <typename T>\nT& Vector<T>::operator[](std::size_t n) {    // 这个类 Vector<T>\n  assert(n < _size);\n  return _elem[n];\n}\n*/\n\ntemplate <typename T>\nT& Vector<T>::operator[](Rank r) const {   // 不改变数据成员, 定义成常量成员函数\n  // 在vector内部, 定义了秩的类型, 统一用Rank\n  assert(r < _size);   // 对下标秩进行溢出检测\n  return _elem[r];\n}\n```\n\n左值, 右值, `引用??`\n引用类型可作为左值。\n\n寻秩访问\n\n代码健壮性简化\n - assert 断言, \n```cpp\n#include <cassert>\nassert(r < _size);\n```\n\n## 插入\n\n```cpp\n// 插入\n/* my test\ntemplate <typename T>\nvoid Vector<T>::insert(const Rank r, const int value) {\n  // 检查移动后是否需要扩容\n  if (++_size > _capacity) expand();\n  // 将秩为r后的所有元素后移一位\n  for (Rank i = _size-2; i >= r; i--) {     // 为了不覆盖数据, 从尾部开始移动\n    _elem[i+1] = _elem[i];     // 向后移动一位\n  }\n  // 在r秩位置上填入要插入的值\n  _elem[r] = value;\n}\n*/\ntemplate <typename T>\nvoid Vector<T>::insert(const Rank r, T const &e) {\n  // value不应该是某一中特点的类型, 而应该利用template的特性\n  assert(0<= r && r < _size);\n  expand();  // 若有必要扩容  结合expand()中, _size < _capacity的定义\n  for (int i = _size; i > r; i--)  // 习惯把改变后的值的索引设置成i\n    _elem[i] = _elem[i-1];     // 后继元素顺次后移一个单元\n  _elem[r] = e; _size++;\n}\n```\n\nTemplate中泛型T的作用, \n模板类中函数的互相搭配,\n插入元素对vector操作的顺序 \n对\\_capacity和_size的影响。\n## 删除算法\n\n自前向后的迁移操作\n缩容\n\n```cpp\n// 删除操作\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::del(const Rank lo, const Rank hi) {\n  for (Rank i = lo; i < _size; i++) {\n    // 清空区间元素\n    if (i < hi) { _elem[i] = 0;\n    } else {\n      // 将元素整体前移\n      _elem[i - (hi-lo)] = _elem[i];\n      // 前移后元素清空\n       _elem[i] = 0;\n    }\n  }\n  // 缩短规模和空间容量\n  _size -= hi-lo; _capacity -= hi-lo;\n}\n*/\n\n\ntemplate <typename T>\nint Vector<T>::del(Rank lo, Rank hi) {\n  // 处理退化情况\n  if (lo == hi) return 0;\n  const int length = hi - lo;\n  // 自前向后的迁移操作\n  while (lo < _size) {\n    if (hi < _capacity) {_elem[lo++] = _elem[hi++];\n    } else {_elem[lo++] = 0;}   // 处理hi++超出_capacityg容量的情况\n  }\n  // 更新规模或者缩容\n  _size -= length;\n  shrunk();\n  // 返回被删除元素的数目\n  return hi-lo;\n}\n```\n\n\n`1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?` 改进成改变size的版本用于shrunk\n`2 , _elem[hi++]能够被一直索引到?` 超过_capacity时, 返回未定义的值\n`3, _elem[hi++]为什么不清空? `把_capacity的剩余空间对应元素赋值给它的方法清空\n`4, 看出移动操作过程中, 变量的同步性`\n`5, 缩容不光光是改变_capacity的值, 仍旧要释放空间`\n\t\n## 查找\n\n无序向量： T为可判等, 重载 \"==\"或者\"!=\"\n有序向量： T为可比较，重载 \"<\" 或  \">\"\n\n```cpp\n// 查找\n/* my test code\ntemplate <typename T>\nint Vector<T>::find(Rank lo, Rank hi, T const &e) const {\n  // 查找e在区间[lo,hi)内\n  // 从右往左查找\n  while (hi >= lo) {\n    if (_elem[hi] == e) {return hi;\n    }\n    hi--;\n  }\n  // 没有在while循环中返回, 不存在匹配元素\n  return -1;\n}\n*/\n\ntemplate <typename T>\nRank Vector<T>::find(Rank lo, Rank hi, T const &e) const {\n  // O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者\n  while (lo < hi-- && e != _elem[hi]) {}   // 逆向查找\n  return hi;   // hi < lo失败; 否则hi即命中元素的秩\n}\n```\n\n`利用while本身的条件语句；后置递增的特性`\n`返回hi?` 将判断是否成功, 交给`上层的调用者`;以及成功后被`上层算法`进一步利用\n\n最好情况 O(1), 最坏情况O(n)\n输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。\n## 删除单元素\n\n`视为区间操作的特例`\n```cpp\n// 删除单个元素\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::remove(Rank r) {\n  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)\n  remove(r, r+1);\n}\n*/\ntemplate <typename T>     // 删除向量中秩为r的元素, 0 <= r < size\nT& Vector<T>::remove(Rank r) {  // O(n-r)\n  T& old_t = _elem[r];    // 备份被删除的元素\n  remove(r, r+1);         // 调用区间删除算法\n  return old_t;           // 返回被删除元素\n}\n```\n\n\n`颠倒考虑`\n\n复杂度分析:\n每次循环的耗时正比于删除区间的后缀长度 O(n-hi)\n循环的次数等于区间宽度 O(hi-lo)\n总体 O(n^2) 复杂度\n\nright, but not fast!!\n\n\n## 唯一化\n\n\n`实现`\n\n```cpp\n// 唯一化\n/*\ntemplate <typename T>\nvoid Vector<T>::deduplicate(Rank lo, Rank hi) {\n  // 对向量中的元素遍历,\n  for (Rank i = lo; i < hi; i++) {\n    // find右往左查, 返回lo-1代表失败\n    // 删除当前元素, 不再对后续元素查找\n    if (find(lo, i, _elem[i]) != lo-1) {remove(i); break;}\n    if (find(i+1, hi, _elem[i]) != i) { remove(i);}\n  }\n}\n*/\n\ntemplate <typename T>\nint Vector<T>::deduplicate() {\n  int old_size = _size;\n  Rank i = 1;\n  while (i < _size) {\n    find(0, i, _elem[i]) < 0 ?\n                             i++  // 小于0说明无雷同, 继续查找\n                             : remove(i);    // 删除雷同者(至多一个?!)\n  }\n  return  old_size - _size;      // 返回规模的变化量\n}\n```\n\n`记录规模?` 考虑返回值怎么设计，这里我估计会在更高级的接口中用到\n`从1开始?` 因为要在当前i的前缀中查找\n`至多一个?` 删除至多一个, 实际不一定至多一个\n`为什么不需要改变_size和_capacity大小?` 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。\n\n`**正确性证明**`：\n**不变性**: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异\n初始时, i = 1, 两个元素成立,...\n\n**单调性**:\n1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合\n2)后缀单调下降, _size迟早减至0;     // 2)更容易把握\n\n故算法必然终止, 至多迭代O(n)轮\n\n`复杂度`\n\n主要来自find() 和 remove();\nfind()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);\nwhile循环会进行n次, \n总体复杂度为 O(n^2)\n\n\n`练习三种优化方案（未完成）`\n\n1, 仿照uniquify()高效版本的思路.\n元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性\n2, 先对需要删除的重复元素标记, 然后统一删除.\n稳定性保持, 但因查找长度更长, 从而导致更多的对比操作\n3, V.sort().uniquify(): 简明实现最优的O(nlogn)\n\n## 遍历\n\nvisit\n\n[关于函数指针和函数对象的笔记](https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/)\n函数指针机制 ?? \n\n函数对象机制 ??\n\n两种方法优劣\n\n实例: 将向量中所有的元素统一加一\n重载操作符 \"++\"\n重载操作符 \"()\"\n\n练习更为复杂的遍历\n\n### 减1\n\n```cpp\n// 遍历运用函数对象机制，对各个元素减1\n/* my test code\n// 单个T类型元素减1的类\ntemplate <typename T>\nVector<T>::struct Decrease {\n  virtual void operator() {T &e--;}     // 重载()操作, 类对象当作函数来用\n};\n\ntemplate <typename T>\nvoid decrease(Vector<T>& V) {\n  V.traverse(Decrease<T>());\n}\n// 泛型模板在调用的时候都要带<type>\n*/\n\ntemplate <typename T>\nstruct Decrease {\n  virtual void operator()(T &e) {e--;}\n};\n```\n\n\n```cpp\ntemplate <typename T>\nvoid decrease(Vector<T> & V) {\n  V.traverse(Decrease<T>());\n}\n```\n\n\n#### 为什么不是Vector<T>::struct Decrease?\n// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。\n#### 为什么需要virtual\n#### void operator()(T &e)?\n// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表\n\n#### 三个函数之间的关系?\nDecrease<T>(T&)函数对象, Vector<T>::traverse(VST&)遍历函数, decrease(Vector<T>)\n\n// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<T>& 类型\n// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素\n\n\n#### 为什么需要函数对象?\n\n\n#### 本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?\n\n将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。\n\n### 加倍 \nDouble(T &e)\n\n\n```cpp\ntemplate <typename T>\nstruct Double_value {\n  virtual void operator()(T& e) {e *= 2;}   // 函数对象对元素翻倍\n};\n\ntemplate <typename T>\nvoid double_value(Vector<T>& V) {\n  V.traverse(Double_value<T>());      // 函数对象作为遍历函数的参数\n}\n```\n### 求和\n\n#### 函数中传入指针\nSum(T& e, T* sumPtr)\n\n```\n// 用于traverse的求和函数对象\ntemplate <typename T>\nstruct Sum {\n  virtual void operator()(const T& e, T* sumPtr) {(*sumPtr) += e;}\n};\n\n\ntemplate <typename T> template <typename VST>\nT& Vector<T>::traverse(VST visit, T* e) {\n  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针\n  for (int i = 1; i < _size; i++) visit(_elem[i], e);   // 从第二个值开始累加\n  return *e;       // 返回求和结果\n}\n```\n**Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。**\n\n前面都没什么问题,\n实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。\n```cpp\ntemplate <typename T>\nvoid sum_ptr(Vector<T>& V) {\n  T* sumPtr = &(V[0]);        // 别定义空指针, 该指针指向向量首位\n  T sum = V.traverse(Sum<T>(), sumPtr);     // 调用并赋值\n  std::cout << \"sum = \" << sum << std::endl;\n}\n```\n\n但print_vector()之后\n```sh\n-- --------print_vector--------- --\n_size = 3\n_capacity = 10\n0:52                 ==> _elem的首位被修改, 原本应该是10\n1:24\n2:18\n3:0\n4:0\n5:0\n6:0\n7:0\n8:0\n9:0\n```\n\n因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!\n\n于是我便做了如下修改:\n```cpp\ntemplate <typename T>\nvoid sum_ptr(Vector<T>& V) {\n  T sum_init = V[0];              // 创建一个副本, 避免通过指针修改V[0]\n  T* sumPtr = &(sum_init);        // 别定义空指针, 该指针指向副本\n  T sum = V.traverse(Sum<T>(), sumPtr);     // 调用并赋值\n  std::cout << \"sum = \" << sum << std::endl;\n}\n```\n\n```sh\n-- --------print_vector--------- --\n_size = 3\n_capacity = 10\n0:10\n1:24\n2:18\n3:0\n4:0\n5:0\n6:0\n7:0\n8:0\n9:0\n```\n\n\n\n##### 重载函数什么时候用virtual?\n\n#### 类内static存放\nstatic sumStc\n静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。\n```cpp\n// 通过类内static求和的函数对象\ntemplate <typename T>\nstruct Sum_static {\n  static T sum_t;     // 内部声明存放求和结果的static变量\n  virtual void operator()(T& e) {\n    sum_t += e; std::cout << \"revise static sum_t, sum_t = \"\n                          << sum_t << std::endl;    // 当心全局变量出错\n  }\n};\n\ntemplate <typename T>\nT Sum_static<T>::sum_t = 0;   // 外部定义静态数据成员\n\ntemplate <typename T>\nvoid sum_static(Vector<T> V) {\n  Sum_static<T> sumstc;           // 实例化模板别忘记<type>\n  V.traverse(Sum_static<T>());\n  T sum = sumstc.sum_t;\n  std::cout << \"in sum_static, sum = \" << sum << std::endl;\n}\n```\n\n关于static, 我的相关练习[source code](https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp)\n","source":"_posts/dsacpp/02-C.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-C\ndate: 2018-01-10 00:09:15\ntags: [数据结构, 向量]\n---\n\n# 无序向量\n```cpp\ntemplate <typename T> class Vector {};    // template定义方式\n```\n\n模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合\n\n```cpp\ntemplate <typename T> class Vector {\n};\nclass BinTree {\n};\ntemplate <typename T> class Tree {\n};\n\nint main() {\n  // ..\n  Vector<int> myVector;    // Right\n\n  Vector<float> myfVector;\n\n  Vector<BinTree> binForest;       // Combine with other class;\n  Vector<Tree<int>> binForest;     // Combine with template;\n  return 0;\n}\n```\n\n无序向量: 没有顺序, 甚至不可能排成顺序。\n\t\n## 元素访问(寻秩访问)\n\nv.get(r), v.put(e)\n\nA[r]\n\n重载下标运算符\"[]\"\n```cpp\n// 寻秩访问\n/* // my test\ntemplate <typename T>\nT& Vector<T>::operator[](std::size_t n) {    // 这个类 Vector<T>\n  assert(n < _size);\n  return _elem[n];\n}\n*/\n\ntemplate <typename T>\nT& Vector<T>::operator[](Rank r) const {   // 不改变数据成员, 定义成常量成员函数\n  // 在vector内部, 定义了秩的类型, 统一用Rank\n  assert(r < _size);   // 对下标秩进行溢出检测\n  return _elem[r];\n}\n```\n\n左值, 右值, `引用??`\n引用类型可作为左值。\n\n寻秩访问\n\n代码健壮性简化\n - assert 断言, \n```cpp\n#include <cassert>\nassert(r < _size);\n```\n\n## 插入\n\n```cpp\n// 插入\n/* my test\ntemplate <typename T>\nvoid Vector<T>::insert(const Rank r, const int value) {\n  // 检查移动后是否需要扩容\n  if (++_size > _capacity) expand();\n  // 将秩为r后的所有元素后移一位\n  for (Rank i = _size-2; i >= r; i--) {     // 为了不覆盖数据, 从尾部开始移动\n    _elem[i+1] = _elem[i];     // 向后移动一位\n  }\n  // 在r秩位置上填入要插入的值\n  _elem[r] = value;\n}\n*/\ntemplate <typename T>\nvoid Vector<T>::insert(const Rank r, T const &e) {\n  // value不应该是某一中特点的类型, 而应该利用template的特性\n  assert(0<= r && r < _size);\n  expand();  // 若有必要扩容  结合expand()中, _size < _capacity的定义\n  for (int i = _size; i > r; i--)  // 习惯把改变后的值的索引设置成i\n    _elem[i] = _elem[i-1];     // 后继元素顺次后移一个单元\n  _elem[r] = e; _size++;\n}\n```\n\nTemplate中泛型T的作用, \n模板类中函数的互相搭配,\n插入元素对vector操作的顺序 \n对\\_capacity和_size的影响。\n## 删除算法\n\n自前向后的迁移操作\n缩容\n\n```cpp\n// 删除操作\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::del(const Rank lo, const Rank hi) {\n  for (Rank i = lo; i < _size; i++) {\n    // 清空区间元素\n    if (i < hi) { _elem[i] = 0;\n    } else {\n      // 将元素整体前移\n      _elem[i - (hi-lo)] = _elem[i];\n      // 前移后元素清空\n       _elem[i] = 0;\n    }\n  }\n  // 缩短规模和空间容量\n  _size -= hi-lo; _capacity -= hi-lo;\n}\n*/\n\n\ntemplate <typename T>\nint Vector<T>::del(Rank lo, Rank hi) {\n  // 处理退化情况\n  if (lo == hi) return 0;\n  const int length = hi - lo;\n  // 自前向后的迁移操作\n  while (lo < _size) {\n    if (hi < _capacity) {_elem[lo++] = _elem[hi++];\n    } else {_elem[lo++] = 0;}   // 处理hi++超出_capacityg容量的情况\n  }\n  // 更新规模或者缩容\n  _size -= length;\n  shrunk();\n  // 返回被删除元素的数目\n  return hi-lo;\n}\n```\n\n\n`1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?` 改进成改变size的版本用于shrunk\n`2 , _elem[hi++]能够被一直索引到?` 超过_capacity时, 返回未定义的值\n`3, _elem[hi++]为什么不清空? `把_capacity的剩余空间对应元素赋值给它的方法清空\n`4, 看出移动操作过程中, 变量的同步性`\n`5, 缩容不光光是改变_capacity的值, 仍旧要释放空间`\n\t\n## 查找\n\n无序向量： T为可判等, 重载 \"==\"或者\"!=\"\n有序向量： T为可比较，重载 \"<\" 或  \">\"\n\n```cpp\n// 查找\n/* my test code\ntemplate <typename T>\nint Vector<T>::find(Rank lo, Rank hi, T const &e) const {\n  // 查找e在区间[lo,hi)内\n  // 从右往左查找\n  while (hi >= lo) {\n    if (_elem[hi] == e) {return hi;\n    }\n    hi--;\n  }\n  // 没有在while循环中返回, 不存在匹配元素\n  return -1;\n}\n*/\n\ntemplate <typename T>\nRank Vector<T>::find(Rank lo, Rank hi, T const &e) const {\n  // O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者\n  while (lo < hi-- && e != _elem[hi]) {}   // 逆向查找\n  return hi;   // hi < lo失败; 否则hi即命中元素的秩\n}\n```\n\n`利用while本身的条件语句；后置递增的特性`\n`返回hi?` 将判断是否成功, 交给`上层的调用者`;以及成功后被`上层算法`进一步利用\n\n最好情况 O(1), 最坏情况O(n)\n输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。\n## 删除单元素\n\n`视为区间操作的特例`\n```cpp\n// 删除单个元素\n/* my test code\ntemplate <typename T>\nvoid Vector<T>::remove(Rank r) {\n  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)\n  remove(r, r+1);\n}\n*/\ntemplate <typename T>     // 删除向量中秩为r的元素, 0 <= r < size\nT& Vector<T>::remove(Rank r) {  // O(n-r)\n  T& old_t = _elem[r];    // 备份被删除的元素\n  remove(r, r+1);         // 调用区间删除算法\n  return old_t;           // 返回被删除元素\n}\n```\n\n\n`颠倒考虑`\n\n复杂度分析:\n每次循环的耗时正比于删除区间的后缀长度 O(n-hi)\n循环的次数等于区间宽度 O(hi-lo)\n总体 O(n^2) 复杂度\n\nright, but not fast!!\n\n\n## 唯一化\n\n\n`实现`\n\n```cpp\n// 唯一化\n/*\ntemplate <typename T>\nvoid Vector<T>::deduplicate(Rank lo, Rank hi) {\n  // 对向量中的元素遍历,\n  for (Rank i = lo; i < hi; i++) {\n    // find右往左查, 返回lo-1代表失败\n    // 删除当前元素, 不再对后续元素查找\n    if (find(lo, i, _elem[i]) != lo-1) {remove(i); break;}\n    if (find(i+1, hi, _elem[i]) != i) { remove(i);}\n  }\n}\n*/\n\ntemplate <typename T>\nint Vector<T>::deduplicate() {\n  int old_size = _size;\n  Rank i = 1;\n  while (i < _size) {\n    find(0, i, _elem[i]) < 0 ?\n                             i++  // 小于0说明无雷同, 继续查找\n                             : remove(i);    // 删除雷同者(至多一个?!)\n  }\n  return  old_size - _size;      // 返回规模的变化量\n}\n```\n\n`记录规模?` 考虑返回值怎么设计，这里我估计会在更高级的接口中用到\n`从1开始?` 因为要在当前i的前缀中查找\n`至多一个?` 删除至多一个, 实际不一定至多一个\n`为什么不需要改变_size和_capacity大小?` 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。\n\n`**正确性证明**`：\n**不变性**: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异\n初始时, i = 1, 两个元素成立,...\n\n**单调性**:\n1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合\n2)后缀单调下降, _size迟早减至0;     // 2)更容易把握\n\n故算法必然终止, 至多迭代O(n)轮\n\n`复杂度`\n\n主要来自find() 和 remove();\nfind()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);\nwhile循环会进行n次, \n总体复杂度为 O(n^2)\n\n\n`练习三种优化方案（未完成）`\n\n1, 仿照uniquify()高效版本的思路.\n元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性\n2, 先对需要删除的重复元素标记, 然后统一删除.\n稳定性保持, 但因查找长度更长, 从而导致更多的对比操作\n3, V.sort().uniquify(): 简明实现最优的O(nlogn)\n\n## 遍历\n\nvisit\n\n[关于函数指针和函数对象的笔记](https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/)\n函数指针机制 ?? \n\n函数对象机制 ??\n\n两种方法优劣\n\n实例: 将向量中所有的元素统一加一\n重载操作符 \"++\"\n重载操作符 \"()\"\n\n练习更为复杂的遍历\n\n### 减1\n\n```cpp\n// 遍历运用函数对象机制，对各个元素减1\n/* my test code\n// 单个T类型元素减1的类\ntemplate <typename T>\nVector<T>::struct Decrease {\n  virtual void operator() {T &e--;}     // 重载()操作, 类对象当作函数来用\n};\n\ntemplate <typename T>\nvoid decrease(Vector<T>& V) {\n  V.traverse(Decrease<T>());\n}\n// 泛型模板在调用的时候都要带<type>\n*/\n\ntemplate <typename T>\nstruct Decrease {\n  virtual void operator()(T &e) {e--;}\n};\n```\n\n\n```cpp\ntemplate <typename T>\nvoid decrease(Vector<T> & V) {\n  V.traverse(Decrease<T>());\n}\n```\n\n\n#### 为什么不是Vector<T>::struct Decrease?\n// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。\n#### 为什么需要virtual\n#### void operator()(T &e)?\n// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表\n\n#### 三个函数之间的关系?\nDecrease<T>(T&)函数对象, Vector<T>::traverse(VST&)遍历函数, decrease(Vector<T>)\n\n// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<T>& 类型\n// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素\n\n\n#### 为什么需要函数对象?\n\n\n#### 本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?\n\n将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。\n\n### 加倍 \nDouble(T &e)\n\n\n```cpp\ntemplate <typename T>\nstruct Double_value {\n  virtual void operator()(T& e) {e *= 2;}   // 函数对象对元素翻倍\n};\n\ntemplate <typename T>\nvoid double_value(Vector<T>& V) {\n  V.traverse(Double_value<T>());      // 函数对象作为遍历函数的参数\n}\n```\n### 求和\n\n#### 函数中传入指针\nSum(T& e, T* sumPtr)\n\n```\n// 用于traverse的求和函数对象\ntemplate <typename T>\nstruct Sum {\n  virtual void operator()(const T& e, T* sumPtr) {(*sumPtr) += e;}\n};\n\n\ntemplate <typename T> template <typename VST>\nT& Vector<T>::traverse(VST visit, T* e) {\n  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针\n  for (int i = 1; i < _size; i++) visit(_elem[i], e);   // 从第二个值开始累加\n  return *e;       // 返回求和结果\n}\n```\n**Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。**\n\n前面都没什么问题,\n实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。\n```cpp\ntemplate <typename T>\nvoid sum_ptr(Vector<T>& V) {\n  T* sumPtr = &(V[0]);        // 别定义空指针, 该指针指向向量首位\n  T sum = V.traverse(Sum<T>(), sumPtr);     // 调用并赋值\n  std::cout << \"sum = \" << sum << std::endl;\n}\n```\n\n但print_vector()之后\n```sh\n-- --------print_vector--------- --\n_size = 3\n_capacity = 10\n0:52                 ==> _elem的首位被修改, 原本应该是10\n1:24\n2:18\n3:0\n4:0\n5:0\n6:0\n7:0\n8:0\n9:0\n```\n\n因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!\n\n于是我便做了如下修改:\n```cpp\ntemplate <typename T>\nvoid sum_ptr(Vector<T>& V) {\n  T sum_init = V[0];              // 创建一个副本, 避免通过指针修改V[0]\n  T* sumPtr = &(sum_init);        // 别定义空指针, 该指针指向副本\n  T sum = V.traverse(Sum<T>(), sumPtr);     // 调用并赋值\n  std::cout << \"sum = \" << sum << std::endl;\n}\n```\n\n```sh\n-- --------print_vector--------- --\n_size = 3\n_capacity = 10\n0:10\n1:24\n2:18\n3:0\n4:0\n5:0\n6:0\n7:0\n8:0\n9:0\n```\n\n\n\n##### 重载函数什么时候用virtual?\n\n#### 类内static存放\nstatic sumStc\n静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。\n```cpp\n// 通过类内static求和的函数对象\ntemplate <typename T>\nstruct Sum_static {\n  static T sum_t;     // 内部声明存放求和结果的static变量\n  virtual void operator()(T& e) {\n    sum_t += e; std::cout << \"revise static sum_t, sum_t = \"\n                          << sum_t << std::endl;    // 当心全局变量出错\n  }\n};\n\ntemplate <typename T>\nT Sum_static<T>::sum_t = 0;   // 外部定义静态数据成员\n\ntemplate <typename T>\nvoid sum_static(Vector<T> V) {\n  Sum_static<T> sumstc;           // 实例化模板别忘记<type>\n  V.traverse(Sum_static<T>());\n  T sum = sumstc.sum_t;\n  std::cout << \"in sum_static, sum = \" << sum << std::endl;\n}\n```\n\n关于static, 我的相关练习[source code](https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp)\n","slug":"dsacpp/02-C","published":1,"updated":"2018-06-19T16:15:03.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyks002ak8mf8pm2ddif","content":"<h1 id=\"无序向量\"><a href=\"#无序向量\" class=\"headerlink\" title=\"无序向量\"></a>无序向量</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>&#125;;    <span class=\"comment\">// template定义方式</span></span><br></pre></td></tr></table></figure>\n<p>模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinTree</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ..</span></span><br><span class=\"line\">  Vector&lt;<span class=\"keyword\">int</span>&gt; myVector;    <span class=\"comment\">// Right</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Vector&lt;<span class=\"keyword\">float</span>&gt; myfVector;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector&lt;BinTree&gt; binForest;       <span class=\"comment\">// Combine with other class;</span></span><br><span class=\"line\">  Vector&lt;Tree&lt;<span class=\"keyword\">int</span>&gt;&gt; binForest;     <span class=\"comment\">// Combine with template;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无序向量: 没有顺序, 甚至不可能排成顺序。</p>\n<h2 id=\"元素访问-寻秩访问\"><a href=\"#元素访问-寻秩访问\" class=\"headerlink\" title=\"元素访问(寻秩访问)\"></a>元素访问(寻秩访问)</h2><p>v.get(r), v.put(e)</p>\n<p>A[r]</p>\n<p>重载下标运算符”[]”<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寻秩访问</span></span><br><span class=\"line\"><span class=\"comment\">/* // my test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">T&amp; Vector&lt;T&gt;::operator[](std::size_t n) &#123;    // 这个类 Vector&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  assert(n &lt; _size);</span></span><br><span class=\"line\"><span class=\"comment\">  return _elem[n];</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>[](Rank r) <span class=\"keyword\">const</span> &#123;   <span class=\"comment\">// 不改变数据成员, 定义成常量成员函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 在vector内部, 定义了秩的类型, 统一用Rank</span></span><br><span class=\"line\">  assert(r &lt; _size);   <span class=\"comment\">// 对下标秩进行溢出检测</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _elem[r];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>左值, 右值, <code>引用??</code><br>引用类型可作为左值。</p>\n<p>寻秩访问</p>\n<p>代码健壮性简化</p>\n<ul>\n<li>assert 断言, <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\">assert(r &lt; _size);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"comment\">/* my test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::insert(const Rank r, const int value) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 检查移动后是否需要扩容</span></span><br><span class=\"line\"><span class=\"comment\">  if (++_size &gt; _capacity) expand();</span></span><br><span class=\"line\"><span class=\"comment\">  // 将秩为r后的所有元素后移一位</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = _size-2; i &gt;= r; i--) &#123;     // 为了不覆盖数据, 从尾部开始移动</span></span><br><span class=\"line\"><span class=\"comment\">    _elem[i+1] = _elem[i];     // 向后移动一位</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 在r秩位置上填入要插入的值</span></span><br><span class=\"line\"><span class=\"comment\">  _elem[r] = value;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::insert(<span class=\"keyword\">const</span> Rank r, T <span class=\"keyword\">const</span> &amp;e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// value不应该是某一中特点的类型, 而应该利用template的特性</span></span><br><span class=\"line\">  assert(<span class=\"number\">0</span>&lt;= r &amp;&amp; r &lt; _size);</span><br><span class=\"line\">  expand();  <span class=\"comment\">// 若有必要扩容  结合expand()中, _size &lt; _capacity的定义</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = _size; i &gt; r; i--)  <span class=\"comment\">// 习惯把改变后的值的索引设置成i</span></span><br><span class=\"line\">    _elem[i] = _elem[i<span class=\"number\">-1</span>];     <span class=\"comment\">// 后继元素顺次后移一个单元</span></span><br><span class=\"line\">  _elem[r] = e; _size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Template中泛型T的作用,<br>模板类中函数的互相搭配,<br>插入元素对vector操作的顺序<br>对_capacity和_size的影响。</p>\n<h2 id=\"删除算法\"><a href=\"#删除算法\" class=\"headerlink\" title=\"删除算法\"></a>删除算法</h2><p>自前向后的迁移操作<br>缩容</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除操作</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::del(const Rank lo, const Rank hi) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = lo; i &lt; _size; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // 清空区间元素</span></span><br><span class=\"line\"><span class=\"comment\">    if (i &lt; hi) &#123; _elem[i] = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      // 将元素整体前移</span></span><br><span class=\"line\"><span class=\"comment\">      _elem[i - (hi-lo)] = _elem[i];</span></span><br><span class=\"line\"><span class=\"comment\">      // 前移后元素清空</span></span><br><span class=\"line\"><span class=\"comment\">       _elem[i] = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 缩短规模和空间容量</span></span><br><span class=\"line\"><span class=\"comment\">  _size -= hi-lo; _capacity -= hi-lo;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Vector&lt;T&gt;::del(Rank lo, Rank hi) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理退化情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo == hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = hi - lo;</span><br><span class=\"line\">  <span class=\"comment\">// 自前向后的迁移操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; _size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hi &lt; _capacity) &#123;_elem[lo++] = _elem[hi++];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;_elem[lo++] = <span class=\"number\">0</span>;&#125;   <span class=\"comment\">// 处理hi++超出_capacityg容量的情况</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 更新规模或者缩容</span></span><br><span class=\"line\">  _size -= length;</span><br><span class=\"line\">  shrunk();</span><br><span class=\"line\">  <span class=\"comment\">// 返回被删除元素的数目</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hi-lo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?</code> 改进成改变size的版本用于shrunk<br><code>2 , _elem[hi++]能够被一直索引到?</code> 超过_capacity时, 返回未定义的值<br><code>3, _elem[hi++]为什么不清空?</code>把_capacity的剩余空间对应元素赋值给它的方法清空<br><code>4, 看出移动操作过程中, 变量的同步性</code><br><code>5, 缩容不光光是改变_capacity的值, 仍旧要释放空间</code></p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><p>无序向量： T为可判等, 重载 “==”或者”!=”<br>有序向量： T为可比较，重载 “&lt;” 或  “&gt;”</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">int Vector&lt;T&gt;::find(Rank lo, Rank hi, T const &amp;e) const &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 查找e在区间[lo,hi)内</span></span><br><span class=\"line\"><span class=\"comment\">  // 从右往左查找</span></span><br><span class=\"line\"><span class=\"comment\">  while (hi &gt;= lo) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (_elem[hi] == e) &#123;return hi;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    hi--;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 没有在while循环中返回, 不存在匹配元素</span></span><br><span class=\"line\"><span class=\"comment\">  return -1;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Rank Vector&lt;T&gt;::find(Rank lo, Rank hi, T <span class=\"keyword\">const</span> &amp;e) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi-- &amp;&amp; e != _elem[hi]) &#123;&#125;   <span class=\"comment\">// 逆向查找</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hi;   <span class=\"comment\">// hi &lt; lo失败; 否则hi即命中元素的秩</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>利用while本身的条件语句；后置递增的特性</code><br><code>返回hi?</code> 将判断是否成功, 交给<code>上层的调用者</code>;以及成功后被<code>上层算法</code>进一步利用</p>\n<p>最好情况 O(1), 最坏情况O(n)<br>输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。</p>\n<h2 id=\"删除单元素\"><a href=\"#删除单元素\" class=\"headerlink\" title=\"删除单元素\"></a>删除单元素</h2><p><code>视为区间操作的特例</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除单个元素</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::remove(Rank r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)</span></span><br><span class=\"line\"><span class=\"comment\">  remove(r, r+1);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;     <span class=\"comment\">// 删除向量中秩为r的元素, 0 &lt;= r &lt; size</span></span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::remove(Rank r) &#123;  <span class=\"comment\">// O(n-r)</span></span><br><span class=\"line\">  T&amp; <span class=\"keyword\">old_t</span> = _elem[r];    <span class=\"comment\">// 备份被删除的元素</span></span><br><span class=\"line\">  remove(r, r+<span class=\"number\">1</span>);         <span class=\"comment\">// 调用区间删除算法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">old_t</span>;           <span class=\"comment\">// 返回被删除元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>颠倒考虑</code></p>\n<p>复杂度分析:<br>每次循环的耗时正比于删除区间的后缀长度 O(n-hi)<br>循环的次数等于区间宽度 O(hi-lo)<br>总体 O(n^2) 复杂度</p>\n<p>right, but not fast!!</p>\n<h2 id=\"唯一化\"><a href=\"#唯一化\" class=\"headerlink\" title=\"唯一化\"></a>唯一化</h2><p><code>实现</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 唯一化</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::deduplicate(Rank lo, Rank hi) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 对向量中的元素遍历,</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = lo; i &lt; hi; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // find右往左查, 返回lo-1代表失败</span></span><br><span class=\"line\"><span class=\"comment\">    // 删除当前元素, 不再对后续元素查找</span></span><br><span class=\"line\"><span class=\"comment\">    if (find(lo, i, _elem[i]) != lo-1) &#123;remove(i); break;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    if (find(i+1, hi, _elem[i]) != i) &#123; remove(i);&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> old_size = _size;</span><br><span class=\"line\">  Rank i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; _size) &#123;</span><br><span class=\"line\">    find(<span class=\"number\">0</span>, i, _elem[i]) &lt; <span class=\"number\">0</span> ?</span><br><span class=\"line\">                             i++  <span class=\"comment\">// 小于0说明无雷同, 继续查找</span></span><br><span class=\"line\">                             : remove(i);    <span class=\"comment\">// 删除雷同者(至多一个?!)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>  old_size - _size;      <span class=\"comment\">// 返回规模的变化量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>记录规模?</code> 考虑返回值怎么设计，这里我估计会在更高级的接口中用到<br><code>从1开始?</code> 因为要在当前i的前缀中查找<br><code>至多一个?</code> 删除至多一个, 实际不一定至多一个<br><code>为什么不需要改变_size和_capacity大小?</code> 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。</p>\n<p><code>**正确性证明**</code>：<br><strong>不变性</strong>: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异<br>初始时, i = 1, 两个元素成立,…</p>\n<p><strong>单调性</strong>:<br>1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合<br>2)后缀单调下降, _size迟早减至0;     // 2)更容易把握</p>\n<p>故算法必然终止, 至多迭代O(n)轮</p>\n<p><code>复杂度</code></p>\n<p>主要来自find() 和 remove();<br>find()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);<br>while循环会进行n次,<br>总体复杂度为 O(n^2)</p>\n<p><code>练习三种优化方案（未完成）</code></p>\n<p>1, 仿照uniquify()高效版本的思路.<br>元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性<br>2, 先对需要删除的重复元素标记, 然后统一删除.<br>稳定性保持, 但因查找长度更长, 从而导致更多的对比操作<br>3, V.sort().uniquify(): 简明实现最优的O(nlogn)</p>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>visit</p>\n<p><a href=\"https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/\">关于函数指针和函数对象的笔记</a><br>函数指针机制 ?? </p>\n<p>函数对象机制 ??</p>\n<p>两种方法优劣</p>\n<p>实例: 将向量中所有的元素统一加一<br>重载操作符 “++”<br>重载操作符 “()”</p>\n<p>练习更为复杂的遍历</p>\n<h3 id=\"减1\"><a href=\"#减1\" class=\"headerlink\" title=\"减1\"></a>减1</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历运用函数对象机制，对各个元素减1</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">// 单个T类型元素减1的类</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Vector&lt;T&gt;::struct Decrease &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  virtual void operator() &#123;T &amp;e--;&#125;     // 重载()操作, 类对象当作函数来用</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void decrease(Vector&lt;T&gt;&amp; V) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  V.traverse(Decrease&lt;T&gt;());</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 泛型模板在调用的时候都要带&lt;type&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Decrease</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T &amp;e)</span> </span>&#123;e--;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decrease</span><span class=\"params\">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Decrease&lt;T&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么不是Vector-struct-Decrease\"><a href=\"#为什么不是Vector-struct-Decrease\" class=\"headerlink\" title=\"为什么不是Vector::struct Decrease?\"></a>为什么不是Vector<t>::struct Decrease?</t></h4><p>// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。</p>\n<h4 id=\"为什么需要virtual\"><a href=\"#为什么需要virtual\" class=\"headerlink\" title=\"为什么需要virtual\"></a>为什么需要virtual</h4><h4 id=\"void-operator-T-amp-e\"><a href=\"#void-operator-T-amp-e\" class=\"headerlink\" title=\"void operator()(T &amp;e)?\"></a>void operator()(T &amp;e)?</h4><p>// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表</p>\n<h4 id=\"三个函数之间的关系\"><a href=\"#三个函数之间的关系\" class=\"headerlink\" title=\"三个函数之间的关系?\"></a>三个函数之间的关系?</h4><p>Decrease<t>(T&amp;)函数对象, Vector<t>::traverse(VST&amp;)遍历函数, decrease(Vector<t>)</t></t></t></p>\n<p>// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<t>&amp; 类型<br>// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素</t></p>\n<h4 id=\"为什么需要函数对象\"><a href=\"#为什么需要函数对象\" class=\"headerlink\" title=\"为什么需要函数对象?\"></a>为什么需要函数对象?</h4><h4 id=\"本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢\"><a href=\"#本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢\" class=\"headerlink\" title=\"本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?\"></a>本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?</h4><p>将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。</p>\n<h3 id=\"加倍\"><a href=\"#加倍\" class=\"headerlink\" title=\"加倍\"></a>加倍</h3><p>Double(T &amp;e)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Double_value</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T&amp; e)</span> </span>&#123;e *= <span class=\"number\">2</span>;&#125;   <span class=\"comment\">// 函数对象对元素翻倍</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">double_value</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Double_value&lt;T&gt;());      <span class=\"comment\">// 函数对象作为遍历函数的参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h3><h4 id=\"函数中传入指针\"><a href=\"#函数中传入指针\" class=\"headerlink\" title=\"函数中传入指针\"></a>函数中传入指针</h4><p>Sum(T&amp; e, T* sumPtr)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 用于traverse的求和函数对象</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Sum &#123;</span><br><span class=\"line\">  virtual void operator()(const T&amp; e, T* sumPtr) &#123;(*sumPtr) += e;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename VST&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::traverse(VST visit, T* e) &#123;</span><br><span class=\"line\">  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针</span><br><span class=\"line\">  for (int i = 1; i &lt; _size; i++) visit(_elem[i], e);   // 从第二个值开始累加</span><br><span class=\"line\">  return *e;       // 返回求和结果</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。</strong></p>\n<p>前面都没什么问题,<br>实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_ptr</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  T* sumPtr = &amp;(V[<span class=\"number\">0</span>]);        <span class=\"comment\">// 别定义空指针, 该指针指向向量首位</span></span><br><span class=\"line\">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class=\"comment\">// 调用并赋值</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但print_vector()之后<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- --------print_vector--------- --</span><br><span class=\"line\">_size = 3</span><br><span class=\"line\">_capacity = 10</span><br><span class=\"line\">0:52                 ==&gt; _elem的首位被修改, 原本应该是10</span><br><span class=\"line\">1:24</span><br><span class=\"line\">2:18</span><br><span class=\"line\">3:0</span><br><span class=\"line\">4:0</span><br><span class=\"line\">5:0</span><br><span class=\"line\">6:0</span><br><span class=\"line\">7:0</span><br><span class=\"line\">8:0</span><br><span class=\"line\">9:0</span><br></pre></td></tr></table></figure></p>\n<p>因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!</p>\n<p>于是我便做了如下修改:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_ptr</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  T sum_init = V[<span class=\"number\">0</span>];              <span class=\"comment\">// 创建一个副本, 避免通过指针修改V[0]</span></span><br><span class=\"line\">  T* sumPtr = &amp;(sum_init);        <span class=\"comment\">// 别定义空指针, 该指针指向副本</span></span><br><span class=\"line\">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class=\"comment\">// 调用并赋值</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- --------print_vector--------- --</span><br><span class=\"line\">_size = 3</span><br><span class=\"line\">_capacity = 10</span><br><span class=\"line\">0:10</span><br><span class=\"line\">1:24</span><br><span class=\"line\">2:18</span><br><span class=\"line\">3:0</span><br><span class=\"line\">4:0</span><br><span class=\"line\">5:0</span><br><span class=\"line\">6:0</span><br><span class=\"line\">7:0</span><br><span class=\"line\">8:0</span><br><span class=\"line\">9:0</span><br></pre></td></tr></table></figure>\n<h5 id=\"重载函数什么时候用virtual\"><a href=\"#重载函数什么时候用virtual\" class=\"headerlink\" title=\"重载函数什么时候用virtual?\"></a>重载函数什么时候用virtual?</h5><h4 id=\"类内static存放\"><a href=\"#类内static存放\" class=\"headerlink\" title=\"类内static存放\"></a>类内static存放</h4><p>static sumStc<br>静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类内static求和的函数对象</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sum_static</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> T <span class=\"keyword\">sum_t</span>;     <span class=\"comment\">// 内部声明存放求和结果的static变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T&amp; e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">sum_t</span> += e; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"revise static sum_t, sum_t = \"</span></span><br><span class=\"line\">                          &lt;&lt; <span class=\"keyword\">sum_t</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// 当心全局变量出错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T Sum_static&lt;T&gt;::<span class=\"keyword\">sum_t</span> = <span class=\"number\">0</span>;   <span class=\"comment\">// 外部定义静态数据成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_static</span><span class=\"params\">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class=\"line\">  Sum_static&lt;T&gt; sumstc;           <span class=\"comment\">// 实例化模板别忘记&lt;type&gt;</span></span><br><span class=\"line\">  V.traverse(Sum_static&lt;T&gt;());</span><br><span class=\"line\">  T sum = sumstc.<span class=\"keyword\">sum_t</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"in sum_static, sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于static, 我的相关练习<a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp\" target=\"_blank\" rel=\"noopener\">source code</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"无序向量\"><a href=\"#无序向量\" class=\"headerlink\" title=\"无序向量\"></a>无序向量</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span>&#125;;    <span class=\"comment\">// template定义方式</span></span><br></pre></td></tr></table></figure>\n<p>模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinTree</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> &#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ..</span></span><br><span class=\"line\">  Vector&lt;<span class=\"keyword\">int</span>&gt; myVector;    <span class=\"comment\">// Right</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Vector&lt;<span class=\"keyword\">float</span>&gt; myfVector;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector&lt;BinTree&gt; binForest;       <span class=\"comment\">// Combine with other class;</span></span><br><span class=\"line\">  Vector&lt;Tree&lt;<span class=\"keyword\">int</span>&gt;&gt; binForest;     <span class=\"comment\">// Combine with template;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无序向量: 没有顺序, 甚至不可能排成顺序。</p>\n<h2 id=\"元素访问-寻秩访问\"><a href=\"#元素访问-寻秩访问\" class=\"headerlink\" title=\"元素访问(寻秩访问)\"></a>元素访问(寻秩访问)</h2><p>v.get(r), v.put(e)</p>\n<p>A[r]</p>\n<p>重载下标运算符”[]”<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寻秩访问</span></span><br><span class=\"line\"><span class=\"comment\">/* // my test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">T&amp; Vector&lt;T&gt;::operator[](std::size_t n) &#123;    // 这个类 Vector&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  assert(n &lt; _size);</span></span><br><span class=\"line\"><span class=\"comment\">  return _elem[n];</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>[](Rank r) <span class=\"keyword\">const</span> &#123;   <span class=\"comment\">// 不改变数据成员, 定义成常量成员函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 在vector内部, 定义了秩的类型, 统一用Rank</span></span><br><span class=\"line\">  assert(r &lt; _size);   <span class=\"comment\">// 对下标秩进行溢出检测</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _elem[r];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>左值, 右值, <code>引用??</code><br>引用类型可作为左值。</p>\n<p>寻秩访问</p>\n<p>代码健壮性简化</p>\n<ul>\n<li>assert 断言, <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\">assert(r &lt; _size);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\"><span class=\"comment\">/* my test</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::insert(const Rank r, const int value) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 检查移动后是否需要扩容</span></span><br><span class=\"line\"><span class=\"comment\">  if (++_size &gt; _capacity) expand();</span></span><br><span class=\"line\"><span class=\"comment\">  // 将秩为r后的所有元素后移一位</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = _size-2; i &gt;= r; i--) &#123;     // 为了不覆盖数据, 从尾部开始移动</span></span><br><span class=\"line\"><span class=\"comment\">    _elem[i+1] = _elem[i];     // 向后移动一位</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 在r秩位置上填入要插入的值</span></span><br><span class=\"line\"><span class=\"comment\">  _elem[r] = value;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> Vector&lt;T&gt;::insert(<span class=\"keyword\">const</span> Rank r, T <span class=\"keyword\">const</span> &amp;e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// value不应该是某一中特点的类型, 而应该利用template的特性</span></span><br><span class=\"line\">  assert(<span class=\"number\">0</span>&lt;= r &amp;&amp; r &lt; _size);</span><br><span class=\"line\">  expand();  <span class=\"comment\">// 若有必要扩容  结合expand()中, _size &lt; _capacity的定义</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = _size; i &gt; r; i--)  <span class=\"comment\">// 习惯把改变后的值的索引设置成i</span></span><br><span class=\"line\">    _elem[i] = _elem[i<span class=\"number\">-1</span>];     <span class=\"comment\">// 后继元素顺次后移一个单元</span></span><br><span class=\"line\">  _elem[r] = e; _size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Template中泛型T的作用,<br>模板类中函数的互相搭配,<br>插入元素对vector操作的顺序<br>对_capacity和_size的影响。</p>\n<h2 id=\"删除算法\"><a href=\"#删除算法\" class=\"headerlink\" title=\"删除算法\"></a>删除算法</h2><p>自前向后的迁移操作<br>缩容</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除操作</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::del(const Rank lo, const Rank hi) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = lo; i &lt; _size; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // 清空区间元素</span></span><br><span class=\"line\"><span class=\"comment\">    if (i &lt; hi) &#123; _elem[i] = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      // 将元素整体前移</span></span><br><span class=\"line\"><span class=\"comment\">      _elem[i - (hi-lo)] = _elem[i];</span></span><br><span class=\"line\"><span class=\"comment\">      // 前移后元素清空</span></span><br><span class=\"line\"><span class=\"comment\">       _elem[i] = 0;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 缩短规模和空间容量</span></span><br><span class=\"line\"><span class=\"comment\">  _size -= hi-lo; _capacity -= hi-lo;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Vector&lt;T&gt;::del(Rank lo, Rank hi) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理退化情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lo == hi) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = hi - lo;</span><br><span class=\"line\">  <span class=\"comment\">// 自前向后的迁移操作</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; _size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hi &lt; _capacity) &#123;_elem[lo++] = _elem[hi++];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;_elem[lo++] = <span class=\"number\">0</span>;&#125;   <span class=\"comment\">// 处理hi++超出_capacityg容量的情况</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 更新规模或者缩容</span></span><br><span class=\"line\">  _size -= length;</span><br><span class=\"line\">  shrunk();</span><br><span class=\"line\">  <span class=\"comment\">// 返回被删除元素的数目</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hi-lo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?</code> 改进成改变size的版本用于shrunk<br><code>2 , _elem[hi++]能够被一直索引到?</code> 超过_capacity时, 返回未定义的值<br><code>3, _elem[hi++]为什么不清空?</code>把_capacity的剩余空间对应元素赋值给它的方法清空<br><code>4, 看出移动操作过程中, 变量的同步性</code><br><code>5, 缩容不光光是改变_capacity的值, 仍旧要释放空间</code></p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><p>无序向量： T为可判等, 重载 “==”或者”!=”<br>有序向量： T为可比较，重载 “&lt;” 或  “&gt;”</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">int Vector&lt;T&gt;::find(Rank lo, Rank hi, T const &amp;e) const &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 查找e在区间[lo,hi)内</span></span><br><span class=\"line\"><span class=\"comment\">  // 从右往左查找</span></span><br><span class=\"line\"><span class=\"comment\">  while (hi &gt;= lo) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (_elem[hi] == e) &#123;return hi;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    hi--;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  // 没有在while循环中返回, 不存在匹配元素</span></span><br><span class=\"line\"><span class=\"comment\">  return -1;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Rank Vector&lt;T&gt;::find(Rank lo, Rank hi, T <span class=\"keyword\">const</span> &amp;e) <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (lo &lt; hi-- &amp;&amp; e != _elem[hi]) &#123;&#125;   <span class=\"comment\">// 逆向查找</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> hi;   <span class=\"comment\">// hi &lt; lo失败; 否则hi即命中元素的秩</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>利用while本身的条件语句；后置递增的特性</code><br><code>返回hi?</code> 将判断是否成功, 交给<code>上层的调用者</code>;以及成功后被<code>上层算法</code>进一步利用</p>\n<p>最好情况 O(1), 最坏情况O(n)<br>输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。</p>\n<h2 id=\"删除单元素\"><a href=\"#删除单元素\" class=\"headerlink\" title=\"删除单元素\"></a>删除单元素</h2><p><code>视为区间操作的特例</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除单个元素</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::remove(Rank r) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)</span></span><br><span class=\"line\"><span class=\"comment\">  remove(r, r+1);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;     <span class=\"comment\">// 删除向量中秩为r的元素, 0 &lt;= r &lt; size</span></span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::remove(Rank r) &#123;  <span class=\"comment\">// O(n-r)</span></span><br><span class=\"line\">  T&amp; <span class=\"keyword\">old_t</span> = _elem[r];    <span class=\"comment\">// 备份被删除的元素</span></span><br><span class=\"line\">  remove(r, r+<span class=\"number\">1</span>);         <span class=\"comment\">// 调用区间删除算法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">old_t</span>;           <span class=\"comment\">// 返回被删除元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>颠倒考虑</code></p>\n<p>复杂度分析:<br>每次循环的耗时正比于删除区间的后缀长度 O(n-hi)<br>循环的次数等于区间宽度 O(hi-lo)<br>总体 O(n^2) 复杂度</p>\n<p>right, but not fast!!</p>\n<h2 id=\"唯一化\"><a href=\"#唯一化\" class=\"headerlink\" title=\"唯一化\"></a>唯一化</h2><p><code>实现</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 唯一化</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void Vector&lt;T&gt;::deduplicate(Rank lo, Rank hi) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  // 对向量中的元素遍历,</span></span><br><span class=\"line\"><span class=\"comment\">  for (Rank i = lo; i &lt; hi; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    // find右往左查, 返回lo-1代表失败</span></span><br><span class=\"line\"><span class=\"comment\">    // 删除当前元素, 不再对后续元素查找</span></span><br><span class=\"line\"><span class=\"comment\">    if (find(lo, i, _elem[i]) != lo-1) &#123;remove(i); break;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    if (find(i+1, hi, _elem[i]) != i) &#123; remove(i);&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> old_size = _size;</span><br><span class=\"line\">  Rank i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; _size) &#123;</span><br><span class=\"line\">    find(<span class=\"number\">0</span>, i, _elem[i]) &lt; <span class=\"number\">0</span> ?</span><br><span class=\"line\">                             i++  <span class=\"comment\">// 小于0说明无雷同, 继续查找</span></span><br><span class=\"line\">                             : remove(i);    <span class=\"comment\">// 删除雷同者(至多一个?!)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>  old_size - _size;      <span class=\"comment\">// 返回规模的变化量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>记录规模?</code> 考虑返回值怎么设计，这里我估计会在更高级的接口中用到<br><code>从1开始?</code> 因为要在当前i的前缀中查找<br><code>至多一个?</code> 删除至多一个, 实际不一定至多一个<br><code>为什么不需要改变_size和_capacity大小?</code> 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。</p>\n<p><code>**正确性证明**</code>：<br><strong>不变性</strong>: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异<br>初始时, i = 1, 两个元素成立,…</p>\n<p><strong>单调性</strong>:<br>1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合<br>2)后缀单调下降, _size迟早减至0;     // 2)更容易把握</p>\n<p>故算法必然终止, 至多迭代O(n)轮</p>\n<p><code>复杂度</code></p>\n<p>主要来自find() 和 remove();<br>find()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);<br>while循环会进行n次,<br>总体复杂度为 O(n^2)</p>\n<p><code>练习三种优化方案（未完成）</code></p>\n<p>1, 仿照uniquify()高效版本的思路.<br>元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性<br>2, 先对需要删除的重复元素标记, 然后统一删除.<br>稳定性保持, 但因查找长度更长, 从而导致更多的对比操作<br>3, V.sort().uniquify(): 简明实现最优的O(nlogn)</p>\n<h2 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h2><p>visit</p>\n<p><a href=\"https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/\">关于函数指针和函数对象的笔记</a><br>函数指针机制 ?? </p>\n<p>函数对象机制 ??</p>\n<p>两种方法优劣</p>\n<p>实例: 将向量中所有的元素统一加一<br>重载操作符 “++”<br>重载操作符 “()”</p>\n<p>练习更为复杂的遍历</p>\n<h3 id=\"减1\"><a href=\"#减1\" class=\"headerlink\" title=\"减1\"></a>减1</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历运用函数对象机制，对各个元素减1</span></span><br><span class=\"line\"><span class=\"comment\">/* my test code</span></span><br><span class=\"line\"><span class=\"comment\">// 单个T类型元素减1的类</span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">Vector&lt;T&gt;::struct Decrease &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  virtual void operator() &#123;T &amp;e--;&#125;     // 重载()操作, 类对象当作函数来用</span></span><br><span class=\"line\"><span class=\"comment\">&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">template &lt;typename T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">void decrease(Vector&lt;T&gt;&amp; V) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  V.traverse(Decrease&lt;T&gt;());</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 泛型模板在调用的时候都要带&lt;type&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Decrease</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T &amp;e)</span> </span>&#123;e--;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decrease</span><span class=\"params\">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Decrease&lt;T&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么不是Vector-struct-Decrease\"><a href=\"#为什么不是Vector-struct-Decrease\" class=\"headerlink\" title=\"为什么不是Vector::struct Decrease?\"></a>为什么不是Vector<t>::struct Decrease?</t></h4><p>// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。</p>\n<h4 id=\"为什么需要virtual\"><a href=\"#为什么需要virtual\" class=\"headerlink\" title=\"为什么需要virtual\"></a>为什么需要virtual</h4><h4 id=\"void-operator-T-amp-e\"><a href=\"#void-operator-T-amp-e\" class=\"headerlink\" title=\"void operator()(T &amp;e)?\"></a>void operator()(T &amp;e)?</h4><p>// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表</p>\n<h4 id=\"三个函数之间的关系\"><a href=\"#三个函数之间的关系\" class=\"headerlink\" title=\"三个函数之间的关系?\"></a>三个函数之间的关系?</h4><p>Decrease<t>(T&amp;)函数对象, Vector<t>::traverse(VST&amp;)遍历函数, decrease(Vector<t>)</t></t></t></p>\n<p>// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<t>&amp; 类型<br>// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素</t></p>\n<h4 id=\"为什么需要函数对象\"><a href=\"#为什么需要函数对象\" class=\"headerlink\" title=\"为什么需要函数对象?\"></a>为什么需要函数对象?</h4><h4 id=\"本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢\"><a href=\"#本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢\" class=\"headerlink\" title=\"本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?\"></a>本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?</h4><p>将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。</p>\n<h3 id=\"加倍\"><a href=\"#加倍\" class=\"headerlink\" title=\"加倍\"></a>加倍</h3><p>Double(T &amp;e)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Double_value</span> &#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T&amp; e)</span> </span>&#123;e *= <span class=\"number\">2</span>;&#125;   <span class=\"comment\">// 函数对象对元素翻倍</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">double_value</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  V.traverse(Double_value&lt;T&gt;());      <span class=\"comment\">// 函数对象作为遍历函数的参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h3><h4 id=\"函数中传入指针\"><a href=\"#函数中传入指针\" class=\"headerlink\" title=\"函数中传入指针\"></a>函数中传入指针</h4><p>Sum(T&amp; e, T* sumPtr)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 用于traverse的求和函数对象</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">struct Sum &#123;</span><br><span class=\"line\">  virtual void operator()(const T&amp; e, T* sumPtr) &#123;(*sumPtr) += e;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt; template &lt;typename VST&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::traverse(VST visit, T* e) &#123;</span><br><span class=\"line\">  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针</span><br><span class=\"line\">  for (int i = 1; i &lt; _size; i++) visit(_elem[i], e);   // 从第二个值开始累加</span><br><span class=\"line\">  return *e;       // 返回求和结果</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。</strong></p>\n<p>前面都没什么问题,<br>实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_ptr</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  T* sumPtr = &amp;(V[<span class=\"number\">0</span>]);        <span class=\"comment\">// 别定义空指针, 该指针指向向量首位</span></span><br><span class=\"line\">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class=\"comment\">// 调用并赋值</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但print_vector()之后<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- --------print_vector--------- --</span><br><span class=\"line\">_size = 3</span><br><span class=\"line\">_capacity = 10</span><br><span class=\"line\">0:52                 ==&gt; _elem的首位被修改, 原本应该是10</span><br><span class=\"line\">1:24</span><br><span class=\"line\">2:18</span><br><span class=\"line\">3:0</span><br><span class=\"line\">4:0</span><br><span class=\"line\">5:0</span><br><span class=\"line\">6:0</span><br><span class=\"line\">7:0</span><br><span class=\"line\">8:0</span><br><span class=\"line\">9:0</span><br></pre></td></tr></table></figure></p>\n<p>因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!</p>\n<p>于是我便做了如下修改:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_ptr</span><span class=\"params\">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class=\"line\">  T sum_init = V[<span class=\"number\">0</span>];              <span class=\"comment\">// 创建一个副本, 避免通过指针修改V[0]</span></span><br><span class=\"line\">  T* sumPtr = &amp;(sum_init);        <span class=\"comment\">// 别定义空指针, 该指针指向副本</span></span><br><span class=\"line\">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class=\"comment\">// 调用并赋值</span></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">-- --------print_vector--------- --</span><br><span class=\"line\">_size = 3</span><br><span class=\"line\">_capacity = 10</span><br><span class=\"line\">0:10</span><br><span class=\"line\">1:24</span><br><span class=\"line\">2:18</span><br><span class=\"line\">3:0</span><br><span class=\"line\">4:0</span><br><span class=\"line\">5:0</span><br><span class=\"line\">6:0</span><br><span class=\"line\">7:0</span><br><span class=\"line\">8:0</span><br><span class=\"line\">9:0</span><br></pre></td></tr></table></figure>\n<h5 id=\"重载函数什么时候用virtual\"><a href=\"#重载函数什么时候用virtual\" class=\"headerlink\" title=\"重载函数什么时候用virtual?\"></a>重载函数什么时候用virtual?</h5><h4 id=\"类内static存放\"><a href=\"#类内static存放\" class=\"headerlink\" title=\"类内static存放\"></a>类内static存放</h4><p>static sumStc<br>静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类内static求和的函数对象</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Sum_static</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> T <span class=\"keyword\">sum_t</span>;     <span class=\"comment\">// 内部声明存放求和结果的static变量</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(T&amp; e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">sum_t</span> += e; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"revise static sum_t, sum_t = \"</span></span><br><span class=\"line\">                          &lt;&lt; <span class=\"keyword\">sum_t</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;    <span class=\"comment\">// 当心全局变量出错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T Sum_static&lt;T&gt;::<span class=\"keyword\">sum_t</span> = <span class=\"number\">0</span>;   <span class=\"comment\">// 外部定义静态数据成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_static</span><span class=\"params\">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class=\"line\">  Sum_static&lt;T&gt; sumstc;           <span class=\"comment\">// 实例化模板别忘记&lt;type&gt;</span></span><br><span class=\"line\">  V.traverse(Sum_static&lt;T&gt;());</span><br><span class=\"line\">  T sum = sumstc.<span class=\"keyword\">sum_t</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"in sum_static, sum = \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于static, 我的相关练习<a href=\"https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp\" target=\"_blank\" rel=\"noopener\">source code</a></p>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-D1","date":"2018-01-11T11:22:42.000Z","_content":"\n```\n\n觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。\n------------------------------ split line ---------------------------\n实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)\n\n# 有序向量唯一化\n\t无序: 比对\n\t有序: 比较\n\n## 有序性及其甄别\n\n\t> * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。\n\t\n\t> * 相邻逆序对数目, 可以度量逆序程度。\n\t\n\t\t> * 逆序程度实现\n\t\t\n\t\t===================== source code =========================\n\t\t// 逆序程度\n\t\t/* my test code \n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < _size - 1; i++)\n\t\t\t\tif (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素\n\t\t\treturn count;\n\t\t}\n\t\t*/\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\t\tint count = 0;   // 计数器\n\t\t\tfor (int i = i; i < _size; i++)\n\t\t\t\tcount += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换\n\t\t\treturn count;  // 向量有序当且仅当n = 0\n\t\t} // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止\n\t\t============================================================\n\t\t\n\t> * 若元素支持大小比较, 可将无序向量转换为有序向量。\n\t> * 无序向量转换为有序向量后, 算法多可优化。\n\n## 低效算法\n\n\t> 1, 我自己的低效deduplicate()版本, \n\t\t依赖一次性remove函数.\n\t\t> * 尝试自己实现,\n\t\t\n\t\t======================== sourece code =======================\n\t\t// my deduplicate code\n\t\t// 唯一化(低效)\n\t\tint deduplicate_lower(int rm_arr[]);\n\t\t// 唯一化所依赖的通过索引数组一次性remove函数\n\t\tvoid remove(int rm_arr[], int n);\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::deduplicate_lower(int rm_arr[]) {\n\t\t\t// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量\n\t\t\tassert(!disordered());   // 当前为有序向量\n\t\t\tRank n = 0;            // 数组当前插入位置\n\t\t\tRank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描\n\t\t\twhile (r2 < _size) {\n\t\t\t\tif (_elem[r1] == _elem[r2]) {   // r2指向的元素和r1对应元素重复\n\t\t\t\t\trm_arr[n++] = r2;     // 索引数组中加入r2\n\t\t\t\t\t// remove(r2);\n\t\t\t\t} else { r1 = r2;}\n\t\t\t\tr2++;    // 递增r2\n\t\t\t\t}\n\t\t\tremove(rm_arr, n);   // 一次性删除索引对应的元素\n\t\t\treturn n;            // 返回删除元素数量\n\t\t}\n\n\n\t    // 有序向量唯一化所依赖的通过索引数组一次性remove函数\n\t\ttemplate <typename T>\n\t\tvoid Vector<T>::remove(int rm_arr[], int n) {\n\t\t\t// 删除索引除外的索引对应元素保留, 从左向右扫描\n\t\t\tint i_n = 0;     // 指向rm_arr中的元素\n\t\t\tint new_i = 0;   // 保留索引\n\t\t\tT* old_elem = _elem;    // 备份一份当前元素\n\t\t\t_elem = new T[_capacity = _capacity];\n\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\tif (i != rm_arr[i_n]) {     // 当前索引不在表中\n\t\t\t\t\t_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置\n\t\t\t\t} else {     // 当前索引在删除索引的表中\n\t\t\t\t\ti_n++;     // 指向下一个rm_arr中的元素\n\t\t\t\t}\n\t\t\t}\n\t\t\t_size -= n;\n\t\t\tdelete [] old_elem;\n\t\t}\n\t\t=============================================================\n\t\n\t> 2, 视频中的唯一化(低效版)\n\t\t代码如下:\n\t\t======================= source code ========================\n\t\t// 有序向量唯一化\n\t\ttemplate <typename T>\n\t\tint Vector<T>::uniquify() {\n\t\t\tint old_size = _size; int i = 0;  // 首元素开始\n\t\t\twhile (i < _size - 1) {\n\t\t\t\t(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;\n\t\t\t}    // _size的改变由remove隐式完成\n\t\t\treturn old_size - _size;\n\t\t}\n\t\t============================================================\n\n## 低效算法: 复杂度\n\t> 1, 低效复杂度\n\t\t运行时间取决于while循环, 总计 _size - 1 = n - 1 \n\t\t最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)\n\t> 2, 比较\n\t\t我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)\n\n\n## 高效算法:\n\t> 1, 反思\n\t\t低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。\n\t> 2, 启示\n\t\t将重复区间视为单位, 成批的删除\n\t> 3, 算法\n\t\t[i] [] [ . . . . duplicates] [j] \n\t\t从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。\n\t\t\n\t\t高明之处在于: 实际上没有删除, 却等效于删除\n\t\t================== source code ==============================\n\t\t/* my test code\n\t\ttemplate <typename>\n\t\tint Vector<T>::uniquify() {\n\t\t\tint old_size = _size;\n\t\t    int i = 0, j = 1;   // i指向首位置\n\t\t\tint n = 1;    // 实际更新后的_elem的索引\n\t\t\twhile (i < _size - 1)\n\t\t\t\tif (_elem[i] != _elem[j])\n\t\t\t\t\t{ _elem[n++] = _elem[j]; i = j; size--;\n\t\t\t\t\t} else {j++;}\n\t        return old_size - n;\n\t\t}\n\t\t*/\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::uniquify_faster() {\n\t\t\tint i = 0, j = 0;   // 两个计数都指向首元素\n\t\t\twhile (++j < _size) {   // j扫描到末尾\n\t\t\t\tif (_elem[i] != _elem[j]) {_elem[++i] = _elem[j];}  // j指向元素移到i后\n\t\t\t}\n\t\t\t_size = ++i; shrunk();      // 改变_size数值后, 缩容\n\t\t\treturn j - i;    // 注意j扫到尾端的特性\n\t\t}     // 依赖shrink();\n\t\t============================================================\n\n\t    /* 实现问题分析\n\t\t// 为什么不要另外的n作为索引计数?\n\t\t当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。\n\t\t// 为什么不在uniquify中进行new 和 delete?\n\t\t接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。\n\t    */\n\n## 高效算法: 实例与复杂度\n\t> 1, *反思 (典型例子)\n\t\t共计n-1次迭代, 每次常数时间, 累计O(n)时间。\n\t\t\n\t\t优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。\n\t\t体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。\n```\n","source":"_posts/dsacpp/02-D1.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-D1\ndate: 2018-01-11 19:22:42\ntags: [数据结构, 有序向量]\n---\n\n```\n\n觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。\n------------------------------ split line ---------------------------\n实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)\n\n# 有序向量唯一化\n\t无序: 比对\n\t有序: 比较\n\n## 有序性及其甄别\n\n\t> * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。\n\t\n\t> * 相邻逆序对数目, 可以度量逆序程度。\n\t\n\t\t> * 逆序程度实现\n\t\t\n\t\t===================== source code =========================\n\t\t// 逆序程度\n\t\t/* my test code \n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < _size - 1; i++)\n\t\t\t\tif (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素\n\t\t\treturn count;\n\t\t}\n\t\t*/\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::disordered() const {\n\t\t\tint count = 0;   // 计数器\n\t\t\tfor (int i = i; i < _size; i++)\n\t\t\t\tcount += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换\n\t\t\treturn count;  // 向量有序当且仅当n = 0\n\t\t} // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止\n\t\t============================================================\n\t\t\n\t> * 若元素支持大小比较, 可将无序向量转换为有序向量。\n\t> * 无序向量转换为有序向量后, 算法多可优化。\n\n## 低效算法\n\n\t> 1, 我自己的低效deduplicate()版本, \n\t\t依赖一次性remove函数.\n\t\t> * 尝试自己实现,\n\t\t\n\t\t======================== sourece code =======================\n\t\t// my deduplicate code\n\t\t// 唯一化(低效)\n\t\tint deduplicate_lower(int rm_arr[]);\n\t\t// 唯一化所依赖的通过索引数组一次性remove函数\n\t\tvoid remove(int rm_arr[], int n);\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::deduplicate_lower(int rm_arr[]) {\n\t\t\t// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量\n\t\t\tassert(!disordered());   // 当前为有序向量\n\t\t\tRank n = 0;            // 数组当前插入位置\n\t\t\tRank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描\n\t\t\twhile (r2 < _size) {\n\t\t\t\tif (_elem[r1] == _elem[r2]) {   // r2指向的元素和r1对应元素重复\n\t\t\t\t\trm_arr[n++] = r2;     // 索引数组中加入r2\n\t\t\t\t\t// remove(r2);\n\t\t\t\t} else { r1 = r2;}\n\t\t\t\tr2++;    // 递增r2\n\t\t\t\t}\n\t\t\tremove(rm_arr, n);   // 一次性删除索引对应的元素\n\t\t\treturn n;            // 返回删除元素数量\n\t\t}\n\n\n\t    // 有序向量唯一化所依赖的通过索引数组一次性remove函数\n\t\ttemplate <typename T>\n\t\tvoid Vector<T>::remove(int rm_arr[], int n) {\n\t\t\t// 删除索引除外的索引对应元素保留, 从左向右扫描\n\t\t\tint i_n = 0;     // 指向rm_arr中的元素\n\t\t\tint new_i = 0;   // 保留索引\n\t\t\tT* old_elem = _elem;    // 备份一份当前元素\n\t\t\t_elem = new T[_capacity = _capacity];\n\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\tif (i != rm_arr[i_n]) {     // 当前索引不在表中\n\t\t\t\t\t_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置\n\t\t\t\t} else {     // 当前索引在删除索引的表中\n\t\t\t\t\ti_n++;     // 指向下一个rm_arr中的元素\n\t\t\t\t}\n\t\t\t}\n\t\t\t_size -= n;\n\t\t\tdelete [] old_elem;\n\t\t}\n\t\t=============================================================\n\t\n\t> 2, 视频中的唯一化(低效版)\n\t\t代码如下:\n\t\t======================= source code ========================\n\t\t// 有序向量唯一化\n\t\ttemplate <typename T>\n\t\tint Vector<T>::uniquify() {\n\t\t\tint old_size = _size; int i = 0;  // 首元素开始\n\t\t\twhile (i < _size - 1) {\n\t\t\t\t(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;\n\t\t\t}    // _size的改变由remove隐式完成\n\t\t\treturn old_size - _size;\n\t\t}\n\t\t============================================================\n\n## 低效算法: 复杂度\n\t> 1, 低效复杂度\n\t\t运行时间取决于while循环, 总计 _size - 1 = n - 1 \n\t\t最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)\n\t> 2, 比较\n\t\t我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)\n\n\n## 高效算法:\n\t> 1, 反思\n\t\t低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。\n\t> 2, 启示\n\t\t将重复区间视为单位, 成批的删除\n\t> 3, 算法\n\t\t[i] [] [ . . . . duplicates] [j] \n\t\t从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。\n\t\t\n\t\t高明之处在于: 实际上没有删除, 却等效于删除\n\t\t================== source code ==============================\n\t\t/* my test code\n\t\ttemplate <typename>\n\t\tint Vector<T>::uniquify() {\n\t\t\tint old_size = _size;\n\t\t    int i = 0, j = 1;   // i指向首位置\n\t\t\tint n = 1;    // 实际更新后的_elem的索引\n\t\t\twhile (i < _size - 1)\n\t\t\t\tif (_elem[i] != _elem[j])\n\t\t\t\t\t{ _elem[n++] = _elem[j]; i = j; size--;\n\t\t\t\t\t} else {j++;}\n\t        return old_size - n;\n\t\t}\n\t\t*/\n\t\t\n\t\ttemplate <typename T>\n\t\tint Vector<T>::uniquify_faster() {\n\t\t\tint i = 0, j = 0;   // 两个计数都指向首元素\n\t\t\twhile (++j < _size) {   // j扫描到末尾\n\t\t\t\tif (_elem[i] != _elem[j]) {_elem[++i] = _elem[j];}  // j指向元素移到i后\n\t\t\t}\n\t\t\t_size = ++i; shrunk();      // 改变_size数值后, 缩容\n\t\t\treturn j - i;    // 注意j扫到尾端的特性\n\t\t}     // 依赖shrink();\n\t\t============================================================\n\n\t    /* 实现问题分析\n\t\t// 为什么不要另外的n作为索引计数?\n\t\t当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。\n\t\t// 为什么不在uniquify中进行new 和 delete?\n\t\t接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。\n\t    */\n\n## 高效算法: 实例与复杂度\n\t> 1, *反思 (典型例子)\n\t\t共计n-1次迭代, 每次常数时间, 累计O(n)时间。\n\t\t\n\t\t优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。\n\t\t体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。\n```\n","slug":"dsacpp/02-D1","published":1,"updated":"2018-06-19T16:15:03.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyku002ck8mf4d687y4c","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。</span><br><span class=\"line\">------------------------------ split line ---------------------------</span><br><span class=\"line\">实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\"># 有序向量唯一化</span><br><span class=\"line\">\t无序: 比对</span><br><span class=\"line\">\t有序: 比较</span><br><span class=\"line\"></span><br><span class=\"line\">## 有序性及其甄别</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 相邻逆序对数目, 可以度量逆序程度。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&gt; * 逆序程度实现</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t===================== source code =========================</span><br><span class=\"line\">\t\t// 逆序程度</span><br><span class=\"line\">\t\t/* my test code </span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\t\tint count = 0;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; _size - 1; i++)</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素</span><br><span class=\"line\">\t\t\treturn count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\t\tint count = 0;   // 计数器</span><br><span class=\"line\">\t\t\tfor (int i = i; i &lt; _size; i++)</span><br><span class=\"line\">\t\t\t\tcount += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class=\"line\">\t\t\treturn count;  // 向量有序当且仅当n = 0</span><br><span class=\"line\">\t\t&#125; // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt; * 若元素支持大小比较, 可将无序向量转换为有序向量。</span><br><span class=\"line\">\t&gt; * 无序向量转换为有序向量后, 算法多可优化。</span><br><span class=\"line\"></span><br><span class=\"line\">## 低效算法</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; 1, 我自己的低效deduplicate()版本, </span><br><span class=\"line\">\t\t依赖一次性remove函数.</span><br><span class=\"line\">\t\t&gt; * 尝试自己实现,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t======================== sourece code =======================</span><br><span class=\"line\">\t\t// my deduplicate code</span><br><span class=\"line\">\t\t// 唯一化(低效)</span><br><span class=\"line\">\t\tint deduplicate_lower(int rm_arr[]);</span><br><span class=\"line\">\t\t// 唯一化所依赖的通过索引数组一次性remove函数</span><br><span class=\"line\">\t\tvoid remove(int rm_arr[], int n);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::deduplicate_lower(int rm_arr[]) &#123;</span><br><span class=\"line\">\t\t\t// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量</span><br><span class=\"line\">\t\t\tassert(!disordered());   // 当前为有序向量</span><br><span class=\"line\">\t\t\tRank n = 0;            // 数组当前插入位置</span><br><span class=\"line\">\t\t\tRank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描</span><br><span class=\"line\">\t\t\twhile (r2 &lt; _size) &#123;</span><br><span class=\"line\">\t\t\t\tif (_elem[r1] == _elem[r2]) &#123;   // r2指向的元素和r1对应元素重复</span><br><span class=\"line\">\t\t\t\t\trm_arr[n++] = r2;     // 索引数组中加入r2</span><br><span class=\"line\">\t\t\t\t\t// remove(r2);</span><br><span class=\"line\">\t\t\t\t&#125; else &#123; r1 = r2;&#125;</span><br><span class=\"line\">\t\t\t\tr2++;    // 递增r2</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\tremove(rm_arr, n);   // 一次性删除索引对应的元素</span><br><span class=\"line\">\t\t\treturn n;            // 返回删除元素数量</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    // 有序向量唯一化所依赖的通过索引数组一次性remove函数</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tvoid Vector&lt;T&gt;::remove(int rm_arr[], int n) &#123;</span><br><span class=\"line\">\t\t\t// 删除索引除外的索引对应元素保留, 从左向右扫描</span><br><span class=\"line\">\t\t\tint i_n = 0;     // 指向rm_arr中的元素</span><br><span class=\"line\">\t\t\tint new_i = 0;   // 保留索引</span><br><span class=\"line\">\t\t\tT* old_elem = _elem;    // 备份一份当前元素</span><br><span class=\"line\">\t\t\t_elem = new T[_capacity = _capacity];</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (i != rm_arr[i_n]) &#123;     // 当前索引不在表中</span><br><span class=\"line\">\t\t\t\t\t_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;     // 当前索引在删除索引的表中</span><br><span class=\"line\">\t\t\t\t\ti_n++;     // 指向下一个rm_arr中的元素</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_size -= n;</span><br><span class=\"line\">\t\t\tdelete [] old_elem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; 2, 视频中的唯一化(低效版)</span><br><span class=\"line\">\t\t代码如下:</span><br><span class=\"line\">\t\t======================= source code ========================</span><br><span class=\"line\">\t\t// 有序向量唯一化</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify() &#123;</span><br><span class=\"line\">\t\t\tint old_size = _size; int i = 0;  // 首元素开始</span><br><span class=\"line\">\t\t\twhile (i &lt; _size - 1) &#123;</span><br><span class=\"line\">\t\t\t\t(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;</span><br><span class=\"line\">\t\t\t&#125;    // _size的改变由remove隐式完成</span><br><span class=\"line\">\t\t\treturn old_size - _size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">## 低效算法: 复杂度</span><br><span class=\"line\">\t&gt; 1, 低效复杂度</span><br><span class=\"line\">\t\t运行时间取决于while循环, 总计 _size - 1 = n - 1 </span><br><span class=\"line\">\t\t最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)</span><br><span class=\"line\">\t&gt; 2, 比较</span><br><span class=\"line\">\t\t我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 高效算法:</span><br><span class=\"line\">\t&gt; 1, 反思</span><br><span class=\"line\">\t\t低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。</span><br><span class=\"line\">\t&gt; 2, 启示</span><br><span class=\"line\">\t\t将重复区间视为单位, 成批的删除</span><br><span class=\"line\">\t&gt; 3, 算法</span><br><span class=\"line\">\t\t[i] [] [ . . . . duplicates] [j] </span><br><span class=\"line\">\t\t从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t高明之处在于: 实际上没有删除, 却等效于删除</span><br><span class=\"line\">\t\t================== source code ==============================</span><br><span class=\"line\">\t\t/* my test code</span><br><span class=\"line\">\t\ttemplate &lt;typename&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify() &#123;</span><br><span class=\"line\">\t\t\tint old_size = _size;</span><br><span class=\"line\">\t\t    int i = 0, j = 1;   // i指向首位置</span><br><span class=\"line\">\t\t\tint n = 1;    // 实际更新后的_elem的索引</span><br><span class=\"line\">\t\t\twhile (i &lt; _size - 1)</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[j])</span><br><span class=\"line\">\t\t\t\t\t&#123; _elem[n++] = _elem[j]; i = j; size--;</span><br><span class=\"line\">\t\t\t\t\t&#125; else &#123;j++;&#125;</span><br><span class=\"line\">\t        return old_size - n;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify_faster() &#123;</span><br><span class=\"line\">\t\t\tint i = 0, j = 0;   // 两个计数都指向首元素</span><br><span class=\"line\">\t\t\twhile (++j &lt; _size) &#123;   // j扫描到末尾</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[j]) &#123;_elem[++i] = _elem[j];&#125;  // j指向元素移到i后</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_size = ++i; shrunk();      // 改变_size数值后, 缩容</span><br><span class=\"line\">\t\t\treturn j - i;    // 注意j扫到尾端的特性</span><br><span class=\"line\">\t\t&#125;     // 依赖shrink();</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">\t    /* 实现问题分析</span><br><span class=\"line\">\t\t// 为什么不要另外的n作为索引计数?</span><br><span class=\"line\">\t\t当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。</span><br><span class=\"line\">\t\t// 为什么不在uniquify中进行new 和 delete?</span><br><span class=\"line\">\t\t接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。</span><br><span class=\"line\">\t    */</span><br><span class=\"line\"></span><br><span class=\"line\">## 高效算法: 实例与复杂度</span><br><span class=\"line\">\t&gt; 1, *反思 (典型例子)</span><br><span class=\"line\">\t\t共计n-1次迭代, 每次常数时间, 累计O(n)时间。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。</span><br><span class=\"line\">\t\t体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。</span><br><span class=\"line\">------------------------------ split line ---------------------------</span><br><span class=\"line\">实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\"># 有序向量唯一化</span><br><span class=\"line\">\t无序: 比对</span><br><span class=\"line\">\t有序: 比较</span><br><span class=\"line\"></span><br><span class=\"line\">## 有序性及其甄别</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; * 相邻逆序对数目, 可以度量逆序程度。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&gt; * 逆序程度实现</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t===================== source code =========================</span><br><span class=\"line\">\t\t// 逆序程度</span><br><span class=\"line\">\t\t/* my test code </span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\t\tint count = 0;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; _size - 1; i++)</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素</span><br><span class=\"line\">\t\t\treturn count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::disordered() const &#123;</span><br><span class=\"line\">\t\t\tint count = 0;   // 计数器</span><br><span class=\"line\">\t\t\tfor (int i = i; i &lt; _size; i++)</span><br><span class=\"line\">\t\t\t\tcount += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class=\"line\">\t\t\treturn count;  // 向量有序当且仅当n = 0</span><br><span class=\"line\">\t\t&#125; // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt; * 若元素支持大小比较, 可将无序向量转换为有序向量。</span><br><span class=\"line\">\t&gt; * 无序向量转换为有序向量后, 算法多可优化。</span><br><span class=\"line\"></span><br><span class=\"line\">## 低效算法</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt; 1, 我自己的低效deduplicate()版本, </span><br><span class=\"line\">\t\t依赖一次性remove函数.</span><br><span class=\"line\">\t\t&gt; * 尝试自己实现,</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t======================== sourece code =======================</span><br><span class=\"line\">\t\t// my deduplicate code</span><br><span class=\"line\">\t\t// 唯一化(低效)</span><br><span class=\"line\">\t\tint deduplicate_lower(int rm_arr[]);</span><br><span class=\"line\">\t\t// 唯一化所依赖的通过索引数组一次性remove函数</span><br><span class=\"line\">\t\tvoid remove(int rm_arr[], int n);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::deduplicate_lower(int rm_arr[]) &#123;</span><br><span class=\"line\">\t\t\t// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量</span><br><span class=\"line\">\t\t\tassert(!disordered());   // 当前为有序向量</span><br><span class=\"line\">\t\t\tRank n = 0;            // 数组当前插入位置</span><br><span class=\"line\">\t\t\tRank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描</span><br><span class=\"line\">\t\t\twhile (r2 &lt; _size) &#123;</span><br><span class=\"line\">\t\t\t\tif (_elem[r1] == _elem[r2]) &#123;   // r2指向的元素和r1对应元素重复</span><br><span class=\"line\">\t\t\t\t\trm_arr[n++] = r2;     // 索引数组中加入r2</span><br><span class=\"line\">\t\t\t\t\t// remove(r2);</span><br><span class=\"line\">\t\t\t\t&#125; else &#123; r1 = r2;&#125;</span><br><span class=\"line\">\t\t\t\tr2++;    // 递增r2</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\tremove(rm_arr, n);   // 一次性删除索引对应的元素</span><br><span class=\"line\">\t\t\treturn n;            // 返回删除元素数量</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t    // 有序向量唯一化所依赖的通过索引数组一次性remove函数</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tvoid Vector&lt;T&gt;::remove(int rm_arr[], int n) &#123;</span><br><span class=\"line\">\t\t\t// 删除索引除外的索引对应元素保留, 从左向右扫描</span><br><span class=\"line\">\t\t\tint i_n = 0;     // 指向rm_arr中的元素</span><br><span class=\"line\">\t\t\tint new_i = 0;   // 保留索引</span><br><span class=\"line\">\t\t\tT* old_elem = _elem;    // 备份一份当前元素</span><br><span class=\"line\">\t\t\t_elem = new T[_capacity = _capacity];</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (i != rm_arr[i_n]) &#123;     // 当前索引不在表中</span><br><span class=\"line\">\t\t\t\t\t_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;     // 当前索引在删除索引的表中</span><br><span class=\"line\">\t\t\t\t\ti_n++;     // 指向下一个rm_arr中的元素</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_size -= n;</span><br><span class=\"line\">\t\t\tdelete [] old_elem;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt; 2, 视频中的唯一化(低效版)</span><br><span class=\"line\">\t\t代码如下:</span><br><span class=\"line\">\t\t======================= source code ========================</span><br><span class=\"line\">\t\t// 有序向量唯一化</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify() &#123;</span><br><span class=\"line\">\t\t\tint old_size = _size; int i = 0;  // 首元素开始</span><br><span class=\"line\">\t\t\twhile (i &lt; _size - 1) &#123;</span><br><span class=\"line\">\t\t\t\t(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;</span><br><span class=\"line\">\t\t\t&#125;    // _size的改变由remove隐式完成</span><br><span class=\"line\">\t\t\treturn old_size - _size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">## 低效算法: 复杂度</span><br><span class=\"line\">\t&gt; 1, 低效复杂度</span><br><span class=\"line\">\t\t运行时间取决于while循环, 总计 _size - 1 = n - 1 </span><br><span class=\"line\">\t\t最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)</span><br><span class=\"line\">\t&gt; 2, 比较</span><br><span class=\"line\">\t\t我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 高效算法:</span><br><span class=\"line\">\t&gt; 1, 反思</span><br><span class=\"line\">\t\t低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。</span><br><span class=\"line\">\t&gt; 2, 启示</span><br><span class=\"line\">\t\t将重复区间视为单位, 成批的删除</span><br><span class=\"line\">\t&gt; 3, 算法</span><br><span class=\"line\">\t\t[i] [] [ . . . . duplicates] [j] </span><br><span class=\"line\">\t\t从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t高明之处在于: 实际上没有删除, 却等效于删除</span><br><span class=\"line\">\t\t================== source code ==============================</span><br><span class=\"line\">\t\t/* my test code</span><br><span class=\"line\">\t\ttemplate &lt;typename&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify() &#123;</span><br><span class=\"line\">\t\t\tint old_size = _size;</span><br><span class=\"line\">\t\t    int i = 0, j = 1;   // i指向首位置</span><br><span class=\"line\">\t\t\tint n = 1;    // 实际更新后的_elem的索引</span><br><span class=\"line\">\t\t\twhile (i &lt; _size - 1)</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[j])</span><br><span class=\"line\">\t\t\t\t\t&#123; _elem[n++] = _elem[j]; i = j; size--;</span><br><span class=\"line\">\t\t\t\t\t&#125; else &#123;j++;&#125;</span><br><span class=\"line\">\t        return old_size - n;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tint Vector&lt;T&gt;::uniquify_faster() &#123;</span><br><span class=\"line\">\t\t\tint i = 0, j = 0;   // 两个计数都指向首元素</span><br><span class=\"line\">\t\t\twhile (++j &lt; _size) &#123;   // j扫描到末尾</span><br><span class=\"line\">\t\t\t\tif (_elem[i] != _elem[j]) &#123;_elem[++i] = _elem[j];&#125;  // j指向元素移到i后</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_size = ++i; shrunk();      // 改变_size数值后, 缩容</span><br><span class=\"line\">\t\t\treturn j - i;    // 注意j扫到尾端的特性</span><br><span class=\"line\">\t\t&#125;     // 依赖shrink();</span><br><span class=\"line\">\t\t============================================================</span><br><span class=\"line\"></span><br><span class=\"line\">\t    /* 实现问题分析</span><br><span class=\"line\">\t\t// 为什么不要另外的n作为索引计数?</span><br><span class=\"line\">\t\t当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。</span><br><span class=\"line\">\t\t// 为什么不在uniquify中进行new 和 delete?</span><br><span class=\"line\">\t\t接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。</span><br><span class=\"line\">\t    */</span><br><span class=\"line\"></span><br><span class=\"line\">## 高效算法: 实例与复杂度</span><br><span class=\"line\">\t&gt; 1, *反思 (典型例子)</span><br><span class=\"line\">\t\t共计n-1次迭代, 每次常数时间, 累计O(n)时间。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。</span><br><span class=\"line\">\t\t体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。</span><br></pre></td></tr></table></figure>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-D2","date":"2018-01-12T09:09:13.000Z","_content":"```\nd2 有序向量: 二分查找\n\n\tVector::find(e, lo, hi);\n\tVector::search(e, lo, hi);\n\n\t操作参数和接口语义类似。\n---------------------------------------------------------------------------------\n# 统一接口\n\t>* ADT接口\n\t======================== source code ==========================\n\t// ADT接口\n\ttemplate <typename T>\n\tRank Vector<T>::search(T const& e, Rank lo, Rank hi) const {\n\t\tstd::srand(std::time(0));\n\t\treturn (std::rand() % 2) ?\n\t\t\tbinSearch(_elem, e, lo, hi)     // 二分查找算法\n\t\t\t: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法\n\t}\n\n\ttemplate <typename T>\n\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\tstd::cout << \"calling binSearch.... \" << std::endl;\n\t\treturn lo;\n\t}\n\t\n\ttemplate <typename T>\n\tRank Vector<T>::fibSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\tstd::cout << \"calling fibSearch... \" << std::endl;\n\t\treturn lo;\n\t}\n\t================================================================\n\t可以设计不同的算法, 根据数据的性质进算法的选择。\n---------------------------------------------------------------------------------\n# 语义约定\n\n\t约点语义的好处就是, 能够更好的和其他代码配合。\n\t>* 优点: \n\t\t维护自身 V.insert(1 + V.search(e), e)\n\t\t\t即便是失败, 也给出插入新元素的位置。\n\t\t\t若允许重复元素, 则每组也按照其插入的次序排序。\n\t\n\t>* 约点:\n\t\t有序V[lo, hi), 不大于e的最后元素秩\n\t\t-00 < e < V[lo], 返回 lo - 1 (左侧哨兵)\n\t\tV[hi] < e < +00, 返回 hi - 1 (末元素, 右哨兵左邻)\n---------------------------------------------------------------------------------\n# 版本A: 原理\n\n\t>* 减而治之\n\t\t待查找区间分成三部分\n\t\tS[lo, mi) <= S[mi] <= S(mi, hi)       // S[mi]轴点\n\t\n\t>* 三种比较情况\n\t\te < x: 左\n\t\tx < e: 右\n\t\te = x: 命中             // 多个解?\n\t\n\t>* 二分(折半)策略\n\t\t每经过至多两次比较, 或命中, 或将规模缩减一半\n----------------------------------------------------------------------------------\n# 版本A: 实现\n\n\t>* 我的尝试\n\t\t======= source code ======================================\n\t\t// 二分查找: 版本A\n\t\t/* my test code\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\tstd::cout << \"calling binSearch.... \" << std::endl;\n\t\t\tif (lo < hi) {   // 区间不存在, 没找到e\n\t\t\t\tRank mi = (lo + hi) >> 1;    // 中点秩\n\t\t\t\tif (elem[mi] == e) return mi;     // 命中, 递归基\n\t\t\t\tif (e < elem[mi]) {     // 在mid左侧\n\t\t\t\t\treturn (binSearch(elem, e, lo, mi));\n\t\t\t\t} else { return binSearch(elem, e, mi + 1, hi);}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t*/\n\t\t==========================================================\n\t\t\n\t>* 给出的版本\n\t\t==================== source code ========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\twhile (lo < hi) {    // 区间存在\n\t\t\t\tRank mi =  (lo + hi) >> 1;        // 取中点\n\t\t\t\tif      (e < elem[mi]) hi = mi;      // 深入前半段查找\n\t\t\t\telse if (elem[mi] < e) lo = mi + 1;  // 深入后半段查找\n\t\t\t\telse                   return mi;    // 在mi命中\n\t\t\t}\n\t\treturn -1;   // 查找失败\n\t\t}\n\t\t=========================================================\n\t\t\n\t>* 分析\n\t\t1, 将递归变成while loop, 内部对hi, lo进行修改。\n\t\t2, while循环通过hi, lo改变, 改变区间。\n\t\t3, if...else 和 else...if什么差别？\n\t\n\t>* 技巧\n\t\t善用 \"<\" 比较\n\t\t\t因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。\n-----------------------------------------------------------------------------------------\n# 版本A: 实例与复杂度\n\n\t>* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中\n\t>* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败\n\t\n\t>* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)\n\t递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)\n--------------------------------------------------------------------------------------\n# 版本A：查找长度\n\n\t>* 更为精细的评估算法性能:\n\t\t考察关键码的比较次数, 查找长度(search length)\n\t>* 成功与失败的最好, 最坏, 平均角度评估\n\t>* 这个算法 = O(1.5logn)\n\t\t向左节点 + 1, 向右节点 +2\n\t\tn = 8\n\t\t最好, 29/7 = 4+\n\t\t最差, 36/8 = 4.5 = 1.5log28\n\n```\n","source":"_posts/dsacpp/02-D2.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-D2\ndate: 2018-01-12 17:09:13\ntags: 数据结构\n---\n```\nd2 有序向量: 二分查找\n\n\tVector::find(e, lo, hi);\n\tVector::search(e, lo, hi);\n\n\t操作参数和接口语义类似。\n---------------------------------------------------------------------------------\n# 统一接口\n\t>* ADT接口\n\t======================== source code ==========================\n\t// ADT接口\n\ttemplate <typename T>\n\tRank Vector<T>::search(T const& e, Rank lo, Rank hi) const {\n\t\tstd::srand(std::time(0));\n\t\treturn (std::rand() % 2) ?\n\t\t\tbinSearch(_elem, e, lo, hi)     // 二分查找算法\n\t\t\t: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法\n\t}\n\n\ttemplate <typename T>\n\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\tstd::cout << \"calling binSearch.... \" << std::endl;\n\t\treturn lo;\n\t}\n\t\n\ttemplate <typename T>\n\tRank Vector<T>::fibSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\tstd::cout << \"calling fibSearch... \" << std::endl;\n\t\treturn lo;\n\t}\n\t================================================================\n\t可以设计不同的算法, 根据数据的性质进算法的选择。\n---------------------------------------------------------------------------------\n# 语义约定\n\n\t约点语义的好处就是, 能够更好的和其他代码配合。\n\t>* 优点: \n\t\t维护自身 V.insert(1 + V.search(e), e)\n\t\t\t即便是失败, 也给出插入新元素的位置。\n\t\t\t若允许重复元素, 则每组也按照其插入的次序排序。\n\t\n\t>* 约点:\n\t\t有序V[lo, hi), 不大于e的最后元素秩\n\t\t-00 < e < V[lo], 返回 lo - 1 (左侧哨兵)\n\t\tV[hi] < e < +00, 返回 hi - 1 (末元素, 右哨兵左邻)\n---------------------------------------------------------------------------------\n# 版本A: 原理\n\n\t>* 减而治之\n\t\t待查找区间分成三部分\n\t\tS[lo, mi) <= S[mi] <= S(mi, hi)       // S[mi]轴点\n\t\n\t>* 三种比较情况\n\t\te < x: 左\n\t\tx < e: 右\n\t\te = x: 命中             // 多个解?\n\t\n\t>* 二分(折半)策略\n\t\t每经过至多两次比较, 或命中, 或将规模缩减一半\n----------------------------------------------------------------------------------\n# 版本A: 实现\n\n\t>* 我的尝试\n\t\t======= source code ======================================\n\t\t// 二分查找: 版本A\n\t\t/* my test code\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\tstd::cout << \"calling binSearch.... \" << std::endl;\n\t\t\tif (lo < hi) {   // 区间不存在, 没找到e\n\t\t\t\tRank mi = (lo + hi) >> 1;    // 中点秩\n\t\t\t\tif (elem[mi] == e) return mi;     // 命中, 递归基\n\t\t\t\tif (e < elem[mi]) {     // 在mid左侧\n\t\t\t\t\treturn (binSearch(elem, e, lo, mi));\n\t\t\t\t} else { return binSearch(elem, e, mi + 1, hi);}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t*/\n\t\t==========================================================\n\t\t\n\t>* 给出的版本\n\t\t==================== source code ========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\twhile (lo < hi) {    // 区间存在\n\t\t\t\tRank mi =  (lo + hi) >> 1;        // 取中点\n\t\t\t\tif      (e < elem[mi]) hi = mi;      // 深入前半段查找\n\t\t\t\telse if (elem[mi] < e) lo = mi + 1;  // 深入后半段查找\n\t\t\t\telse                   return mi;    // 在mi命中\n\t\t\t}\n\t\treturn -1;   // 查找失败\n\t\t}\n\t\t=========================================================\n\t\t\n\t>* 分析\n\t\t1, 将递归变成while loop, 内部对hi, lo进行修改。\n\t\t2, while循环通过hi, lo改变, 改变区间。\n\t\t3, if...else 和 else...if什么差别？\n\t\n\t>* 技巧\n\t\t善用 \"<\" 比较\n\t\t\t因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。\n-----------------------------------------------------------------------------------------\n# 版本A: 实例与复杂度\n\n\t>* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中\n\t>* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败\n\t\n\t>* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)\n\t递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)\n--------------------------------------------------------------------------------------\n# 版本A：查找长度\n\n\t>* 更为精细的评估算法性能:\n\t\t考察关键码的比较次数, 查找长度(search length)\n\t>* 成功与失败的最好, 最坏, 平均角度评估\n\t>* 这个算法 = O(1.5logn)\n\t\t向左节点 + 1, 向右节点 +2\n\t\tn = 8\n\t\t最好, 29/7 = 4+\n\t\t最差, 36/8 = 4.5 = 1.5log28\n\n```\n","slug":"dsacpp/02-D2","published":1,"updated":"2018-06-19T16:15:03.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykw002dk8mfatpq8zhx","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">d2 有序向量: 二分查找</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector::find(e, lo, hi);</span><br><span class=\"line\">\tVector::search(e, lo, hi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t操作参数和接口语义类似。</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 统一接口</span><br><span class=\"line\">\t&gt;* ADT接口</span><br><span class=\"line\">\t======================== source code ==========================</span><br><span class=\"line\">\t// ADT接口</span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::srand(std::time(0));</span><br><span class=\"line\">\t\treturn (std::rand() % 2) ?</span><br><span class=\"line\">\t\t\tbinSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class=\"line\">\t\t\t: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\treturn lo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\treturn lo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t================================================================</span><br><span class=\"line\">\t可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 语义约定</span><br><span class=\"line\"></span><br><span class=\"line\">\t约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class=\"line\">\t&gt;* 优点: </span><br><span class=\"line\">\t\t维护自身 V.insert(1 + V.search(e), e)</span><br><span class=\"line\">\t\t\t即便是失败, 也给出插入新元素的位置。</span><br><span class=\"line\">\t\t\t若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 约点:</span><br><span class=\"line\">\t\t有序V[lo, hi), 不大于e的最后元素秩</span><br><span class=\"line\">\t\t-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class=\"line\">\t\tV[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 原理</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 减而治之</span><br><span class=\"line\">\t\t待查找区间分成三部分</span><br><span class=\"line\">\t\tS[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 三种比较情况</span><br><span class=\"line\">\t\te &lt; x: 左</span><br><span class=\"line\">\t\tx &lt; e: 右</span><br><span class=\"line\">\t\te = x: 命中             // 多个解?</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 二分(折半)策略</span><br><span class=\"line\">\t\t每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 实现</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t======= source code ======================================</span><br><span class=\"line\">\t\t// 二分查找: 版本A</span><br><span class=\"line\">\t\t/* my test code</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\tif (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class=\"line\">\t\t\t\tRank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class=\"line\">\t\t\t\tif (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class=\"line\">\t\t\t\tif (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class=\"line\">\t\t\t\t\treturn (binSearch(elem, e, lo, mi));</span><br><span class=\"line\">\t\t\t\t&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t==========================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 给出的版本</span><br><span class=\"line\">\t\t==================== source code ========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;    // 区间存在</span><br><span class=\"line\">\t\t\t\tRank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class=\"line\">\t\t\t\tif      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class=\"line\">\t\t\t\telse if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class=\"line\">\t\t\t\telse                   return mi;    // 在mi命中</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;   // 查找失败</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=========================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 分析</span><br><span class=\"line\">\t\t1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class=\"line\">\t\t2, while循环通过hi, lo改变, 改变区间。</span><br><span class=\"line\">\t\t3, if...else 和 else...if什么差别？</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 技巧</span><br><span class=\"line\">\t\t善用 &quot;&lt;&quot; 比较</span><br><span class=\"line\">\t\t\t因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class=\"line\">-----------------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 实例与复杂度</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class=\"line\">\t&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class=\"line\">\t递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class=\"line\">--------------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A：查找长度</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 更为精细的评估算法性能:</span><br><span class=\"line\">\t\t考察关键码的比较次数, 查找长度(search length)</span><br><span class=\"line\">\t&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class=\"line\">\t&gt;* 这个算法 = O(1.5logn)</span><br><span class=\"line\">\t\t向左节点 + 1, 向右节点 +2</span><br><span class=\"line\">\t\tn = 8</span><br><span class=\"line\">\t\t最好, 29/7 = 4+</span><br><span class=\"line\">\t\t最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">d2 有序向量: 二分查找</span><br><span class=\"line\"></span><br><span class=\"line\">\tVector::find(e, lo, hi);</span><br><span class=\"line\">\tVector::search(e, lo, hi);</span><br><span class=\"line\"></span><br><span class=\"line\">\t操作参数和接口语义类似。</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 统一接口</span><br><span class=\"line\">\t&gt;* ADT接口</span><br><span class=\"line\">\t======================== source code ==========================</span><br><span class=\"line\">\t// ADT接口</span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::srand(std::time(0));</span><br><span class=\"line\">\t\treturn (std::rand() % 2) ?</span><br><span class=\"line\">\t\t\tbinSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class=\"line\">\t\t\t: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\treturn lo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\tRank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\treturn lo;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t================================================================</span><br><span class=\"line\">\t可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 语义约定</span><br><span class=\"line\"></span><br><span class=\"line\">\t约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class=\"line\">\t&gt;* 优点: </span><br><span class=\"line\">\t\t维护自身 V.insert(1 + V.search(e), e)</span><br><span class=\"line\">\t\t\t即便是失败, 也给出插入新元素的位置。</span><br><span class=\"line\">\t\t\t若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 约点:</span><br><span class=\"line\">\t\t有序V[lo, hi), 不大于e的最后元素秩</span><br><span class=\"line\">\t\t-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class=\"line\">\t\tV[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class=\"line\">---------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 原理</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 减而治之</span><br><span class=\"line\">\t\t待查找区间分成三部分</span><br><span class=\"line\">\t\tS[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 三种比较情况</span><br><span class=\"line\">\t\te &lt; x: 左</span><br><span class=\"line\">\t\tx &lt; e: 右</span><br><span class=\"line\">\t\te = x: 命中             // 多个解?</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 二分(折半)策略</span><br><span class=\"line\">\t\t每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 实现</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t======= source code ======================================</span><br><span class=\"line\">\t\t// 二分查找: 版本A</span><br><span class=\"line\">\t\t/* my test code</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\tstd::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\tif (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class=\"line\">\t\t\t\tRank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class=\"line\">\t\t\t\tif (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class=\"line\">\t\t\t\tif (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class=\"line\">\t\t\t\t\treturn (binSearch(elem, e, lo, mi));</span><br><span class=\"line\">\t\t\t\t&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*/</span><br><span class=\"line\">\t\t==========================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 给出的版本</span><br><span class=\"line\">\t\t==================== source code ========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;    // 区间存在</span><br><span class=\"line\">\t\t\t\tRank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class=\"line\">\t\t\t\tif      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class=\"line\">\t\t\t\telse if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class=\"line\">\t\t\t\telse                   return mi;    // 在mi命中</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\treturn -1;   // 查找失败</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=========================================================</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 分析</span><br><span class=\"line\">\t\t1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class=\"line\">\t\t2, while循环通过hi, lo改变, 改变区间。</span><br><span class=\"line\">\t\t3, if...else 和 else...if什么差别？</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 技巧</span><br><span class=\"line\">\t\t善用 &quot;&lt;&quot; 比较</span><br><span class=\"line\">\t\t\t因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class=\"line\">-----------------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A: 实例与复杂度</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class=\"line\">\t&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class=\"line\">\t递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class=\"line\">--------------------------------------------------------------------------------------</span><br><span class=\"line\"># 版本A：查找长度</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 更为精细的评估算法性能:</span><br><span class=\"line\">\t\t考察关键码的比较次数, 查找长度(search length)</span><br><span class=\"line\">\t&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class=\"line\">\t&gt;* 这个算法 = O(1.5logn)</span><br><span class=\"line\">\t\t向左节点 + 1, 向右节点 +2</span><br><span class=\"line\">\t\tn = 8</span><br><span class=\"line\">\t\t最好, 29/7 = 4+</span><br><span class=\"line\">\t\t最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>\n"},{"title":"邓俊辉<<数据结构>>-公开课-02-D3","date":"2018-01-20T01:33:42.000Z","_content":"\n```\n(d3) 有序向量: Fibonacci查找\n\n1, 思路\n\t向左侧1次, 向右两次。\n\t表面平衡, 内部极大不平衡。\n\t比较次数不等, 递归深度却相等。\n\t\n\t左侧更深, 右侧更浅。\n\t递归深度不平衡, 对转向成本不同进行补偿。\n\t\n\t若 n = fib(k) - 1, 则mi = fib(k-1) - 1\n\t前向量fib(k-1) - 1, 后向量fib(k-2) - 1\n--------------------------------------------------------------------------------\n2, 实现\n\t>* 我的尝试, 定义fib类\n\t\t====== source code ====\n\t\t// ERROR:my test fib\n\t\t// 定义fibonacci相关的类\n\t\tclass Fib {\n\t\t\tint* _fib_lst; int _size;\n\t\t\tpublic:\n\t\t\t// 构造函数\n\t\t\texplicit Fib(const int n) : _size(n) {\n\t\t\t\temptyFib(n);\n\t\t\t\tfib(n-1, _fib_lst);\n\t\t\t}\n\t\t\t\n\t\t\t// 将数列置空\n\t\t\tvoid emptyFib(const int n) {\n\t\t\t\t// 初始化0\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t_fib_lst[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 生成fib数列\n\t\t\tint fib(const int n, int* _fib_lst) {\n\t\t\t\tif (_fib_lst[n] != 0) {\n\t\t\t\t\treturn _fib_lst[n];\n\t\t\t\t} else {\n\t\t\t\t\tif (n < 2) {_fib_lst[n] = n;} else {\n\t\t\t\t\t\t_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);\n\t\t\t\t\t\treturn _fib_lst[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 获得数列中某一索引的值\n\t\t\tint& get(const int& n) const {return _fib_lst[n];}\n\t\t\t\n\t\t\tint index(const int v) const {\n\t\t\t\t// 获得某一值在fib数列对应的索引\n\t\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\t\tif (v == _fib_lst[i]) return i;\n\t\t\t\t\tif (v < _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败\n\t\t\t\t}\n\t\t\t\treturn -1;    // 在扫描过程中没找到, 返回失败\n\t\t\t}\n\t\t\t\n\t\t\t// 打印数列\n\t\t\tvoid printFib() const {\n\t\t\t\tstd::cout << \"---- print fib series -----\\n\";\n\t\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\t\tstd::cout << i <<\": _fib_lst[i]\"\n\t\t\t\t\t\t<< _fib_lst[i] << std::endl;\t\n\t\t\t\t}\n\t\t\t\tstd::cout << \"_size = \" << _size << std::endl;\n\t\t\t}\n\t\t};\n\t\t==================================================\n\t\t运行总是溢出, 找不到出错位置。\n\t\t考虑先right, 后fast\n\n\t>* 根据课件的修改\n\t\t=================== source code ==========================\n\t\t// 定义fib相关的类\n\t\tclass Fib {\n\t\t\tint _size;\n\t\t\t\n\t\t\tpublic:\n\t\t\texplicit Fib(int n) : _size(n) {}\n\t\t\tint createFib(int n) {\n\t\t\t\treturn (2 > n) ? n: createFib(n-1) + createFib(n-2);\n\t\t\t}\n\t\t\t\n\t\t\t// 获得当前项\n\t\t\tint get() {\n\t\t\t\tint result = createFib(_size - 1);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t// 获得前一项\n\t\t\tint prev() {\n\t\t\t\tif (0 < _size - 1) {\n\t\t\t\tint result = createFib(--_size - 1);\n\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t};\n\t\t===========================================================\n\t\t先使用了低效的fib生成函数, 且不储存在一个list中。\n\t\t\n\t\t以及查找函数\n\t\t======================== source code ========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::fibSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\tFib fib(hi - lo);\n\t\t\twhile (lo < hi) {\n\t\t\t\twhile ((hi - lo) < fib.get()) fib.prev();\n\t\t\t\tint priv = lo + fib.get() - 1;\n\t\t\t\tif      (e < elem[priv]) hi = priv;\n\t\t\t\telse if (elem[priv] < e) lo = priv + 1;\n\t\t\t\telse                     return priv;\n\t\t\t}\n\t\t    return -1;\n\t\t}\n\t\t=============================================================\n\t\t本质是选择轴点不同。\n\t>* 改进fib类\n\t\t用动态规划求解fib数列中的某一项\n\t\t================= source code ==============================\n\t\tint createFib(int n) {\n\t\t\tint f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;\n\t\t\tif (n < 2) {int r = (n) ? g : f; return r;}\n\t\t\twhile (0 < n--) {\n\t\t\t\tg = g + f;\n\t\t\t\tf = g - f;\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\t===========================================================\n-----------------------------------------------------------------------------------\n3, 查找最优性\n\t>* 通用策略: \n\t\t对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 <= lambda < 1\n\t\t二分0.5, fibonacci对应lambda  = 0.6180339\n\t>* 递推式和微积分求极值\n\t\t这个...\n\t\t\n-------------------------------------------------------------------------------\n4, 总结\n\t这个算法花费很长时间去实现, 原因如下：\n\t\t1, 面向对象不理解, 为什么定义fib类\n\t\t2, 先选择了fast, not right\n```\n","source":"_posts/dsacpp/02-D3.md","raw":"---\ntitle: 邓俊辉<<数据结构>>-公开课-02-D3\ndate: 2018-01-20 09:33:42\ntags: 数据结构\n---\n\n```\n(d3) 有序向量: Fibonacci查找\n\n1, 思路\n\t向左侧1次, 向右两次。\n\t表面平衡, 内部极大不平衡。\n\t比较次数不等, 递归深度却相等。\n\t\n\t左侧更深, 右侧更浅。\n\t递归深度不平衡, 对转向成本不同进行补偿。\n\t\n\t若 n = fib(k) - 1, 则mi = fib(k-1) - 1\n\t前向量fib(k-1) - 1, 后向量fib(k-2) - 1\n--------------------------------------------------------------------------------\n2, 实现\n\t>* 我的尝试, 定义fib类\n\t\t====== source code ====\n\t\t// ERROR:my test fib\n\t\t// 定义fibonacci相关的类\n\t\tclass Fib {\n\t\t\tint* _fib_lst; int _size;\n\t\t\tpublic:\n\t\t\t// 构造函数\n\t\t\texplicit Fib(const int n) : _size(n) {\n\t\t\t\temptyFib(n);\n\t\t\t\tfib(n-1, _fib_lst);\n\t\t\t}\n\t\t\t\n\t\t\t// 将数列置空\n\t\t\tvoid emptyFib(const int n) {\n\t\t\t\t// 初始化0\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t_fib_lst[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// 生成fib数列\n\t\t\tint fib(const int n, int* _fib_lst) {\n\t\t\t\tif (_fib_lst[n] != 0) {\n\t\t\t\t\treturn _fib_lst[n];\n\t\t\t\t} else {\n\t\t\t\t\tif (n < 2) {_fib_lst[n] = n;} else {\n\t\t\t\t\t\t_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);\n\t\t\t\t\t\treturn _fib_lst[n];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 获得数列中某一索引的值\n\t\t\tint& get(const int& n) const {return _fib_lst[n];}\n\t\t\t\n\t\t\tint index(const int v) const {\n\t\t\t\t// 获得某一值在fib数列对应的索引\n\t\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\t\tif (v == _fib_lst[i]) return i;\n\t\t\t\t\tif (v < _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败\n\t\t\t\t}\n\t\t\t\treturn -1;    // 在扫描过程中没找到, 返回失败\n\t\t\t}\n\t\t\t\n\t\t\t// 打印数列\n\t\t\tvoid printFib() const {\n\t\t\t\tstd::cout << \"---- print fib series -----\\n\";\n\t\t\t\tfor (int i = 0; i < _size; i++) {\n\t\t\t\t\tstd::cout << i <<\": _fib_lst[i]\"\n\t\t\t\t\t\t<< _fib_lst[i] << std::endl;\t\n\t\t\t\t}\n\t\t\t\tstd::cout << \"_size = \" << _size << std::endl;\n\t\t\t}\n\t\t};\n\t\t==================================================\n\t\t运行总是溢出, 找不到出错位置。\n\t\t考虑先right, 后fast\n\n\t>* 根据课件的修改\n\t\t=================== source code ==========================\n\t\t// 定义fib相关的类\n\t\tclass Fib {\n\t\t\tint _size;\n\t\t\t\n\t\t\tpublic:\n\t\t\texplicit Fib(int n) : _size(n) {}\n\t\t\tint createFib(int n) {\n\t\t\t\treturn (2 > n) ? n: createFib(n-1) + createFib(n-2);\n\t\t\t}\n\t\t\t\n\t\t\t// 获得当前项\n\t\t\tint get() {\n\t\t\t\tint result = createFib(_size - 1);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t// 获得前一项\n\t\t\tint prev() {\n\t\t\t\tif (0 < _size - 1) {\n\t\t\t\tint result = createFib(--_size - 1);\n\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t};\n\t\t===========================================================\n\t\t先使用了低效的fib生成函数, 且不储存在一个list中。\n\t\t\n\t\t以及查找函数\n\t\t======================== source code ========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::fibSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\tFib fib(hi - lo);\n\t\t\twhile (lo < hi) {\n\t\t\t\twhile ((hi - lo) < fib.get()) fib.prev();\n\t\t\t\tint priv = lo + fib.get() - 1;\n\t\t\t\tif      (e < elem[priv]) hi = priv;\n\t\t\t\telse if (elem[priv] < e) lo = priv + 1;\n\t\t\t\telse                     return priv;\n\t\t\t}\n\t\t    return -1;\n\t\t}\n\t\t=============================================================\n\t\t本质是选择轴点不同。\n\t>* 改进fib类\n\t\t用动态规划求解fib数列中的某一项\n\t\t================= source code ==============================\n\t\tint createFib(int n) {\n\t\t\tint f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;\n\t\t\tif (n < 2) {int r = (n) ? g : f; return r;}\n\t\t\twhile (0 < n--) {\n\t\t\t\tg = g + f;\n\t\t\t\tf = g - f;\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\t===========================================================\n-----------------------------------------------------------------------------------\n3, 查找最优性\n\t>* 通用策略: \n\t\t对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 <= lambda < 1\n\t\t二分0.5, fibonacci对应lambda  = 0.6180339\n\t>* 递推式和微积分求极值\n\t\t这个...\n\t\t\n-------------------------------------------------------------------------------\n4, 总结\n\t这个算法花费很长时间去实现, 原因如下：\n\t\t1, 面向对象不理解, 为什么定义fib类\n\t\t2, 先选择了fast, not right\n```\n","slug":"dsacpp/02-D3","published":1,"updated":"2018-06-19T16:15:03.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydykz002fk8mfrrtn5u8e","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(d3) 有序向量: Fibonacci查找</span><br><span class=\"line\"></span><br><span class=\"line\">1, 思路</span><br><span class=\"line\">\t向左侧1次, 向右两次。</span><br><span class=\"line\">\t表面平衡, 内部极大不平衡。</span><br><span class=\"line\">\t比较次数不等, 递归深度却相等。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t左侧更深, 右侧更浅。</span><br><span class=\"line\">\t递归深度不平衡, 对转向成本不同进行补偿。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t若 n = fib(k) - 1, 则mi = fib(k-1) - 1</span><br><span class=\"line\">\t前向量fib(k-1) - 1, 后向量fib(k-2) - 1</span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\">2, 实现</span><br><span class=\"line\">\t&gt;* 我的尝试, 定义fib类</span><br><span class=\"line\">\t\t====== source code ====</span><br><span class=\"line\">\t\t// ERROR:my test fib</span><br><span class=\"line\">\t\t// 定义fibonacci相关的类</span><br><span class=\"line\">\t\tclass Fib &#123;</span><br><span class=\"line\">\t\t\tint* _fib_lst; int _size;</span><br><span class=\"line\">\t\t\tpublic:</span><br><span class=\"line\">\t\t\t// 构造函数</span><br><span class=\"line\">\t\t\texplicit Fib(const int n) : _size(n) &#123;</span><br><span class=\"line\">\t\t\t\temptyFib(n);</span><br><span class=\"line\">\t\t\t\tfib(n-1, _fib_lst);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 将数列置空</span><br><span class=\"line\">\t\t\tvoid emptyFib(const int n) &#123;</span><br><span class=\"line\">\t\t\t\t// 初始化0</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\t\t_fib_lst[i] = 0;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 生成fib数列</span><br><span class=\"line\">\t\t\tint fib(const int n, int* _fib_lst) &#123;</span><br><span class=\"line\">\t\t\t\tif (_fib_lst[n] != 0) &#123;</span><br><span class=\"line\">\t\t\t\t\treturn _fib_lst[n];</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tif (n &lt; 2) &#123;_fib_lst[n] = n;&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);</span><br><span class=\"line\">\t\t\t\t\t\treturn _fib_lst[n];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// 获得数列中某一索引的值</span><br><span class=\"line\">\t\t\tint&amp; get(const int&amp; n) const &#123;return _fib_lst[n];&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tint index(const int v) const &#123;</span><br><span class=\"line\">\t\t\t\t// 获得某一值在fib数列对应的索引</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (v == _fib_lst[i]) return i;</span><br><span class=\"line\">\t\t\t\t\tif (v &lt; _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn -1;    // 在扫描过程中没找到, 返回失败</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 打印数列</span><br><span class=\"line\">\t\t\tvoid printFib() const &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;---- print fib series -----\\n&quot;;</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\tstd::cout &lt;&lt; i &lt;&lt;&quot;: _fib_lst[i]&quot;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;&lt; _fib_lst[i] &lt;&lt; std::endl;\t</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;_size = &quot; &lt;&lt; _size &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t==================================================</span><br><span class=\"line\">\t\t运行总是溢出, 找不到出错位置。</span><br><span class=\"line\">\t\t考虑先right, 后fast</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 根据课件的修改</span><br><span class=\"line\">\t\t=================== source code ==========================</span><br><span class=\"line\">\t\t// 定义fib相关的类</span><br><span class=\"line\">\t\tclass Fib &#123;</span><br><span class=\"line\">\t\t\tint _size;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tpublic:</span><br><span class=\"line\">\t\t\texplicit Fib(int n) : _size(n) &#123;&#125;</span><br><span class=\"line\">\t\t\tint createFib(int n) &#123;</span><br><span class=\"line\">\t\t\t\treturn (2 &gt; n) ? n: createFib(n-1) + createFib(n-2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 获得当前项</span><br><span class=\"line\">\t\t\tint get() &#123;</span><br><span class=\"line\">\t\t\t\tint result = createFib(_size - 1);</span><br><span class=\"line\">\t\t\t\treturn result;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 获得前一项</span><br><span class=\"line\">\t\t\tint prev() &#123;</span><br><span class=\"line\">\t\t\t\tif (0 &lt; _size - 1) &#123;</span><br><span class=\"line\">\t\t\t\tint result = createFib(--_size - 1);</span><br><span class=\"line\">\t\t\t\treturn result;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn -1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t先使用了低效的fib生成函数, 且不储存在一个list中。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t以及查找函数</span><br><span class=\"line\">\t\t======================== source code ========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\tFib fib(hi - lo);</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;</span><br><span class=\"line\">\t\t\t\twhile ((hi - lo) &lt; fib.get()) fib.prev();</span><br><span class=\"line\">\t\t\t\tint priv = lo + fib.get() - 1;</span><br><span class=\"line\">\t\t\t\tif      (e &lt; elem[priv]) hi = priv;</span><br><span class=\"line\">\t\t\t\telse if (elem[priv] &lt; e) lo = priv + 1;</span><br><span class=\"line\">\t\t\t\telse                     return priv;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t    return -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t本质是选择轴点不同。</span><br><span class=\"line\">\t&gt;* 改进fib类</span><br><span class=\"line\">\t\t用动态规划求解fib数列中的某一项</span><br><span class=\"line\">\t\t================= source code ==============================</span><br><span class=\"line\">\t\tint createFib(int n) &#123;</span><br><span class=\"line\">\t\t\tint f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;</span><br><span class=\"line\">\t\t\tif (n &lt; 2) &#123;int r = (n) ? g : f; return r;&#125;</span><br><span class=\"line\">\t\t\twhile (0 &lt; n--) &#123;</span><br><span class=\"line\">\t\t\t\tg = g + f;</span><br><span class=\"line\">\t\t\t\tf = g - f;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn g;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">3, 查找最优性</span><br><span class=\"line\">\t&gt;* 通用策略: </span><br><span class=\"line\">\t\t对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 &lt;= lambda &lt; 1</span><br><span class=\"line\">\t\t二分0.5, fibonacci对应lambda  = 0.6180339</span><br><span class=\"line\">\t&gt;* 递推式和微积分求极值</span><br><span class=\"line\">\t\t这个...</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">4, 总结</span><br><span class=\"line\">\t这个算法花费很长时间去实现, 原因如下：</span><br><span class=\"line\">\t\t1, 面向对象不理解, 为什么定义fib类</span><br><span class=\"line\">\t\t2, 先选择了fast, not right</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(d3) 有序向量: Fibonacci查找</span><br><span class=\"line\"></span><br><span class=\"line\">1, 思路</span><br><span class=\"line\">\t向左侧1次, 向右两次。</span><br><span class=\"line\">\t表面平衡, 内部极大不平衡。</span><br><span class=\"line\">\t比较次数不等, 递归深度却相等。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t左侧更深, 右侧更浅。</span><br><span class=\"line\">\t递归深度不平衡, 对转向成本不同进行补偿。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t若 n = fib(k) - 1, 则mi = fib(k-1) - 1</span><br><span class=\"line\">\t前向量fib(k-1) - 1, 后向量fib(k-2) - 1</span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\">2, 实现</span><br><span class=\"line\">\t&gt;* 我的尝试, 定义fib类</span><br><span class=\"line\">\t\t====== source code ====</span><br><span class=\"line\">\t\t// ERROR:my test fib</span><br><span class=\"line\">\t\t// 定义fibonacci相关的类</span><br><span class=\"line\">\t\tclass Fib &#123;</span><br><span class=\"line\">\t\t\tint* _fib_lst; int _size;</span><br><span class=\"line\">\t\t\tpublic:</span><br><span class=\"line\">\t\t\t// 构造函数</span><br><span class=\"line\">\t\t\texplicit Fib(const int n) : _size(n) &#123;</span><br><span class=\"line\">\t\t\t\temptyFib(n);</span><br><span class=\"line\">\t\t\t\tfib(n-1, _fib_lst);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 将数列置空</span><br><span class=\"line\">\t\t\tvoid emptyFib(const int n) &#123;</span><br><span class=\"line\">\t\t\t\t// 初始化0</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\t\t\t_fib_lst[i] = 0;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 生成fib数列</span><br><span class=\"line\">\t\t\tint fib(const int n, int* _fib_lst) &#123;</span><br><span class=\"line\">\t\t\t\tif (_fib_lst[n] != 0) &#123;</span><br><span class=\"line\">\t\t\t\t\treturn _fib_lst[n];</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tif (n &lt; 2) &#123;_fib_lst[n] = n;&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\t\t_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);</span><br><span class=\"line\">\t\t\t\t\t\treturn _fib_lst[n];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// 获得数列中某一索引的值</span><br><span class=\"line\">\t\t\tint&amp; get(const int&amp; n) const &#123;return _fib_lst[n];&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tint index(const int v) const &#123;</span><br><span class=\"line\">\t\t\t\t// 获得某一值在fib数列对应的索引</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (v == _fib_lst[i]) return i;</span><br><span class=\"line\">\t\t\t\t\tif (v &lt; _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn -1;    // 在扫描过程中没找到, 返回失败</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 打印数列</span><br><span class=\"line\">\t\t\tvoid printFib() const &#123;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;---- print fib series -----\\n&quot;;</span><br><span class=\"line\">\t\t\t\tfor (int i = 0; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\tstd::cout &lt;&lt; i &lt;&lt;&quot;: _fib_lst[i]&quot;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;&lt; _fib_lst[i] &lt;&lt; std::endl;\t</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; &quot;_size = &quot; &lt;&lt; _size &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t==================================================</span><br><span class=\"line\">\t\t运行总是溢出, 找不到出错位置。</span><br><span class=\"line\">\t\t考虑先right, 后fast</span><br><span class=\"line\"></span><br><span class=\"line\">\t&gt;* 根据课件的修改</span><br><span class=\"line\">\t\t=================== source code ==========================</span><br><span class=\"line\">\t\t// 定义fib相关的类</span><br><span class=\"line\">\t\tclass Fib &#123;</span><br><span class=\"line\">\t\t\tint _size;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tpublic:</span><br><span class=\"line\">\t\t\texplicit Fib(int n) : _size(n) &#123;&#125;</span><br><span class=\"line\">\t\t\tint createFib(int n) &#123;</span><br><span class=\"line\">\t\t\t\treturn (2 &gt; n) ? n: createFib(n-1) + createFib(n-2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 获得当前项</span><br><span class=\"line\">\t\t\tint get() &#123;</span><br><span class=\"line\">\t\t\t\tint result = createFib(_size - 1);</span><br><span class=\"line\">\t\t\t\treturn result;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t// 获得前一项</span><br><span class=\"line\">\t\t\tint prev() &#123;</span><br><span class=\"line\">\t\t\t\tif (0 &lt; _size - 1) &#123;</span><br><span class=\"line\">\t\t\t\tint result = createFib(--_size - 1);</span><br><span class=\"line\">\t\t\t\treturn result;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\treturn -1;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t先使用了低效的fib生成函数, 且不储存在一个list中。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t以及查找函数</span><br><span class=\"line\">\t\t======================== source code ========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\tFib fib(hi - lo);</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;</span><br><span class=\"line\">\t\t\t\twhile ((hi - lo) &lt; fib.get()) fib.prev();</span><br><span class=\"line\">\t\t\t\tint priv = lo + fib.get() - 1;</span><br><span class=\"line\">\t\t\t\tif      (e &lt; elem[priv]) hi = priv;</span><br><span class=\"line\">\t\t\t\telse if (elem[priv] &lt; e) lo = priv + 1;</span><br><span class=\"line\">\t\t\t\telse                     return priv;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t    return -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t\t本质是选择轴点不同。</span><br><span class=\"line\">\t&gt;* 改进fib类</span><br><span class=\"line\">\t\t用动态规划求解fib数列中的某一项</span><br><span class=\"line\">\t\t================= source code ==============================</span><br><span class=\"line\">\t\tint createFib(int n) &#123;</span><br><span class=\"line\">\t\t\tint f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;</span><br><span class=\"line\">\t\t\tif (n &lt; 2) &#123;int r = (n) ? g : f; return r;&#125;</span><br><span class=\"line\">\t\t\twhile (0 &lt; n--) &#123;</span><br><span class=\"line\">\t\t\t\tg = g + f;</span><br><span class=\"line\">\t\t\t\tf = g - f;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn g;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">-----------------------------------------------------------------------------------</span><br><span class=\"line\">3, 查找最优性</span><br><span class=\"line\">\t&gt;* 通用策略: </span><br><span class=\"line\">\t\t对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 &lt;= lambda &lt; 1</span><br><span class=\"line\">\t\t二分0.5, fibonacci对应lambda  = 0.6180339</span><br><span class=\"line\">\t&gt;* 递推式和微积分求极值</span><br><span class=\"line\">\t\t这个...</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">-------------------------------------------------------------------------------</span><br><span class=\"line\">4, 总结</span><br><span class=\"line\">\t这个算法花费很长时间去实现, 原因如下：</span><br><span class=\"line\">\t\t1, 面向对象不理解, 为什么定义fib类</span><br><span class=\"line\">\t\t2, 先选择了fast, not right</span><br></pre></td></tr></table></figure>\n"},{"title":"02-D4","date":"2018-01-21T06:05:05.000Z","_content":"```\n(d4) 有序向量: 二分查找(改进)\n-----------------------------\n\n# 版本B, 改进思路:\n\t>* 左右转向成本平衡：\n\t\t无论向左还是向右进行一次比较。\n\t\n\t>* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半\n\t\t1, e <  x: e若存在则在左侧子区间S[lo, mi), 可递归深入\n\t\t2, x <= e: e若存在则在右侧子区间S[mi, hi), 可递归深入\n\t\t只有当hi - lo = 1时, 判断元素是否命中。\n\t\t\n# 实现:\n\t>* 我的尝试\n\t\t=========================  source code =======================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\t// 二分平衡查找算法\n\t\t\twhile (1 < hi - lo) {\n\t\t\t\tint mi = (lo + hi) >> 1;          // 轴点为中点\n\t\t\t\tif (e < elem[mi]) hi = mi;        // 深入左区间\n\t\t\t\telse if (elem[mi] <= e) lo = mi;  // 深入右区间\n\t\t\t}\n\t\t\t// hi - lo == 1, 判断当前元素是否命中\n\t\t\tif (e == elem[lo]) return lo;\n\t\t\telse               return -1;\n\t\t}\n\t\t===========================================================\n\t\t思路上无问题, 但代码可以简化。\n\t\t\n\t>* 更为简洁的写法\n\t\t=====\n\t    template <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, const T& e, Rank lo, Rank hi) const {\n\t\t\twhile (1 < hi - lo) {\n\t\t\tint mi = (lo + hi) >> 1;               // 轴点为中点\n\t\t\t(e < elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入\n\t\t\t}    // 退出循环时, 区间长度1, elem[lo]为有效元素\n\t\t\treturn (e == elem[lo])? lo: -1;\n\t\t}        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)\n\t\t====\n\t\t\n\t\t1, 两种情况if...else 用以下代替\n\t\t\t(cond)? expr1 : expr2;\n\t\t2, 在其中使用返回语句\n\t\t\t(cond) ? return expr1 : return expr2;    // ERROR!!\n\t\t\treturn (cond) ? expr1 : expr2;           // Right!!\n----------------------------------------------------------------------------------\n\n# 语义约定\n\t>* 为什么要语义约定?\n\t\t便于其他高阶操作的调用。\n\t\tv.insert(1 + search(e, lo, hi), e);\n\t\t\t：在找到元素索引的下个索引处插入。\n\t\n\t>* 思路\n\t\t1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)\n\t\t2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])\n\t\n\t>* 实现, 版本C\n\t\t>* 我的尝试\n\t\t将原来的 return (e == elem[lo]) ? lo : -1; 改为:\n\t\t============= source code ============================\n\t\tif (e == elem[lo]) {  // 存在匹配\n\t\t\twhile (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩\n\t\t\treturn lo;\n\t\t} else {  // 无匹配\n\t\t\treturn (e < elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩\n\t\t}\n\t\t=======================================================\n\t\t一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩\n\t\t\n\t\t>* 更优解\n\t\t==================== source code ===========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, const T& e, Rank lo, Rank hi) const {\n\t\t\twhile (lo < hi) {  // 区间缩短至0\n\t\t\t\tint mi = (lo + hi) >> 1;                   // 轴点为中点\n\t\t\t\t(e < elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)\n\t\t\t}    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素\n\t\t\treturn --lo;    // 故lo-1 为不大于e的最大秩\n\t\t}      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)\n\t\t=============================================================\n\t\n\t>* 更优解实现分析\n\t\t>* 差别\n\t\t\t1, 循环结束区间宽度0, 而非1\n\t\t\t2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?\n\t\t\t3, 无论成功与否, 返回秩序严格符合定义的语义接口。\n\t\t\t4, 和我的实现比起来, 无需多余的while和if判断\n----------------------------------------------------------------------------------\n\n# 版本C, 正确性:\n\t>* 不变性:\n\t\tA[0, lo) <= e < A[hi, n)          // A[hi] 总是大于e的最小者\n\t>* 初始\n\t\tlo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立\n\t>* 数学归纳两种情况,\n\t\t这两种情况不是很清楚。以后可以回过头来看看。\n\t\t\n\n```\n","source":"_posts/dsacpp/02-D4.md","raw":"---\ntitle: 02-D4\ndate: 2018-01-21 14:05:05\ntags: 数据结构\n---\n```\n(d4) 有序向量: 二分查找(改进)\n-----------------------------\n\n# 版本B, 改进思路:\n\t>* 左右转向成本平衡：\n\t\t无论向左还是向右进行一次比较。\n\t\n\t>* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半\n\t\t1, e <  x: e若存在则在左侧子区间S[lo, mi), 可递归深入\n\t\t2, x <= e: e若存在则在右侧子区间S[mi, hi), 可递归深入\n\t\t只有当hi - lo = 1时, 判断元素是否命中。\n\t\t\n# 实现:\n\t>* 我的尝试\n\t\t=========================  source code =======================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, T const& e, Rank lo, Rank hi) const {\n\t\t\t// 二分平衡查找算法\n\t\t\twhile (1 < hi - lo) {\n\t\t\t\tint mi = (lo + hi) >> 1;          // 轴点为中点\n\t\t\t\tif (e < elem[mi]) hi = mi;        // 深入左区间\n\t\t\t\telse if (elem[mi] <= e) lo = mi;  // 深入右区间\n\t\t\t}\n\t\t\t// hi - lo == 1, 判断当前元素是否命中\n\t\t\tif (e == elem[lo]) return lo;\n\t\t\telse               return -1;\n\t\t}\n\t\t===========================================================\n\t\t思路上无问题, 但代码可以简化。\n\t\t\n\t>* 更为简洁的写法\n\t\t=====\n\t    template <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, const T& e, Rank lo, Rank hi) const {\n\t\t\twhile (1 < hi - lo) {\n\t\t\tint mi = (lo + hi) >> 1;               // 轴点为中点\n\t\t\t(e < elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入\n\t\t\t}    // 退出循环时, 区间长度1, elem[lo]为有效元素\n\t\t\treturn (e == elem[lo])? lo: -1;\n\t\t}        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)\n\t\t====\n\t\t\n\t\t1, 两种情况if...else 用以下代替\n\t\t\t(cond)? expr1 : expr2;\n\t\t2, 在其中使用返回语句\n\t\t\t(cond) ? return expr1 : return expr2;    // ERROR!!\n\t\t\treturn (cond) ? expr1 : expr2;           // Right!!\n----------------------------------------------------------------------------------\n\n# 语义约定\n\t>* 为什么要语义约定?\n\t\t便于其他高阶操作的调用。\n\t\tv.insert(1 + search(e, lo, hi), e);\n\t\t\t：在找到元素索引的下个索引处插入。\n\t\n\t>* 思路\n\t\t1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)\n\t\t2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])\n\t\n\t>* 实现, 版本C\n\t\t>* 我的尝试\n\t\t将原来的 return (e == elem[lo]) ? lo : -1; 改为:\n\t\t============= source code ============================\n\t\tif (e == elem[lo]) {  // 存在匹配\n\t\t\twhile (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩\n\t\t\treturn lo;\n\t\t} else {  // 无匹配\n\t\t\treturn (e < elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩\n\t\t}\n\t\t=======================================================\n\t\t一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩\n\t\t\n\t\t>* 更优解\n\t\t==================== source code ===========================\n\t\ttemplate <typename T>\n\t\tRank Vector<T>::binBlcSearch(T* elem, const T& e, Rank lo, Rank hi) const {\n\t\t\twhile (lo < hi) {  // 区间缩短至0\n\t\t\t\tint mi = (lo + hi) >> 1;                   // 轴点为中点\n\t\t\t\t(e < elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)\n\t\t\t}    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素\n\t\t\treturn --lo;    // 故lo-1 为不大于e的最大秩\n\t\t}      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)\n\t\t=============================================================\n\t\n\t>* 更优解实现分析\n\t\t>* 差别\n\t\t\t1, 循环结束区间宽度0, 而非1\n\t\t\t2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?\n\t\t\t3, 无论成功与否, 返回秩序严格符合定义的语义接口。\n\t\t\t4, 和我的实现比起来, 无需多余的while和if判断\n----------------------------------------------------------------------------------\n\n# 版本C, 正确性:\n\t>* 不变性:\n\t\tA[0, lo) <= e < A[hi, n)          // A[hi] 总是大于e的最小者\n\t>* 初始\n\t\tlo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立\n\t>* 数学归纳两种情况,\n\t\t这两种情况不是很清楚。以后可以回过头来看看。\n\t\t\n\n```\n","slug":"dsacpp/02-D4","published":1,"updated":"2018-06-19T16:15:03.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyl0002gk8mf13cfbflq","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(d4) 有序向量: 二分查找(改进)</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 版本B, 改进思路:</span><br><span class=\"line\">\t&gt;* 左右转向成本平衡：</span><br><span class=\"line\">\t\t无论向左还是向右进行一次比较。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半</span><br><span class=\"line\">\t\t1, e &lt;  x: e若存在则在左侧子区间S[lo, mi), 可递归深入</span><br><span class=\"line\">\t\t2, x &lt;= e: e若存在则在右侧子区间S[mi, hi), 可递归深入</span><br><span class=\"line\">\t\t只有当hi - lo = 1时, 判断元素是否命中。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"># 实现:</span><br><span class=\"line\">\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t=========================  source code =======================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\t// 二分平衡查找算法</span><br><span class=\"line\">\t\t\twhile (1 &lt; hi - lo) &#123;</span><br><span class=\"line\">\t\t\t\tint mi = (lo + hi) &gt;&gt; 1;          // 轴点为中点</span><br><span class=\"line\">\t\t\t\tif (e &lt; elem[mi]) hi = mi;        // 深入左区间</span><br><span class=\"line\">\t\t\t\telse if (elem[mi] &lt;= e) lo = mi;  // 深入右区间</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// hi - lo == 1, 判断当前元素是否命中</span><br><span class=\"line\">\t\t\tif (e == elem[lo]) return lo;</span><br><span class=\"line\">\t\t\telse               return -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t思路上无问题, 但代码可以简化。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 更为简洁的写法</span><br><span class=\"line\">\t\t=====</span><br><span class=\"line\">\t    template &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (1 &lt; hi - lo) &#123;</span><br><span class=\"line\">\t\t\tint mi = (lo + hi) &gt;&gt; 1;               // 轴点为中点</span><br><span class=\"line\">\t\t\t(e &lt; elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入</span><br><span class=\"line\">\t\t\t&#125;    // 退出循环时, 区间长度1, elem[lo]为有效元素</span><br><span class=\"line\">\t\t\treturn (e == elem[lo])? lo: -1;</span><br><span class=\"line\">\t\t&#125;        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class=\"line\">\t\t====</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t1, 两种情况if...else 用以下代替</span><br><span class=\"line\">\t\t\t(cond)? expr1 : expr2;</span><br><span class=\"line\">\t\t2, 在其中使用返回语句</span><br><span class=\"line\">\t\t\t(cond) ? return expr1 : return expr2;    // ERROR!!</span><br><span class=\"line\">\t\t\treturn (cond) ? expr1 : expr2;           // Right!!</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 语义约定</span><br><span class=\"line\">\t&gt;* 为什么要语义约定?</span><br><span class=\"line\">\t\t便于其他高阶操作的调用。</span><br><span class=\"line\">\t\tv.insert(1 + search(e, lo, hi), e);</span><br><span class=\"line\">\t\t\t：在找到元素索引的下个索引处插入。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 思路</span><br><span class=\"line\">\t\t1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)</span><br><span class=\"line\">\t\t2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 实现, 版本C</span><br><span class=\"line\">\t\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t将原来的 return (e == elem[lo]) ? lo : -1; 改为:</span><br><span class=\"line\">\t\t============= source code ============================</span><br><span class=\"line\">\t\tif (e == elem[lo]) &#123;  // 存在匹配</span><br><span class=\"line\">\t\t\twhile (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩</span><br><span class=\"line\">\t\t\treturn lo;</span><br><span class=\"line\">\t\t&#125; else &#123;  // 无匹配</span><br><span class=\"line\">\t\t\treturn (e &lt; elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=======================================================</span><br><span class=\"line\">\t\t一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&gt;* 更优解</span><br><span class=\"line\">\t\t==================== source code ===========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;  // 区间缩短至0</span><br><span class=\"line\">\t\t\t\tint mi = (lo + hi) &gt;&gt; 1;                   // 轴点为中点</span><br><span class=\"line\">\t\t\t\t(e &lt; elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)</span><br><span class=\"line\">\t\t\t&#125;    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素</span><br><span class=\"line\">\t\t\treturn --lo;    // 故lo-1 为不大于e的最大秩</span><br><span class=\"line\">\t\t&#125;      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 更优解实现分析</span><br><span class=\"line\">\t\t&gt;* 差别</span><br><span class=\"line\">\t\t\t1, 循环结束区间宽度0, 而非1</span><br><span class=\"line\">\t\t\t2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?</span><br><span class=\"line\">\t\t\t3, 无论成功与否, 返回秩序严格符合定义的语义接口。</span><br><span class=\"line\">\t\t\t4, 和我的实现比起来, 无需多余的while和if判断</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 版本C, 正确性:</span><br><span class=\"line\">\t&gt;* 不变性:</span><br><span class=\"line\">\t\tA[0, lo) &lt;= e &lt; A[hi, n)          // A[hi] 总是大于e的最小者</span><br><span class=\"line\">\t&gt;* 初始</span><br><span class=\"line\">\t\tlo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立</span><br><span class=\"line\">\t&gt;* 数学归纳两种情况,</span><br><span class=\"line\">\t\t这两种情况不是很清楚。以后可以回过头来看看。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(d4) 有序向量: 二分查找(改进)</span><br><span class=\"line\">-----------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 版本B, 改进思路:</span><br><span class=\"line\">\t&gt;* 左右转向成本平衡：</span><br><span class=\"line\">\t\t无论向左还是向右进行一次比较。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半</span><br><span class=\"line\">\t\t1, e &lt;  x: e若存在则在左侧子区间S[lo, mi), 可递归深入</span><br><span class=\"line\">\t\t2, x &lt;= e: e若存在则在右侧子区间S[mi, hi), 可递归深入</span><br><span class=\"line\">\t\t只有当hi - lo = 1时, 判断元素是否命中。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"># 实现:</span><br><span class=\"line\">\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t=========================  source code =======================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\t// 二分平衡查找算法</span><br><span class=\"line\">\t\t\twhile (1 &lt; hi - lo) &#123;</span><br><span class=\"line\">\t\t\t\tint mi = (lo + hi) &gt;&gt; 1;          // 轴点为中点</span><br><span class=\"line\">\t\t\t\tif (e &lt; elem[mi]) hi = mi;        // 深入左区间</span><br><span class=\"line\">\t\t\t\telse if (elem[mi] &lt;= e) lo = mi;  // 深入右区间</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t// hi - lo == 1, 判断当前元素是否命中</span><br><span class=\"line\">\t\t\tif (e == elem[lo]) return lo;</span><br><span class=\"line\">\t\t\telse               return -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t===========================================================</span><br><span class=\"line\">\t\t思路上无问题, 但代码可以简化。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&gt;* 更为简洁的写法</span><br><span class=\"line\">\t\t=====</span><br><span class=\"line\">\t    template &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (1 &lt; hi - lo) &#123;</span><br><span class=\"line\">\t\t\tint mi = (lo + hi) &gt;&gt; 1;               // 轴点为中点</span><br><span class=\"line\">\t\t\t(e &lt; elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入</span><br><span class=\"line\">\t\t\t&#125;    // 退出循环时, 区间长度1, elem[lo]为有效元素</span><br><span class=\"line\">\t\t\treturn (e == elem[lo])? lo: -1;</span><br><span class=\"line\">\t\t&#125;        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class=\"line\">\t\t====</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t1, 两种情况if...else 用以下代替</span><br><span class=\"line\">\t\t\t(cond)? expr1 : expr2;</span><br><span class=\"line\">\t\t2, 在其中使用返回语句</span><br><span class=\"line\">\t\t\t(cond) ? return expr1 : return expr2;    // ERROR!!</span><br><span class=\"line\">\t\t\treturn (cond) ? expr1 : expr2;           // Right!!</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 语义约定</span><br><span class=\"line\">\t&gt;* 为什么要语义约定?</span><br><span class=\"line\">\t\t便于其他高阶操作的调用。</span><br><span class=\"line\">\t\tv.insert(1 + search(e, lo, hi), e);</span><br><span class=\"line\">\t\t\t：在找到元素索引的下个索引处插入。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 思路</span><br><span class=\"line\">\t\t1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)</span><br><span class=\"line\">\t\t2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 实现, 版本C</span><br><span class=\"line\">\t\t&gt;* 我的尝试</span><br><span class=\"line\">\t\t将原来的 return (e == elem[lo]) ? lo : -1; 改为:</span><br><span class=\"line\">\t\t============= source code ============================</span><br><span class=\"line\">\t\tif (e == elem[lo]) &#123;  // 存在匹配</span><br><span class=\"line\">\t\t\twhile (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩</span><br><span class=\"line\">\t\t\treturn lo;</span><br><span class=\"line\">\t\t&#125; else &#123;  // 无匹配</span><br><span class=\"line\">\t\t\treturn (e &lt; elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=======================================================</span><br><span class=\"line\">\t\t一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&gt;* 更优解</span><br><span class=\"line\">\t\t==================== source code ===========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tRank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class=\"line\">\t\t\twhile (lo &lt; hi) &#123;  // 区间缩短至0</span><br><span class=\"line\">\t\t\t\tint mi = (lo + hi) &gt;&gt; 1;                   // 轴点为中点</span><br><span class=\"line\">\t\t\t\t(e &lt; elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)</span><br><span class=\"line\">\t\t\t&#125;    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素</span><br><span class=\"line\">\t\t\treturn --lo;    // 故lo-1 为不大于e的最大秩</span><br><span class=\"line\">\t\t&#125;      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&gt;* 更优解实现分析</span><br><span class=\"line\">\t\t&gt;* 差别</span><br><span class=\"line\">\t\t\t1, 循环结束区间宽度0, 而非1</span><br><span class=\"line\">\t\t\t2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?</span><br><span class=\"line\">\t\t\t3, 无论成功与否, 返回秩序严格符合定义的语义接口。</span><br><span class=\"line\">\t\t\t4, 和我的实现比起来, 无需多余的while和if判断</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 版本C, 正确性:</span><br><span class=\"line\">\t&gt;* 不变性:</span><br><span class=\"line\">\t\tA[0, lo) &lt;= e &lt; A[hi, n)          // A[hi] 总是大于e的最小者</span><br><span class=\"line\">\t&gt;* 初始</span><br><span class=\"line\">\t\tlo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立</span><br><span class=\"line\">\t&gt;* 数学归纳两种情况,</span><br><span class=\"line\">\t\t这两种情况不是很清楚。以后可以回过头来看看。</span><br></pre></td></tr></table></figure>\n"},{"title":"02-E","date":"2018-01-21T14:36:05.000Z","_content":"```\n(e) 起泡排序\n为了使得向量有序, 要对向量进行排序。\n\n# 排序器, ADT 统一入口:\n\t>* 实现\n\t\t====================== source code ===========================\n\t\ttemplate <typename T>\n\t\tvoid Vector<T>::sort(Rank lo, Rank hi) {\n\t\t\tint i = 1;\n\t\t\tswitch (i) {\n\t\t\t\tcase 1: bubbleSort(lo, hi); break;     // 起泡排序\n\t\t\t\tcase 2: selectionSort(lo, hi); break;  // 选择排序(习题)\n\t\t\t\tcase 3: mergeSort(lo, hi); break;      // 归并排序\n\t\t\t\tcase 4: heapSort(lo, hi); break;       // 堆排序(ch 10)\n\t\t\t\tdefault: quickSort(lo, hi); break;     // 快速排序(12)\n\t\t\t}\n\t\t}\n\t\t=============================================================\n----------------------------------------------------------------------------------\n\n# 起泡排序\n\t>* 改进思路\n\t\t未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。\n\t\t在上一趟扫描中, 记录有序对\n\n\n```\n","source":"_posts/dsacpp/02-E.md","raw":"---\ntitle: 02-E\ndate: 2018-01-21 22:36:05\ntags: 数据结构\n---\n```\n(e) 起泡排序\n为了使得向量有序, 要对向量进行排序。\n\n# 排序器, ADT 统一入口:\n\t>* 实现\n\t\t====================== source code ===========================\n\t\ttemplate <typename T>\n\t\tvoid Vector<T>::sort(Rank lo, Rank hi) {\n\t\t\tint i = 1;\n\t\t\tswitch (i) {\n\t\t\t\tcase 1: bubbleSort(lo, hi); break;     // 起泡排序\n\t\t\t\tcase 2: selectionSort(lo, hi); break;  // 选择排序(习题)\n\t\t\t\tcase 3: mergeSort(lo, hi); break;      // 归并排序\n\t\t\t\tcase 4: heapSort(lo, hi); break;       // 堆排序(ch 10)\n\t\t\t\tdefault: quickSort(lo, hi); break;     // 快速排序(12)\n\t\t\t}\n\t\t}\n\t\t=============================================================\n----------------------------------------------------------------------------------\n\n# 起泡排序\n\t>* 改进思路\n\t\t未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。\n\t\t在上一趟扫描中, 记录有序对\n\n\n```\n","slug":"dsacpp/02-E","published":1,"updated":"2018-06-19T16:15:03.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyl3002ik8mfapsorf97","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(e) 起泡排序</span><br><span class=\"line\">为了使得向量有序, 要对向量进行排序。</span><br><span class=\"line\"></span><br><span class=\"line\"># 排序器, ADT 统一入口:</span><br><span class=\"line\">\t&gt;* 实现</span><br><span class=\"line\">\t\t====================== source code ===========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tvoid Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123;</span><br><span class=\"line\">\t\t\tint i = 1;</span><br><span class=\"line\">\t\t\tswitch (i) &#123;</span><br><span class=\"line\">\t\t\t\tcase 1: bubbleSort(lo, hi); break;     // 起泡排序</span><br><span class=\"line\">\t\t\t\tcase 2: selectionSort(lo, hi); break;  // 选择排序(习题)</span><br><span class=\"line\">\t\t\t\tcase 3: mergeSort(lo, hi); break;      // 归并排序</span><br><span class=\"line\">\t\t\t\tcase 4: heapSort(lo, hi); break;       // 堆排序(ch 10)</span><br><span class=\"line\">\t\t\t\tdefault: quickSort(lo, hi); break;     // 快速排序(12)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 起泡排序</span><br><span class=\"line\">\t&gt;* 改进思路</span><br><span class=\"line\">\t\t未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。</span><br><span class=\"line\">\t\t在上一趟扫描中, 记录有序对</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(e) 起泡排序</span><br><span class=\"line\">为了使得向量有序, 要对向量进行排序。</span><br><span class=\"line\"></span><br><span class=\"line\"># 排序器, ADT 统一入口:</span><br><span class=\"line\">\t&gt;* 实现</span><br><span class=\"line\">\t\t====================== source code ===========================</span><br><span class=\"line\">\t\ttemplate &lt;typename T&gt;</span><br><span class=\"line\">\t\tvoid Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123;</span><br><span class=\"line\">\t\t\tint i = 1;</span><br><span class=\"line\">\t\t\tswitch (i) &#123;</span><br><span class=\"line\">\t\t\t\tcase 1: bubbleSort(lo, hi); break;     // 起泡排序</span><br><span class=\"line\">\t\t\t\tcase 2: selectionSort(lo, hi); break;  // 选择排序(习题)</span><br><span class=\"line\">\t\t\t\tcase 3: mergeSort(lo, hi); break;      // 归并排序</span><br><span class=\"line\">\t\t\t\tcase 4: heapSort(lo, hi); break;       // 堆排序(ch 10)</span><br><span class=\"line\">\t\t\t\tdefault: quickSort(lo, hi); break;     // 快速排序(12)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t=============================================================</span><br><span class=\"line\">----------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"># 起泡排序</span><br><span class=\"line\">\t&gt;* 改进思路</span><br><span class=\"line\">\t\t未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。</span><br><span class=\"line\">\t\t在上一趟扫描中, 记录有序对</span><br></pre></td></tr></table></figure>\n"},{"title":"冬至的一点光亮","date":"2017-12-22T15:30:00.000Z","_content":"\n今日冬至，晒太阳翻了翻<<鸟哥的Linux入门>>，通读了一遍，了解结构为后续学习挑出主次。中午找S交谈OpenGL相关问题，当然不止于此。有几点收获:\n1, 学习底层知识，少学习容易过时的知识。我引用Quora上得到的回答，对自己目前的状态做一个反思:\"Are you good at object-oriented programming? C? The Unix tools? Have you taken discrete math? A course in computer systems?\"\n2, 不轻易做一个计划，做一个计划不轻易放弃。我对什么事情都感兴趣，什么都想玩一玩，但是如果不把一项技术学精，虎头蛇尾，是一种空言壮志的表现。S举例了我从GH, Python, 计算几何, C++, Flask, OpenGL等计划, 当然我知道还有其他, 说明我容易循着一条轨迹向下寻溯。但时未兴，我无法准确判断计划的可靠性。\n3, 不把当下决定看得太重。对于那些无所事事的人，他们要减少对时间的浪费;对于我，浪费的时间反而有意义的。浪费与否，学习哪条方向, 都是一种经历。不能陷入到对未知的结果的忧虑当中去，要承认对未知的复杂性。\n4, 捡最近的镜子。满地镜子看花眼睛时候，找最近的镜子。对S来说，数字化的最近镜子是学生；他如此提醒我，想必是要说，我最近的镜子，应该是我的同学和S。但是什么是技术的最近的镜子呢？数据结构，图形，游戏。也许。\n\n冬至夜， 按照去年留下的习俗， 和朋友约一起煮火锅下水饺和汤圆。吃得也饱，聊得也欢快。\n\n其他人陆陆续续的去忙别的事情，只剩下X，H和我。话题的起因是老生常谈，女孩。我看上去是个优胜者，他们两个向我请教。给出了一些符合xu逻辑的方法,\n1, 列出关于学校集体活动的一个list;\n2, 将每个活动的具体形式考量一遍;\n3, 加入该活动的方式;\n4, 可能会出现的几个状况;\n5, 综合考量后排序挑选前5个活动参加。\n因为，前前后后也跟X讲了好多次，没有什么实际行动，我想，问题可能出在，我总是讲具体跟女孩的交流方式，其实这是因人而异的，刻意的追求结果未必是好。但作为前馈数据，需要的大概是接触到更多人的环境，让他自己在这个环境中摸爬。希望这大概能够好些。\n\n聊完这个，便聊第二个老生常谈，但并未透彻的话题，体制。重新思考话题展开的原因相对来说比较有意义，是探索一种启蒙的模型。这个话题能够展开，总得来讲，出于对当下以及未来的困惑，我尝试分开来讲几点原因，\n1, 计算机科学自下而上的思维模式，撼动原有的自上而下的体系。这其中差异，看上去是从技术角度出发，却渗透到经济，结构，体制，文化，人性等各个方面。\n2, 怀有对资社的不充分理解和想要探求的心理状态。\n3, 评论和试图解决遇到的问题，寻求一种生活的模型。\n\nX先提出了对该体制是否会倒塌的质疑，我觉得这个问题好回答，但也不好回答，确实凭借我的认知还无法解释清楚，能够解释清楚的人大多也都别有用心。我但是从我的数据库中索引出来一些，但凌晨四点睡去醒来后，又作了些思考。\n\n人一般走上畸路的过程分成几个阶段，先是犯错误，错误带来不良后果，判断他没救的依据是，依旧不改正错误，后果没得到解决。道理是相同的。\n\n错误性体现在，社会主义相对于资本主义的乌托邦本质。共产主义，当财富是大家共有的时候，谁来决定财富的分配？能够决定分配的人，势必会有权力。如果该掌权者是一个大公无私的，理性智慧的人，大家能够得到平等的分配。这看上去很对，能够实现。但却忽略了一个关键的事实，人性是有阴暗面的，是有私心的。这种私心若是顺其自然的发展，以共同利益为由，是能够孕育出灿烂果实的；有趣的是，但若想消除这种私心，这种私心就被放大了，因为看上去大家都不存在私心了，但消除别人私心的行为本身就是一种私心，说这是私心温和了些，应该说是恶，然而这种恶会被不断的累积和放大，因此，在最高位置上的伟大领袖，或许并非那么伟大。\n\n那么后果是什么？总体上讲是系统内耗造成的资源短缺。这种框架下，势必一切会向权力看。人们会为了生存而追求利益，而追求利益的竞争在这个情况下，又转变成了为追逐权力而努力竞争。值得一提的是，生存是第一要义。竞争是必要的，但除了竞争之外还有合作；利益是必要的，但除了利益之外还有共同利益；追逐地位是必要的，但地位的来源不是唯一的来自于权力和财富。\n\n这种追求利益的方式，产生了第一种后果，其实就是系统内耗。拿我熟悉的高等教育举例子，真正想做科研的教授，他势必不想将时间浪费在这一内耗上，但是不进行这种内耗他便得不到科研经费，科研没有开始就已经结束。然而，也许有人会说，教授你只要忍受一下，便可以开始真正的科研，但事实情况是这样:1, 一旦进行了一次这样的内耗，他会找你第二次; 2, 要记住，这是在进行权力的斗争，如果你做的研究是你的上一级无法控制的，他会对你起疑心；如果你的研究是上一级可以控制的，他会把你的研究为他所用作为自己权力斗争的筹码。也就是说，在这种机制的情况下，他是逆向淘汰的，有科研能力的人，被最终的边缘化。\n\n第二种后果便是，内耗之后，是对系统资源的严重浪费。这个问题在各行各业各个单位普遍都是存在，且按照中共逻辑来说是正常的。权力的斗争中，可不像我在计算机上写代码一样，他有很多区别，但仍然可以用计算机的角度来解释。\n\n1, 区别在于，建立一个模型，跑一跑数据资源，出错了；重新建立一个模型，再跑一跑。但现实世界中，没人会给我们这个机会。地下水就是地下水，矿产就是矿产，森林就是森林，不多不少就放在这里，终究竭尽。\n\n2, 用计算机的角度解释就是说， 上述所说的权力斗争，导致创新能力低下，经济对重工业的依赖性强，资源的消耗速度快。也就是，没有优秀的算法，数据结构选择又不合理，内存管理又不做，建立模型后，冗余运算大，结果是消耗了很多资源，却写了个破程序，还要把时间花在无止尽的debug上。之后也会相应解释。\n\n\n那么，错误是否被改正？这其实是个相对较伪命题，这个问题上我们翻过很多次跟斗，共党把他们最信任的，工人骗了，学生骗了，农民也骗了。只要认识到乌托邦的本质，就能够得出结论，他不无法被改正的。如果说要从计划经济走向市场经济，原因是有了权力之后就要用权力去换取财富。十年寒窗是为了什么？更何况12年苦读之后，换来的是更鲜艳的红旗。拿建筑学的建模软件来说，如果sketchUp开源底层代码了，那它还是sketchUp吗？还是叫sketchDown?\n\n后果是否得到解决呢？对应的，当我写错一个程序的时候，我可能会把他扔掉，甚至说从一开始我就应该谨慎设计一个程序，那样就不至于后面一大堆麻烦。 政府官员需要权力斗争的筹码，这些筹码要从白手套，也就是商人那里得到，企业发展势会消耗资源，在资本主义中这种消耗是良性的，因为商人为了自身利益出发，要考虑一种相对长远的发展，商人就会去选择新的技术，投资新的研发，考虑如何合理分配现有资源，因为他们的资本决定了他们的相对自由。然而，在天朝，权力斗争是激烈的，对筹码的欲望是贪婪的，商人是被迫无奈如妓女似的，环境？资源？这种考虑是可能只会是在某个失眠的夜晚发问内心，然而事实上却是不会存在的，而这种对内心的发问，又会用另外一种形式去完成对内心的救赎。只有这种发展不可持续，才会提出可持续发展观。同理，只有在素质低下的国家，才会提出乐于助人般的口号，提出共识，就先不展开了。\n\n天朝统治者和民众一起，在追求结果的平等的过程中，必然造成了过程的不平等，而统治者享受到了不平等的高点，低点留给民众享受。然而他们真的是在高点了吗？领袖足够了吗？常委们幸福吗？首富们的日子好过吗？共产主义马克思是cancer, 把白的黑的都卷入了这场漩涡中，无法脱身。但是cancer现在有医治手段了吗？上帝会像看着一个犯错的孩子一样看着我们，他终究还是宽容的吧，他会“给岁月以文明，而不是给文明以岁月”的吧，中华民族还要在时间中被消耗迭代，但他终归还是坚强的吧。即使，有的人选择在别人将他逼疯之前先逼疯了自己，但他们还是坚强无比的吧。\n\n\n我们很多人不承认，但事实上不得不承认：我们习惯于将现在当作是过去历史的结果，用历史去解释未来，但事实上，现在就是未来的原因。\n","source":"_posts/essay/a-little-light.md","raw":"---\ntitle: 冬至的一点光亮\ndate: 2017-12-22 23:30:00\ntags: 随想\n---\n\n今日冬至，晒太阳翻了翻<<鸟哥的Linux入门>>，通读了一遍，了解结构为后续学习挑出主次。中午找S交谈OpenGL相关问题，当然不止于此。有几点收获:\n1, 学习底层知识，少学习容易过时的知识。我引用Quora上得到的回答，对自己目前的状态做一个反思:\"Are you good at object-oriented programming? C? The Unix tools? Have you taken discrete math? A course in computer systems?\"\n2, 不轻易做一个计划，做一个计划不轻易放弃。我对什么事情都感兴趣，什么都想玩一玩，但是如果不把一项技术学精，虎头蛇尾，是一种空言壮志的表现。S举例了我从GH, Python, 计算几何, C++, Flask, OpenGL等计划, 当然我知道还有其他, 说明我容易循着一条轨迹向下寻溯。但时未兴，我无法准确判断计划的可靠性。\n3, 不把当下决定看得太重。对于那些无所事事的人，他们要减少对时间的浪费;对于我，浪费的时间反而有意义的。浪费与否，学习哪条方向, 都是一种经历。不能陷入到对未知的结果的忧虑当中去，要承认对未知的复杂性。\n4, 捡最近的镜子。满地镜子看花眼睛时候，找最近的镜子。对S来说，数字化的最近镜子是学生；他如此提醒我，想必是要说，我最近的镜子，应该是我的同学和S。但是什么是技术的最近的镜子呢？数据结构，图形，游戏。也许。\n\n冬至夜， 按照去年留下的习俗， 和朋友约一起煮火锅下水饺和汤圆。吃得也饱，聊得也欢快。\n\n其他人陆陆续续的去忙别的事情，只剩下X，H和我。话题的起因是老生常谈，女孩。我看上去是个优胜者，他们两个向我请教。给出了一些符合xu逻辑的方法,\n1, 列出关于学校集体活动的一个list;\n2, 将每个活动的具体形式考量一遍;\n3, 加入该活动的方式;\n4, 可能会出现的几个状况;\n5, 综合考量后排序挑选前5个活动参加。\n因为，前前后后也跟X讲了好多次，没有什么实际行动，我想，问题可能出在，我总是讲具体跟女孩的交流方式，其实这是因人而异的，刻意的追求结果未必是好。但作为前馈数据，需要的大概是接触到更多人的环境，让他自己在这个环境中摸爬。希望这大概能够好些。\n\n聊完这个，便聊第二个老生常谈，但并未透彻的话题，体制。重新思考话题展开的原因相对来说比较有意义，是探索一种启蒙的模型。这个话题能够展开，总得来讲，出于对当下以及未来的困惑，我尝试分开来讲几点原因，\n1, 计算机科学自下而上的思维模式，撼动原有的自上而下的体系。这其中差异，看上去是从技术角度出发，却渗透到经济，结构，体制，文化，人性等各个方面。\n2, 怀有对资社的不充分理解和想要探求的心理状态。\n3, 评论和试图解决遇到的问题，寻求一种生活的模型。\n\nX先提出了对该体制是否会倒塌的质疑，我觉得这个问题好回答，但也不好回答，确实凭借我的认知还无法解释清楚，能够解释清楚的人大多也都别有用心。我但是从我的数据库中索引出来一些，但凌晨四点睡去醒来后，又作了些思考。\n\n人一般走上畸路的过程分成几个阶段，先是犯错误，错误带来不良后果，判断他没救的依据是，依旧不改正错误，后果没得到解决。道理是相同的。\n\n错误性体现在，社会主义相对于资本主义的乌托邦本质。共产主义，当财富是大家共有的时候，谁来决定财富的分配？能够决定分配的人，势必会有权力。如果该掌权者是一个大公无私的，理性智慧的人，大家能够得到平等的分配。这看上去很对，能够实现。但却忽略了一个关键的事实，人性是有阴暗面的，是有私心的。这种私心若是顺其自然的发展，以共同利益为由，是能够孕育出灿烂果实的；有趣的是，但若想消除这种私心，这种私心就被放大了，因为看上去大家都不存在私心了，但消除别人私心的行为本身就是一种私心，说这是私心温和了些，应该说是恶，然而这种恶会被不断的累积和放大，因此，在最高位置上的伟大领袖，或许并非那么伟大。\n\n那么后果是什么？总体上讲是系统内耗造成的资源短缺。这种框架下，势必一切会向权力看。人们会为了生存而追求利益，而追求利益的竞争在这个情况下，又转变成了为追逐权力而努力竞争。值得一提的是，生存是第一要义。竞争是必要的，但除了竞争之外还有合作；利益是必要的，但除了利益之外还有共同利益；追逐地位是必要的，但地位的来源不是唯一的来自于权力和财富。\n\n这种追求利益的方式，产生了第一种后果，其实就是系统内耗。拿我熟悉的高等教育举例子，真正想做科研的教授，他势必不想将时间浪费在这一内耗上，但是不进行这种内耗他便得不到科研经费，科研没有开始就已经结束。然而，也许有人会说，教授你只要忍受一下，便可以开始真正的科研，但事实情况是这样:1, 一旦进行了一次这样的内耗，他会找你第二次; 2, 要记住，这是在进行权力的斗争，如果你做的研究是你的上一级无法控制的，他会对你起疑心；如果你的研究是上一级可以控制的，他会把你的研究为他所用作为自己权力斗争的筹码。也就是说，在这种机制的情况下，他是逆向淘汰的，有科研能力的人，被最终的边缘化。\n\n第二种后果便是，内耗之后，是对系统资源的严重浪费。这个问题在各行各业各个单位普遍都是存在，且按照中共逻辑来说是正常的。权力的斗争中，可不像我在计算机上写代码一样，他有很多区别，但仍然可以用计算机的角度来解释。\n\n1, 区别在于，建立一个模型，跑一跑数据资源，出错了；重新建立一个模型，再跑一跑。但现实世界中，没人会给我们这个机会。地下水就是地下水，矿产就是矿产，森林就是森林，不多不少就放在这里，终究竭尽。\n\n2, 用计算机的角度解释就是说， 上述所说的权力斗争，导致创新能力低下，经济对重工业的依赖性强，资源的消耗速度快。也就是，没有优秀的算法，数据结构选择又不合理，内存管理又不做，建立模型后，冗余运算大，结果是消耗了很多资源，却写了个破程序，还要把时间花在无止尽的debug上。之后也会相应解释。\n\n\n那么，错误是否被改正？这其实是个相对较伪命题，这个问题上我们翻过很多次跟斗，共党把他们最信任的，工人骗了，学生骗了，农民也骗了。只要认识到乌托邦的本质，就能够得出结论，他不无法被改正的。如果说要从计划经济走向市场经济，原因是有了权力之后就要用权力去换取财富。十年寒窗是为了什么？更何况12年苦读之后，换来的是更鲜艳的红旗。拿建筑学的建模软件来说，如果sketchUp开源底层代码了，那它还是sketchUp吗？还是叫sketchDown?\n\n后果是否得到解决呢？对应的，当我写错一个程序的时候，我可能会把他扔掉，甚至说从一开始我就应该谨慎设计一个程序，那样就不至于后面一大堆麻烦。 政府官员需要权力斗争的筹码，这些筹码要从白手套，也就是商人那里得到，企业发展势会消耗资源，在资本主义中这种消耗是良性的，因为商人为了自身利益出发，要考虑一种相对长远的发展，商人就会去选择新的技术，投资新的研发，考虑如何合理分配现有资源，因为他们的资本决定了他们的相对自由。然而，在天朝，权力斗争是激烈的，对筹码的欲望是贪婪的，商人是被迫无奈如妓女似的，环境？资源？这种考虑是可能只会是在某个失眠的夜晚发问内心，然而事实上却是不会存在的，而这种对内心的发问，又会用另外一种形式去完成对内心的救赎。只有这种发展不可持续，才会提出可持续发展观。同理，只有在素质低下的国家，才会提出乐于助人般的口号，提出共识，就先不展开了。\n\n天朝统治者和民众一起，在追求结果的平等的过程中，必然造成了过程的不平等，而统治者享受到了不平等的高点，低点留给民众享受。然而他们真的是在高点了吗？领袖足够了吗？常委们幸福吗？首富们的日子好过吗？共产主义马克思是cancer, 把白的黑的都卷入了这场漩涡中，无法脱身。但是cancer现在有医治手段了吗？上帝会像看着一个犯错的孩子一样看着我们，他终究还是宽容的吧，他会“给岁月以文明，而不是给文明以岁月”的吧，中华民族还要在时间中被消耗迭代，但他终归还是坚强的吧。即使，有的人选择在别人将他逼疯之前先逼疯了自己，但他们还是坚强无比的吧。\n\n\n我们很多人不承认，但事实上不得不承认：我们习惯于将现在当作是过去历史的结果，用历史去解释未来，但事实上，现在就是未来的原因。\n","slug":"essay/a-little-light","published":1,"updated":"2018-06-19T16:15:03.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyl4002kk8mfwmp8rusn","content":"<p>今日冬至，晒太阳翻了翻&lt;&lt;鸟哥的Linux入门&gt;&gt;，通读了一遍，了解结构为后续学习挑出主次。中午找S交谈OpenGL相关问题，当然不止于此。有几点收获:<br>1, 学习底层知识，少学习容易过时的知识。我引用Quora上得到的回答，对自己目前的状态做一个反思:”Are you good at object-oriented programming? C? The Unix tools? Have you taken discrete math? A course in computer systems?”<br>2, 不轻易做一个计划，做一个计划不轻易放弃。我对什么事情都感兴趣，什么都想玩一玩，但是如果不把一项技术学精，虎头蛇尾，是一种空言壮志的表现。S举例了我从GH, Python, 计算几何, C++, Flask, OpenGL等计划, 当然我知道还有其他, 说明我容易循着一条轨迹向下寻溯。但时未兴，我无法准确判断计划的可靠性。<br>3, 不把当下决定看得太重。对于那些无所事事的人，他们要减少对时间的浪费;对于我，浪费的时间反而有意义的。浪费与否，学习哪条方向, 都是一种经历。不能陷入到对未知的结果的忧虑当中去，要承认对未知的复杂性。<br>4, 捡最近的镜子。满地镜子看花眼睛时候，找最近的镜子。对S来说，数字化的最近镜子是学生；他如此提醒我，想必是要说，我最近的镜子，应该是我的同学和S。但是什么是技术的最近的镜子呢？数据结构，图形，游戏。也许。</p>\n<p>冬至夜， 按照去年留下的习俗， 和朋友约一起煮火锅下水饺和汤圆。吃得也饱，聊得也欢快。</p>\n<p>其他人陆陆续续的去忙别的事情，只剩下X，H和我。话题的起因是老生常谈，女孩。我看上去是个优胜者，他们两个向我请教。给出了一些符合xu逻辑的方法,<br>1, 列出关于学校集体活动的一个list;<br>2, 将每个活动的具体形式考量一遍;<br>3, 加入该活动的方式;<br>4, 可能会出现的几个状况;<br>5, 综合考量后排序挑选前5个活动参加。<br>因为，前前后后也跟X讲了好多次，没有什么实际行动，我想，问题可能出在，我总是讲具体跟女孩的交流方式，其实这是因人而异的，刻意的追求结果未必是好。但作为前馈数据，需要的大概是接触到更多人的环境，让他自己在这个环境中摸爬。希望这大概能够好些。</p>\n<p>聊完这个，便聊第二个老生常谈，但并未透彻的话题，体制。重新思考话题展开的原因相对来说比较有意义，是探索一种启蒙的模型。这个话题能够展开，总得来讲，出于对当下以及未来的困惑，我尝试分开来讲几点原因，<br>1, 计算机科学自下而上的思维模式，撼动原有的自上而下的体系。这其中差异，看上去是从技术角度出发，却渗透到经济，结构，体制，文化，人性等各个方面。<br>2, 怀有对资社的不充分理解和想要探求的心理状态。<br>3, 评论和试图解决遇到的问题，寻求一种生活的模型。</p>\n<p>X先提出了对该体制是否会倒塌的质疑，我觉得这个问题好回答，但也不好回答，确实凭借我的认知还无法解释清楚，能够解释清楚的人大多也都别有用心。我但是从我的数据库中索引出来一些，但凌晨四点睡去醒来后，又作了些思考。</p>\n<p>人一般走上畸路的过程分成几个阶段，先是犯错误，错误带来不良后果，判断他没救的依据是，依旧不改正错误，后果没得到解决。道理是相同的。</p>\n<p>错误性体现在，社会主义相对于资本主义的乌托邦本质。共产主义，当财富是大家共有的时候，谁来决定财富的分配？能够决定分配的人，势必会有权力。如果该掌权者是一个大公无私的，理性智慧的人，大家能够得到平等的分配。这看上去很对，能够实现。但却忽略了一个关键的事实，人性是有阴暗面的，是有私心的。这种私心若是顺其自然的发展，以共同利益为由，是能够孕育出灿烂果实的；有趣的是，但若想消除这种私心，这种私心就被放大了，因为看上去大家都不存在私心了，但消除别人私心的行为本身就是一种私心，说这是私心温和了些，应该说是恶，然而这种恶会被不断的累积和放大，因此，在最高位置上的伟大领袖，或许并非那么伟大。</p>\n<p>那么后果是什么？总体上讲是系统内耗造成的资源短缺。这种框架下，势必一切会向权力看。人们会为了生存而追求利益，而追求利益的竞争在这个情况下，又转变成了为追逐权力而努力竞争。值得一提的是，生存是第一要义。竞争是必要的，但除了竞争之外还有合作；利益是必要的，但除了利益之外还有共同利益；追逐地位是必要的，但地位的来源不是唯一的来自于权力和财富。</p>\n<p>这种追求利益的方式，产生了第一种后果，其实就是系统内耗。拿我熟悉的高等教育举例子，真正想做科研的教授，他势必不想将时间浪费在这一内耗上，但是不进行这种内耗他便得不到科研经费，科研没有开始就已经结束。然而，也许有人会说，教授你只要忍受一下，便可以开始真正的科研，但事实情况是这样:1, 一旦进行了一次这样的内耗，他会找你第二次; 2, 要记住，这是在进行权力的斗争，如果你做的研究是你的上一级无法控制的，他会对你起疑心；如果你的研究是上一级可以控制的，他会把你的研究为他所用作为自己权力斗争的筹码。也就是说，在这种机制的情况下，他是逆向淘汰的，有科研能力的人，被最终的边缘化。</p>\n<p>第二种后果便是，内耗之后，是对系统资源的严重浪费。这个问题在各行各业各个单位普遍都是存在，且按照中共逻辑来说是正常的。权力的斗争中，可不像我在计算机上写代码一样，他有很多区别，但仍然可以用计算机的角度来解释。</p>\n<p>1, 区别在于，建立一个模型，跑一跑数据资源，出错了；重新建立一个模型，再跑一跑。但现实世界中，没人会给我们这个机会。地下水就是地下水，矿产就是矿产，森林就是森林，不多不少就放在这里，终究竭尽。</p>\n<p>2, 用计算机的角度解释就是说， 上述所说的权力斗争，导致创新能力低下，经济对重工业的依赖性强，资源的消耗速度快。也就是，没有优秀的算法，数据结构选择又不合理，内存管理又不做，建立模型后，冗余运算大，结果是消耗了很多资源，却写了个破程序，还要把时间花在无止尽的debug上。之后也会相应解释。</p>\n<p>那么，错误是否被改正？这其实是个相对较伪命题，这个问题上我们翻过很多次跟斗，共党把他们最信任的，工人骗了，学生骗了，农民也骗了。只要认识到乌托邦的本质，就能够得出结论，他不无法被改正的。如果说要从计划经济走向市场经济，原因是有了权力之后就要用权力去换取财富。十年寒窗是为了什么？更何况12年苦读之后，换来的是更鲜艳的红旗。拿建筑学的建模软件来说，如果sketchUp开源底层代码了，那它还是sketchUp吗？还是叫sketchDown?</p>\n<p>后果是否得到解决呢？对应的，当我写错一个程序的时候，我可能会把他扔掉，甚至说从一开始我就应该谨慎设计一个程序，那样就不至于后面一大堆麻烦。 政府官员需要权力斗争的筹码，这些筹码要从白手套，也就是商人那里得到，企业发展势会消耗资源，在资本主义中这种消耗是良性的，因为商人为了自身利益出发，要考虑一种相对长远的发展，商人就会去选择新的技术，投资新的研发，考虑如何合理分配现有资源，因为他们的资本决定了他们的相对自由。然而，在天朝，权力斗争是激烈的，对筹码的欲望是贪婪的，商人是被迫无奈如妓女似的，环境？资源？这种考虑是可能只会是在某个失眠的夜晚发问内心，然而事实上却是不会存在的，而这种对内心的发问，又会用另外一种形式去完成对内心的救赎。只有这种发展不可持续，才会提出可持续发展观。同理，只有在素质低下的国家，才会提出乐于助人般的口号，提出共识，就先不展开了。</p>\n<p>天朝统治者和民众一起，在追求结果的平等的过程中，必然造成了过程的不平等，而统治者享受到了不平等的高点，低点留给民众享受。然而他们真的是在高点了吗？领袖足够了吗？常委们幸福吗？首富们的日子好过吗？共产主义马克思是cancer, 把白的黑的都卷入了这场漩涡中，无法脱身。但是cancer现在有医治手段了吗？上帝会像看着一个犯错的孩子一样看着我们，他终究还是宽容的吧，他会“给岁月以文明，而不是给文明以岁月”的吧，中华民族还要在时间中被消耗迭代，但他终归还是坚强的吧。即使，有的人选择在别人将他逼疯之前先逼疯了自己，但他们还是坚强无比的吧。</p>\n<p>我们很多人不承认，但事实上不得不承认：我们习惯于将现在当作是过去历史的结果，用历史去解释未来，但事实上，现在就是未来的原因。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今日冬至，晒太阳翻了翻&lt;&lt;鸟哥的Linux入门&gt;&gt;，通读了一遍，了解结构为后续学习挑出主次。中午找S交谈OpenGL相关问题，当然不止于此。有几点收获:<br>1, 学习底层知识，少学习容易过时的知识。我引用Quora上得到的回答，对自己目前的状态做一个反思:”Are you good at object-oriented programming? C? The Unix tools? Have you taken discrete math? A course in computer systems?”<br>2, 不轻易做一个计划，做一个计划不轻易放弃。我对什么事情都感兴趣，什么都想玩一玩，但是如果不把一项技术学精，虎头蛇尾，是一种空言壮志的表现。S举例了我从GH, Python, 计算几何, C++, Flask, OpenGL等计划, 当然我知道还有其他, 说明我容易循着一条轨迹向下寻溯。但时未兴，我无法准确判断计划的可靠性。<br>3, 不把当下决定看得太重。对于那些无所事事的人，他们要减少对时间的浪费;对于我，浪费的时间反而有意义的。浪费与否，学习哪条方向, 都是一种经历。不能陷入到对未知的结果的忧虑当中去，要承认对未知的复杂性。<br>4, 捡最近的镜子。满地镜子看花眼睛时候，找最近的镜子。对S来说，数字化的最近镜子是学生；他如此提醒我，想必是要说，我最近的镜子，应该是我的同学和S。但是什么是技术的最近的镜子呢？数据结构，图形，游戏。也许。</p>\n<p>冬至夜， 按照去年留下的习俗， 和朋友约一起煮火锅下水饺和汤圆。吃得也饱，聊得也欢快。</p>\n<p>其他人陆陆续续的去忙别的事情，只剩下X，H和我。话题的起因是老生常谈，女孩。我看上去是个优胜者，他们两个向我请教。给出了一些符合xu逻辑的方法,<br>1, 列出关于学校集体活动的一个list;<br>2, 将每个活动的具体形式考量一遍;<br>3, 加入该活动的方式;<br>4, 可能会出现的几个状况;<br>5, 综合考量后排序挑选前5个活动参加。<br>因为，前前后后也跟X讲了好多次，没有什么实际行动，我想，问题可能出在，我总是讲具体跟女孩的交流方式，其实这是因人而异的，刻意的追求结果未必是好。但作为前馈数据，需要的大概是接触到更多人的环境，让他自己在这个环境中摸爬。希望这大概能够好些。</p>\n<p>聊完这个，便聊第二个老生常谈，但并未透彻的话题，体制。重新思考话题展开的原因相对来说比较有意义，是探索一种启蒙的模型。这个话题能够展开，总得来讲，出于对当下以及未来的困惑，我尝试分开来讲几点原因，<br>1, 计算机科学自下而上的思维模式，撼动原有的自上而下的体系。这其中差异，看上去是从技术角度出发，却渗透到经济，结构，体制，文化，人性等各个方面。<br>2, 怀有对资社的不充分理解和想要探求的心理状态。<br>3, 评论和试图解决遇到的问题，寻求一种生活的模型。</p>\n<p>X先提出了对该体制是否会倒塌的质疑，我觉得这个问题好回答，但也不好回答，确实凭借我的认知还无法解释清楚，能够解释清楚的人大多也都别有用心。我但是从我的数据库中索引出来一些，但凌晨四点睡去醒来后，又作了些思考。</p>\n<p>人一般走上畸路的过程分成几个阶段，先是犯错误，错误带来不良后果，判断他没救的依据是，依旧不改正错误，后果没得到解决。道理是相同的。</p>\n<p>错误性体现在，社会主义相对于资本主义的乌托邦本质。共产主义，当财富是大家共有的时候，谁来决定财富的分配？能够决定分配的人，势必会有权力。如果该掌权者是一个大公无私的，理性智慧的人，大家能够得到平等的分配。这看上去很对，能够实现。但却忽略了一个关键的事实，人性是有阴暗面的，是有私心的。这种私心若是顺其自然的发展，以共同利益为由，是能够孕育出灿烂果实的；有趣的是，但若想消除这种私心，这种私心就被放大了，因为看上去大家都不存在私心了，但消除别人私心的行为本身就是一种私心，说这是私心温和了些，应该说是恶，然而这种恶会被不断的累积和放大，因此，在最高位置上的伟大领袖，或许并非那么伟大。</p>\n<p>那么后果是什么？总体上讲是系统内耗造成的资源短缺。这种框架下，势必一切会向权力看。人们会为了生存而追求利益，而追求利益的竞争在这个情况下，又转变成了为追逐权力而努力竞争。值得一提的是，生存是第一要义。竞争是必要的，但除了竞争之外还有合作；利益是必要的，但除了利益之外还有共同利益；追逐地位是必要的，但地位的来源不是唯一的来自于权力和财富。</p>\n<p>这种追求利益的方式，产生了第一种后果，其实就是系统内耗。拿我熟悉的高等教育举例子，真正想做科研的教授，他势必不想将时间浪费在这一内耗上，但是不进行这种内耗他便得不到科研经费，科研没有开始就已经结束。然而，也许有人会说，教授你只要忍受一下，便可以开始真正的科研，但事实情况是这样:1, 一旦进行了一次这样的内耗，他会找你第二次; 2, 要记住，这是在进行权力的斗争，如果你做的研究是你的上一级无法控制的，他会对你起疑心；如果你的研究是上一级可以控制的，他会把你的研究为他所用作为自己权力斗争的筹码。也就是说，在这种机制的情况下，他是逆向淘汰的，有科研能力的人，被最终的边缘化。</p>\n<p>第二种后果便是，内耗之后，是对系统资源的严重浪费。这个问题在各行各业各个单位普遍都是存在，且按照中共逻辑来说是正常的。权力的斗争中，可不像我在计算机上写代码一样，他有很多区别，但仍然可以用计算机的角度来解释。</p>\n<p>1, 区别在于，建立一个模型，跑一跑数据资源，出错了；重新建立一个模型，再跑一跑。但现实世界中，没人会给我们这个机会。地下水就是地下水，矿产就是矿产，森林就是森林，不多不少就放在这里，终究竭尽。</p>\n<p>2, 用计算机的角度解释就是说， 上述所说的权力斗争，导致创新能力低下，经济对重工业的依赖性强，资源的消耗速度快。也就是，没有优秀的算法，数据结构选择又不合理，内存管理又不做，建立模型后，冗余运算大，结果是消耗了很多资源，却写了个破程序，还要把时间花在无止尽的debug上。之后也会相应解释。</p>\n<p>那么，错误是否被改正？这其实是个相对较伪命题，这个问题上我们翻过很多次跟斗，共党把他们最信任的，工人骗了，学生骗了，农民也骗了。只要认识到乌托邦的本质，就能够得出结论，他不无法被改正的。如果说要从计划经济走向市场经济，原因是有了权力之后就要用权力去换取财富。十年寒窗是为了什么？更何况12年苦读之后，换来的是更鲜艳的红旗。拿建筑学的建模软件来说，如果sketchUp开源底层代码了，那它还是sketchUp吗？还是叫sketchDown?</p>\n<p>后果是否得到解决呢？对应的，当我写错一个程序的时候，我可能会把他扔掉，甚至说从一开始我就应该谨慎设计一个程序，那样就不至于后面一大堆麻烦。 政府官员需要权力斗争的筹码，这些筹码要从白手套，也就是商人那里得到，企业发展势会消耗资源，在资本主义中这种消耗是良性的，因为商人为了自身利益出发，要考虑一种相对长远的发展，商人就会去选择新的技术，投资新的研发，考虑如何合理分配现有资源，因为他们的资本决定了他们的相对自由。然而，在天朝，权力斗争是激烈的，对筹码的欲望是贪婪的，商人是被迫无奈如妓女似的，环境？资源？这种考虑是可能只会是在某个失眠的夜晚发问内心，然而事实上却是不会存在的，而这种对内心的发问，又会用另外一种形式去完成对内心的救赎。只有这种发展不可持续，才会提出可持续发展观。同理，只有在素质低下的国家，才会提出乐于助人般的口号，提出共识，就先不展开了。</p>\n<p>天朝统治者和民众一起，在追求结果的平等的过程中，必然造成了过程的不平等，而统治者享受到了不平等的高点，低点留给民众享受。然而他们真的是在高点了吗？领袖足够了吗？常委们幸福吗？首富们的日子好过吗？共产主义马克思是cancer, 把白的黑的都卷入了这场漩涡中，无法脱身。但是cancer现在有医治手段了吗？上帝会像看着一个犯错的孩子一样看着我们，他终究还是宽容的吧，他会“给岁月以文明，而不是给文明以岁月”的吧，中华民族还要在时间中被消耗迭代，但他终归还是坚强的吧。即使，有的人选择在别人将他逼疯之前先逼疯了自己，但他们还是坚强无比的吧。</p>\n<p>我们很多人不承认，但事实上不得不承认：我们习惯于将现在当作是过去历史的结果，用历史去解释未来，但事实上，现在就是未来的原因。</p>\n"},{"title":"关于休息","date":"2018-01-15T14:56:54.000Z","_content":"```\n人的一生有多少时间是在休息中度过的？\n\n时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。\nJ课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。\n早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。\n结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。\n一没看数据结构和C++, 二没把复习的想法实现。\n\n回过头来, 这件事情要是这样, \n回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。\n我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。\n因此, 将生活与工作的接口分离是有必要的。\n\n先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。\n但我希望缓慢能做到。\n\n一天24小时, 睡8小时的话, 有1/3在睡眠中度过。\n剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; \n打网球是种休息, 在传统的人比如我妈看来是在受罪; \n书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; \n亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; \n...等等很多。\n我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。\n这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。\n\n休息是一种智慧。 \n记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, \n无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。\n而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,\n但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。\n\n对休息也需要重构。\n当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。\n\n先生活后工作。\n```\n","source":"_posts/essay/about-rest.md","raw":"---\ntitle: 关于休息\ndate: 2018-01-15 22:56:54\ntags: 随想\n---\n```\n人的一生有多少时间是在休息中度过的？\n\n时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。\nJ课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。\n早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。\n结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。\n一没看数据结构和C++, 二没把复习的想法实现。\n\n回过头来, 这件事情要是这样, \n回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。\n我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。\n因此, 将生活与工作的接口分离是有必要的。\n\n先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。\n但我希望缓慢能做到。\n\n一天24小时, 睡8小时的话, 有1/3在睡眠中度过。\n剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; \n打网球是种休息, 在传统的人比如我妈看来是在受罪; \n书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; \n亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; \n...等等很多。\n我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。\n这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。\n\n休息是一种智慧。 \n记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, \n无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。\n而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,\n但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。\n\n对休息也需要重构。\n当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。\n\n先生活后工作。\n```\n","slug":"essay/about-rest","published":1,"updated":"2018-06-19T16:15:03.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyl6002nk8mf68q2rc5s","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">人的一生有多少时间是在休息中度过的？</span><br><span class=\"line\"></span><br><span class=\"line\">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class=\"line\">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class=\"line\">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class=\"line\">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class=\"line\">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class=\"line\"></span><br><span class=\"line\">回过头来, 这件事情要是这样, </span><br><span class=\"line\">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class=\"line\">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class=\"line\">因此, 将生活与工作的接口分离是有必要的。</span><br><span class=\"line\"></span><br><span class=\"line\">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class=\"line\">但我希望缓慢能做到。</span><br><span class=\"line\"></span><br><span class=\"line\">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class=\"line\">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class=\"line\">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class=\"line\">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class=\"line\">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class=\"line\">...等等很多。</span><br><span class=\"line\">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class=\"line\">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class=\"line\"></span><br><span class=\"line\">休息是一种智慧。 </span><br><span class=\"line\">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class=\"line\">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class=\"line\">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class=\"line\">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class=\"line\"></span><br><span class=\"line\">对休息也需要重构。</span><br><span class=\"line\">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class=\"line\"></span><br><span class=\"line\">先生活后工作。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">人的一生有多少时间是在休息中度过的？</span><br><span class=\"line\"></span><br><span class=\"line\">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class=\"line\">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class=\"line\">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class=\"line\">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class=\"line\">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class=\"line\"></span><br><span class=\"line\">回过头来, 这件事情要是这样, </span><br><span class=\"line\">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class=\"line\">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class=\"line\">因此, 将生活与工作的接口分离是有必要的。</span><br><span class=\"line\"></span><br><span class=\"line\">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class=\"line\">但我希望缓慢能做到。</span><br><span class=\"line\"></span><br><span class=\"line\">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class=\"line\">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class=\"line\">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class=\"line\">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class=\"line\">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class=\"line\">...等等很多。</span><br><span class=\"line\">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class=\"line\">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class=\"line\"></span><br><span class=\"line\">休息是一种智慧。 </span><br><span class=\"line\">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class=\"line\">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class=\"line\">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class=\"line\">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class=\"line\"></span><br><span class=\"line\">对休息也需要重构。</span><br><span class=\"line\">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class=\"line\"></span><br><span class=\"line\">先生活后工作。</span><br></pre></td></tr></table></figure>\n"},{"title":"建筑设计应用和计算机科学一点随想","date":"2018-01-10T08:27:28.000Z","_content":"\n\n要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。\n\n批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 \n\n学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。\n","source":"_posts/essay/architecture-application-between-computer-science.md","raw":"---\ntitle: 建筑设计应用和计算机科学一点随想\ndate: 2018-01-10 16:27:28\ntags: [建筑, 计算机科学, 随想]\n---\n\n\n要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。\n\n批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 \n\n学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。\n","slug":"essay/architecture-application-between-computer-science","published":1,"updated":"2018-06-19T16:15:03.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyl8002pk8mfzmc7w676","content":"<p>要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。</p>\n<p>批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 </p>\n<p>学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。</p>\n<p>批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 </p>\n<p>学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。</p>\n"},{"title":"楚门的世界, 写于观后和离前","date":"2018-01-13T03:29:45.000Z","_content":"\n```\n凌晨睡不着看了一部电影叫<<看楚门的世界>>。\n\n--------------------------------------------------------------------------------\n1, 疑惑\n\t1) 戏中戏外的时间不同步\n\t\t戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。\n\t\t是否意味着，在这样一个世界时间也是可以改变的可能。\n\t\t大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。\n\t\t在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....\n\t2) 关于梦醒\n\t\t长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, \n\t\t梦何时醒? 梦醒需要多久? 梦醒的痛苦？\n\n------------------------------------------------------------------------------------------\n2, 观点\n\t1) 戏里戏外都在被安慰\n\t\t戏里的楚门被creator安排在一个normal的世界里生活。\n\t\t有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。\n\t\t而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。\n\t\t他们都想用自己认为的方式安慰戏中的楚门。\n\t\t\n\t\t戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，\n\t\t通过秀来排解对现实的不满，不需要过多思考就安慰。\n\t\t创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？\n\n\t2) 构成生活看似真实性的一些元素\n\t\t说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。\n\t\t交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。\n\t\t独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。\n\t\t神的安排。\n\n\t3) 二十世纪末的美国科技和科幻能力\n\t\t98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。\n\t\t制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。\n\t\t楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。\n\t\t当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?\n\n\t4) 如果对现有的生活不再眷恋\n\t\t除草。漂泊。割舍。接受。\n```\n","source":"_posts/movies/the-Truman-show-critic.md","raw":"---\ntitle: 楚门的世界, 写于观后和离前\ndate: 2018-01-13 11:29:45\ntags: [电影, 随想]\n---\n\n```\n凌晨睡不着看了一部电影叫<<看楚门的世界>>。\n\n--------------------------------------------------------------------------------\n1, 疑惑\n\t1) 戏中戏外的时间不同步\n\t\t戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。\n\t\t是否意味着，在这样一个世界时间也是可以改变的可能。\n\t\t大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。\n\t\t在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....\n\t2) 关于梦醒\n\t\t长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, \n\t\t梦何时醒? 梦醒需要多久? 梦醒的痛苦？\n\n------------------------------------------------------------------------------------------\n2, 观点\n\t1) 戏里戏外都在被安慰\n\t\t戏里的楚门被creator安排在一个normal的世界里生活。\n\t\t有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。\n\t\t而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。\n\t\t他们都想用自己认为的方式安慰戏中的楚门。\n\t\t\n\t\t戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，\n\t\t通过秀来排解对现实的不满，不需要过多思考就安慰。\n\t\t创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？\n\n\t2) 构成生活看似真实性的一些元素\n\t\t说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。\n\t\t交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。\n\t\t独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。\n\t\t神的安排。\n\n\t3) 二十世纪末的美国科技和科幻能力\n\t\t98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。\n\t\t制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。\n\t\t楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。\n\t\t当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?\n\n\t4) 如果对现有的生活不再眷恋\n\t\t除草。漂泊。割舍。接受。\n```\n","slug":"movies/the-Truman-show-critic","published":1,"updated":"2018-06-19T16:15:03.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjilydyla002rk8mfve5ymivf","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\">1, 疑惑</span><br><span class=\"line\">\t1) 戏中戏外的时间不同步</span><br><span class=\"line\">\t\t戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class=\"line\">\t\t是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class=\"line\">\t\t大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class=\"line\">\t\t在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class=\"line\">\t2) 关于梦醒</span><br><span class=\"line\">\t\t长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class=\"line\">\t\t梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------------------------------------------------------</span><br><span class=\"line\">2, 观点</span><br><span class=\"line\">\t1) 戏里戏外都在被安慰</span><br><span class=\"line\">\t\t戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class=\"line\">\t\t有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class=\"line\">\t\t而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class=\"line\">\t\t他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class=\"line\">\t\t通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class=\"line\">\t\t创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class=\"line\"></span><br><span class=\"line\">\t2) 构成生活看似真实性的一些元素</span><br><span class=\"line\">\t\t说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class=\"line\">\t\t交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class=\"line\">\t\t独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class=\"line\">\t\t神的安排。</span><br><span class=\"line\"></span><br><span class=\"line\">\t3) 二十世纪末的美国科技和科幻能力</span><br><span class=\"line\">\t\t98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class=\"line\">\t\t制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class=\"line\">\t\t楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class=\"line\">\t\t当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class=\"line\"></span><br><span class=\"line\">\t4) 如果对现有的生活不再眷恋</span><br><span class=\"line\">\t\t除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\">1, 疑惑</span><br><span class=\"line\">\t1) 戏中戏外的时间不同步</span><br><span class=\"line\">\t\t戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class=\"line\">\t\t是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class=\"line\">\t\t大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class=\"line\">\t\t在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class=\"line\">\t2) 关于梦醒</span><br><span class=\"line\">\t\t长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class=\"line\">\t\t梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------------------------------------------------------------------------</span><br><span class=\"line\">2, 观点</span><br><span class=\"line\">\t1) 戏里戏外都在被安慰</span><br><span class=\"line\">\t\t戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class=\"line\">\t\t有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class=\"line\">\t\t而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class=\"line\">\t\t他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class=\"line\">\t\t通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class=\"line\">\t\t创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class=\"line\"></span><br><span class=\"line\">\t2) 构成生活看似真实性的一些元素</span><br><span class=\"line\">\t\t说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class=\"line\">\t\t交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class=\"line\">\t\t独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class=\"line\">\t\t神的安排。</span><br><span class=\"line\"></span><br><span class=\"line\">\t3) 二十世纪末的美国科技和科幻能力</span><br><span class=\"line\">\t\t98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class=\"line\">\t\t制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class=\"line\">\t\t楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class=\"line\">\t\t当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class=\"line\"></span><br><span class=\"line\">\t4) 如果对现有的生活不再眷恋</span><br><span class=\"line\">\t\t除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjilydyit0001k8mfhwbd7y82","tag_id":"cjilydyj00004k8mfce3grcg5","_id":"cjilydyjc0009k8mf8a1bzu2k"},{"post_id":"cjilydyix0003k8mf6njzud0o","tag_id":"cjilydyjb0008k8mfn8xv13cn","_id":"cjilydyji000ek8mfslb4xlhb"},{"post_id":"cjilydyjf000bk8mfhhuqde30","tag_id":"cjilydyjb0008k8mfn8xv13cn","_id":"cjilydyjj000gk8mfu1j1n9wj"},{"post_id":"cjilydyj30005k8mf9ucgs3ta","tag_id":"cjilydyjg000ck8mfqqcbyle3","_id":"cjilydyjl000jk8mf4ib6ofx2"},{"post_id":"cjilydyj80007k8mf8aa7nqk4","tag_id":"cjilydyjk000hk8mfga0zg5pb","_id":"cjilydyjq000qk8mf1iaslx2x"},{"post_id":"cjilydyj80007k8mf8aa7nqk4","tag_id":"cjilydyjm000lk8mfvv0t6wvb","_id":"cjilydyjr000sk8mf25h2y6sf"},{"post_id":"cjilydyjq000rk8mffvbov6fx","tag_id":"cjilydyj00004k8mfce3grcg5","_id":"cjilydyjt000vk8mf900tojys"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyjq000pk8mf14f1ztd1","_id":"cjilydyjw0012k8mf5hb2ylb2"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyjs000uk8mfm466akht","_id":"cjilydyjw0013k8mf58cribg5"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyju000xk8mf4lk25mtt","_id":"cjilydyjx0015k8mfs66gqae4"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyju000yk8mfbic129vr","_id":"cjilydyjx0016k8mf4xa249by"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyjv000zk8mfhsbi0wkr","_id":"cjilydyjx0018k8mfrjom7gm0"},{"post_id":"cjilydyjc000ak8mfzkmzwlmp","tag_id":"cjilydyjv0010k8mf7dznvblz","_id":"cjilydyjy0019k8mfir117jvo"},{"post_id":"cjilydyji000fk8mf3eanrgvm","tag_id":"cjilydyjs000uk8mfm466akht","_id":"cjilydyjy001bk8mfi954xran"},{"post_id":"cjilydyjl000kk8mfoxlfw3ld","tag_id":"cjilydyjw0014k8mfs3isby6b","_id":"cjilydyjy001ck8mf742l4rqt"},{"post_id":"cjilydyjn000mk8mfagz2pbtl","tag_id":"cjilydyjw0014k8mfs3isby6b","_id":"cjilydyjz001ek8mf8zfleymd"},{"post_id":"cjilydyjn000mk8mfagz2pbtl","tag_id":"cjilydyjy001ak8mfzpaju45q","_id":"cjilydyjz001fk8mf8hzg5h2s"},{"post_id":"cjilydyjo000nk8mfs9gkd01c","tag_id":"cjilydyjy001dk8mf83gqso07","_id":"cjilydyk0001ik8mf2m6vnqan"},{"post_id":"cjilydyjo000nk8mfs9gkd01c","tag_id":"cjilydyjz001gk8mf4t372uyh","_id":"cjilydyk0001jk8mfiwojio43"},{"post_id":"cjilydyjp000ok8mfcp3ol532","tag_id":"cjilydyjs000uk8mfm466akht","_id":"cjilydyk1001lk8mfy0f4f3fd"},{"post_id":"cjilydyjt000wk8mf4chwvzo9","tag_id":"cjilydyju000xk8mf4lk25mtt","_id":"cjilydyk2001ok8mff3e3coto"},{"post_id":"cjilydyjt000wk8mf4chwvzo9","tag_id":"cjilydyk1001mk8mf3bf4n0d0","_id":"cjilydyk2001pk8mfi3ve8r10"},{"post_id":"cjilydyjt000wk8mf4chwvzo9","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydyk2001qk8mfzxsqelf6"},{"post_id":"cjilydyk9001sk8mff5tbgzxw","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydykc001vk8mfybek93ua"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydyl4002jk8mf2ruz4voz"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydykb001tk8mfb5eb8ni5","_id":"cjilydyl6002lk8mfqe1u97vp"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydykf001yk8mf3fr01qyk","_id":"cjilydyl8002ok8mfv9g7zf6h"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydyki0021k8mf1vu2yq88","_id":"cjilydyl9002qk8mfwhw6nx7g"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydykk0024k8mfsb6gikjj","_id":"cjilydylb002tk8mfk38d32gy"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydyko0027k8mfubfox7k4","_id":"cjilydylb002uk8mfz5qv172m"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydykt002bk8mfz2mnsr0i","_id":"cjilydylc002wk8mf0a01k18w"},{"post_id":"cjilydyk9001rk8mf45wil7ip","tag_id":"cjilydyky002ek8mfrppiee10","_id":"cjilydylc002xk8mfss32d1rf"},{"post_id":"cjilydyl4002kk8mfwmp8rusn","tag_id":"cjilydyju000yk8mfbic129vr","_id":"cjilydylc002yk8mf2b55f63q"},{"post_id":"cjilydyl6002nk8mf68q2rc5s","tag_id":"cjilydyju000yk8mfbic129vr","_id":"cjilydylc0030k8mfnvmx9bjc"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydyld0032k8mf6b0ny1xy"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydyl2002hk8mfqh7mmyrq","_id":"cjilydyld0033k8mfjyd6i47a"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydyl6002mk8mfa9pg6dr4","_id":"cjilydyle0035k8mff8sg4yqt"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydyla002sk8mfswdcw7cp","_id":"cjilydylf0036k8mfh7ck4mb0"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydylc002vk8mfn0ysidd1","_id":"cjilydylf0038k8mf2476nrq4"},{"post_id":"cjilydykb001uk8mfaa6sgpim","tag_id":"cjilydylc002zk8mfjezyk16n","_id":"cjilydylf0039k8mfdvh9vs37"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydylh003ek8mfv5btantg"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydyld0031k8mfzxosazc8","_id":"cjilydylh003fk8mfou1n33d7"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydyld0034k8mft9g7pt3u","_id":"cjilydylh003hk8mfwb4kq9sd"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydylf0037k8mfq0vrkmpc","_id":"cjilydyli003ik8mfr0bi6owp"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydylf003ak8mfj3lxcjzr","_id":"cjilydyli003kk8mfi7irs5il"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydylg003bk8mf29whpue5","_id":"cjilydyli003lk8mfb58v6e8f"},{"post_id":"cjilydyke001xk8mfm7ldw1zg","tag_id":"cjilydylg003ck8mfhaaz0ptt","_id":"cjilydyli003nk8mf2ynm48ra"},{"post_id":"cjilydykf001zk8mfbzmtfykh","tag_id":"cjilydyk1001nk8mfl5nvtvco","_id":"cjilydylj003pk8mfjlm5yrp6"},{"post_id":"cjilydykf001zk8mfbzmtfykh","tag_id":"cjilydylg003dk8mfknkqwuru","_id":"cjilydylj003qk8mf4536crcd"},{"post_id":"cjilydykf001zk8mfbzmtfykh","tag_id":"cjilydylh003gk8mfvdo8dbm9","_id":"cjilydylk003sk8mfgnb2pcn0"},{"post_id":"cjilydykf001zk8mfbzmtfykh","tag_id":"cjilydyli003jk8mfrglvbq8v","_id":"cjilydylk003tk8mf4zm2l77s"},{"post_id":"cjilydykf001zk8mfbzmtfykh","tag_id":"cjilydyli003mk8mf8uno36u2","_id":"cjilydyll003vk8mfzz0otoq1"},{"post_id":"cjilydykh0020k8mfuug580ki","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydyll003wk8mfw9i7lftz"},{"post_id":"cjilydyki0022k8mfhq1xg5vh","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydyll003yk8mfvpf7n08h"},{"post_id":"cjilydykj0023k8mffrkbnaav","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylm0040k8mfzep6mbrx"},{"post_id":"cjilydykj0023k8mffrkbnaav","tag_id":"cjilydyll003xk8mfh94phhtv","_id":"cjilydylm0041k8mfeub6xacx"},{"post_id":"cjilydykl0025k8mfsichlyma","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydyln0043k8mfjerlcek6"},{"post_id":"cjilydykn0026k8mfuzmvhzs2","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylo0046k8mf1itl26w9"},{"post_id":"cjilydykn0026k8mfuzmvhzs2","tag_id":"cjilydyln0044k8mf4v341v7e","_id":"cjilydylo0047k8mf03wqb9er"},{"post_id":"cjilydykp0028k8mf4n61zm7z","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylp004ak8mf7pgprdmi"},{"post_id":"cjilydykp0028k8mf4n61zm7z","tag_id":"cjilydylo0048k8mf165l3dw1","_id":"cjilydylp004bk8mf3v51oatw"},{"post_id":"cjilydykq0029k8mf45zdna9f","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylr004ek8mf7vxfm8sp"},{"post_id":"cjilydykq0029k8mf45zdna9f","tag_id":"cjilydyll003xk8mfh94phhtv","_id":"cjilydylr004fk8mfnpn46sj7"},{"post_id":"cjilydyks002ak8mf8pm2ddif","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylu004ik8mf9jzmoax7"},{"post_id":"cjilydyks002ak8mf8pm2ddif","tag_id":"cjilydylo0048k8mf165l3dw1","_id":"cjilydylu004jk8mf1fzp23eu"},{"post_id":"cjilydyku002ck8mf4d687y4c","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylv004mk8mfjifpvnsn"},{"post_id":"cjilydyku002ck8mf4d687y4c","tag_id":"cjilydylu004kk8mfv5pbuc98","_id":"cjilydylv004nk8mfiy3gszkl"},{"post_id":"cjilydykw002dk8mfatpq8zhx","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylw004pk8mfoqfbr61e"},{"post_id":"cjilydykz002fk8mfrrtn5u8e","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylw004rk8mfcgrmd3mu"},{"post_id":"cjilydyl0002gk8mf13cfbflq","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydylx004tk8mf2xw0i7od"},{"post_id":"cjilydyl3002ik8mfapsorf97","tag_id":"cjilydylj003ok8mfnq6ybl4t","_id":"cjilydyly004vk8mfufsj75h3"},{"post_id":"cjilydyl8002pk8mfzmc7w676","tag_id":"cjilydylx004uk8mfc7h7rpez","_id":"cjilydylz004yk8mfh80vgx3g"},{"post_id":"cjilydyl8002pk8mfzmc7w676","tag_id":"cjilydyly004wk8mfwv4wpudn","_id":"cjilydylz004zk8mf3r1pzy3b"},{"post_id":"cjilydyl8002pk8mfzmc7w676","tag_id":"cjilydyju000yk8mfbic129vr","_id":"cjilydylz0050k8mf09bk3unu"},{"post_id":"cjilydyla002rk8mfve5ymivf","tag_id":"cjilydyly004xk8mf468y41cd","_id":"cjilydylz0051k8mf83zztlvl"},{"post_id":"cjilydyla002rk8mfve5ymivf","tag_id":"cjilydyju000yk8mfbic129vr","_id":"cjilydym00052k8mft585jz2i"}],"Tag":[{"name":"markdown","_id":"cjilydyj00004k8mfce3grcg5"},{"name":"git","_id":"cjilydyjb0008k8mfn8xv13cn"},{"name":"shell","_id":"cjilydyjg000ck8mfqqcbyle3"},{"name":"DirectX","_id":"cjilydyjk000hk8mfga0zg5pb"},{"name":"Games","_id":"cjilydyjm000lk8mfvv0t6wvb"},{"name":"图形学","_id":"cjilydyjq000pk8mf14f1ztd1"},{"name":"OpenGL","_id":"cjilydyjs000uk8mfm466akht"},{"name":"读书","_id":"cjilydyju000xk8mf4lk25mtt"},{"name":"随想","_id":"cjilydyju000yk8mfbic129vr"},{"name":"方法论","_id":"cjilydyjv000zk8mfhsbi0wkr"},{"name":"引擎","_id":"cjilydyjv0010k8mf7dznvblz"},{"name":"hexo","_id":"cjilydyjw0014k8mfs3isby6b"},{"name":"UTF-8","_id":"cjilydyjy001ak8mfzpaju45q"},{"name":"program","_id":"cjilydyjy001dk8mf83gqso07"},{"name":"learn","_id":"cjilydyjz001gk8mf4t372uyh"},{"name":"游戏","_id":"cjilydyk1001mk8mf3bf4n0d0"},{"name":"C++","_id":"cjilydyk1001nk8mfl5nvtvco"},{"name":"继承","_id":"cjilydykb001tk8mfb5eb8ni5"},{"name":"类","_id":"cjilydykf001yk8mf3fr01qyk"},{"name":"virtual","_id":"cjilydyki0021k8mf1vu2yq88"},{"name":"override","_id":"cjilydykk0024k8mfsb6gikjj"},{"name":"函数重载","_id":"cjilydyko0027k8mfubfox7k4"},{"name":"static","_id":"cjilydykt002bk8mfz2mnsr0i"},{"name":"静态成员","_id":"cjilydyky002ek8mfrppiee10"},{"name":"const","_id":"cjilydyl2002hk8mfqh7mmyrq"},{"name":"常量指针","_id":"cjilydyl6002mk8mfa9pg6dr4"},{"name":"常量引用","_id":"cjilydyla002sk8mfswdcw7cp"},{"name":"protected","_id":"cjilydylc002vk8mfn0ysidd1"},{"name":"for","_id":"cjilydylc002zk8mfjezyk16n"},{"name":"位操作","_id":"cjilydyld0031k8mfzxosazc8"},{"name":"new","_id":"cjilydyld0034k8mft9g7pt3u"},{"name":"delete","_id":"cjilydylf0037k8mfq0vrkmpc"},{"name":"运算符重载","_id":"cjilydylf003ak8mfj3lxcjzr"},{"name":"函数指针","_id":"cjilydylg003bk8mf29whpue5"},{"name":"函数对象","_id":"cjilydylg003ck8mfhaaz0ptt"},{"name":"指针","_id":"cjilydylg003dk8mfknkqwuru"},{"name":"数组","_id":"cjilydylh003gk8mfvdo8dbm9"},{"name":"常量成员函数","_id":"cjilydyli003jk8mfrglvbq8v"},{"name":"模板","_id":"cjilydyli003mk8mf8uno36u2"},{"name":"数据结构","_id":"cjilydylj003ok8mfnq6ybl4t"},{"name":"复杂度","_id":"cjilydyll003xk8mfh94phhtv"},{"name":"动态规划","_id":"cjilydyln0044k8mf4v341v7e"},{"name":"向量","_id":"cjilydylo0048k8mf165l3dw1"},{"name":"有序向量","_id":"cjilydylu004kk8mfv5pbuc98"},{"name":"建筑","_id":"cjilydylx004uk8mfc7h7rpez"},{"name":"计算机科学","_id":"cjilydyly004wk8mfwv4wpudn"},{"name":"电影","_id":"cjilydyly004xk8mf468y41cd"}]}}