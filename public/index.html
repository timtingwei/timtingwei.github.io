<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="mituh's notes" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="mituh&#39;s notes">
<meta property="og:url" content="https://timtingwei.github.io/index.html">
<meta property="og:site_name" content="mituh&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mituh&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timtingwei.github.io/"/>





  <title>mituh's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mituh's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/16/cpp/cpp-notes-0006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/cpp/cpp-notes-0006/" itemprop="url">C++ Zero To One 0.006</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T22:30:14+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 局部变量的销毁顺序</span><br><span class="line">	=============================</span><br><span class="line">	void f(int i) &#123;</span><br><span class="line">		Table aa(1);</span><br><span class="line">		Table bb(2);</span><br><span class="line">		if (i &gt; 0) &#123;</span><br><span class="line">			Table cc(3);</span><br><span class="line">		&#125;</span><br><span class="line">		Table dd(4);</span><br><span class="line">	&#125;</span><br><span class="line">	-------------- ./a.out ----------------</span><br><span class="line">	in Table() sz = 1</span><br><span class="line">	in Table() sz = 2</span><br><span class="line">	in Table() sz = 3</span><br><span class="line">	in ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class="line">	in Table() sz = 4</span><br><span class="line">	in ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class="line">	in ~Table() sz = 2</span><br><span class="line">	in ~Table() sz = 1</span><br><span class="line">	================================</span><br><span class="line"></span><br><span class="line">2, 构造函数复制</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/15/essay/about-rest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/essay/about-rest/" itemprop="url">关于休息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T22:56:54+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">人的一生有多少时间是在休息中度过的？</span><br><span class="line"></span><br><span class="line">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class="line">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class="line">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class="line">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class="line">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class="line"></span><br><span class="line">回过头来, 这件事情要是这样, </span><br><span class="line">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class="line">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class="line">因此, 将生活与工作的接口分离是有必要的。</span><br><span class="line"></span><br><span class="line">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class="line">但我希望缓慢能做到。</span><br><span class="line"></span><br><span class="line">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class="line">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class="line">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class="line">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class="line">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class="line">...等等很多。</span><br><span class="line">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class="line">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class="line"></span><br><span class="line">休息是一种智慧。 </span><br><span class="line">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class="line">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class="line">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class="line">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class="line"></span><br><span class="line">对休息也需要重构。</span><br><span class="line">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class="line"></span><br><span class="line">先生活后工作。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/cpp/cpp-notes-0005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/cpp/cpp-notes-0005/" itemprop="url">C++ Zero To One 0.005</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T21:42:33+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, protected能否被实例对象访问</span><br><span class="line"></span><br><span class="line">	&gt;* 发现问题	</span><br><span class="line">		重新实现Vector中, 要对ADT的access进行区别。</span><br><span class="line">		protected能否被实例对象访问?</span><br><span class="line">		protected能否被继承类访问?</span><br><span class="line">	&gt;* 尝试</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		class Base &#123;</span><br><span class="line">		private:</span><br><span class="line">			int i = 0;</span><br><span class="line">			void f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		protected:</span><br><span class="line">			void f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		public:</span><br><span class="line">			void f() &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class="line">				f_prot();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		class Derived : Base &#123;</span><br><span class="line">		public:</span><br><span class="line">			void call_f_prot() &#123;f_prot();&#125;</span><br><span class="line">			// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		int main() &#123;</span><br><span class="line">			Base b;</span><br><span class="line">			Derived d;</span><br><span class="line">			// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class="line">			d.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class="line">			// d.call_f_priv();</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 特点</span><br><span class="line">		protected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class="line">		</span><br><span class="line">		希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class="line">		而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, for循环语句的简单写法</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">	for语句的三个表达式如何写?</span><br><span class="line">	Vector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class="line">	&#123;_elem = new T[_capacity = c];</span><br><span class="line">		for (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class="line">		</span><br><span class="line">	&gt;* 利用for的参数</span><br><span class="line">		for ( declaration-or-expression(optional) ; </span><br><span class="line">			declaration-or-expression(optional) ; </span><br><span class="line">			expression(optional) )</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		const int s = 8;</span><br><span class="line">		int size = 0;</span><br><span class="line">		int elem[s] = &#123;&#125;;</span><br><span class="line">		/*</span><br><span class="line">		for (size = 0; size &lt; s; size++) &#123;</span><br><span class="line">			elem[size] = 2;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		// 第三个参数, 递增size的同时, 给修改elem</span><br><span class="line">		for (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class="line">		// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class="line">		for (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	&gt;* 反思</span><br><span class="line">		某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		Vector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class="line">		Vector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class="line">		============================================================</span><br><span class="line">		对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class="line"></span><br><span class="line">	&gt;* 常量引用</span><br><span class="line">		type const&amp;, type&amp; const之间是什么区别 ?</span><br><span class="line">		先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class="line">		</span><br><span class="line">		让测试代码跑跑。</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		int f() &#123;</span><br><span class="line">		int a = 0, b = 1;</span><br><span class="line">		const int ca = 0, cb = 1;</span><br><span class="line">		</span><br><span class="line">		int&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class="line">		int* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class="line">		const int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class="line">		const int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class="line">		int const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class="line">		const int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class="line">		// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class="line">		// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class="line">		// 引用不能duplicate const</span><br><span class="line">		f1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class="line">		// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class="line">		// cref_a_1++;    // read-only</span><br><span class="line">		</span><br><span class="line">		// 引用指针</span><br><span class="line">		int* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class="line">		// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class="line">		const int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class="line">		// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class="line">		const int* const&amp; cref_cptrca = cptr_ca;</span><br><span class="line">		</span><br><span class="line">		(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class="line">		// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void f1(int const&amp; ic) &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling f1()...\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">		常量引用的写法. 所引用的对象类型为type</span><br><span class="line">		(type) const&amp; ref_t;</span><br><span class="line">		// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class="line">		</span><br><span class="line">		另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class="line">		</span><br><span class="line">	&gt;* 常量指针</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int a = 0, b = 0, c = 0, d = 0;</span><br><span class="line">		int* p_a = &amp;a;                 // 指向int的指针</span><br><span class="line">		// 指针地址可变, 指向的a可变</span><br><span class="line">		(*p_a)++; p_a = &amp;b;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">		const int* p_b = &amp;b;          // 指向const int的指针</span><br><span class="line">		// 指针地址可变, 指向的元素转换成const不可变</span><br><span class="line">		// (*p_b)++;</span><br><span class="line">		p_b = &amp;c;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">		int* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class="line">		// 指针地址不可变, 指向的元素可以变</span><br><span class="line">		(*cp_c)++;</span><br><span class="line">		// cp_c = &amp;d;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">		// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class="line">		const int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class="line">		// 指针地址不可变, 指向值不可变</span><br><span class="line">		// (*cp_cd)++;</span><br><span class="line">		// cp_cd = &amp;a;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">		------------------------ ./a.out ---------------------------</span><br><span class="line">		*p_a = 0, a = 1</span><br><span class="line">		*p_b = 0, b = 0</span><br><span class="line">		*cp_c = 1, c = 1</span><br><span class="line">		*cp_cd = 0, d = 0</span><br><span class="line">		============================================================</span><br><span class="line">		T*               = &amp;a;      // 指针</span><br><span class="line">		const T*         = &amp;ca;     // 指向常量的指针</span><br><span class="line">		T* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class="line">		const T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class="line">		</span><br><span class="line">	&gt;* const_cast&lt;type&gt;();</span><br><span class="line">		=======</span><br><span class="line">		int b = 0;</span><br><span class="line">		const int* p_b= &amp;b;</span><br><span class="line">		*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class="line">		// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class="line">		==========</span><br><span class="line">		一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class="line">		我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class="line">	</span><br><span class="line">	&gt;*  最初的辨析</span><br><span class="line">		T const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class="line">		const T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class="line">		T&amp; const : 非法 </span><br><span class="line">		T const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class="line">		const T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class="line">		T* const : 指针, 指向T的常量指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/movies/the-Truman-show-critic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/movies/the-Truman-show-critic/" itemprop="url">楚门的世界, 写于观后和离前</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T11:29:45+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1, 疑惑</span><br><span class="line">	1) 戏中戏外的时间不同步</span><br><span class="line">		戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class="line">		是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class="line">		大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class="line">		在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class="line">	2) 关于梦醒</span><br><span class="line">		长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class="line">		梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">2, 观点</span><br><span class="line">	1) 戏里戏外都在被安慰</span><br><span class="line">		戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class="line">		有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class="line">		而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class="line">		他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class="line">		</span><br><span class="line">		戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class="line">		通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class="line">		创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class="line"></span><br><span class="line">	2) 构成生活看似真实性的一些元素</span><br><span class="line">		说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class="line">		交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class="line">		独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class="line">		神的安排。</span><br><span class="line"></span><br><span class="line">	3) 二十世纪末的美国科技和科幻能力</span><br><span class="line">		98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class="line">		制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class="line">		楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class="line">		当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class="line"></span><br><span class="line">	4) 如果对现有的生活不再眷恋</span><br><span class="line">		除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/dsacpp/02-D2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/dsacpp/02-D2/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T17:09:13+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d2 有序向量: 二分查找</span><br><span class="line"></span><br><span class="line">	Vector::find(e, lo, hi);</span><br><span class="line">	Vector::search(e, lo, hi);</span><br><span class="line"></span><br><span class="line">	操作参数和接口语义类似。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 统一接口</span><br><span class="line">	&gt;* ADT接口</span><br><span class="line">	======================== source code ==========================</span><br><span class="line">	// ADT接口</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::srand(std::time(0));</span><br><span class="line">		return (std::rand() % 2) ?</span><br><span class="line">			binSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class="line">			: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	================================================================</span><br><span class="line">	可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 语义约定</span><br><span class="line"></span><br><span class="line">	约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class="line">	&gt;* 优点: </span><br><span class="line">		维护自身 V.insert(1 + V.search(e), e)</span><br><span class="line">			即便是失败, 也给出插入新元素的位置。</span><br><span class="line">			若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class="line">	</span><br><span class="line">	&gt;* 约点:</span><br><span class="line">		有序V[lo, hi), 不大于e的最后元素秩</span><br><span class="line">		-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class="line">		V[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 原理</span><br><span class="line"></span><br><span class="line">	&gt;* 减而治之</span><br><span class="line">		待查找区间分成三部分</span><br><span class="line">		S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class="line">	</span><br><span class="line">	&gt;* 三种比较情况</span><br><span class="line">		e &lt; x: 左</span><br><span class="line">		x &lt; e: 右</span><br><span class="line">		e = x: 命中             // 多个解?</span><br><span class="line">	</span><br><span class="line">	&gt;* 二分(折半)策略</span><br><span class="line">		每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实现</span><br><span class="line"></span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		======= source code ======================================</span><br><span class="line">		// 二分查找: 版本A</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">			if (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class="line">				Rank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class="line">				if (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class="line">				if (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class="line">					return (binSearch(elem, e, lo, mi));</span><br><span class="line">				&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		==========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 给出的版本</span><br><span class="line">		==================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">				Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">				if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">				else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">				else                   return mi;    // 在mi命中</span><br><span class="line">			&#125;</span><br><span class="line">		return -1;   // 查找失败</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 分析</span><br><span class="line">		1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class="line">		2, while循环通过hi, lo改变, 改变区间。</span><br><span class="line">		3, if...else 和 else...if什么差别？</span><br><span class="line">	</span><br><span class="line">	&gt;* 技巧</span><br><span class="line">		善用 &quot;&lt;&quot; 比较</span><br><span class="line">			因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实例与复杂度</span><br><span class="line"></span><br><span class="line">	&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class="line">	&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class="line">	</span><br><span class="line">	&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class="line">	递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"># 版本A：查找长度</span><br><span class="line"></span><br><span class="line">	&gt;* 更为精细的评估算法性能:</span><br><span class="line">		考察关键码的比较次数, 查找长度(search length)</span><br><span class="line">	&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class="line">	&gt;* 这个算法 = O(1.5logn)</span><br><span class="line">		向左节点 + 1, 向右节点 +2</span><br><span class="line">		n = 8</span><br><span class="line">		最好, 29/7 = 4+</span><br><span class="line">		最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/cpp/cpp-notes-0004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/cpp/cpp-notes-0004/" itemprop="url">C++ Zero To One 0.004</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T10:28:06+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1, bool和int的隐式转换</span><br><span class="line">	[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt;* 问题起因</span><br><span class="line">		======================= source code =========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">		int count = 0;   // 计数器</span><br><span class="line">		for (int i = i; i &lt; _size; i++)</span><br><span class="line">			count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">		return count;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class="line">	</span><br><span class="line">	&gt;* sizeof(bool) = 1</span><br><span class="line">  </span><br><span class="line">	&gt;* bool-&gt; not bool</span><br><span class="line">		布尔值转赋值给非布尔值, 初始值false时0, true时1 	</span><br><span class="line">	</span><br><span class="line">	&gt;* not bool -&gt; bool</span><br><span class="line">		非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class="line">	</span><br><span class="line">		其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		void f_to_bool() &#123;</span><br><span class="line">		int i1 = 5, i2 = 0;</span><br><span class="line">		int* pi0 = 0;       // 定义空指针</span><br><span class="line">		int* pi1 = &amp;i1;      // 指针指向i1</span><br><span class="line">		int&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class="line">		int&amp; ri1 = i1;      // 引用i1</span><br><span class="line">		</span><br><span class="line">		bool bi = i1;        // prints  bi = 1</span><br><span class="line">		bool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class="line">		bool bpi1 = pi1;     //         bpi1 = 1</span><br><span class="line">		bool bri0 = ri0;     //         bri0 = 0</span><br><span class="line">		bool bri1 = ri1;     //         bri1 = 1</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------------------------  </span><br><span class="line"># 2, 不能返回函数内部初始化的指针</span><br><span class="line">	[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class="line"></span><br><span class="line">	&gt;* 问题</span><br><span class="line">		数据结构学习中, Rank* deduplicate_lower();</span><br><span class="line">		我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class="line">	&gt;* 错误的方法</span><br><span class="line">		函数体内声明定义的指针，返回不了</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int* f() &#123;</span><br><span class="line">			int iarr[] = &#123;&#125;;</span><br><span class="line">			iarr[0] = 2;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out -----------------------------</span><br><span class="line">		warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class="line">		============================================================</span><br><span class="line">		我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class="line">	</span><br><span class="line">	&gt;* 可行的方法</span><br><span class="line">		将指针作为参数传入</span><br><span class="line">		================== source code =============================</span><br><span class="line">		int* f1(int* iarr) &#123;</span><br><span class="line">			*iarr += 1;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class="line">		便于函数之间的调用, 还是需要的。</span><br><span class="line">	</span><br><span class="line">	&gt;* 另一种可行方法: malloc返回指针</span><br><span class="line">		================= source code ============================</span><br><span class="line">		// 强制返回指针, 分配内存却不释放</span><br><span class="line">		int* fun() &#123;</span><br><span class="line">			int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class="line">			for (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class="line">				*(i_ptr+i) = 0;</span><br><span class="line">			// free(i_ptr);  // 释放指针</span><br><span class="line">			return i_ptr;    // 函数返回指针</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"># 3, malloc和free</span><br><span class="line">	[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class="line">  </span><br><span class="line">	&gt; * 概念</span><br><span class="line">		malloc:</span><br><span class="line">		void* malloc (size_t size);</span><br><span class="line">		在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class="line">		free:</span><br><span class="line">		void free(void* ptr);</span><br><span class="line">		重新分配作用域中的memeory, 给未来的分配使用</span><br><span class="line">	</span><br><span class="line">	&gt; * 需要include的库</span><br><span class="line">		#include &lt;stdlib.h&gt;</span><br><span class="line">		#include &lt;stdio.h&gt;</span><br><span class="line">	</span><br><span class="line">	&gt; * 案例</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int main() &#123;</span><br><span class="line">			int i, n;</span><br><span class="line">			char* buffer;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;how long do you want the string?&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">	        buffer = (char*) malloc(i+1);</span><br><span class="line">	        if (buffer==NULL) exit(1);</span><br><span class="line"></span><br><span class="line">	        for (n=0; n &lt; i; n++)</span><br><span class="line">				buffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class="line">			buffer[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;Random string: %s\n&quot;, buffer);</span><br><span class="line">	        free(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		------------------ ./a.out -------------------------------</span><br><span class="line">		how long do you want the string?5</span><br><span class="line">		Random string: nwlrb</span><br><span class="line">		===========================================================</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"># 4, 未声明大小的数组</span><br><span class="line">	[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class="line"></span><br><span class="line">	&gt; * 问题</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int size = 5;</span><br><span class="line">		int iarr[size] = &#123;&#125;;</span><br><span class="line">		------------------- ./a.out ----------------------------------</span><br><span class="line">		error: variable-sized object ‘iarr1’ may not be initialized</span><br><span class="line">		===========================================================</span><br><span class="line">	</span><br><span class="line">	&gt; * const</span><br><span class="line">		=========== source code ==========</span><br><span class="line">		const unsigned int size = 5;</span><br><span class="line">		int iarr1[size] = &#123;&#125;;</span><br><span class="line">		==================================</span><br><span class="line">	</span><br><span class="line">	&gt; * define</span><br><span class="line">		========== source code ==============</span><br><span class="line">		#define ARRAY_SIZE 5;</span><br><span class="line">		// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class="line">		int iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class="line">		======================================</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"># 5, continue 和 break 区别</span><br><span class="line">	[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt; * 概念 </span><br><span class="line">		continue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class="line">		break: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class="line">	</span><br><span class="line">	&gt; * continue实例:</span><br><span class="line">		loop:</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		// 跳过loop剩余部分</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class="line">				continue;&#125;</span><br><span class="line">				// ...</span><br><span class="line">				std::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">    &gt; * break实例:	</span><br><span class="line">		1, loop:</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		// 终止循环</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class="line">				std::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	</span><br><span class="line">		2, switch</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int i = 2;</span><br><span class="line">		switch (i) &#123;</span><br><span class="line">			case 1: std::cout &lt;&lt; &quot;1\n&quot;;</span><br><span class="line">			case 2: std::cout &lt;&lt; &quot;2\n&quot;;         // 选择到这里</span><br><span class="line">			case 3: std::cout &lt;&lt; &quot;3\n&quot;;</span><br><span class="line">			case 4:</span><br><span class="line">			case 5: std::cout &lt;&lt; &quot;45 \n&quot;;</span><br><span class="line">				break;                            // 终止switch</span><br><span class="line">			case 6: std::cout &lt;&lt; &quot;6\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		------------------- ./a.out ------------------------------</span><br><span class="line">		2</span><br><span class="line">		3</span><br><span class="line">		45</span><br><span class="line">		============================================================</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"># if...else 和 if...else if的区别</span><br><span class="line">	[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line">	&gt;* 问题</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">			Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">			if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">			else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">			else                   return mi;    // 在mi命中</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		if, else...if 和 else是什么关系？</span><br><span class="line">		从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class="line">	</span><br><span class="line">	&gt;* if...else</span><br><span class="line">		====</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out ---------------------------</span><br><span class="line">		i &gt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if...else if...else if</span><br><span class="line">		===</span><br><span class="line">		int i = 4;</span><br><span class="line">		if (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		-----</span><br><span class="line">		i &lt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if</span><br><span class="line">		===</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class="line">		if (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class="line">		----------------- ./a.out --------------------------</span><br><span class="line">		i =  6</span><br><span class="line">		i != 7</span><br><span class="line">		====================================================</span><br><span class="line">	&gt;* 各自的作用域辨析</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		bool foo = false, bar = true, baz = true;</span><br><span class="line">		if (foo) &#123;</span><br><span class="line">			// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;if(foo)\n&quot;;</span><br><span class="line">		&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;else if(bar)\n&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class="line">			std::cout &lt;&lt; &quot;else &#123;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class="line">			// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class="line">			std::cout &lt;&lt; &quot;if(baz)\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		---------------------- ./a.out ----------------------------------</span><br><span class="line">		// else if(bar)</span><br><span class="line">		// if(baz)</span><br><span class="line">		==============================================================</span><br><span class="line">		我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class="line">		这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class="line">	&gt;* 总结</span><br><span class="line">		if(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class="line">		如果有一个true, 则不会执行接下来的else; </span><br><span class="line">		如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class="line">		</span><br><span class="line">		因此，对于二分查找来说, </span><br><span class="line">		前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class="line">		</span><br><span class="line">		1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class="line">		2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class="line">		===== source code ======</span><br><span class="line">		int i = 4, count = 0;</span><br><span class="line">		(i == 4) ? count++</span><br><span class="line">			: i = 4;</span><br><span class="line">		========================</span><br><span class="line">		缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class="line">		3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/11/dsacpp/02-D1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/dsacpp/02-D1/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T19:22:42+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。</span><br><span class="line">------------------------------ split line ---------------------------</span><br><span class="line">实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line"></span><br><span class="line"># 有序向量唯一化</span><br><span class="line">	无序: 比对</span><br><span class="line">	有序: 比较</span><br><span class="line"></span><br><span class="line">## 有序性及其甄别</span><br><span class="line"></span><br><span class="line">	&gt; * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。</span><br><span class="line">	</span><br><span class="line">	&gt; * 相邻逆序对数目, 可以度量逆序程度。</span><br><span class="line">	</span><br><span class="line">		&gt; * 逆序程度实现</span><br><span class="line">		</span><br><span class="line">		===================== source code =========================</span><br><span class="line">		// 逆序程度</span><br><span class="line">		/* my test code </span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;</span><br><span class="line">			for (int i = 0; i &lt; _size - 1; i++)</span><br><span class="line">				if (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素</span><br><span class="line">			return count;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;   // 计数器</span><br><span class="line">			for (int i = i; i &lt; _size; i++)</span><br><span class="line">				count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">			return count;  // 向量有序当且仅当n = 0</span><br><span class="line">		&#125; // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止</span><br><span class="line">		============================================================</span><br><span class="line">		</span><br><span class="line">	&gt; * 若元素支持大小比较, 可将无序向量转换为有序向量。</span><br><span class="line">	&gt; * 无序向量转换为有序向量后, 算法多可优化。</span><br><span class="line"></span><br><span class="line">## 低效算法</span><br><span class="line"></span><br><span class="line">	&gt; 1, 我自己的低效deduplicate()版本, </span><br><span class="line">		依赖一次性remove函数.</span><br><span class="line">		&gt; * 尝试自己实现,</span><br><span class="line">		</span><br><span class="line">		======================== sourece code =======================</span><br><span class="line">		// my deduplicate code</span><br><span class="line">		// 唯一化(低效)</span><br><span class="line">		int deduplicate_lower(int rm_arr[]);</span><br><span class="line">		// 唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		void remove(int rm_arr[], int n);</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::deduplicate_lower(int rm_arr[]) &#123;</span><br><span class="line">			// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量</span><br><span class="line">			assert(!disordered());   // 当前为有序向量</span><br><span class="line">			Rank n = 0;            // 数组当前插入位置</span><br><span class="line">			Rank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描</span><br><span class="line">			while (r2 &lt; _size) &#123;</span><br><span class="line">				if (_elem[r1] == _elem[r2]) &#123;   // r2指向的元素和r1对应元素重复</span><br><span class="line">					rm_arr[n++] = r2;     // 索引数组中加入r2</span><br><span class="line">					// remove(r2);</span><br><span class="line">				&#125; else &#123; r1 = r2;&#125;</span><br><span class="line">				r2++;    // 递增r2</span><br><span class="line">				&#125;</span><br><span class="line">			remove(rm_arr, n);   // 一次性删除索引对应的元素</span><br><span class="line">			return n;            // 返回删除元素数量</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    // 有序向量唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::remove(int rm_arr[], int n) &#123;</span><br><span class="line">			// 删除索引除外的索引对应元素保留, 从左向右扫描</span><br><span class="line">			int i_n = 0;     // 指向rm_arr中的元素</span><br><span class="line">			int new_i = 0;   // 保留索引</span><br><span class="line">			T* old_elem = _elem;    // 备份一份当前元素</span><br><span class="line">			_elem = new T[_capacity = _capacity];</span><br><span class="line">			for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">				if (i != rm_arr[i_n]) &#123;     // 当前索引不在表中</span><br><span class="line">					_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置</span><br><span class="line">				&#125; else &#123;     // 当前索引在删除索引的表中</span><br><span class="line">					i_n++;     // 指向下一个rm_arr中的元素</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_size -= n;</span><br><span class="line">			delete [] old_elem;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt; 2, 视频中的唯一化(低效版)</span><br><span class="line">		代码如下:</span><br><span class="line">		======================= source code ========================</span><br><span class="line">		// 有序向量唯一化</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size; int i = 0;  // 首元素开始</span><br><span class="line">			while (i &lt; _size - 1) &#123;</span><br><span class="line">				(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;</span><br><span class="line">			&#125;    // _size的改变由remove隐式完成</span><br><span class="line">			return old_size - _size;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">## 低效算法: 复杂度</span><br><span class="line">	&gt; 1, 低效复杂度</span><br><span class="line">		运行时间取决于while循环, 总计 _size - 1 = n - 1 </span><br><span class="line">		最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)</span><br><span class="line">	&gt; 2, 比较</span><br><span class="line">		我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 高效算法:</span><br><span class="line">	&gt; 1, 反思</span><br><span class="line">		低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。</span><br><span class="line">	&gt; 2, 启示</span><br><span class="line">		将重复区间视为单位, 成批的删除</span><br><span class="line">	&gt; 3, 算法</span><br><span class="line">		[i] [] [ . . . . duplicates] [j] </span><br><span class="line">		从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。</span><br><span class="line">		</span><br><span class="line">		高明之处在于: 实际上没有删除, 却等效于删除</span><br><span class="line">		================== source code ==============================</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size;</span><br><span class="line">		    int i = 0, j = 1;   // i指向首位置</span><br><span class="line">			int n = 1;    // 实际更新后的_elem的索引</span><br><span class="line">			while (i &lt; _size - 1)</span><br><span class="line">				if (_elem[i] != _elem[j])</span><br><span class="line">					&#123; _elem[n++] = _elem[j]; i = j; size--;</span><br><span class="line">					&#125; else &#123;j++;&#125;</span><br><span class="line">	        return old_size - n;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify_faster() &#123;</span><br><span class="line">			int i = 0, j = 0;   // 两个计数都指向首元素</span><br><span class="line">			while (++j &lt; _size) &#123;   // j扫描到末尾</span><br><span class="line">				if (_elem[i] != _elem[j]) &#123;_elem[++i] = _elem[j];&#125;  // j指向元素移到i后</span><br><span class="line">			&#125;</span><br><span class="line">			_size = ++i; shrunk();      // 改变_size数值后, 缩容</span><br><span class="line">			return j - i;    // 注意j扫到尾端的特性</span><br><span class="line">		&#125;     // 依赖shrink();</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">	    /* 实现问题分析</span><br><span class="line">		// 为什么不要另外的n作为索引计数?</span><br><span class="line">		当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。</span><br><span class="line">		// 为什么不在uniquify中进行new 和 delete?</span><br><span class="line">		接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。</span><br><span class="line">	    */</span><br><span class="line"></span><br><span class="line">## 高效算法: 实例与复杂度</span><br><span class="line">	&gt; 1, *反思 (典型例子)</span><br><span class="line">		共计n-1次迭代, 每次常数时间, 累计O(n)时间。</span><br><span class="line">		</span><br><span class="line">		优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。</span><br><span class="line">		体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/11/cpp/cpp-notes-0003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/cpp/cpp-notes-0003/" itemprop="url">C++ Zero To One 0.003</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T16:06:51+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重载函数什么时候用virtual"><a href="#重载函数什么时候用virtual" class="headerlink" title="重载函数什么时候用virtual?"></a>重载函数什么时候用virtual?</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp" target="_blank" rel="noopener">source code - load_funtion.cpp</a></p>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit)</span></span>;</span><br><span class="line"><span class="comment">// template &lt;typename VST&gt; virtual void traverse(VST visit, T* e);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit, T* e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为什么这里不需要virtual??</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个T类型元素加1的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;e)</span> </span>&#123;e++;&#125;    <span class="comment">// Increase&lt;T&gt;()实现函数功能  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么这里又需要virtual??</p>
<h2 id="概念偏差"><a href="#概念偏差" class="headerlink" title="概念偏差"></a>概念偏差</h2><p>virtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。</p>
<p><strong>vitual为虚函数</strong>：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 </p>
<p><strong>重载函数</strong>：同一作用域内的几个函数名字相同但形参列表不同。</p>
<h2 id="使用与不使用virtual"><a href="#使用与不使用virtual" class="headerlink" title="使用与不使用virtual"></a>使用与不使用virtual</h2><p>解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>    <span class="comment">// 声明virtual后, 可被继承类override重载</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;   <span class="comment">// 'override'可写可不写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>关键问题: 上述两者什么差别????</code></p>
<p>运行测试一下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释是使用virtual结果</span></span><br><span class="line">  Base b;</span><br><span class="line">  Derived d;</span><br><span class="line"></span><br><span class="line">  Base&amp; br = b;      <span class="comment">// refer b, br的类型是Base&amp;</span></span><br><span class="line">  Base&amp; dr = d;      <span class="comment">// dr类型也是Base&amp;</span></span><br><span class="line">  br.print();        <span class="comment">// Base</span></span><br><span class="line">  dr.print();        <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  Base* pb = &amp;b;     <span class="comment">// pointer to b, Base*</span></span><br><span class="line">  Base* pd = &amp;d;     <span class="comment">// Base* as well</span></span><br><span class="line"></span><br><span class="line">  pb-&gt;print();       <span class="comment">// Base</span></span><br><span class="line">  pd-&gt;print();       <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  b.Base::print();   <span class="comment">// Base</span></span><br><span class="line">  d.Base::print();   <span class="comment">// Base</span></span><br></pre></td></tr></table></figure></p>
<p>使用vitual的运行结果:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure>
<p>不使用虚方法的运行结果:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure></p>
<p>virtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。</p>
<h2 id="解决最初问题"><a href="#解决最初问题" class="headerlink" title="解决最初问题"></a>解决最初问题</h2><h3 id="为什么traverse函数不需要virtual"><a href="#为什么traverse函数不需要virtual" class="headerlink" title="为什么traverse函数不需要virtual"></a>为什么traverse函数不需要virtual</h3><p>traverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。</p>
<h3 id="为什么函数对象需要virtual重载操作符函数"><a href="#为什么函数对象需要virtual重载操作符函数" class="headerlink" title="为什么函数对象需要virtual重载操作符函数?"></a>为什么函数对象需要virtual重载操作符函数?</h3><p>定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象用virtual声明operator()()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="comment">// 重载()后, 对象可充当函数的功能</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> </span>&#123;(*e)++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase_two</span> :</span> Increase &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> override </span>&#123;(*e)+= <span class="number">2</span>;&#125;    <span class="comment">// 元素+2;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试函数, 以及prints结果如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Increase a;</span><br><span class="line">  Increase_two b;</span><br><span class="line"></span><br><span class="line">  Increase&amp; ra = a;</span><br><span class="line">  Increase&amp; rb = b;     <span class="comment">// rb的类型为 Increase&amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> e = <span class="number">5</span>; <span class="keyword">int</span>* pe = &amp;e;</span><br><span class="line">  ra.<span class="keyword">operator</span>()(pe);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e = "</span> &lt;&lt; e &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// prints "e = 6"</span></span><br><span class="line">  <span class="keyword">int</span> e2 = <span class="number">5</span>; <span class="keyword">int</span>* pe2 = &amp;e2;</span><br><span class="line">  rb.<span class="keyword">operator</span>()(pe2);   <span class="comment">// 调用基类的引用时, 动态绑定到Increase_two中的方法</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e2 = "</span> &lt;&lt; e2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// prints "e2 = 7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。</p>
<h1 id="静态成员声明定义使用"><a href="#静态成员声明定义使用" class="headerlink" title="静态成员声明定义使用"></a>静态成员声明定义使用</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp" target="_blank" rel="noopener">source code - static.cpp</a></p>
<h2 id="静态成员的特点"><a href="#静态成员的特点" class="headerlink" title="静态成员的特点"></a>静态成员的特点</h2><p>静态数据成员不属于任何类的一个对象。</p>
<p>类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期</p>
<h2 id="类内static成员如何声明定义"><a href="#类内static成员如何声明定义" class="headerlink" title="类内static成员如何声明定义?"></a>类内static成员如何声明定义?</h2><blockquote>
<ul>
<li>在类内部声明, 外部通过类名作用域访问定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatic</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> i_stc;   <span class="comment">// 类内部声明</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyStatic::i_stc = <span class="number">0</span>;     <span class="comment">// 类外部定义, 注意需要声明成员的类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。</p>
<h2 id="在不同实例中被多次调用改变后的情况"><a href="#在不同实例中被多次调用改变后的情况" class="headerlink" title="在不同实例中被多次调用改变后的情况?"></a>在不同实例中被多次调用改变后的情况?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MyStatic::increment() &#123;++i_stc;&#125;</span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">  MyStatic c0;</span><br><span class="line">  c0.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c0 = &quot; &lt;&lt; c0.i_stc &lt;&lt; std::endl;</span><br><span class="line">  MyStatic c1;</span><br><span class="line">  c1.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f1() &#123;</span><br><span class="line">  MyStatic c2;</span><br><span class="line">  c2.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">c0 = 1</span><br><span class="line">c1 = 2</span><br><span class="line">c2 = 3</span><br></pre></td></tr></table></figure>
<p>静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/essay/architecture-application-between-computer-science/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/essay/architecture-application-between-computer-science/" itemprop="url">建筑设计应用和计算机科学一点随想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T16:27:28+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。</p>
<p>批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 </p>
<p>学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/cpp/cpp-notes-02/" itemprop="url">C++ Zero To One 0.002</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T13:01:23+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组-指针数组-指向指针的指针的数组-…"><a href="#数组-指针数组-指向指针的指针的数组-…" class="headerlink" title="数组, 指针数组, 指向指针的指针的数组, …."></a>数组, 指针数组, 指向指针的指针的数组, ….</h1><p>在逛<a href="http://www.cplusplus.com/forum/beginner/" target="_blank" rel="noopener">Cplusplus Forum - Beginner</a>的时候发现了一个看上去看简单的<a href="http://www.cplusplus.com/forum/beginner/228196/" target="_blank" rel="noopener">问题</a></p>
<p><strong>How do I receive two numbers from the keyboard, save them in an array of two element?</strong></p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a><strong>第一次尝试</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;     <span class="comment">// ERROR: 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 不合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iarr[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; iarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想得太简单了。不能在标准输入中, 直接对数据进行修改。</p>
<h2 id="下面给出的答案"><a href="#下面给出的答案" class="headerlink" title="下面给出的答案"></a><strong>下面给出的答案</strong></h2><p>1,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; iarr[<span class="number">0</span>] &gt;&gt; iarr[<span class="number">1</span>];     <span class="comment">// 直接输入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;     <span class="comment">// 先输入, 再存放</span></span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="但是我仍然考虑我思路实现的可能性？"><a href="#但是我仍然考虑我思路实现的可能性？" class="headerlink" title="但是我仍然考虑我思路实现的可能性？"></a><strong>但是我仍然考虑我思路实现的可能性？</strong></h2><p>对已经放置在数组中的值进行修改的思路如何实现？</p>
<h3 id="第一个想到的就是指针。"><a href="#第一个想到的就是指针。" class="headerlink" title="第一个想到的就是指针。"></a>第一个想到的就是指针。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;  <span class="comment">// <span class="doctag">BUG:</span> 为什么不能通过数组中保存的指针修改数组??</span></span><br><span class="line">  <span class="keyword">int</span> *pa, *pb;</span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;</span><br><span class="line">  <span class="keyword">int</span> tmp_a, tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp_a &gt;&gt; tmp_b;        <span class="comment">// 存放到临时变量</span></span><br><span class="line">  pa = &amp;tmp_a; pb = &amp;tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pa = "</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// *pa = 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(*iarr) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iarr[<span class="number">0</span>]) &lt;&lt; <span class="string">' '</span> &lt;&lt; *(iarr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">*pa = 1</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<p>很气, 我得出结论。不能通过数组中保存的指针修改数组。</p>
<h3 id="数组作为函数形参"><a href="#数组作为函数形参" class="headerlink" title="数组作为函数形参"></a>数组作为函数形参</h3><p>接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：<br><strong>创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_int</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n指向的整数递增1</span></span><br><span class="line">  (*(arr+n)) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  revise_value_int(iarr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iarr[2] = "</span> &lt;&lt; iarr[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise();</span><br></pre></td></tr></table></figure>
<p>可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。</p>
<h3 id="函数形参为存放指针的数组"><a href="#函数形参为存放指针的数组" class="headerlink" title="函数形参为存放指针的数组"></a>函数形参为存放指针的数组</h3><p>接着，我改变了数组，用于存放指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span> ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译时就出现了错误,.<em>error: invalid conversion from ‘int</em>’ to ‘int’ [-fpermissive]<em><br><strong>因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\</strong></em></p>
<p>修改<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>写修改指针所指向整数的函数, 注意, 这个形参类型是<code>int**</code>, <strong>ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_ptr</span><span class="params">(<span class="keyword">int</span>** ptrArr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n的指向的指针所指向的整数递增1</span></span><br><span class="line">  (**(ptrArr+n))+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Segmentation-fault-core-dumped"><a href="#Segmentation-fault-core-dumped" class="headerlink" title="Segmentation fault (core dumped)"></a>Segmentation fault (core dumped)</h3><p>再次编译<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>出现 Segmentation fault (core dumped) 的原因， 参考[<a href="http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html</a>]</p>
<h4 id="1-内存访问越界"><a href="#1-内存访问越界" class="headerlink" title="1 内存访问越界"></a>1 内存访问越界</h4><p>  a) 由于使用错误的下标，导致数组访问越界</p>
<p>  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>
<p>  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<h4 id="2-多线程程序使用了线程不安全的函数。"><a href="#2-多线程程序使用了线程不安全的函数。" class="headerlink" title="2 多线程程序使用了线程不安全的函数。"></a>2 多线程程序使用了线程不安全的函数。</h4><h4 id="3-多线程读写的数据未加锁保护。"><a href="#3-多线程读写的数据未加锁保护。" class="headerlink" title="3 多线程读写的数据未加锁保护。"></a>3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>
<h4 id="非法指针"><a href="#非法指针" class="headerlink" title="非法指针"></a>非法指针</h4><p>  a) 使用空指针<br>  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>
<h4 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h4><p>不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<h3 id="非法指针-1"><a href="#非法指针-1" class="headerlink" title="非法指针"></a>非法指针</h3><p>我的代码是:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我使用了非法的指针, 这个指针没有指向任何</p>
<p>修改,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br><span class="line">  another_revise_value_ptr(ptrArr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"**(ptrArr)   = "</span> &lt;&lt; **(ptrArr)   &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+1) = "</span> &lt;&lt; **(ptrArr+<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+2) = "</span> &lt;&lt; **(ptrArr+<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise()</span><br></pre></td></tr></table></figure>
<p>编译得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">**(ptrArr)   = 1</span><br><span class="line">**(ptrArr+1) = 2</span><br><span class="line">**(ptrArr+2) = 4</span><br></pre></td></tr></table></figure></p>
<h3 id="解决最开始问题并总结"><a href="#解决最开始问题并总结" class="headerlink" title="解决最开始问题并总结"></a>解决最开始问题并总结</h3><p><strong>修改后的代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;     <span class="comment">// DE<span class="doctag">BUG:</span> 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, <span class="keyword">int</span>* pb = &amp;b;     <span class="comment">// 注意: 不要定义空指针</span></span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 注意数组的类型是数组中元素的类型</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 也能合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; **iarr &lt;&lt; <span class="string">' '</span> &lt;&lt; **(iarr+<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 解引用</span></span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不要定义空指针"><a href="#不要定义空指针" class="headerlink" title="不要定义空指针"></a>不要定义空指针</h4><p>如这样<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa;</span><br></pre></td></tr></table></figure></p>
<p>即使要定义也要<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *pa = 0;</span><br><span class="line">int *pb = nullptr;</span><br></pre></td></tr></table></figure></p>
<p>尽量让指针指向某个对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><p>数组的类型是数组中元素的类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 类型为 int*</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解引用数组"><a href="#解引用数组" class="headerlink" title="解引用数组"></a>解引用数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 如果数组这样定义</span></span><br><span class="line">iarr;                           <span class="comment">// iarr是指向数组首个元素的指针</span></span><br><span class="line">*iarr;                          <span class="comment">// 因为pa是指针, 所以解引用数组头指针, 得到pa地址</span></span><br><span class="line">**iarr;                         <span class="comment">// 再次解引用得到pa指向的int</span></span><br></pre></td></tr></table></figure>
<p>标准输出它们得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iarr = 0x7ffed5caa560</span><br><span class="line">*iarr = 0x7ffed5caa548</span><br><span class="line">**iarr = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="更多的尝试"><a href="#更多的尝试" class="headerlink" title="更多的尝试"></a><strong>更多的尝试</strong></h2><h3 id="数组中存放对象"><a href="#数组中存放对象" class="headerlink" title="数组中存放对象"></a>数组中存放对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* _c; <span class="keyword">int</span> _length; <span class="keyword">int</span> _capacity;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Name(<span class="keyword">char</span>* c, <span class="keyword">int</span> length): _c(c), _length(length) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* Name&lt;T&gt;::getName() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Name&lt;T&gt;::getLength() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c1[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> c2[] = &#123;<span class="string">'h'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length1 = <span class="number">3</span>, length2 = <span class="number">2</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; name1(c1, length1), name2(c2, length2);</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; nArr[] = &#123;name1, name2&#125;;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">2</span>;</span><br><span class="line">  print_instance_data_in_array(nArr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">3</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; n(c, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_instance_data_in_array</span><span class="params">(Name&lt;<span class="keyword">int</span>&gt;* nArr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name = "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nArr[i].getLength(); j++) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *((nArr[i].getName())+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Name = tim</span><br><span class="line">Name = hu</span><br></pre></td></tr></table></figure>
<p>面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。</p>
<h3 id="数组中存放长度不同的数组"><a href="#数组中存放长度不同的数组" class="headerlink" title="数组中存放长度不同的数组"></a>数组中存放长度不同的数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span> _size_pa = <span class="number">1</span>, _size_pb = <span class="number">1</span>, _size_pc = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr1[] = &#123;pa&#125;;    <span class="comment">// pArr1数组存放pa, pb指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr2[] = &#123;pa, pb, pc&#125;;    <span class="comment">// pArr2数组存放pa, pb, pc指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr2 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr3[] = &#123;pa, pc&#125;;</span><br><span class="line">  <span class="keyword">int</span> _size_pArr3 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> size_pArr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>** ppArr[] = &#123;pArr1, pArr2, pArr3&#125;;   <span class="comment">// ppArr存放3个指针数组</span></span><br><span class="line">  <span class="keyword">int</span> _size_ppArr = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> size_ppArr[] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>* size_arr[] = &#123;size_ppArr, size_pArr&#125;;</span><br><span class="line">  <span class="comment">// convert_size_structor(size_arr);</span></span><br><span class="line">  print_arr_b(ppArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr_b</span><span class="params">(<span class="keyword">int</span>*** ppArr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解引用并打印ppArr数组中依次数组中的pa, pb, pc</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a0 = "</span> &lt;&lt; ***ppArr&lt;&lt; <span class="string">" in pArr1[0]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"b0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">1</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr2[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"c0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">2</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr3[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a><strong>感想</strong></h2><p>即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。</p>
<h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">  MyClass(<span class="keyword">int</span> v) :x(v) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;   <span class="comment">// 常量成员函数在是否为常量上可以重载</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="声明时引用符号总最靠近变量名"><a href="#声明时引用符号总最靠近变量名" class="headerlink" title="声明时引用符号总最靠近变量名"></a>声明时引用符号总最靠近变量名</h2><h2 id="为什么可以对a-get-赋值"><a href="#为什么可以对a-get-赋值" class="headerlink" title="为什么可以对a.get()赋值"></a>为什么可以对a.get()赋值</h2><p>get()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。</p>
<h2 id="在是否为成员函数上重载后如何匹配"><a href="#在是否为成员函数上重载后如何匹配" class="headerlink" title="在是否为成员函数上重载后如何匹配?"></a>在是否为成员函数上重载后如何匹配?</h2><p>成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。</p>
<h2 id="const-int-amp-get-const-return-x-为什么返回类型需要const"><a href="#const-int-amp-get-const-return-x-为什么返回类型需要const" class="headerlink" title="const int&amp; get() const {return x;} 为什么返回类型需要const?"></a>const int&amp; get() const {return x;} 为什么返回类型需要const?</h2><p>常量函数返回数据成员, 编译器会将数据成员声明成const类型;</p>
<h2 id="什么是数据成员"><a href="#什么是数据成员" class="headerlink" title="什么是数据成员?"></a>什么是数据成员?</h2><p>MyClass类public中定义新成员测试是否为数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; get() <span class="keyword">const</span> &#123;<span class="keyword">return</span> --a;&#125;    <span class="comment">// 错误：改变a的值,</span></span><br></pre></td></tr></table></figure>
<p>改变a的值无法通过编译, a为数据成员。</p>
<p>在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。</p>
<h1 id="template基础用法"><a href="#template基础用法" class="headerlink" title="template基础用法"></a>template基础用法</h1><h2 id="typename-T-和-class-T的区别"><a href="#typename-T-和-class-T的区别" class="headerlink" title="typename T 和 class T的区别"></a>typename T 和 class T的区别</h2><p>在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class</p>
<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P580 模板与泛型编程</code></p>
<h2 id="特殊化模板"><a href="#特殊化模板" class="headerlink" title="特殊化模板"></a>特殊化模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span></span><br><span class="line">  T element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> T e) : element(e) &#123;&#125;</span><br><span class="line">  <span class="function">T <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增element</span></span><br><span class="line">  <span class="function">T <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对char类型, 有特定的方法uppercase()大写化字母<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span></span><br><span class="line">  <span class="keyword">char</span> element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> <span class="keyword">char</span> e): element(e) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增char</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">uppercase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element &lt;= <span class="string">'z'</span> &amp;&amp; element &gt;= <span class="string">'a'</span>) &#123;   <span class="comment">// 是小写字母</span></span><br><span class="line">      element += <span class="string">'A'</span> - <span class="string">'a'</span>; <span class="keyword">return</span> element;</span><br><span class="line">    &#125;  <span class="comment">// 返回元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"element "</span> &lt;&lt; element &lt;&lt; <span class="string">"is not lower"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>格式如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mituh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/timtingwei" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/timtingwei/" target="_blank" title="douban">
                    
                      <i class="fa fa-fw fa-globe"></i>douban</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mituh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
