<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="mituh's notes" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="mituh&#39;s notes">
<meta property="og:url" content="https://timtingwei.github.io/page/2/index.html">
<meta property="og:site_name" content="mituh&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mituh&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timtingwei.github.io/page/2/"/>





  <title>mituh's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mituh's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/cpp/cpp-notes-0004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/cpp/cpp-notes-0004/" itemprop="url">C++ Zero To One 0.004</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T10:28:06+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1, bool和int的隐式转换</span><br><span class="line">	[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt;* 问题起因</span><br><span class="line">		======================= source code =========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">		int count = 0;   // 计数器</span><br><span class="line">		for (int i = i; i &lt; _size; i++)</span><br><span class="line">			count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">		return count;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class="line">	</span><br><span class="line">	&gt;* sizeof(bool) = 1</span><br><span class="line">  </span><br><span class="line">	&gt;* bool-&gt; not bool</span><br><span class="line">		布尔值转赋值给非布尔值, 初始值false时0, true时1 	</span><br><span class="line">	</span><br><span class="line">	&gt;* not bool -&gt; bool</span><br><span class="line">		非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class="line">	</span><br><span class="line">		其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		void f_to_bool() &#123;</span><br><span class="line">		int i1 = 5, i2 = 0;</span><br><span class="line">		int* pi0 = 0;       // 定义空指针</span><br><span class="line">		int* pi1 = &amp;i1;      // 指针指向i1</span><br><span class="line">		int&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class="line">		int&amp; ri1 = i1;      // 引用i1</span><br><span class="line">		</span><br><span class="line">		bool bi = i1;        // prints  bi = 1</span><br><span class="line">		bool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class="line">		bool bpi1 = pi1;     //         bpi1 = 1</span><br><span class="line">		bool bri0 = ri0;     //         bri0 = 0</span><br><span class="line">		bool bri1 = ri1;     //         bri1 = 1</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------------------------  </span><br><span class="line"># 2, 不能返回函数内部初始化的指针</span><br><span class="line">	[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class="line"></span><br><span class="line">	&gt;* 问题</span><br><span class="line">		数据结构学习中, Rank* deduplicate_lower();</span><br><span class="line">		我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class="line">	&gt;* 错误的方法</span><br><span class="line">		函数体内声明定义的指针，返回不了</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int* f() &#123;</span><br><span class="line">			int iarr[] = &#123;&#125;;</span><br><span class="line">			iarr[0] = 2;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out -----------------------------</span><br><span class="line">		warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class="line">		============================================================</span><br><span class="line">		我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class="line">	</span><br><span class="line">	&gt;* 可行的方法</span><br><span class="line">		将指针作为参数传入</span><br><span class="line">		================== source code =============================</span><br><span class="line">		int* f1(int* iarr) &#123;</span><br><span class="line">			*iarr += 1;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class="line">		便于函数之间的调用, 还是需要的。</span><br><span class="line">	</span><br><span class="line">	&gt;* 另一种可行方法: malloc返回指针</span><br><span class="line">		================= source code ============================</span><br><span class="line">		// 强制返回指针, 分配内存却不释放</span><br><span class="line">		int* fun() &#123;</span><br><span class="line">			int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class="line">			for (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class="line">				*(i_ptr+i) = 0;</span><br><span class="line">			// free(i_ptr);  // 释放指针</span><br><span class="line">			return i_ptr;    // 函数返回指针</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"># 3, malloc和free</span><br><span class="line">	[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class="line">  </span><br><span class="line">	&gt; * 概念</span><br><span class="line">		malloc:</span><br><span class="line">		void* malloc (size_t size);</span><br><span class="line">		在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class="line">		free:</span><br><span class="line">		void free(void* ptr);</span><br><span class="line">		重新分配作用域中的memeory, 给未来的分配使用</span><br><span class="line">	</span><br><span class="line">	&gt; * 需要include的库</span><br><span class="line">		#include &lt;stdlib.h&gt;</span><br><span class="line">		#include &lt;stdio.h&gt;</span><br><span class="line">	</span><br><span class="line">	&gt; * 案例</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int main() &#123;</span><br><span class="line">			int i, n;</span><br><span class="line">			char* buffer;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;how long do you want the string?&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">	        buffer = (char*) malloc(i+1);</span><br><span class="line">	        if (buffer==NULL) exit(1);</span><br><span class="line"></span><br><span class="line">	        for (n=0; n &lt; i; n++)</span><br><span class="line">				buffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class="line">			buffer[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;Random string: %s\n&quot;, buffer);</span><br><span class="line">	        free(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		------------------ ./a.out -------------------------------</span><br><span class="line">		how long do you want the string?5</span><br><span class="line">		Random string: nwlrb</span><br><span class="line">		===========================================================</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"># 4, 未声明大小的数组</span><br><span class="line">	[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class="line"></span><br><span class="line">	&gt; * 问题</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int size = 5;</span><br><span class="line">		int iarr[size] = &#123;&#125;;</span><br><span class="line">		------------------- ./a.out ----------------------------------</span><br><span class="line">		error: variable-sized object ‘iarr1’ may not be initialized</span><br><span class="line">		===========================================================</span><br><span class="line">	</span><br><span class="line">	&gt; * const</span><br><span class="line">		=========== source code ==========</span><br><span class="line">		const unsigned int size = 5;</span><br><span class="line">		int iarr1[size] = &#123;&#125;;</span><br><span class="line">		==================================</span><br><span class="line">	</span><br><span class="line">	&gt; * define</span><br><span class="line">		========== source code ==============</span><br><span class="line">		#define ARRAY_SIZE 5;</span><br><span class="line">		// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class="line">		int iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class="line">		======================================</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"># 5, continue 和 break 区别</span><br><span class="line">	[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt; * 概念 </span><br><span class="line">		continue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class="line">		break: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class="line">	</span><br><span class="line">	&gt; * continue实例:</span><br><span class="line">		loop:</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		// 跳过loop剩余部分</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class="line">				continue;&#125;</span><br><span class="line">				// ...</span><br><span class="line">				std::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">    &gt; * break实例:	</span><br><span class="line">		1, loop:</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		// 终止循环</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class="line">				std::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	</span><br><span class="line">		2, switch</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int i = 2;</span><br><span class="line">		switch (i) &#123;</span><br><span class="line">			case 1: std::cout &lt;&lt; &quot;1\n&quot;;</span><br><span class="line">			case 2: std::cout &lt;&lt; &quot;2\n&quot;;         // 选择到这里</span><br><span class="line">			case 3: std::cout &lt;&lt; &quot;3\n&quot;;</span><br><span class="line">			case 4:</span><br><span class="line">			case 5: std::cout &lt;&lt; &quot;45 \n&quot;;</span><br><span class="line">				break;                            // 终止switch</span><br><span class="line">			case 6: std::cout &lt;&lt; &quot;6\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		------------------- ./a.out ------------------------------</span><br><span class="line">		2</span><br><span class="line">		3</span><br><span class="line">		45</span><br><span class="line">		============================================================</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"># if...else 和 if...else if的区别</span><br><span class="line">	[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line">	&gt;* 问题</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">			Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">			if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">			else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">			else                   return mi;    // 在mi命中</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		if, else...if 和 else是什么关系？</span><br><span class="line">		从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class="line">	</span><br><span class="line">	&gt;* if...else</span><br><span class="line">		====</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out ---------------------------</span><br><span class="line">		i &gt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if...else if...else if</span><br><span class="line">		===</span><br><span class="line">		int i = 4;</span><br><span class="line">		if (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		-----</span><br><span class="line">		i &lt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if</span><br><span class="line">		===</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class="line">		if (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class="line">		----------------- ./a.out --------------------------</span><br><span class="line">		i =  6</span><br><span class="line">		i != 7</span><br><span class="line">		====================================================</span><br><span class="line">	&gt;* 各自的作用域辨析</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		bool foo = false, bar = true, baz = true;</span><br><span class="line">		if (foo) &#123;</span><br><span class="line">			// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;if(foo)\n&quot;;</span><br><span class="line">		&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;else if(bar)\n&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class="line">			std::cout &lt;&lt; &quot;else &#123;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class="line">			// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class="line">			std::cout &lt;&lt; &quot;if(baz)\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		---------------------- ./a.out ----------------------------------</span><br><span class="line">		// else if(bar)</span><br><span class="line">		// if(baz)</span><br><span class="line">		==============================================================</span><br><span class="line">		我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class="line">		这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class="line">	&gt;* 总结</span><br><span class="line">		if(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class="line">		如果有一个true, 则不会执行接下来的else; </span><br><span class="line">		如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class="line">		</span><br><span class="line">		因此，对于二分查找来说, </span><br><span class="line">		前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class="line">		</span><br><span class="line">		1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class="line">		2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class="line">		===== source code ======</span><br><span class="line">		int i = 4, count = 0;</span><br><span class="line">		(i == 4) ? count++</span><br><span class="line">			: i = 4;</span><br><span class="line">		========================</span><br><span class="line">		缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class="line">		3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/11/dsacpp/02-D1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/dsacpp/02-D1/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T19:22:42+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。</span><br><span class="line">------------------------------ split line ---------------------------</span><br><span class="line">实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line"></span><br><span class="line"># 有序向量唯一化</span><br><span class="line">	无序: 比对</span><br><span class="line">	有序: 比较</span><br><span class="line"></span><br><span class="line">## 有序性及其甄别</span><br><span class="line"></span><br><span class="line">	&gt; * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。</span><br><span class="line">	</span><br><span class="line">	&gt; * 相邻逆序对数目, 可以度量逆序程度。</span><br><span class="line">	</span><br><span class="line">		&gt; * 逆序程度实现</span><br><span class="line">		</span><br><span class="line">		===================== source code =========================</span><br><span class="line">		// 逆序程度</span><br><span class="line">		/* my test code </span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;</span><br><span class="line">			for (int i = 0; i &lt; _size - 1; i++)</span><br><span class="line">				if (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素</span><br><span class="line">			return count;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;   // 计数器</span><br><span class="line">			for (int i = i; i &lt; _size; i++)</span><br><span class="line">				count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">			return count;  // 向量有序当且仅当n = 0</span><br><span class="line">		&#125; // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止</span><br><span class="line">		============================================================</span><br><span class="line">		</span><br><span class="line">	&gt; * 若元素支持大小比较, 可将无序向量转换为有序向量。</span><br><span class="line">	&gt; * 无序向量转换为有序向量后, 算法多可优化。</span><br><span class="line"></span><br><span class="line">## 低效算法</span><br><span class="line"></span><br><span class="line">	&gt; 1, 我自己的低效deduplicate()版本, </span><br><span class="line">		依赖一次性remove函数.</span><br><span class="line">		&gt; * 尝试自己实现,</span><br><span class="line">		</span><br><span class="line">		======================== sourece code =======================</span><br><span class="line">		// my deduplicate code</span><br><span class="line">		// 唯一化(低效)</span><br><span class="line">		int deduplicate_lower(int rm_arr[]);</span><br><span class="line">		// 唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		void remove(int rm_arr[], int n);</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::deduplicate_lower(int rm_arr[]) &#123;</span><br><span class="line">			// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量</span><br><span class="line">			assert(!disordered());   // 当前为有序向量</span><br><span class="line">			Rank n = 0;            // 数组当前插入位置</span><br><span class="line">			Rank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描</span><br><span class="line">			while (r2 &lt; _size) &#123;</span><br><span class="line">				if (_elem[r1] == _elem[r2]) &#123;   // r2指向的元素和r1对应元素重复</span><br><span class="line">					rm_arr[n++] = r2;     // 索引数组中加入r2</span><br><span class="line">					// remove(r2);</span><br><span class="line">				&#125; else &#123; r1 = r2;&#125;</span><br><span class="line">				r2++;    // 递增r2</span><br><span class="line">				&#125;</span><br><span class="line">			remove(rm_arr, n);   // 一次性删除索引对应的元素</span><br><span class="line">			return n;            // 返回删除元素数量</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    // 有序向量唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::remove(int rm_arr[], int n) &#123;</span><br><span class="line">			// 删除索引除外的索引对应元素保留, 从左向右扫描</span><br><span class="line">			int i_n = 0;     // 指向rm_arr中的元素</span><br><span class="line">			int new_i = 0;   // 保留索引</span><br><span class="line">			T* old_elem = _elem;    // 备份一份当前元素</span><br><span class="line">			_elem = new T[_capacity = _capacity];</span><br><span class="line">			for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">				if (i != rm_arr[i_n]) &#123;     // 当前索引不在表中</span><br><span class="line">					_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置</span><br><span class="line">				&#125; else &#123;     // 当前索引在删除索引的表中</span><br><span class="line">					i_n++;     // 指向下一个rm_arr中的元素</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_size -= n;</span><br><span class="line">			delete [] old_elem;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt; 2, 视频中的唯一化(低效版)</span><br><span class="line">		代码如下:</span><br><span class="line">		======================= source code ========================</span><br><span class="line">		// 有序向量唯一化</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size; int i = 0;  // 首元素开始</span><br><span class="line">			while (i &lt; _size - 1) &#123;</span><br><span class="line">				(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;</span><br><span class="line">			&#125;    // _size的改变由remove隐式完成</span><br><span class="line">			return old_size - _size;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">## 低效算法: 复杂度</span><br><span class="line">	&gt; 1, 低效复杂度</span><br><span class="line">		运行时间取决于while循环, 总计 _size - 1 = n - 1 </span><br><span class="line">		最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)</span><br><span class="line">	&gt; 2, 比较</span><br><span class="line">		我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 高效算法:</span><br><span class="line">	&gt; 1, 反思</span><br><span class="line">		低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。</span><br><span class="line">	&gt; 2, 启示</span><br><span class="line">		将重复区间视为单位, 成批的删除</span><br><span class="line">	&gt; 3, 算法</span><br><span class="line">		[i] [] [ . . . . duplicates] [j] </span><br><span class="line">		从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。</span><br><span class="line">		</span><br><span class="line">		高明之处在于: 实际上没有删除, 却等效于删除</span><br><span class="line">		================== source code ==============================</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size;</span><br><span class="line">		    int i = 0, j = 1;   // i指向首位置</span><br><span class="line">			int n = 1;    // 实际更新后的_elem的索引</span><br><span class="line">			while (i &lt; _size - 1)</span><br><span class="line">				if (_elem[i] != _elem[j])</span><br><span class="line">					&#123; _elem[n++] = _elem[j]; i = j; size--;</span><br><span class="line">					&#125; else &#123;j++;&#125;</span><br><span class="line">	        return old_size - n;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify_faster() &#123;</span><br><span class="line">			int i = 0, j = 0;   // 两个计数都指向首元素</span><br><span class="line">			while (++j &lt; _size) &#123;   // j扫描到末尾</span><br><span class="line">				if (_elem[i] != _elem[j]) &#123;_elem[++i] = _elem[j];&#125;  // j指向元素移到i后</span><br><span class="line">			&#125;</span><br><span class="line">			_size = ++i; shrunk();      // 改变_size数值后, 缩容</span><br><span class="line">			return j - i;    // 注意j扫到尾端的特性</span><br><span class="line">		&#125;     // 依赖shrink();</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">	    /* 实现问题分析</span><br><span class="line">		// 为什么不要另外的n作为索引计数?</span><br><span class="line">		当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。</span><br><span class="line">		// 为什么不在uniquify中进行new 和 delete?</span><br><span class="line">		接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。</span><br><span class="line">	    */</span><br><span class="line"></span><br><span class="line">## 高效算法: 实例与复杂度</span><br><span class="line">	&gt; 1, *反思 (典型例子)</span><br><span class="line">		共计n-1次迭代, 每次常数时间, 累计O(n)时间。</span><br><span class="line">		</span><br><span class="line">		优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。</span><br><span class="line">		体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/11/cpp/cpp-notes-0003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/cpp/cpp-notes-0003/" itemprop="url">C++ Zero To One 0.003</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T16:06:51+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="重载函数什么时候用virtual"><a href="#重载函数什么时候用virtual" class="headerlink" title="重载函数什么时候用virtual?"></a>重载函数什么时候用virtual?</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp" target="_blank" rel="noopener">source code - load_funtion.cpp</a></p>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit)</span></span>;</span><br><span class="line"><span class="comment">// template &lt;typename VST&gt; virtual void traverse(VST visit, T* e);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit, T* e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为什么这里不需要virtual??</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个T类型元素加1的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;e)</span> </span>&#123;e++;&#125;    <span class="comment">// Increase&lt;T&gt;()实现函数功能  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么这里又需要virtual??</p>
<h2 id="概念偏差"><a href="#概念偏差" class="headerlink" title="概念偏差"></a>概念偏差</h2><p>virtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。</p>
<p><strong>vitual为虚函数</strong>：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 </p>
<p><strong>重载函数</strong>：同一作用域内的几个函数名字相同但形参列表不同。</p>
<h2 id="使用与不使用virtual"><a href="#使用与不使用virtual" class="headerlink" title="使用与不使用virtual"></a>使用与不使用virtual</h2><p>解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>    <span class="comment">// 声明virtual后, 可被继承类override重载</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;   <span class="comment">// 'override'可写可不写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>关键问题: 上述两者什么差别????</code></p>
<p>运行测试一下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释是使用virtual结果</span></span><br><span class="line">  Base b;</span><br><span class="line">  Derived d;</span><br><span class="line"></span><br><span class="line">  Base&amp; br = b;      <span class="comment">// refer b, br的类型是Base&amp;</span></span><br><span class="line">  Base&amp; dr = d;      <span class="comment">// dr类型也是Base&amp;</span></span><br><span class="line">  br.print();        <span class="comment">// Base</span></span><br><span class="line">  dr.print();        <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  Base* pb = &amp;b;     <span class="comment">// pointer to b, Base*</span></span><br><span class="line">  Base* pd = &amp;d;     <span class="comment">// Base* as well</span></span><br><span class="line"></span><br><span class="line">  pb-&gt;print();       <span class="comment">// Base</span></span><br><span class="line">  pd-&gt;print();       <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  b.Base::print();   <span class="comment">// Base</span></span><br><span class="line">  d.Base::print();   <span class="comment">// Base</span></span><br></pre></td></tr></table></figure></p>
<p>使用vitual的运行结果:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure>
<p>不使用虚方法的运行结果:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure></p>
<p>virtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。</p>
<h2 id="解决最初问题"><a href="#解决最初问题" class="headerlink" title="解决最初问题"></a>解决最初问题</h2><h3 id="为什么traverse函数不需要virtual"><a href="#为什么traverse函数不需要virtual" class="headerlink" title="为什么traverse函数不需要virtual"></a>为什么traverse函数不需要virtual</h3><p>traverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。</p>
<h3 id="为什么函数对象需要virtual重载操作符函数"><a href="#为什么函数对象需要virtual重载操作符函数" class="headerlink" title="为什么函数对象需要virtual重载操作符函数?"></a>为什么函数对象需要virtual重载操作符函数?</h3><p>定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象用virtual声明operator()()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="comment">// 重载()后, 对象可充当函数的功能</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> </span>&#123;(*e)++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase_two</span> :</span> Increase &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> override </span>&#123;(*e)+= <span class="number">2</span>;&#125;    <span class="comment">// 元素+2;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试函数, 以及prints结果如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Increase a;</span><br><span class="line">  Increase_two b;</span><br><span class="line"></span><br><span class="line">  Increase&amp; ra = a;</span><br><span class="line">  Increase&amp; rb = b;     <span class="comment">// rb的类型为 Increase&amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> e = <span class="number">5</span>; <span class="keyword">int</span>* pe = &amp;e;</span><br><span class="line">  ra.<span class="keyword">operator</span>()(pe);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e = "</span> &lt;&lt; e &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// prints "e = 6"</span></span><br><span class="line">  <span class="keyword">int</span> e2 = <span class="number">5</span>; <span class="keyword">int</span>* pe2 = &amp;e2;</span><br><span class="line">  rb.<span class="keyword">operator</span>()(pe2);   <span class="comment">// 调用基类的引用时, 动态绑定到Increase_two中的方法</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e2 = "</span> &lt;&lt; e2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// prints "e2 = 7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。</p>
<h1 id="静态成员声明定义使用"><a href="#静态成员声明定义使用" class="headerlink" title="静态成员声明定义使用"></a>静态成员声明定义使用</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp" target="_blank" rel="noopener">source code - static.cpp</a></p>
<h2 id="静态成员的特点"><a href="#静态成员的特点" class="headerlink" title="静态成员的特点"></a>静态成员的特点</h2><p>静态数据成员不属于任何类的一个对象。</p>
<p>类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期</p>
<h2 id="类内static成员如何声明定义"><a href="#类内static成员如何声明定义" class="headerlink" title="类内static成员如何声明定义?"></a>类内static成员如何声明定义?</h2><blockquote>
<ul>
<li>在类内部声明, 外部通过类名作用域访问定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatic</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> i_stc;   <span class="comment">// 类内部声明</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyStatic::i_stc = <span class="number">0</span>;     <span class="comment">// 类外部定义, 注意需要声明成员的类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。</p>
<h2 id="在不同实例中被多次调用改变后的情况"><a href="#在不同实例中被多次调用改变后的情况" class="headerlink" title="在不同实例中被多次调用改变后的情况?"></a>在不同实例中被多次调用改变后的情况?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MyStatic::increment() &#123;++i_stc;&#125;</span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">  MyStatic c0;</span><br><span class="line">  c0.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c0 = &quot; &lt;&lt; c0.i_stc &lt;&lt; std::endl;</span><br><span class="line">  MyStatic c1;</span><br><span class="line">  c1.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f1() &#123;</span><br><span class="line">  MyStatic c2;</span><br><span class="line">  c2.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">c0 = 1</span><br><span class="line">c1 = 2</span><br><span class="line">c2 = 3</span><br></pre></td></tr></table></figure>
<p>静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/essay/architecture-application-between-computer-science/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/essay/architecture-application-between-computer-science/" itemprop="url">建筑设计应用和计算机科学一点随想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T16:27:28+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。</p>
<p>批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 </p>
<p>学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/cpp/cpp-notes-02/" itemprop="url">C++ Zero To One 0.002</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T13:01:23+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组-指针数组-指向指针的指针的数组-…"><a href="#数组-指针数组-指向指针的指针的数组-…" class="headerlink" title="数组, 指针数组, 指向指针的指针的数组, …."></a>数组, 指针数组, 指向指针的指针的数组, ….</h1><p>在逛<a href="http://www.cplusplus.com/forum/beginner/" target="_blank" rel="noopener">Cplusplus Forum - Beginner</a>的时候发现了一个看上去看简单的<a href="http://www.cplusplus.com/forum/beginner/228196/" target="_blank" rel="noopener">问题</a></p>
<p><strong>How do I receive two numbers from the keyboard, save them in an array of two element?</strong></p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a><strong>第一次尝试</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;     <span class="comment">// ERROR: 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 不合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iarr[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; iarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想得太简单了。不能在标准输入中, 直接对数据进行修改。</p>
<h2 id="下面给出的答案"><a href="#下面给出的答案" class="headerlink" title="下面给出的答案"></a><strong>下面给出的答案</strong></h2><p>1,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; iarr[<span class="number">0</span>] &gt;&gt; iarr[<span class="number">1</span>];     <span class="comment">// 直接输入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;     <span class="comment">// 先输入, 再存放</span></span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="但是我仍然考虑我思路实现的可能性？"><a href="#但是我仍然考虑我思路实现的可能性？" class="headerlink" title="但是我仍然考虑我思路实现的可能性？"></a><strong>但是我仍然考虑我思路实现的可能性？</strong></h2><p>对已经放置在数组中的值进行修改的思路如何实现？</p>
<h3 id="第一个想到的就是指针。"><a href="#第一个想到的就是指针。" class="headerlink" title="第一个想到的就是指针。"></a>第一个想到的就是指针。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;  <span class="comment">// <span class="doctag">BUG:</span> 为什么不能通过数组中保存的指针修改数组??</span></span><br><span class="line">  <span class="keyword">int</span> *pa, *pb;</span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;</span><br><span class="line">  <span class="keyword">int</span> tmp_a, tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp_a &gt;&gt; tmp_b;        <span class="comment">// 存放到临时变量</span></span><br><span class="line">  pa = &amp;tmp_a; pb = &amp;tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pa = "</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// *pa = 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(*iarr) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iarr[<span class="number">0</span>]) &lt;&lt; <span class="string">' '</span> &lt;&lt; *(iarr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">*pa = 1</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<p>很气, 我得出结论。不能通过数组中保存的指针修改数组。</p>
<h3 id="数组作为函数形参"><a href="#数组作为函数形参" class="headerlink" title="数组作为函数形参"></a>数组作为函数形参</h3><p>接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：<br><strong>创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_int</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n指向的整数递增1</span></span><br><span class="line">  (*(arr+n)) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  revise_value_int(iarr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iarr[2] = "</span> &lt;&lt; iarr[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise();</span><br></pre></td></tr></table></figure>
<p>可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。</p>
<h3 id="函数形参为存放指针的数组"><a href="#函数形参为存放指针的数组" class="headerlink" title="函数形参为存放指针的数组"></a>函数形参为存放指针的数组</h3><p>接着，我改变了数组，用于存放指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span> ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译时就出现了错误,.<em>error: invalid conversion from ‘int</em>’ to ‘int’ [-fpermissive]<em><br><strong>因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\</strong></em></p>
<p>修改<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>写修改指针所指向整数的函数, 注意, 这个形参类型是<code>int**</code>, <strong>ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_ptr</span><span class="params">(<span class="keyword">int</span>** ptrArr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n的指向的指针所指向的整数递增1</span></span><br><span class="line">  (**(ptrArr+n))+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Segmentation-fault-core-dumped"><a href="#Segmentation-fault-core-dumped" class="headerlink" title="Segmentation fault (core dumped)"></a>Segmentation fault (core dumped)</h3><p>再次编译<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>出现 Segmentation fault (core dumped) 的原因， 参考[<a href="http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html</a>]</p>
<h4 id="1-内存访问越界"><a href="#1-内存访问越界" class="headerlink" title="1 内存访问越界"></a>1 内存访问越界</h4><p>  a) 由于使用错误的下标，导致数组访问越界</p>
<p>  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>
<p>  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<h4 id="2-多线程程序使用了线程不安全的函数。"><a href="#2-多线程程序使用了线程不安全的函数。" class="headerlink" title="2 多线程程序使用了线程不安全的函数。"></a>2 多线程程序使用了线程不安全的函数。</h4><h4 id="3-多线程读写的数据未加锁保护。"><a href="#3-多线程读写的数据未加锁保护。" class="headerlink" title="3 多线程读写的数据未加锁保护。"></a>3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>
<h4 id="非法指针"><a href="#非法指针" class="headerlink" title="非法指针"></a>非法指针</h4><p>  a) 使用空指针<br>  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>
<h4 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h4><p>不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<h3 id="非法指针-1"><a href="#非法指针-1" class="headerlink" title="非法指针"></a>非法指针</h3><p>我的代码是:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我使用了非法的指针, 这个指针没有指向任何</p>
<p>修改,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br><span class="line">  another_revise_value_ptr(ptrArr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"**(ptrArr)   = "</span> &lt;&lt; **(ptrArr)   &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+1) = "</span> &lt;&lt; **(ptrArr+<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+2) = "</span> &lt;&lt; **(ptrArr+<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise()</span><br></pre></td></tr></table></figure>
<p>编译得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">**(ptrArr)   = 1</span><br><span class="line">**(ptrArr+1) = 2</span><br><span class="line">**(ptrArr+2) = 4</span><br></pre></td></tr></table></figure></p>
<h3 id="解决最开始问题并总结"><a href="#解决最开始问题并总结" class="headerlink" title="解决最开始问题并总结"></a>解决最开始问题并总结</h3><p><strong>修改后的代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;     <span class="comment">// DE<span class="doctag">BUG:</span> 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, <span class="keyword">int</span>* pb = &amp;b;     <span class="comment">// 注意: 不要定义空指针</span></span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 注意数组的类型是数组中元素的类型</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 也能合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; **iarr &lt;&lt; <span class="string">' '</span> &lt;&lt; **(iarr+<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 解引用</span></span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不要定义空指针"><a href="#不要定义空指针" class="headerlink" title="不要定义空指针"></a>不要定义空指针</h4><p>如这样<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa;</span><br></pre></td></tr></table></figure></p>
<p>即使要定义也要<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *pa = 0;</span><br><span class="line">int *pb = nullptr;</span><br></pre></td></tr></table></figure></p>
<p>尽量让指针指向某个对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><p>数组的类型是数组中元素的类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 类型为 int*</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解引用数组"><a href="#解引用数组" class="headerlink" title="解引用数组"></a>解引用数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 如果数组这样定义</span></span><br><span class="line">iarr;                           <span class="comment">// iarr是指向数组首个元素的指针</span></span><br><span class="line">*iarr;                          <span class="comment">// 因为pa是指针, 所以解引用数组头指针, 得到pa地址</span></span><br><span class="line">**iarr;                         <span class="comment">// 再次解引用得到pa指向的int</span></span><br></pre></td></tr></table></figure>
<p>标准输出它们得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iarr = 0x7ffed5caa560</span><br><span class="line">*iarr = 0x7ffed5caa548</span><br><span class="line">**iarr = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="更多的尝试"><a href="#更多的尝试" class="headerlink" title="更多的尝试"></a><strong>更多的尝试</strong></h2><h3 id="数组中存放对象"><a href="#数组中存放对象" class="headerlink" title="数组中存放对象"></a>数组中存放对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* _c; <span class="keyword">int</span> _length; <span class="keyword">int</span> _capacity;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Name(<span class="keyword">char</span>* c, <span class="keyword">int</span> length): _c(c), _length(length) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* Name&lt;T&gt;::getName() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Name&lt;T&gt;::getLength() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c1[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> c2[] = &#123;<span class="string">'h'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length1 = <span class="number">3</span>, length2 = <span class="number">2</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; name1(c1, length1), name2(c2, length2);</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; nArr[] = &#123;name1, name2&#125;;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">2</span>;</span><br><span class="line">  print_instance_data_in_array(nArr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">3</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; n(c, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_instance_data_in_array</span><span class="params">(Name&lt;<span class="keyword">int</span>&gt;* nArr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name = "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nArr[i].getLength(); j++) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *((nArr[i].getName())+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Name = tim</span><br><span class="line">Name = hu</span><br></pre></td></tr></table></figure>
<p>面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。</p>
<h3 id="数组中存放长度不同的数组"><a href="#数组中存放长度不同的数组" class="headerlink" title="数组中存放长度不同的数组"></a>数组中存放长度不同的数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span> _size_pa = <span class="number">1</span>, _size_pb = <span class="number">1</span>, _size_pc = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr1[] = &#123;pa&#125;;    <span class="comment">// pArr1数组存放pa, pb指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr2[] = &#123;pa, pb, pc&#125;;    <span class="comment">// pArr2数组存放pa, pb, pc指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr2 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr3[] = &#123;pa, pc&#125;;</span><br><span class="line">  <span class="keyword">int</span> _size_pArr3 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> size_pArr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>** ppArr[] = &#123;pArr1, pArr2, pArr3&#125;;   <span class="comment">// ppArr存放3个指针数组</span></span><br><span class="line">  <span class="keyword">int</span> _size_ppArr = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> size_ppArr[] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>* size_arr[] = &#123;size_ppArr, size_pArr&#125;;</span><br><span class="line">  <span class="comment">// convert_size_structor(size_arr);</span></span><br><span class="line">  print_arr_b(ppArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr_b</span><span class="params">(<span class="keyword">int</span>*** ppArr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解引用并打印ppArr数组中依次数组中的pa, pb, pc</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a0 = "</span> &lt;&lt; ***ppArr&lt;&lt; <span class="string">" in pArr1[0]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"b0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">1</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr2[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"c0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">2</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr3[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a><strong>感想</strong></h2><p>即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。</p>
<h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">  MyClass(<span class="keyword">int</span> v) :x(v) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;   <span class="comment">// 常量成员函数在是否为常量上可以重载</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="声明时引用符号总最靠近变量名"><a href="#声明时引用符号总最靠近变量名" class="headerlink" title="声明时引用符号总最靠近变量名"></a>声明时引用符号总最靠近变量名</h2><h2 id="为什么可以对a-get-赋值"><a href="#为什么可以对a-get-赋值" class="headerlink" title="为什么可以对a.get()赋值"></a>为什么可以对a.get()赋值</h2><p>get()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。</p>
<h2 id="在是否为成员函数上重载后如何匹配"><a href="#在是否为成员函数上重载后如何匹配" class="headerlink" title="在是否为成员函数上重载后如何匹配?"></a>在是否为成员函数上重载后如何匹配?</h2><p>成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。</p>
<h2 id="const-int-amp-get-const-return-x-为什么返回类型需要const"><a href="#const-int-amp-get-const-return-x-为什么返回类型需要const" class="headerlink" title="const int&amp; get() const {return x;} 为什么返回类型需要const?"></a>const int&amp; get() const {return x;} 为什么返回类型需要const?</h2><p>常量函数返回数据成员, 编译器会将数据成员声明成const类型;</p>
<h2 id="什么是数据成员"><a href="#什么是数据成员" class="headerlink" title="什么是数据成员?"></a>什么是数据成员?</h2><p>MyClass类public中定义新成员测试是否为数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; get() <span class="keyword">const</span> &#123;<span class="keyword">return</span> --a;&#125;    <span class="comment">// 错误：改变a的值,</span></span><br></pre></td></tr></table></figure>
<p>改变a的值无法通过编译, a为数据成员。</p>
<p>在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。</p>
<h1 id="template基础用法"><a href="#template基础用法" class="headerlink" title="template基础用法"></a>template基础用法</h1><h2 id="typename-T-和-class-T的区别"><a href="#typename-T-和-class-T的区别" class="headerlink" title="typename T 和 class T的区别"></a>typename T 和 class T的区别</h2><p>在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class</p>
<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P580 模板与泛型编程</code></p>
<h2 id="特殊化模板"><a href="#特殊化模板" class="headerlink" title="特殊化模板"></a>特殊化模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span></span><br><span class="line">  T element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> T e) : element(e) &#123;&#125;</span><br><span class="line">  <span class="function">T <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增element</span></span><br><span class="line">  <span class="function">T <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对char类型, 有特定的方法uppercase()大写化字母<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span></span><br><span class="line">  <span class="keyword">char</span> element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> <span class="keyword">char</span> e): element(e) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增char</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">uppercase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element &lt;= <span class="string">'z'</span> &amp;&amp; element &gt;= <span class="string">'a'</span>) &#123;   <span class="comment">// 是小写字母</span></span><br><span class="line">      element += <span class="string">'A'</span> - <span class="string">'a'</span>; <span class="keyword">return</span> element;</span><br><span class="line">    &#125;  <span class="comment">// 返回元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"element "</span> &lt;&lt; element &lt;&lt; <span class="string">"is not lower"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>格式如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/cpp/cpp-notes-01/" itemprop="url">C++ Zero To One 0.001</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T06:45:50+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。</p>
<p>这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。</p>
<h2 id="右移，左移"><a href="#右移，左移" class="headerlink" title="右移，左移"></a>右移，左移</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_capacity &gt;&gt;= 1;     // _capacity *= 0.5;</span><br><span class="line">_capacity &lt;&lt;= 1;     // _capacity *= 2;</span><br></pre></td></tr></table></figure>
<h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new delete"></a>new delete</h2><p>要先new一个新的, 才能delete旧的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::shrunk() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size &gt; (_capacity/<span class="number">2</span>)) <span class="keyword">return</span>;   <span class="comment">// 规模大于1/2不必缩容</span></span><br><span class="line">  _capacity = <span class="built_in">std</span>::max(_capacity, DEAFAULT_CAPACITY);</span><br><span class="line">  <span class="comment">// 储存一份旧元素, 创建新的数据空间</span></span><br><span class="line">  T* old_elem = _elem; _elem = <span class="keyword">new</span> T[_capacity &gt;&gt;= <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (Rank r = <span class="number">0</span>; r &lt; _size; r++) &#123;</span><br><span class="line">    _elem[r] = old_elem[r];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除旧元素的内存空间</span></span><br><span class="line">  <span class="keyword">delete</span> [] old_elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>new分配空间<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* tarr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi - lo)];</span><br><span class="line">    _size = hi - lo;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*tarr = "</span> &lt;&lt; tarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*_elem = "</span> &lt;&lt; *_elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* tarr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    _size = hi - lo;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*tarr = "</span> &lt;&lt; tarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*_elem = "</span> &lt;&lt; *_elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习</p>
<h2 id="同一if语句-同一行中的后置递增"><a href="#同一if语句-同一行中的后置递增" class="headerlink" title="同一if语句, 同一行中的后置递增"></a>同一if语句, 同一行中的后置递增</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"---- test in same if statement----"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="comment">// 在同if, for, while中, 对某一变量i后置递增, i前后不变</span></span><br><span class="line">  <span class="keyword">if</span> (equal(i++, arr[i])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"equal\n"</span></span><br><span class="line">                                    &lt;&lt; <span class="string">"now i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一if, for, while语句中, 后置递增返回当前值<br>同一行, 不同语句, 当然会让值产生变化</p>
<h2 id="重载后置-操作符号"><a href="#重载后置-操作符号" class="headerlink" title="重载后置++操作符号"></a>重载后置++操作符号</h2><p>前置递增 operator++()<br>后置递增, 以前置递增为基础 operator++(int i)<br>increment_and_decrement_operators.cpp</p>
<p>递增运算符重载的返回类型:<br><code>为什么返回*_elem 而不是 *this??</code><br>递减运算符重载函数的返回类型是int&amp;<br>*this的类型为Vector<int>, 而*_elem 的类型是int</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>--() &#123;          <span class="comment">// 重载前置--操作符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    _elem[i]--;                    <span class="comment">// 对每个元素-1</span></span><br><span class="line">  <span class="keyword">return</span> *_elem;                    <span class="comment">// 返回当前 *this or *_elem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Vector&lt;T&gt;::<span class="keyword">operator</span>--(<span class="keyword">int</span> i) &#123;          <span class="comment">// 重载后置--操作符</span></span><br><span class="line">  T* e = _elem;</span><br><span class="line">  --*<span class="keyword">this</span>;                         <span class="comment">// 调用前置递减</span></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P502, P421</code></p>
<h2 id="函数指针-和-函数对象"><a href="#函数指针-和-函数对象" class="headerlink" title="函数指针 和 函数对象"></a>函数指针 和 函数对象</h2><p>对无序向量的遍历操作中, 统一对各个元素分别实施visit操作</p>
<p><strong>函数指针</strong>, 只读或者<span style="color:red"><strong>局部性修改</strong></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span> (*visit)(T&amp;))      <span class="comment">// 函数指针</span></span><br><span class="line">  &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) visit(_elem[i]);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数对象</strong>, 可<span style="color:red"><strong>全局性修改</strong></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; &lt;<span class="keyword">template</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST &amp; visit) &#123;        <span class="comment">// 函数对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) visit(_elem[i];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><span style="color:red"><strong>函数指针</strong></span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLarger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i1 &lt; i2 ? i2: i1;            <span class="comment">// 返回两者较大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>声明和定义分离:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);</span><br><span class="line"></span><br><span class="line">pf1 = getLarget;</span><br><span class="line">pf1 = &amp;getLarget;       <span class="comment">// 等价,</span></span><br></pre></td></tr></table></figure></p>
<p>个人认为&amp;表达出pf1是个指针的语义明确点。</p>
<p>声明并定义:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = &amp;getLarger;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i_pf1 = (*pf1)(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> i_pf1_2 = (pf1)(<span class="number">3</span>, <span class="number">5</span>);           <span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">int</span> i_pf1_3 = getLarget(<span class="number">3</span>, <span class="number">5</span>);       <span class="comment">// 等价 调用原函数</span></span><br></pre></td></tr></table></figure></p>
<h4 id="赋值-指向新的函数"><a href="#赋值-指向新的函数" class="headerlink" title="赋值, 指向新的函数?"></a>赋值, 指向新的函数?</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i1 &lt; i2 ? <span class="literal">true</span> : <span class="literal">false</span>;      <span class="comment">// i1 &lt; i2, 返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并定义</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = &amp;compareInt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋nullptr:指针没有指向任何一个函数</span></span><br><span class="line">pf = <span class="number">0</span>;</span><br><span class="line">pf = getLarger;     <span class="comment">// error: pf已经被声明成bool(*)(const int&amp;, const int&amp;)</span></span><br><span class="line">pf = increment;     <span class="comment">// error: 同上</span></span><br></pre></td></tr></table></figure>
<p>能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。</p>
<p><code>但如果是一个类型相同的函数, 便可以重新指向该函数。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">otherCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">pf = otherCompare;</span><br></pre></td></tr></table></figure>
<h4 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h4><p>函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="keyword">void</span> (*pff1)(<span class="keyword">int</span> *) = &amp;ff;      <span class="comment">// pff1指向ff的 void (int*)版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pff2)(<span class="keyword">int</span>) = &amp;ff;        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">int</span> (*pff3)(<span class="keyword">unsigned</span>) = &amp;ff;    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针作为形参-调用函数指针"><a href="#函数指针作为形参-调用函数指针" class="headerlink" title="函数指针作为形参(调用函数指针)"></a>函数指针作为形参(调用函数指针)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三个参数是函数指针类型</span></span><br><span class="line">void useBigger(const int&amp;, const int&amp;, bool (*pf)(const int&amp;, const int&amp;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时, 传入指向compareInt的指针</span></span><br><span class="line">useBigger(i1, i2, &amp;compareInt);</span><br></pre></td></tr></table></figure>
<p>可以用别名的方法简化定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(compareInt)</span> *FuncP2</span>;    <span class="comment">// FuncP2是指向函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(compareInt)</span> Func</span>;       <span class="comment">// decltype()返回函数类型, Func是函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, FuncP2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, Func2)</span></span>;   <span class="comment">// 编译器将Func2函数类型自动转换为了函数的指针类型</span></span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>一般, 别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PF = <span class="keyword">bool</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);      <span class="comment">// PF是函数的指针类型</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="keyword">bool</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);          <span class="comment">// F是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;          <span class="comment">// 返回函数的指针类型</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;          <span class="comment">// 显式f1返回的是一个指针类型</span></span><br><span class="line"><span class="function">F <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>;           <span class="comment">// Error:F是函数类型, 无法返回一个函数</span></span><br></pre></td></tr></table></figure>
<p>尾置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto f1(int) -&gt; int(*)(int*, int)</span><br></pre></td></tr></table></figure></p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a><span style="color:red"><strong>函数对象</strong></span></h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载()"></a>重载()</h4><p>说明这个对象, 他可以当作函数来使用。因此需要重载”()”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> iarr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      sum += iarr[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用这个函数对象"><a href="#使用这个函数对象" class="headerlink" title="使用这个函数对象"></a>使用这个函数对象</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sum s;</span><br><span class="line"><span class="keyword">int</span> iarr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">s(iarr, n);      <span class="comment">// sum = 21</span></span><br></pre></td></tr></table></figure>
<h4 id="作为其他函数的参数"><a href="#作为其他函数的参数" class="headerlink" title="作为其他函数的参数"></a>作为其他函数的参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象作为另一个函数的形参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CLS&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(CLS &amp; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">  c(iarr, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Sum s1;</span><br><span class="line">f(s1);       <span class="comment">// sum = 18</span></span><br></pre></td></tr></table></figure>
<h4 id="回顾一下数据结构中的用法"><a href="#回顾一下数据结构中的用法" class="headerlink" title="回顾一下数据结构中的用法"></a>回顾一下数据结构中的用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST visit) &#123;</span><br><span class="line">  <span class="comment">// 对每个元素执行visit操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;visit(_elem[i]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不能用引用类型?</span></span><br><span class="line"><span class="comment">// no known conversion for argument 1 from ‘Increase&lt;int&gt;’ to ‘Increase&lt;int&gt;&amp;’</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* my error test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void increase(Vector&lt;T&gt; V) &#123;</span></span><br><span class="line"><span class="comment">  V.traverse(Increase(T&amp; e));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Increase&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不用实例化, 带入参数便可直接调用??</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/02-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/02-C/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-C</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:09:15+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>&#125;;    <span class="comment">// template定义方式</span></span><br></pre></td></tr></table></figure>
<p>模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  Vector&lt;<span class="keyword">int</span>&gt; myVector;    <span class="comment">// Right</span></span><br><span class="line"></span><br><span class="line">  Vector&lt;<span class="keyword">float</span>&gt; myfVector;</span><br><span class="line"></span><br><span class="line">  Vector&lt;BinTree&gt; binForest;       <span class="comment">// Combine with other class;</span></span><br><span class="line">  Vector&lt;Tree&lt;<span class="keyword">int</span>&gt;&gt; binForest;     <span class="comment">// Combine with template;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无序向量: 没有顺序, 甚至不可能排成顺序。</p>
<h2 id="元素访问-寻秩访问"><a href="#元素访问-寻秩访问" class="headerlink" title="元素访问(寻秩访问)"></a>元素访问(寻秩访问)</h2><p>v.get(r), v.put(e)</p>
<p>A[r]</p>
<p>重载下标运算符”[]”<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻秩访问</span></span><br><span class="line"><span class="comment">/* // my test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">T&amp; Vector&lt;T&gt;::operator[](std::size_t n) &#123;    // 这个类 Vector&lt;T&gt;</span></span><br><span class="line"><span class="comment">  assert(n &lt; _size);</span></span><br><span class="line"><span class="comment">  return _elem[n];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span> &#123;   <span class="comment">// 不改变数据成员, 定义成常量成员函数</span></span><br><span class="line">  <span class="comment">// 在vector内部, 定义了秩的类型, 统一用Rank</span></span><br><span class="line">  assert(r &lt; _size);   <span class="comment">// 对下标秩进行溢出检测</span></span><br><span class="line">  <span class="keyword">return</span> _elem[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>左值, 右值, <code>引用??</code><br>引用类型可作为左值。</p>
<p>寻秩访问</p>
<p>代码健壮性简化</p>
<ul>
<li>assert 断言, <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line">assert(r &lt; _size);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">/* my test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::insert(const Rank r, const int value) &#123;</span></span><br><span class="line"><span class="comment">  // 检查移动后是否需要扩容</span></span><br><span class="line"><span class="comment">  if (++_size &gt; _capacity) expand();</span></span><br><span class="line"><span class="comment">  // 将秩为r后的所有元素后移一位</span></span><br><span class="line"><span class="comment">  for (Rank i = _size-2; i &gt;= r; i--) &#123;     // 为了不覆盖数据, 从尾部开始移动</span></span><br><span class="line"><span class="comment">    _elem[i+1] = _elem[i];     // 向后移动一位</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 在r秩位置上填入要插入的值</span></span><br><span class="line"><span class="comment">  _elem[r] = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::insert(<span class="keyword">const</span> Rank r, T <span class="keyword">const</span> &amp;e) &#123;</span><br><span class="line">  <span class="comment">// value不应该是某一中特点的类型, 而应该利用template的特性</span></span><br><span class="line">  assert(<span class="number">0</span>&lt;= r &amp;&amp; r &lt; _size);</span><br><span class="line">  expand();  <span class="comment">// 若有必要扩容  结合expand()中, _size &lt; _capacity的定义</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">// 习惯把改变后的值的索引设置成i</span></span><br><span class="line">    _elem[i] = _elem[i<span class="number">-1</span>];     <span class="comment">// 后继元素顺次后移一个单元</span></span><br><span class="line">  _elem[r] = e; _size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Template中泛型T的作用,<br>模板类中函数的互相搭配,<br>插入元素对vector操作的顺序<br>对_capacity和_size的影响。</p>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p>自前向后的迁移操作<br>缩容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::del(const Rank lo, const Rank hi) &#123;</span></span><br><span class="line"><span class="comment">  for (Rank i = lo; i &lt; _size; i++) &#123;</span></span><br><span class="line"><span class="comment">    // 清空区间元素</span></span><br><span class="line"><span class="comment">    if (i &lt; hi) &#123; _elem[i] = 0;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">      // 将元素整体前移</span></span><br><span class="line"><span class="comment">      _elem[i - (hi-lo)] = _elem[i];</span></span><br><span class="line"><span class="comment">      // 前移后元素清空</span></span><br><span class="line"><span class="comment">       _elem[i] = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 缩短规模和空间容量</span></span><br><span class="line"><span class="comment">  _size -= hi-lo; _capacity -= hi-lo;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::del(Rank lo, Rank hi) &#123;</span><br><span class="line">  <span class="comment">// 处理退化情况</span></span><br><span class="line">  <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> length = hi - lo;</span><br><span class="line">  <span class="comment">// 自前向后的迁移操作</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; _size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt; _capacity) &#123;_elem[lo++] = _elem[hi++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;_elem[lo++] = <span class="number">0</span>;&#125;   <span class="comment">// 处理hi++超出_capacityg容量的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新规模或者缩容</span></span><br><span class="line">  _size -= length;</span><br><span class="line">  shrunk();</span><br><span class="line">  <span class="comment">// 返回被删除元素的数目</span></span><br><span class="line">  <span class="keyword">return</span> hi-lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?</code> 改进成改变size的版本用于shrunk<br><code>2 , _elem[hi++]能够被一直索引到?</code> 超过_capacity时, 返回未定义的值<br><code>3, _elem[hi++]为什么不清空?</code>把_capacity的剩余空间对应元素赋值给它的方法清空<br><code>4, 看出移动操作过程中, 变量的同步性</code><br><code>5, 缩容不光光是改变_capacity的值, 仍旧要释放空间</code></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>无序向量： T为可判等, 重载 “==”或者”!=”<br>有序向量： T为可比较，重载 “&lt;” 或  “&gt;”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">int Vector&lt;T&gt;::find(Rank lo, Rank hi, T const &amp;e) const &#123;</span></span><br><span class="line"><span class="comment">  // 查找e在区间[lo,hi)内</span></span><br><span class="line"><span class="comment">  // 从右往左查找</span></span><br><span class="line"><span class="comment">  while (hi &gt;= lo) &#123;</span></span><br><span class="line"><span class="comment">    if (_elem[hi] == e) &#123;return hi;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    hi--;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 没有在while循环中返回, 不存在匹配元素</span></span><br><span class="line"><span class="comment">  return -1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::find(Rank lo, Rank hi, T <span class="keyword">const</span> &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi-- &amp;&amp; e != _elem[hi]) &#123;&#125;   <span class="comment">// 逆向查找</span></span><br><span class="line">  <span class="keyword">return</span> hi;   <span class="comment">// hi &lt; lo失败; 否则hi即命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>利用while本身的条件语句；后置递增的特性</code><br><code>返回hi?</code> 将判断是否成功, 交给<code>上层的调用者</code>;以及成功后被<code>上层算法</code>进一步利用</p>
<p>最好情况 O(1), 最坏情况O(n)<br>输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。</p>
<h2 id="删除单元素"><a href="#删除单元素" class="headerlink" title="删除单元素"></a>删除单元素</h2><p><code>视为区间操作的特例</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除单个元素</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::remove(Rank r) &#123;</span></span><br><span class="line"><span class="comment">  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)</span></span><br><span class="line"><span class="comment">  remove(r, r+1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// 删除向量中秩为r的元素, 0 &lt;= r &lt; size</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::remove(Rank r) &#123;  <span class="comment">// O(n-r)</span></span><br><span class="line">  T&amp; <span class="keyword">old_t</span> = _elem[r];    <span class="comment">// 备份被删除的元素</span></span><br><span class="line">  remove(r, r+<span class="number">1</span>);         <span class="comment">// 调用区间删除算法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">old_t</span>;           <span class="comment">// 返回被删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>颠倒考虑</code></p>
<p>复杂度分析:<br>每次循环的耗时正比于删除区间的后缀长度 O(n-hi)<br>循环的次数等于区间宽度 O(hi-lo)<br>总体 O(n^2) 复杂度</p>
<p>right, but not fast!!</p>
<h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><p><code>实现</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::deduplicate(Rank lo, Rank hi) &#123;</span></span><br><span class="line"><span class="comment">  // 对向量中的元素遍历,</span></span><br><span class="line"><span class="comment">  for (Rank i = lo; i &lt; hi; i++) &#123;</span></span><br><span class="line"><span class="comment">    // find右往左查, 返回lo-1代表失败</span></span><br><span class="line"><span class="comment">    // 删除当前元素, 不再对后续元素查找</span></span><br><span class="line"><span class="comment">    if (find(lo, i, _elem[i]) != lo-1) &#123;remove(i); break;&#125;</span></span><br><span class="line"><span class="comment">    if (find(i+1, hi, _elem[i]) != i) &#123; remove(i);&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class="line">  <span class="keyword">int</span> old_size = _size;</span><br><span class="line">  Rank i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; _size) &#123;</span><br><span class="line">    find(<span class="number">0</span>, i, _elem[i]) &lt; <span class="number">0</span> ?</span><br><span class="line">                             i++  <span class="comment">// 小于0说明无雷同, 继续查找</span></span><br><span class="line">                             : remove(i);    <span class="comment">// 删除雷同者(至多一个?!)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  old_size - _size;      <span class="comment">// 返回规模的变化量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>记录规模?</code> 考虑返回值怎么设计，这里我估计会在更高级的接口中用到<br><code>从1开始?</code> 因为要在当前i的前缀中查找<br><code>至多一个?</code> 删除至多一个, 实际不一定至多一个<br><code>为什么不需要改变_size和_capacity大小?</code> 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。</p>
<p><code>**正确性证明**</code>：<br><strong>不变性</strong>: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异<br>初始时, i = 1, 两个元素成立,…</p>
<p><strong>单调性</strong>:<br>1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合<br>2)后缀单调下降, _size迟早减至0;     // 2)更容易把握</p>
<p>故算法必然终止, 至多迭代O(n)轮</p>
<p><code>复杂度</code></p>
<p>主要来自find() 和 remove();<br>find()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);<br>while循环会进行n次,<br>总体复杂度为 O(n^2)</p>
<p><code>练习三种优化方案（未完成）</code></p>
<p>1, 仿照uniquify()高效版本的思路.<br>元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性<br>2, 先对需要删除的重复元素标记, 然后统一删除.<br>稳定性保持, 但因查找长度更长, 从而导致更多的对比操作<br>3, V.sort().uniquify(): 简明实现最优的O(nlogn)</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>visit</p>
<p><a href="https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/">关于函数指针和函数对象的笔记</a><br>函数指针机制 ?? </p>
<p>函数对象机制 ??</p>
<p>两种方法优劣</p>
<p>实例: 将向量中所有的元素统一加一<br>重载操作符 “++”<br>重载操作符 “()”</p>
<p>练习更为复杂的遍历</p>
<h3 id="减1"><a href="#减1" class="headerlink" title="减1"></a>减1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历运用函数对象机制，对各个元素减1</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">// 单个T类型元素减1的类</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">Vector&lt;T&gt;::struct Decrease &#123;</span></span><br><span class="line"><span class="comment">  virtual void operator() &#123;T &amp;e--;&#125;     // 重载()操作, 类对象当作函数来用</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void decrease(Vector&lt;T&gt;&amp; V) &#123;</span></span><br><span class="line"><span class="comment">  V.traverse(Decrease&lt;T&gt;());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 泛型模板在调用的时候都要带&lt;type&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Decrease</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;e)</span> </span>&#123;e--;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrease</span><span class="params">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Decrease&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么不是Vector-struct-Decrease"><a href="#为什么不是Vector-struct-Decrease" class="headerlink" title="为什么不是Vector::struct Decrease?"></a>为什么不是Vector<t>::struct Decrease?</t></h4><p>// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。</p>
<h4 id="为什么需要virtual"><a href="#为什么需要virtual" class="headerlink" title="为什么需要virtual"></a>为什么需要virtual</h4><h4 id="void-operator-T-amp-e"><a href="#void-operator-T-amp-e" class="headerlink" title="void operator()(T &amp;e)?"></a>void operator()(T &amp;e)?</h4><p>// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表</p>
<h4 id="三个函数之间的关系"><a href="#三个函数之间的关系" class="headerlink" title="三个函数之间的关系?"></a>三个函数之间的关系?</h4><p>Decrease<t>(T&amp;)函数对象, Vector<t>::traverse(VST&amp;)遍历函数, decrease(Vector<t>)</t></t></t></p>
<p>// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<t>&amp; 类型<br>// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素</t></p>
<h4 id="为什么需要函数对象"><a href="#为什么需要函数对象" class="headerlink" title="为什么需要函数对象?"></a>为什么需要函数对象?</h4><h4 id="本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢"><a href="#本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢" class="headerlink" title="本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?"></a>本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?</h4><p>将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。</p>
<h3 id="加倍"><a href="#加倍" class="headerlink" title="加倍"></a>加倍</h3><p>Double(T &amp;e)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Double_value</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>&#123;e *= <span class="number">2</span>;&#125;   <span class="comment">// 函数对象对元素翻倍</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_value</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Double_value&lt;T&gt;());      <span class="comment">// 函数对象作为遍历函数的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><h4 id="函数中传入指针"><a href="#函数中传入指针" class="headerlink" title="函数中传入指针"></a>函数中传入指针</h4><p>Sum(T&amp; e, T* sumPtr)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用于traverse的求和函数对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct Sum &#123;</span><br><span class="line">  virtual void operator()(const T&amp; e, T* sumPtr) &#123;(*sumPtr) += e;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; template &lt;typename VST&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::traverse(VST visit, T* e) &#123;</span><br><span class="line">  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针</span><br><span class="line">  for (int i = 1; i &lt; _size; i++) visit(_elem[i], e);   // 从第二个值开始累加</span><br><span class="line">  return *e;       // 返回求和结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。</strong></p>
<p>前面都没什么问题,<br>实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_ptr</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  T* sumPtr = &amp;(V[<span class="number">0</span>]);        <span class="comment">// 别定义空指针, 该指针指向向量首位</span></span><br><span class="line">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class="comment">// 调用并赋值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但print_vector()之后<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- --------print_vector--------- --</span><br><span class="line">_size = 3</span><br><span class="line">_capacity = 10</span><br><span class="line">0:52                 ==&gt; _elem的首位被修改, 原本应该是10</span><br><span class="line">1:24</span><br><span class="line">2:18</span><br><span class="line">3:0</span><br><span class="line">4:0</span><br><span class="line">5:0</span><br><span class="line">6:0</span><br><span class="line">7:0</span><br><span class="line">8:0</span><br><span class="line">9:0</span><br></pre></td></tr></table></figure></p>
<p>因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!</p>
<p>于是我便做了如下修改:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_ptr</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  T sum_init = V[<span class="number">0</span>];              <span class="comment">// 创建一个副本, 避免通过指针修改V[0]</span></span><br><span class="line">  T* sumPtr = &amp;(sum_init);        <span class="comment">// 别定义空指针, 该指针指向副本</span></span><br><span class="line">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class="comment">// 调用并赋值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- --------print_vector--------- --</span><br><span class="line">_size = 3</span><br><span class="line">_capacity = 10</span><br><span class="line">0:10</span><br><span class="line">1:24</span><br><span class="line">2:18</span><br><span class="line">3:0</span><br><span class="line">4:0</span><br><span class="line">5:0</span><br><span class="line">6:0</span><br><span class="line">7:0</span><br><span class="line">8:0</span><br><span class="line">9:0</span><br></pre></td></tr></table></figure>
<h5 id="重载函数什么时候用virtual"><a href="#重载函数什么时候用virtual" class="headerlink" title="重载函数什么时候用virtual?"></a>重载函数什么时候用virtual?</h5><h4 id="类内static存放"><a href="#类内static存放" class="headerlink" title="类内static存放"></a>类内static存放</h4><p>static sumStc<br>静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类内static求和的函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum_static</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> T <span class="keyword">sum_t</span>;     <span class="comment">// 内部声明存放求和结果的static变量</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sum_t</span> += e; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"revise static sum_t, sum_t = "</span></span><br><span class="line">                          &lt;&lt; <span class="keyword">sum_t</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 当心全局变量出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Sum_static&lt;T&gt;::<span class="keyword">sum_t</span> = <span class="number">0</span>;   <span class="comment">// 外部定义静态数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_static</span><span class="params">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class="line">  Sum_static&lt;T&gt; sumstc;           <span class="comment">// 实例化模板别忘记&lt;type&gt;</span></span><br><span class="line">  V.traverse(Sum_static&lt;T&gt;());</span><br><span class="line">  T sum = sumstc.<span class="keyword">sum_t</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"in sum_static, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于static, 我的相关练习<a href="https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp" target="_blank" rel="noopener">source code</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/02-B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/02-B/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-B</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:09:07+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h1><h2 id="静态管理空间"><a href="#静态管理空间" class="headerlink" title="静态管理空间"></a>静态管理空间</h2><p>_capacity固定, 存在不足:</p>
<blockquote>
<p>1, 上溢(overflow）, _elem[]不足以存放元素<br>2, 下溢(underflow), _elem[]中元素寥寥无几<br>装填因子(load factor) = <em>size/ </em> capacity &lt;&lt; 50% 空间利用率低</p>
</blockquote>
<h1 id="动态管理空间"><a href="#动态管理空间" class="headerlink" title="动态管理空间"></a>动态管理空间</h1><p>蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。</p>
<p>即将发生<strong>上溢</strong>，适当扩展容量</p>
<h2 id="扩容算法实现"><a href="#扩容算法实现" class="headerlink" title="扩容算法实现"></a>扩容算法实现</h2><p>最终的扩容代码如下: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;    <span class="comment">// 容量未到达不必扩容</span></span><br><span class="line">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    <span class="comment">// 不小于最小容量</span></span><br><span class="line">  <span class="comment">// 存储旧元素, 新数组容量扩大</span></span><br><span class="line">  T* old_elem = _elem; _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">    _elem[i] = old_elem[i];   <span class="comment">// 复制原数组到新数组的对应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> [] old_elem;    <span class="comment">// 释放原数组的对应空间，归还系统</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外尝试两种出现BUG的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class="line"><span class="comment">  if (_size == _capacity) &#123;   // 规模到达最大容量时</span></span><br><span class="line"><span class="comment">    // 创建一个容量更大的数组</span></span><br><span class="line"><span class="comment">    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个</span></span><br><span class="line"><span class="comment">    Rank _tmp_size = _size;</span></span><br><span class="line"><span class="comment">    _size = 0;</span></span><br><span class="line"><span class="comment">    // 复制原数组到新数组的对应位置</span></span><br><span class="line"><span class="comment">    copyFrom(this-&gt;_elem, 0, _tmp_size);</span></span><br><span class="line"><span class="comment">    // 释放原数组的对应空间，归还系统</span></span><br><span class="line"><span class="comment">    delete [] _elem;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class="line"><span class="comment">  if (_size &lt; _capacity) return;    // 容量未到达不必扩容</span></span><br><span class="line"><span class="comment">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量</span></span><br><span class="line"><span class="comment">  // 存储旧元素, 新数组容量扩大</span></span><br><span class="line"><span class="comment">  T* new_elem = new T[_capacity &lt;&lt;= 1];</span></span><br><span class="line"><span class="comment">  for (int i = 0; i &lt; _size; i++) &#123;</span></span><br><span class="line"><span class="comment">    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则</span></span><br><span class="line"><span class="comment">  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()</span></span><br><span class="line"><span class="comment">  delete [] new_elem;    // 释放临时数组的对应空间，归还系统</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>第二种错误代码分析：</p>
<blockquote>
<ul>
<li>备份一份旧的, 把当前的刷成新的。</li>
<li>创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。</li>
</ul>
</blockquote>
<p>封装的好处</p>
<blockquote>
<ul>
<li><code>得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针</code>, 封装后，上述通过_elem统一的指示器标记起点.</li>
</ul>
</blockquote>
<p>为何必须采用容量加倍</p>
<blockquote>
<ul>
<li>递增式扩容</li>
<li>加倍式扩容</li>
</ul>
</blockquote>
<h1 id="递增式扩容"><a href="#递增式扩容" class="headerlink" title="递增式扩容"></a>递增式扩容</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_elem = <span class="keyword">new</span>[T = _capacity + INCREMENT];     <span class="comment">// 追加固定大小量</span></span><br></pre></td></tr></table></figure>
<p>每次扩容, 复制原向量的成本<br>I, 2I, 3I, … (m-1)I           // 算术级数</p>
<p><span style="color:red"><strong>算术级数</strong></span>:从某个数开始, 以固定间隔为<br>单位, 不断的线性递增，总和成为算术级数。<strong>总和和末项成平方关系</strong></p>
<p>总耗时 = I <em> (m-1) </em> m/2 = O(n^2), 每次O(n)</p>
<h1 id="加倍式扩容"><a href="#加倍式扩容" class="headerlink" title="加倍式扩容"></a>加倍式扩容</h1><p>1, 2, 4, 8, 16…2^m 次扩容           // 几何级数<br>几何级数与末项等阶, O(n)</p>
<p>总耗时O(n), 每次扩容分摊成本为O(1)</p>
<p>空间上的牺牲, 在时间上获得巨大的收益。</p>
<h1 id="分摊复杂度"><a href="#分摊复杂度" class="headerlink" title="分摊复杂度"></a>分摊复杂度</h1><h2 id="平均分析-vs-分摊分析"><a href="#平均分析-vs-分摊分析" class="headerlink" title="平均分析 vs 分摊分析"></a>平均分析 vs 分摊分析</h2><p><code>平均分析(average/ expected complexity)</code><br>独立事件, 割裂相关性<br>往往不能准确反应。</p>
<p><code>分摊分析(amortized complexity)</code><br>连续的, 足够多的操作。<br>实际可行，整体考量。<br>更为真实反应。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/02-A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/02-A/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-A</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:58+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><p>如何根据同一接口规范，定制ADT和实现implementation一个数据结构?<br>如何通过更有效的算法，使得对外接口更高效的工作?</p>
<ul>
<li>search </li>
<li><p>sort</p>
<p><code>Abstract Data Type vs. Data Structure</code></p>
<p>抽象数据类型 = 数据模型 + 定义在该模型上的一组操作<br>数据结构     = 基于某种特定语言，实现ADT的一套算法</p>
</li>
</ul>
<h1 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h1><h2 id="数组到向量"><a href="#数组到向量" class="headerlink" title="数组到向量"></a>数组到向量</h2><p>数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的<strong>编号一一对应</strong></p>
<p>A[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)</p>
<p>向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成<br>与[0, n)内的<strong>秩(rank)</strong>一一对应    // 循秩访问(call-by-rank)<br>元素类型不限于基本类型<br>操作，管理维护更加简化安全。<br>可更为简便的参与更复杂的数据结构的定制。</p>
<h1 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h1><h2 id="Vector模板类"><a href="#Vector模板类" class="headerlink" title="Vector模板类"></a>Vector模板类</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank;             <span class="comment">// 秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEAFAULT_CAPACITY 3   <span class="comment">// 默认初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* ... 构造函数*/</span></span><br><span class="line">  <span class="comment">/* ... 析构函数*/</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应用和实现相互分离;<br>实现对内部数据项的封装。</p>
<h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// /* ... 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* <span class="keyword">const</span> A, Rank lo, Rank hi)</span></span>;</span><br><span class="line">  Vector(<span class="keyword">int</span> c = DEAFAULT_CAPACITY)</span><br><span class="line">  &#123;_elem = <span class="keyword">new</span> T[_capacity = c]; _size = <span class="number">0</span>;&#125;     <span class="comment">// 默认</span></span><br><span class="line">  Vector(T* <span class="keyword">const</span> A, Rank lo, Rank hi)          <span class="comment">// 数组区间复制</span></span><br><span class="line">  &#123;copyFrom(A, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi)   <span class="comment">// 向量区间复制</span></span><br><span class="line">  &#123;copyFrom(V, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V)                     <span class="comment">// 向量整体复制</span></span><br><span class="line">  &#123;copyFrom(V._elem, <span class="number">0</span>, V._size);&#125;</span><br><span class="line">  <span class="comment">//  */</span></span><br><span class="line">  <span class="comment">// /* ... 析构函数</span></span><br><span class="line">  ~Vector() &#123;<span class="keyword">delete</span> [] _elem;&#125;                   <span class="comment">// 释放内部空间</span></span><br><span class="line">  <span class="comment">// */</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom(T* <span class="keyword">const</span> A, Rank lo, Rank hi) &#123;</span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi- lo)];      <span class="comment">// 分配空间</span></span><br><span class="line">  _size = <span class="number">0</span>;  <span class="comment">// 清零规模</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi)   <span class="comment">// A[lo, hi)中的元素逐一</span></span><br><span class="line">    _elem[_size++] = A[lo++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/01-F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/01-F/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-F</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:52+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work  \<br>Make it right - 递归<br>Make it fast  - 迭代<br>     – Kent Beck</p>
<p><code>动态规划</code>: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span> &gt; n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work, right, but not fast.</p>
<h1 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h1><p>$^36 = 2^25,  ==&gt; $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec<br>$^5 = 10,     ==&gt; $^67 = 10^14 flo = 10^5 sec = 1 day</p>
<h1 id="递归跟踪"><a href="#递归跟踪" class="headerlink" title="递归跟踪"></a>递归跟踪</h1><p>效率低的原因是递归实例被重复调用。</p>
<p><code>解决方法A(记忆:memoization)</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_memoization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> mem_lst[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将已经计算的结果, 制成表备查</span></span><br><span class="line">  <span class="keyword">if</span> (is_exist(mem_lst[n])) &#123;</span><br><span class="line">    <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; n) &#123;mem_lst[n] = n;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mem_lst[n] = fib_memoization(n<span class="number">-1</span>, mem_lst) +</span><br><span class="line">          fib_memoization(n<span class="number">-2</span>, mem_lst);</span><br><span class="line">      <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>解决方法B 动态规划</code><br>上楼梯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_dynamic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;          <span class="comment">// fib(0) = 0; fib(1) = 1;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) &#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太能理解, 先放着</p>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><code>子序列(Subsequence)</code>: 有序列中若干字符，按原相对次序构成</p>
<p><code>最长公共子序列(Longest common subsequence)</code>，两个序列公共子序列的最长者</p>
<p>可能有多个，可能有歧义</p>
<p><code>实现</code></p>
<p>暂时还实现不了</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mituh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/timtingwei" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/timtingwei/" target="_blank" title="douban">
                    
                      <i class="fa fa-fw fa-globe"></i>douban</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mituh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
