<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="mituh's notes" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="mituh&#39;s notes">
<meta property="og:url" content="https://timtingwei.github.io/page/2/index.html">
<meta property="og:site_name" content="mituh&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mituh&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timtingwei.github.io/page/2/"/>





  <title>mituh's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mituh's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/02-A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/02-A/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-A</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:58+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><p>如何根据同一接口规范，定制ADT和实现implementation一个数据结构?<br>如何通过更有效的算法，使得对外接口更高效的工作?</p>
<ul>
<li>search </li>
<li><p>sort</p>
<p><code>Abstract Data Type vs. Data Structure</code></p>
<p>抽象数据类型 = 数据模型 + 定义在该模型上的一组操作<br>数据结构     = 基于某种特定语言，实现ADT的一套算法</p>
</li>
</ul>
<h1 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h1><h2 id="数组到向量"><a href="#数组到向量" class="headerlink" title="数组到向量"></a>数组到向量</h2><p>数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的<strong>编号一一对应</strong></p>
<p>A[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)</p>
<p>向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成<br>与[0, n)内的<strong>秩(rank)</strong>一一对应    // 循秩访问(call-by-rank)<br>元素类型不限于基本类型<br>操作，管理维护更加简化安全。<br>可更为简便的参与更复杂的数据结构的定制。</p>
<h1 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h1><h2 id="Vector模板类"><a href="#Vector模板类" class="headerlink" title="Vector模板类"></a>Vector模板类</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank;             <span class="comment">// 秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEAFAULT_CAPACITY 3   <span class="comment">// 默认初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* ... 构造函数*/</span></span><br><span class="line">  <span class="comment">/* ... 析构函数*/</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应用和实现相互分离;<br>实现对内部数据项的封装。</p>
<h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// /* ... 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* <span class="keyword">const</span> A, Rank lo, Rank hi)</span></span>;</span><br><span class="line">  Vector(<span class="keyword">int</span> c = DEAFAULT_CAPACITY)</span><br><span class="line">  &#123;_elem = <span class="keyword">new</span> T[_capacity = c]; _size = <span class="number">0</span>;&#125;     <span class="comment">// 默认</span></span><br><span class="line">  Vector(T* <span class="keyword">const</span> A, Rank lo, Rank hi)          <span class="comment">// 数组区间复制</span></span><br><span class="line">  &#123;copyFrom(A, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi)   <span class="comment">// 向量区间复制</span></span><br><span class="line">  &#123;copyFrom(V, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V)                     <span class="comment">// 向量整体复制</span></span><br><span class="line">  &#123;copyFrom(V._elem, <span class="number">0</span>, V._size);&#125;</span><br><span class="line">  <span class="comment">//  */</span></span><br><span class="line">  <span class="comment">// /* ... 析构函数</span></span><br><span class="line">  ~Vector() &#123;<span class="keyword">delete</span> [] _elem;&#125;                   <span class="comment">// 释放内部空间</span></span><br><span class="line">  <span class="comment">// */</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom(T* <span class="keyword">const</span> A, Rank lo, Rank hi) &#123;</span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi- lo)];      <span class="comment">// 分配空间</span></span><br><span class="line">  _size = <span class="number">0</span>;  <span class="comment">// 清零规模</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi)   <span class="comment">// A[lo, hi)中的元素逐一</span></span><br><span class="line">    _elem[_size++] = A[lo++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/01-F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/01-F/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-F</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:52+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work  \<br>Make it right - 递归<br>Make it fast  - 迭代<br>     – Kent Beck</p>
<p><code>动态规划</code>: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span> &gt; n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work, right, but not fast.</p>
<h1 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h1><p>$^36 = 2^25,  ==&gt; $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec<br>$^5 = 10,     ==&gt; $^67 = 10^14 flo = 10^5 sec = 1 day</p>
<h1 id="递归跟踪"><a href="#递归跟踪" class="headerlink" title="递归跟踪"></a>递归跟踪</h1><p>效率低的原因是递归实例被重复调用。</p>
<p><code>解决方法A(记忆:memoization)</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_memoization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> mem_lst[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将已经计算的结果, 制成表备查</span></span><br><span class="line">  <span class="keyword">if</span> (is_exist(mem_lst[n])) &#123;</span><br><span class="line">    <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; n) &#123;mem_lst[n] = n;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mem_lst[n] = fib_memoization(n<span class="number">-1</span>, mem_lst) +</span><br><span class="line">          fib_memoization(n<span class="number">-2</span>, mem_lst);</span><br><span class="line">      <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>解决方法B 动态规划</code><br>上楼梯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_dynamic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;          <span class="comment">// fib(0) = 0; fib(1) = 1;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) &#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太能理解, 先放着</p>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><code>子序列(Subsequence)</code>: 有序列中若干字符，按原相对次序构成</p>
<p><code>最长公共子序列(Longest common subsequence)</code>，两个序列公共子序列的最长者</p>
<p>可能有多个，可能有歧义</p>
<p><code>实现</code></p>
<p>暂时还实现不了</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/01-E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/01-E/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-E</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:41+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><p>分而治之：分解成子问题，递归式的求解。</p>
<p>空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。</p>
<h1 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 合                合并</span><br><span class="line">----&gt;    问题   --------</span><br><span class="line">^      /      \        ^</span><br><span class="line">| 缩减/        \ 平凡   |</span><br><span class="line">|	   /          \       |</span><br><span class="line"> -&gt; 子问题     子问题 &lt;---</span><br><span class="line"> !     !         !    !</span><br><span class="line"> -------         ------</span><br><span class="line">   治              治</span><br></pre></td></tr></table></figure>
<p>-—例子1—–<br><code>求n个总数之和</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A为整数数组, n为问题规模, 返回数组中整数的总和</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">      (n &lt; <span class="number">1</span>) ?</span><br><span class="line">      <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析:</strong></p>
<blockquote>
<ul>
<li>该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]</li>
<li>最后规模小到一定程度时， 缩减问题变为 平凡问题</li>
<li>将两个问题合并得到结果</li>
</ul>
</blockquote>
<p><strong>复杂度如何？</strong></p>
<p><code>递归跟踪(recursion trace)</code>分析 (用于简单的递归)</p>
<ul>
<li>检查每个<span style="color:red"><strong>递归实例</strong></span></li>
<li>累积所需要时间（调用语句本身抹去，计入递归实例）</li>
<li>其总和是算法执行时间<br>||          ||<br>vv          vv<br><code>线性递归</code>：得出上述递归是线性递归，复杂度渐进O(n)</li>
</ul>
<p><code>递推方程</code>分析 (用于复杂的递归)<br>上述例子中:<br>T(n) = T(n-1) + O(1)         // recurrence<br>T(0) = O(1)                  // base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...</span><br><span class="line">         = T(2) - 2</span><br><span class="line">		 = T(1) - 1</span><br><span class="line">		 = T(0) - 0 = O(1)</span><br><span class="line"></span><br><span class="line">T(n) = O(1) + n = O(n)</span><br></pre></td></tr></table></figure>
<p>-——例子2—————–<br><code>任给数组A[0,n), 将其前后颠倒</code>            // 更一般的子区间[lo, hi]<br><strong>统一接口</strong> : void reverse(int * A, int lo, int hi);</p>
<p><code>递归版</code></p>
<p>规模缩小两个单位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo</span></span><br><span class="line">  <span class="comment">// 无返回值，改变指针A所指向的数组, 使其倒序</span></span><br><span class="line">  <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">    swap(&amp;(A[lo]), &amp;(A[hi]));</span><br><span class="line">    <span class="keyword">if</span> (((hi-lo) == <span class="number">1</span>) || ((hi - lo) == <span class="number">0</span>)) <span class="keyword">return</span>;</span><br><span class="line">    reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析时间复杂度：</p>
<p><code>递归跟踪(recursion trace)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main();</span><br><span class="line">reverse(A[n], lo, hi);</span><br><span class="line">reverse(A[n-2], lo+1, hi-1);</span><br><span class="line">reverse(A[n-4], lo+2, hi-2);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">reverse(A[1], lo+(n-1)/2, hi+(n-1)/2);</span><br><span class="line">or</span><br><span class="line">reverse(A[0], lo + n/2, hi+ n/2);</span><br><span class="line">      (n-1)/2 , n是奇数</span><br><span class="line">     /                   </span><br><span class="line">O(1)*                    = O(n)</span><br><span class="line">     \n / 2,    n是偶数</span><br></pre></td></tr></table></figure></p>
<p><code>递推方程</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) = T(n) + O(1);</span><br><span class="line">T(n) - n = T(n-1) - (n-1)</span><br><span class="line">T(n) - n = T(2) - 2</span><br><span class="line">         = T(0) - 0</span><br><span class="line">T(n) = T(0) + n = O(n)</span><br></pre></td></tr></table></figure></p>
<p>&lt;span style=”color”:blue”&gt;<em>感觉不怎么正确??</em></p>
<p>课后推敲:</p>
<p><code>迭代原始版本</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_iterate_original</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代原始版本</span></span><br><span class="line">next:</span><br><span class="line">  <span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">  &#123;swap(&amp;A[lo], &amp;A[hi]); lo++; hi--; <span class="keyword">goto</span> next;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><em>使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过</em></span></p>
<p><code>迭代精简版</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_iterate</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代版本</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi) swap(&amp;A[lo++], &amp;A[hi--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="分而治之-divide-and-conquer"><a href="#分而治之-divide-and-conquer" class="headerlink" title="分而治之(divide-and-conquer)"></a>分而治之(divide-and-conquer)</h1><p>分解为多个或两个子问题，得到解后归并。<br>-—–二分递归———-</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mid_sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组求和 :二分递归</span></span><br><span class="line">  <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">  <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> mid_sum(A, lo, mid) + mid_sum(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>注意 mid + 1</strong></span></p>
<p>// 分析:<br>// 被分解成两个相似问题，mid_sum(n/2)<br>// 规模每次缩减一半，最后到达递归基<br>// 将多个问题结果合并</p>
<p>分析复杂度:</p>
<p><code>递归跟踪(几何归纳)</code></p>
<p>以2为倍数的<strong>几何级数</strong>，总和与<strong>末项同阶</strong>。</p>
<p><code>递推方程(代数运算)</code></p>
<p>两个问题都是n/2<br>累加O(1)时间<br>递归基O(1)时间返回</p>
<p>递推关系<br>T(n) = 2* T(n/2) + O(1)<br>T(1) = O(1)</p>
<p>..<br>T(n) = O(n)</p>
<h1 id="Max2-迭代1"><a href="#Max2-迭代1" class="headerlink" title="Max2: 迭代1"></a>Max2: 迭代1</h1><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] &gt; A[x2]<br>比较次数要尽可能的少</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2_three_iters</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;   <span class="comment">// 1 &lt; n = hi - lo</span></span><br><span class="line">  <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> x1, x2;</span><br><span class="line">  <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">    <span class="keyword">if</span> (max1 &lt; A[i]) &#123;max1 = A[i]; x1 = i;&#125;       <span class="comment">// hi-lo-1 = n-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x1 != lo) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i_lo  = lo; i_lo &lt; x1; i_lo++)</span><br><span class="line">      <span class="keyword">if</span> (max2 &lt; A[i_lo]) &#123;max2 = A[i_lo]; x2 = i_lo;&#125; <span class="comment">// x1-lo-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x1 != hi) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i_hi = x1+<span class="number">1</span>; i_hi &lt;= hi; i_hi++)</span><br><span class="line">      <span class="keyword">if</span> (max2 &lt; A[i_hi]) &#123;max2 = A[i_hi]; x2 = i_hi;&#125; <span class="comment">// hi-x1-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> max_array[<span class="number">2</span>] = &#123;max1, max2&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A[x1] = "</span> &lt;&lt; A[x1] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">" A[x2] = "</span> &lt;&lt; A[x2] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共比较n-1+n-2 =2n-3 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历一次，改变指针</span></span><br><span class="line">  <span class="keyword">int</span>* x1 = &amp;lo;</span><br><span class="line">  <span class="keyword">int</span> lo_next = lo + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* x2 = &amp;lo_next;</span><br><span class="line">  <span class="keyword">if</span> (A[*x1] &lt; A[*x2]) &#123;x1 = &amp;lo_next; x2 = &amp;lo;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[*x2] &lt; A[i]) &#123;      <span class="comment">// 索引i的对象比较小的值大</span></span><br><span class="line">      <span class="keyword">if</span> (A[*x1] &lt; A[i]) &#123;    <span class="comment">// 索引i的对象甚至超过了较大值</span></span><br><span class="line">        x2 = &amp;(*x1); x1 = &amp;i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *x2 = i;                <span class="comment">// x1指针指向的元素赋值成i</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A[*x1] "</span>  &lt;&lt; A[*x1] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">" A[*x2] "</span>  &lt;&lt; A[*x2] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况: 1 + (n-2)<em>1 = n-1<br>最坏情况: 1+ (n-2) </em>2 = 2n-3</p>
<p><code>即使在最坏情况，也更高效的改进算法</code></p>
<blockquote>
<ul>
<li>分而治之</li>
<li>实现退化情况</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp; x1, <span class="keyword">int</span> &amp; x2)</span> </span>&#123;     <span class="comment">// [lo, hi)</span></span><br><span class="line">  <span class="keyword">if</span> (lo + <span class="number">2</span> == hi) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[lo] &lt; A[lo+<span class="number">1</span>]) &#123;</span><br><span class="line">      x1 = A[lo+<span class="number">1</span>]; x2 = A[lo];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x2 = A[lo+<span class="number">1</span>]; x1 = A[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;                         <span class="comment">// T(2) = 1</span></span><br><span class="line">  <span class="keyword">if</span> (lo + <span class="number">3</span> == hi) &#123;       <span class="comment">// lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;</span></span><br><span class="line">    x1 = lo, x2 = lo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[x1] &lt; A[x2]) &#123;x1 = lo+<span class="number">1</span>; x2 = lo;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo+<span class="number">2</span>; i &lt; hi+<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[i] &gt; A[x2]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[x1]) &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = x1;</span><br><span class="line">          x1 = i; x2 = tmp;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x2 = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;                         <span class="comment">// T(3) &lt;= 3</span></span><br><span class="line">  <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> x1L, x2L; max2(A, lo, mid, x1L, x2L);</span><br><span class="line">  <span class="keyword">int</span> x1R, x2R; max2(A, mid+<span class="number">1</span>, hi, x1R, x2R);</span><br><span class="line">  <span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">    x1 = x1L; x2 = (x2L &lt; x1R) ? x1R:x2L;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x1 = x1R; x2 = (x2R &lt; x1L) ? x1L:x2R;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 1 + 1 = 2</span></span><br></pre></td></tr></table></figure>
<p>最坏情况: T(n) = 2 * T(n/2) + 2 &lt;= 5n/3 -2</p>
<p><code>递推方程推导过程:</code> ? </p>
<p><code>最好情况复杂度:</code> ?</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种重要算法策略：减而治之，分而治之</p>
<p>两种分析方法：递归跟踪和递推方程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/01-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/01-C/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-C</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:08:22+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>渐进分析: 大O记号 </p>
<p>好读书不求甚解。</p>
<p>考察DSA（考察人）:</p>
<blockquote>
<ul>
<li>长远</li>
<li>主流,</li>
</ul>
</blockquote>
<p>渐进分析(Asymptotic Analysis) n &gt;&gt; 2, 对于规模为n输入，算法</p>
<ul>
<li>需要执行的基本操作数: T(n) = ?</li>
<li>..存储单元: S(n) = ?       // 通常不考虑？<strong>教材</strong></li>
</ul>
<p><strong>教材P33</strong></p>
<blockquote>
<ul>
<li>空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。</li>
<li>但两种情况下会有意义:<ul>
<li>对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)</li>
<li>数据的输入规模大。</li>
</ul>
</li>
</ul>
</blockquote>
<p>big-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)</p>
<blockquote>
<ul>
<li>常系数可忽略(主流):O(f(n)) = O(c*f(n))</li>
<li>低次项可忽略(主流)</li>
</ul>
</blockquote>
<p>O(1)<br>常数</p>
<blockquote>
<ul>
<li>2 = 2013 = 2013*2013 = O(1)</li>
<li>效率: 最高效</li>
<li>出现的情况，需要具体分析<pre><code>不含循环，不含分支转向，一定不能有(递归)调用？
</code></pre><strong>教材</strong></li>
</ul>
</blockquote>
<p>O(logn)<br>对数</p>
<blockquote>
<ul>
<li>常底数无所谓</li>
<li>常数次幂无所谓</li>
<li>多项式</li>
<li>效率: 接近于常数</li>
</ul>
</blockquote>
<p>O(n^c)<br>多项式</p>
<blockquote>
<ul>
<li>一般 取最高次<br>线性：所有O(n)函数<br>从O(n)到O(n^2):编程习题主要覆盖范围<br>效率: 已经可令人满意。</li>
</ul>
</blockquote>
<p>O(2^n)<br>指数<br>效率: 算法成本增长极快，通常不可忍受。<br>n^x-&gt;2^n, 是从有效算法到无效算法的分水岭。</p>
<p>2-Subset<br>直觉算法：逐一枚举S的每一个子集，并统计其中元素总和<br>定理:2-Subset is NP-complete<br>意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。<br>     除非，添加条件：分布规律啦, 票的总数啦，</p>
<p>复杂度增长速度表格。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/10/dsacpp/01-B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/dsacpp/01-B/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-B</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T00:07:54+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>功能：<br>算法:<br>规范：图灵机复位h的原因。 =&gt; 在软件中叫做接口</p>
<p>RAM: Random Access Machine<br>共同之处：无限的空间。<br>寄存器：</p>
<blockquote>
<ul>
<li>常数赋值给RAM             </li>
<li>RAM之间直接赋值 R[i] &lt; R[j]</li>
<li>RAM之间间接赋值 R[i] &lt;- R[R[j]]</li>
<li>RAM+-</li>
<li>判断0跳转      IF R[i] = 0 GOTO l</li>
<li>判断正跳转             &gt; 0</li>
<li>跳转</li>
<li>停止           STOP</li>
</ul>
</blockquote>
<p>概括:<br>对计算工具抽象后的简化。<br>独立于环境和平台，可评判效率。</p>
<blockquote>
<ul>
<li>将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数</li>
<li><h1 id="这个次数是清晰的，可度量的。"><a href="#这个次数是清晰的，可度量的。" class="headerlink" title="这个次数是清晰的，可度量的。"></a>这个次数是清晰的，可度量的。</h1></li>
</ul>
</blockquote>
<p>RAM实例:Floor<br>向下取整除法, 0 &lt;= c, 0 &lt; d<br>c%d = max {x | d<em>c &lt;= c}<br>    = max {x | d</em>x &lt; 1+c}</p>
<h2 id="R-0-c-1-R-1-d"><a href="#R-0-c-1-R-1-d" class="headerlink" title="R[0] = c+1, R[1] = d"></a>R[0] = c+1, R[1] = d</h2><p>0, R[0] &lt;- c                 // int c = c;<br>1, R[1] &lt;- d                 // int d = d;<br>2, R[2] &lt;- 0                 // int x = 0;<br>3, R[3] &lt;- 1                 // int a = 1;<br>4, R[0] &lt;- R[0] + R[2]       // c++<br>6, R[0] &lt;- R[0] - R[1]       // c-=d<br>7, R[2] &lt;- R[2] + R[3]       // x++<br>8, IF R[0] &gt; 0 GOTO 4        // if c &gt; 0 goto 4<br>9, R[0] &lt;- R[2] - R[3]       // else x– and;<br>9, STOP                      // return R[0] = x</p>
<p>src:</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/04/trip-of-game-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/04/trip-of-game-notes/" itemprop="url"><<游戏之旅>>笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-04T09:34:38+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近读了云风大大的书, 感谢云风, 对我有所帮助。<br>选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14</p>
<h1 id="对我有所启发的points"><a href="#对我有所启发的points" class="headerlink" title="对我有所启发的points"></a>对我有所启发的points</h1><blockquote>
<ul>
<li>写email的建议</li>
<li>C和C++的关系</li>
<li>C++的开发经验</li>
<li>学习C++阅读次序</li>
<li>template的技巧</li>
<li><strong>开发的成功和失败的经验</strong></li>
<li>游戏编程几个反思</li>
<li>后记中编程实践和思考方法 </li>
<li>致谢中云风父亲的背景以及教育方法</li>
</ul>
</blockquote>
<hr>
<h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h1><h2 id="2-1-程序-算法-数据结构"><a href="#2-1-程序-算法-数据结构" class="headerlink" title="2.1 程序 = 算法+数据结构"></a>2.1 程序 = 算法+数据结构</h2><p>计算机解决的问题，看成一个需要求解的函数，</p>
<blockquote>
<ul>
<li>算法：将输入转化为输出的方法。</li>
<li>数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。</li>
</ul>
</blockquote>
<h4 id="2-1-1-算法"><a href="#2-1-1-算法" class="headerlink" title="2.1.1 算法"></a>2.1.1 算法</h4><p>时间和空间之间寻求平衡。</p>
<blockquote>
<ul>
<li>空间换时间的做法，非常广泛，即预处理</li>
<li>时间换空间，不容忽视，即使重复计算。</li>
</ul>
</blockquote>
<p>依赖平台特性:</p>
<blockquote>
<ul>
<li>非并行计算机，不考虑用并行来提速。</li>
<li>空间允许随机访问，不是纸带机的顺序。</li>
</ul>
</blockquote>
<h4 id="2-1-2-数据结构"><a href="#2-1-2-数据结构" class="headerlink" title="2.1.2 数据结构"></a>2.1.2 数据结构</h4><p>简单定义：对数据的组织方法，还有对数据组织方式的处理方法。<br>C++已经提供了常见的数据结构，为什么还要学？</p>
<blockquote>
<ul>
<li>学蕴含思想</li>
<li>根据实际情况对数据结构进行改造，更高效。</li>
</ul>
</blockquote>
<h5 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h5><pre><code>有限逻辑上的有序数列，有确定的前驱和后驱；
分为成：数组和链表;

数组:
</code></pre><h5 id="2-堆栈、队列和串"><a href="#2-堆栈、队列和串" class="headerlink" title="2. 堆栈、队列和串"></a>2. 堆栈、队列和串</h5><h5 id="3-树、二叉树及其他"><a href="#3-树、二叉树及其他" class="headerlink" title="3. 树、二叉树及其他"></a>3. 树、二叉树及其他</h5><p><strong>树：</strong><br>有层次的数据集的组织方式。</p>
<p>GUI界面，通常用树来组织；<br>游戏中的对象管理，用树来解决管理上的层次问题。</p>
<p><strong>二叉树:</strong><br>严格来说不算是树。<br>表达式计算，数据压缩，排序查找方面有很多用途。</p>
<p><strong>四叉树、八叉树：</strong><br>空间状态划分，</p>
<blockquote>
<ul>
<li>四叉树：平面</li>
<li>八叉树: 空间</li>
</ul>
</blockquote>
<p>空间: 场景空间+ 调色盘算法等（向量空间）</p>
<p><strong>图：</strong><br>节点没有父子关系，纯粹的点和边的集合。<br>节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。<br>节点和节点之间可以有方向，也可以无方向。</p>
<p><strong>图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。</strong></p>
<p><strong>映射表</strong><br>std::map,STL最复杂的容器。</p>
<p><strong>禁忌思想，</strong></p>
<blockquote>
<ul>
<li>模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。</li>
<li>蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。</li>
</ul>
</blockquote>
<p>算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。</p>
<h4 id="2-4-优化"><a href="#2-4-优化" class="headerlink" title="2.4 优化"></a>2.4 优化</h4><blockquote>
<ul>
<li>数学方法的改进</li>
<li>预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间</li>
<li>简化算法求得近似来取代精确解（或最有解）</li>
<li>改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。</li>
</ul>
</blockquote>
<p>碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。</p>
<p>&lt;<c语言程序设计400例>&gt;</c语言程序设计400例></p>
<p><strong>C</strong><br>C语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。<br>C语言函数，让问题分而治理它。<br>全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。<br>最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。</p>
<p><strong>BASIC</strong></p>
<h3 id="比较解释语言和C语言的不同"><a href="#比较解释语言和C语言的不同" class="headerlink" title="比较解释语言和C语言的不同"></a>比较解释语言和C语言的不同</h3><p>解释型语言：</p>
<blockquote>
<ol>
<li>每运行一次，解释器就读一次，对符号进行翻译</li>
<li>中间状态以严格规定保存起来，在后面的语句需要时被重新加载<br>C语言</li>
<li>在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。</li>
<li>编译器对代码同类向合并，最后的机器码会很简洁。</li>
</ol>
</blockquote>
<p>逻辑学教育，BASIC，适合理解编程。</p>
<h1 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="3. 编程语言"></a>3. 编程语言</h1><h2 id="3-3-C"><a href="#3-3-C" class="headerlink" title="3.3 C++"></a>3.3 C++</h2><h3 id="C-的不同理解"><a href="#C-的不同理解" class="headerlink" title="C++的不同理解"></a>C++的不同理解</h3><p>第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。</p>
<h3 id="C对于C-的优势"><a href="#C对于C-的优势" class="headerlink" title="C对于C++的优势"></a>C对于C++的优势</h3><p>简洁，而非高效；适合做小内存的嵌入式系统开发。</p>
<h3 id="但大多数游戏平台，C-比C更适合"><a href="#但大多数游戏平台，C-比C更适合" class="headerlink" title="但大多数游戏平台，C++比C更适合"></a>但大多数游戏平台，C++比C更适合</h3><h2 id="3-4-汇编语言"><a href="#3-4-汇编语言" class="headerlink" title="3.4 汇编语言"></a>3.4 汇编语言</h2><p>合适场合使用汇编，能让程序跑得更快。<br>了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，<br>在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。</p>
<h1 id="4-前Windows时代"><a href="#4-前Windows时代" class="headerlink" title="4. 前Windows时代"></a>4. 前Windows时代</h1><h2 id="4-3-保护模式下的开发工具"><a href="#4-3-保护模式下的开发工具" class="headerlink" title="4.3 保护模式下的开发工具"></a>4.3 保护模式下的开发工具</h2><p>个人主页建立之初，我罗列出了个人兴趣 ：…很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。</p>
<blockquote>
<ul>
<li>翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友</li>
<li><p>写关于游戏编程技术方面的小文，各处转载</p>
</li>
<li><p>利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。</p>
</li>
</ul>
</blockquote>
<p>学习新的技术，翻译一本相关的英语著作可以算是捷径。</p>
<blockquote>
<ul>
<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>
<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>
<li>即使对此有所了解，翻译后也能更上一层楼。</li>
<li>英语水平也会提高。</li>
</ul>
</blockquote>
<h2 id="4-4-闲话allegro"><a href="#4-4-闲话allegro" class="headerlink" title="4.4 闲话allegro"></a>4.4 闲话allegro</h2><h3 id="4-4-4-几何图形和3D"><a href="#4-4-4-几何图形和3D" class="headerlink" title="4.4.4 几何图形和3D"></a>4.4.4 几何图形和3D</h3><p>图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。</p>
<p>3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。<br>相关的:</p>
<blockquote>
<ul>
<li>透视映射</li>
<li>矩阵，三维空间中变换的工具, 自带一套矩阵运算。</li>
<li>实现了一套定点数的运算该改善游戏中需要的数学运算速度。</li>
</ul>
</blockquote>
<p><strong>1,定点数</strong><br>巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。</p>
<p>浮点数：计算机用一种纯小数加指数的形式表示实数。<br>定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。</p>
<p>高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。</p>
<p>精读在1/6*10^4, 十进制小数点后四位的精度。</p>
<p>定点数的一些计算技巧和优势：</p>
<blockquote>
<ul>
<li>原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。</li>
<li>角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。</li>
</ul>
</blockquote>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h2><p>云风关于写email的建议：</p>
<blockquote>
<ul>
<li>回复收到的每封email, 即使没空写， 也让对方知道自己已读。</li>
<li>使用纯文本，发送过大附件前请求</li>
<li>合适的标题，能概括内容；偏题时，修改标题。</li>
<li>删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。</li>
<li>合理分段，表达自己意见，别赞同两字多写一点。</li>
<li>发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确</li>
<li>不要随意公开转载私人信件，即使转载也注明出处。</li>
</ul>
</blockquote>
<h1 id="8-引擎中的优化"><a href="#8-引擎中的优化" class="headerlink" title="8. 引擎中的优化"></a>8. 引擎中的优化</h1><p>“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。</p>
<p>只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。</p>
<h1 id="9-C和C"><a href="#9-C和C" class="headerlink" title="9. C和C++"></a>9. C和C++</h1><h2 id="9-1-从C到C"><a href="#9-1-从C到C" class="headerlink" title="9.1 从C到C++"></a>9.1 从C到C++</h2><p>1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。</p>
<p>2, C对大块的数据，使用数据指针来表达。</p>
<p>3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据</p>
<p>4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。</p>
<p>5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。</p>
<p><code>困难性的说明</code>，<br>高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往<strong>只能针对特定的类型</strong>。</p>
<p><code>C++面向对象的说明</code></p>
<blockquote>
<ul>
<li>既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。</li>
<li>将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。</li>
</ul>
</blockquote>
<h2 id="9-2-C-vs-C-，-效率至上"><a href="#9-2-C-vs-C-，-效率至上" class="headerlink" title="9.2 C vs C++， 效率至上"></a>9.2 C vs C++， 效率至上</h2><p><code>C++中混有C语言的好处:</code></p>
<blockquote>
<p>1, 更广泛的移植性<br>2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖<br>3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事<br>4, C简洁, 编译速度快</p>
</blockquote>
<h2 id="9-3-优雅的C"><a href="#9-3-优雅的C" class="headerlink" title="9.3 优雅的C++"></a>9.3 优雅的C++</h2><p>将C细化，又不增加额外的开销;<br>不对程序员有过多限制。</p>
<h3 id="9-3-1-宏"><a href="#9-3-1-宏" class="headerlink" title="9.3.1 宏"></a>9.3.1 宏</h3><p><code>宏的作用</code></p>
<blockquote>
<p>1, 定义常数<br>2, 代码生成<br>3, 内联代码<br>4, 对编译流程作出选择</p>
</blockquote>
<p>1, 定义常数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926f;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI;</span><br></pre></td></tr></table></figure>
<p>C++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。</p>
<p>经典的如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a&lt;b)?(a):(b))</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&lt;b ? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-const修饰以及类型转换"><a href="#9-3-2-const修饰以及类型转换" class="headerlink" title="9.3.2 const修饰以及类型转换"></a>9.3.2 const修饰以及类型转换</h3><h4 id="const修饰"><a href="#const修饰" class="headerlink" title="const修饰"></a>const修饰</h4><p>const chat<em> 而不是 C 的 char</em></p>
<p>将函数参数写成const;<br>成员变量修饰成const, 只有在构造的时构建他们;<br>为成员函数增加一个const, 表达这个函数不会修改类的成员变量</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>C中几乎任何类型都可以任意转换，缘于C汇编的根。<br>C++用static_cast 以模板的语法表达看起来可以互相转换的类型互换</p>
<p>const和const之间的转换，只能通过const_cast转换。</p>
<p>严格描述每个对象的const性质，可以帮助在编译期发生错误减少。</p>
<h3 id="9-3-3-隐藏实现"><a href="#9-3-3-隐藏实现" class="headerlink" title="9.3.3 隐藏实现"></a>9.3.3 隐藏实现</h3><p>好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。</p>
<p>作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。</p>
<h3 id="9-3-4-引用而非指针"><a href="#9-3-4-引用而非指针" class="headerlink" title="9.3.4 引用而非指针"></a>9.3.4 引用而非指针</h3><p>指针是导致资源被遗忘释放的罪魁祸首。</p>
<blockquote>
<ul>
<li>当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。</li>
</ul>
</blockquote>
<p>引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。</p>
<p>C++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。</p>
<h3 id="9-3-5-命名空间"><a href="#9-3-5-命名空间" class="headerlink" title="9.3.5 命名空间"></a>9.3.5 命名空间</h3><p>引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。</p>
<h2 id="9-4-C-的误区"><a href="#9-4-C-的误区" class="headerlink" title="9.4 C++的误区"></a>9.4 C++的误区</h2><p>自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。</p>
<p>举例:</p>
<blockquote>
<ul>
<li>能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。</li>
</ul>
</blockquote>
<p>解释：</p>
<blockquote>
<ul>
<li>没有完美的程序，也没有完美的原则。</li>
<li>不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。</li>
</ul>
</blockquote>
<h3 id="9-4-1-类层次过细"><a href="#9-4-1-类层次过细" class="headerlink" title="9.4.1 类层次过细"></a>9.4.1 类层次过细</h3><p>会造成间接调用引起的损耗。</p>
<h3 id="9-4-2-滥用操作符重载"><a href="#9-4-2-滥用操作符重载" class="headerlink" title="9.4.2 滥用操作符重载"></a>9.4.2 滥用操作符重载</h3><p>为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。<br>如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。</p>
<h3 id="9-4-3-滥用标准容器"><a href="#9-4-3-滥用标准容器" class="headerlink" title="9.4.3 滥用标准容器"></a>9.4.3 滥用标准容器</h3><p>用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。</p>
<p><code>std::map可以这样子做，</code><br>如果只是为了创建一张key-value的对应表可供查询，完全可以用<br>key-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。</p>
<h3 id="9-4-5-滥用多重继承"><a href="#9-4-5-滥用多重继承" class="headerlink" title="9.4.5 滥用多重继承"></a>9.4.5 滥用多重继承</h3><p>会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。</p>
<h3 id="9-4-6-忽视C-高级特性的复杂度"><a href="#9-4-6-忽视C-高级特性的复杂度" class="headerlink" title="9.4.6 忽视C++高级特性的复杂度"></a>9.4.6 忽视C++高级特性的复杂度</h3><p>如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。</p>
<h3 id="9-4-7-学习C"><a href="#9-4-7-学习C" class="headerlink" title="9.4.7 学习C++"></a>9.4.7 学习C++</h3><p>我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。</p>
<p>因此，需要</p>
<blockquote>
<p>1，学<br>2, 用<br>3, 思考<br>2, 回到1</p>
</blockquote>
<p>如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。</p>
<p>推荐一个阅读次序:</p>
<blockquote>
<p>1, 先学会C，只是也是C++子集的部分。<br>2, &lt;<c++编程思想>&gt;<br>3, &lt;<c++ primer="">&gt; 和 &lt;<c++ programing="" language="">&gt;<br>4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。<br>5, &lt;<c++的发展和演化>&gt;，深入了解C++设计的根源以及C++编译器实现方法入手.<br>6, &lt;&lt;深度探索C++物件模型&gt;&gt;对追求高效的C++程序员尤为受用。</c++的发展和演化></c++></c++></c++编程思想></p>
</blockquote>
<p>进阶学习: 需要一定的开发经验才能阅读</p>
<blockquote>
<ul>
<li>&lt;<effective c++="">&gt;, &lt;<more effective="" c++="">&gt;, &lt;<c++沉思录>&gt;</c++沉思录></more></effective></li>
<li>泛型编程&lt;<stl 源码剖析="">&gt;，有点难，但是花上一定的时间一定有收获。</stl></li>
<li>&lt;<c++设计新思维------泛型编程与设计模式之应用>&gt;template使用自信，对泛型编程感觉良好，</c++设计新思维------泛型编程与设计模式之应用></li>
<li>&lt;<c++标准程序库>&gt;想更精通标准库，C++程序员案头必备的参考手册。</c++标准程序库></li>
<li>&lt;<effective stl="" 中文版="">&gt;， 与前面的effcive系列一样</effective></li>
</ul>
</blockquote>
<h3 id="9-5-3-再论动态内存分配"><a href="#9-5-3-再论动态内存分配" class="headerlink" title="9.5.3 再论动态内存分配"></a>9.5.3 再论动态内存分配</h3><p>//…</p>
<p>理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。</p>
<h3 id="9-6-template"><a href="#9-6-template" class="headerlink" title="9.6 template"></a>9.6 template</h3><p>template最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。</p>
<h4 id="9-6-1-封装C-的成员函数的调用"><a href="#9-6-1-封装C-的成员函数的调用" class="headerlink" title="9.6.1 封装C++的成员函数的调用"></a>9.6.1 封装C++的成员函数的调用</h4><h4 id="9-6-4-避免重复代码"><a href="#9-6-4-避免重复代码" class="headerlink" title="9.6.4 避免重复代码"></a>9.6.4 避免重复代码</h4><p><code>大部分程序错误的根源:</code></p>
<blockquote>
<ul>
<li>在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。</li>
</ul>
</blockquote>
<p>没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。</p>
<p>举个blit()例子</p>
<h4 id="9-6-5-选择最佳的容器"><a href="#9-6-5-选择最佳的容器" class="headerlink" title="9.6.5 选择最佳的容器"></a>9.6.5 选择最佳的容器</h4><p>很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。</p>
<p>对于一个容器到底是保存</p>
<blockquote>
<ul>
<li>对象指针</li>
<li><p>对象值</p>
</li>
<li><p>对于体积较大的对象，保存指针, 复制很快</p>
</li>
<li>对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用</li>
</ul>
</blockquote>
<p>可以利用模板在编译期间由编译器自动进行；</p>
<h4 id="9-6-5-延迟计算"><a href="#9-6-5-延迟计算" class="headerlink" title="9.6.5 延迟计算"></a>9.6.5 延迟计算</h4><p>由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。</p>
<h4 id="9-6-7-编译时的计算游戏（未完成）"><a href="#9-6-7-编译时的计算游戏（未完成）" class="headerlink" title="9.6.7 编译时的计算游戏（未完成）"></a>9.6.7 编译时的计算游戏（未完成）</h4><p>三个数排序<br>+</p>
<h3 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7 小结"></a>9.7 小结</h3><p>早犯一天错误，就可以早一天改正错误。</p>
<h1 id="13-开发方法"><a href="#13-开发方法" class="headerlink" title="13. 开发方法"></a>13. 开发方法</h1><h2 id="13-1-失败的经验"><a href="#13-1-失败的经验" class="headerlink" title="13.1 失败的经验"></a>13.1 失败的经验</h2><blockquote>
<p>1, 过多的工作压力压到一个人身上。<br>2, 过分的弹性工作制<br>3, 没完没了的变化和返工<br>4, 没有及时的测试<br>5, 项目的主导严重偏向了某一职位上</p>
</blockquote>
<p><code>1, 过多的工作压力压到一个人身上。</code><br>迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。</p>
<p><code>2, 过分的弹性工作制</code><br>兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。</p>
<p><code>3, 没完没了的变化和返工</code><br>想法太多，什么都想加入进来，导致最后漏洞很多。</p>
<p><code>&gt; 4, 没有及时的测试</code><br>很少有严格的测试，而是把错误积累。 </p>
<p><code>5, 项目的主导严重偏向了某一职位上</code><br>程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.</p>
<h2 id="13-2-成功的经验"><a href="#13-2-成功的经验" class="headerlink" title="13.2 成功的经验"></a>13.2 成功的经验</h2><blockquote>
<p>1, 引擎和实现的分离<br>2, 结对编程（XP 极限编程）<br>3, 随时方便地测试<br>4, 尽早发现结构上的问题, 并尽早重构<br>5, 其他</p>
</blockquote>
<p><code>1, 引擎和实现的分离</code><br>早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。<br>许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。<br>和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。</p>
<p>其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。</p>
<p><code>2, 结对编程</code><br>找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。</p>
<p>潜在问题的代码，在XP极限编程中，被称做代码的<strong>坏味道</strong>。</p>
<p>好处:</p>
<blockquote>
<p>1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。<br>2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。<br>3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。</p>
</blockquote>
<p><code>3, 随时方便地测试</code><br>测试应该从开发者开始，从项目一开始就开始。</p>
<p><code>4, 尽早发现结构上的问题, 并尽早重构</code></p>
<p><code>5, 其他</code></p>
<p>脚本和版本控制。<br>软件开发的素养。</p>
<h1 id="14-编程和游戏"><a href="#14-编程和游戏" class="headerlink" title="14. 编程和游戏"></a>14. 编程和游戏</h1><p>技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。<br>而忽略了一些更重要的东西。</p>
<h2 id="14-1-操作"><a href="#14-1-操作" class="headerlink" title="14.1 操作"></a>14.1 操作</h2><p>任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。</p>
<h2 id="14-2-角色设定"><a href="#14-2-角色设定" class="headerlink" title="14.2 角色设定"></a>14.2 角色设定</h2><p>生动的角色，RPG，增加游戏气氛</p>
<h2 id="14-3-操作技术"><a href="#14-3-操作技术" class="headerlink" title="14.3 操作技术"></a>14.3 操作技术</h2><p><code>3D和2D</code></p>
<blockquote>
<ul>
<li>应该由游戏本身的需要决定。</li>
<li>3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。</li>
<li>2D技术怎样控制和管理不断膨胀的图片数量</li>
</ul>
</blockquote>
<h2 id="14-4-浅谈网络游戏"><a href="#14-4-浅谈网络游戏" class="headerlink" title="14.4 浅谈网络游戏"></a>14.4 浅谈网络游戏</h2><p><code>社会性</code><br>除了传统的游戏它自身的娱乐性之外，还存在一种社会性。<br>因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。</p>
<p>看似不是程序的事情，但非程序的策划很难去做：</p>
<blockquote>
<ul>
<li>大规模的数字采集和统计的工作</li>
<li>大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。</li>
</ul>
</blockquote>
<p><code>平衡性</code></p>
<blockquote>
<ul>
<li>传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。</li>
<li>程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。</li>
</ul>
</blockquote>
<h2 id="14-5-小结"><a href="#14-5-小结" class="headerlink" title="14.5 小结"></a>14.5 小结</h2><p>一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2017/12/28/doc-computer-graphic-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/doc-computer-graphic-learn/" itemprop="url">关于文档学习方法和图形学学习的随想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:59:50+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇笔记<a href="http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/">OpenGL绘制三角形附练习</a>来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的<code>&lt;&lt;游戏之旅&gt;&gt;</code>， 查阅了OpenGL与图形引擎的相关资料, </p>
<h2 id="BLOG整理文档学习方法"><a href="#BLOG整理文档学习方法" class="headerlink" title="BLOG整理文档学习方法"></a>BLOG整理文档学习方法</h2><p>从云风的书中偶得一段话，</p>
<p><code>学习新的技术，翻译一本相关的英语著作可以算是捷径。</code></p>
<blockquote>
<ul>
<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>
<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>
<li>即使对此有所了解，翻译后也能更上一层楼。</li>
<li>英语水平也会提高。</li>
</ul>
</blockquote>
<p><code>发现产生了一些共鸣。</code><br>其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了<code>&lt;&lt;grasshopper运算器手册&gt;&gt;</code>一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？</p>
<p>之二是石老师推荐学生翻译<code>&lt;&lt;Form Space &amp; Order&gt;&gt;, &lt;&lt;Parten Language&gt;&gt;, &lt;&lt;A New Kind of Science&gt;&gt;</code>等书来学习数字化技术。</p>
<p>我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。</p>
<h2 id="图形学学习"><a href="#图形学学习" class="headerlink" title="图形学学习"></a>图形学学习</h2><p>另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：</p>
<blockquote>
<ul>
<li>图形学是研究用计算机如果画出一个图像的学科。</li>
<li>OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。</li>
<li>他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。</li>
<li>但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。</li>
</ul>
</blockquote>
<p>下面是摘自 <span style="color:red"><strong>Milo Yip</strong></span> 叶神在<a href="https://www.zhihu.com/question/24786878" target="_blank" rel="noopener">知乎</a>上的回答，要借鉴这个学习轨迹, 并以此勉励自己：</p>
<p><code>如何开始用 C++ 写一个光栅化渲染器？</code></p>
<p><strong>Milo Yip</strong><br>计算机图形学、编程、C++ 等 7 个话题的优秀回答者<br>228 人赞同了该回答<br>@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。</p>
<p>首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。</p>
<p>如果我们从图形学的历史进程来学习，可以这样做练习：</p>
<p>2D部分：</p>
<blockquote>
<p>1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）<br>2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）<br>3, 2D直线的剪切算法（见Line clipping）<br>4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。<br>5, 光栅化简单／复杂多边形<br>3D部分：<br>1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。<br>2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型<br>3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。<br>改为使用深度缓冲。<br>4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。<br>5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。<br>6, 通过顶点法线插值，实现Phong shading。<br>7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2017/12/28/dsacpp/01-D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/dsacpp/01-D/" itemprop="url">邓俊辉<<数据结构>>-公开课-01-D</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T11:14:53+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="color:blue"><em>我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.</em></span></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>运用DSA</p>
<p>算法分析的两个任务</p>
<blockquote>
<ul>
<li>正确性(不变性 * 单调性)</li>
<li>复杂度增长速度表格</li>
</ul>
</blockquote>
<p>C++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当<br>  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏<br>  迭代循环:for(), while()..   // 本质上 “if+goto”<br>  调用+递归                   // 本质上也是 “goto”</p>
<p>复杂度分析方法:</p>
<blockquote>
<ol>
<li>迭代: 级数求和</li>
<li>递归: 递归跟踪 + 递推方程<br>猜测 + 验证</li>
</ol>
</blockquote>
<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="算术级数：与末项平方同阶"><a href="#算术级数：与末项平方同阶" class="headerlink" title="算术级数：与末项平方同阶"></a>算术级数：与<strong>末项平方</strong>同阶</h2><h2 id="幂方级数：比幂次高出一阶"><a href="#幂方级数：比幂次高出一阶" class="headerlink" title="幂方级数：比幂次高出一阶"></a>幂方级数：比幂次高出一阶</h2><h2 id="几何级数（a-gt-1）-与末项同阶"><a href="#几何级数（a-gt-1）-与末项同阶" class="headerlink" title="几何级数（a &gt; 1）:与末项同阶"></a>几何级数（a &gt; 1）:与末项同阶</h2><h2 id="收敛级数-O-1"><a href="#收敛级数-O-1" class="headerlink" title="收敛级数:O(1)"></a>收敛级数:O(1)</h2><h2 id="未必收敛，但长度有限"><a href="#未必收敛，但长度有限" class="headerlink" title="未必收敛，但长度有限"></a>未必收敛，但长度有限</h2><p>h(n) = 1 + 1/2 + 1/3 + … + 1/n = O(logn)            // 调和级数<br>log1 + log2 + log3 + … + logn = log(n!) = O(nlogn)  // 对数级数</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><code>&lt;&lt;Concrete Math&gt;&gt;</code> 具体数学</p>
<h1 id="循环-vs-级数"><a href="#循环-vs-级数" class="headerlink" title="循环 vs 级数"></a>循环 vs 级数</h1><h2 id="没有耦合的二层循环"><a href="#没有耦合的二层循环" class="headerlink" title="没有耦合的二层循环"></a>没有耦合的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数:  n * n = O(n^2)<br>等效：矩形被填充的过程，时间复杂度等于矩形面积。</p>
<h2 id="耦合的二层循环"><a href="#耦合的二层循环" class="headerlink" title="耦合的二层循环"></a>耦合的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数: n(n-1) / 2 = O(n^2)<br>等效：三角形被填充，复杂度等于矩形面积。</p>
<h2 id="递增不为1的二层循环"><a href="#递增不为1的二层循环" class="headerlink" title="递增不为1的二层循环"></a>递增不为1的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j += <span class="number">2013</span>)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数：O(n^2)</p>
<h2 id="外循环左移一位-加倍"><a href="#外循环左移一位-加倍" class="headerlink" title="外循环左移一位(加倍)"></a>外循环左移一位(加倍)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    O1peration(i, j);</span><br></pre></td></tr></table></figure>
<p>几何级数：O(n)     // ??</p>
<h2 id="更复杂的实例"><a href="#更复杂的实例" class="headerlink" title="更复杂的实例"></a>更复杂的实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;  i; j += j)</span><br><span class="line">    O1peration(i, j);</span><br></pre></td></tr></table></figure>
<h2 id="习题解析"><a href="#习题解析" class="headerlink" title="习题解析"></a>习题解析</h2><h1 id="取非极端元素、冒泡排序"><a href="#取非极端元素、冒泡排序" class="headerlink" title="取非极端元素、冒泡排序"></a>取非极端元素、冒泡排序</h1><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>算法： </p>
<blockquote>
<p>1, 从S中取出三个元素{x, y, z}<br>2, 确定并排除其中的最小值和最大值<br>3, 输出剩下的元素z</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinaryElements</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从n &gt;= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”</span></span><br><span class="line">  <span class="comment">// 先比较a,b;再确定c对于(a,b)区间的关系</span></span><br><span class="line">  <span class="keyword">int</span> a = A[<span class="number">0</span>], b = A[<span class="number">1</span>], c = A[<span class="number">2</span>];    <span class="comment">// 从特定单元读取元素O(3)</span></span><br><span class="line">  <span class="comment">// 统一成区间(a, b), 用于c对其判断</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c &lt; a) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; b) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  <span class="comment">// return 输出非极端数O(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// =======================================</span></span><br><span class="line">  <span class="comment">// T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论:无论输入规模有多大，所需执行该算法的执行时间都不变。</p>
<h2 id="起泡排序问题"><a href="#起泡排序问题" class="headerlink" title="起泡排序问题"></a>起泡排序问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;  <span class="comment">// 自左向右逐对检查[0,n)各相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> (A[i<span class="number">-1</span>] &gt; A[i]) &#123;         <span class="comment">// 若逆序,则</span></span><br><span class="line">        swap(&amp;A[i<span class="number">-1</span>], &amp;A[i]);      <span class="comment">// 令其交换位置</span></span><br><span class="line">        sorted = <span class="literal">false</span>;            <span class="comment">// 消除全局有序标记</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>不变性：经k轮扫描交换后，最大的k个元素必然就位<br>单调性：经k轮扫描交换后，问题的规模缩减至n-k<br>正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案</p>
<p>基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性</p>
<h1 id="封底估计-Back-Of-The-Envelope-Calculation"><a href="#封底估计-Back-Of-The-Envelope-Calculation" class="headerlink" title="封底估计 Back-Of-The-Envelope Calculation"></a>封底估计 Back-Of-The-Envelope Calculation</h1><p>不需要工具</p>
<p>787km 占据整个周长的1/50 =&gt; 整个周长4wkm</p>
<p>抓住问题的主要方面，简洁得出总体规律</p>
<p>在复杂度分析中，对象是时间。</p>
<h1 id="封底估计实例"><a href="#封底估计实例" class="headerlink" title="封底估计实例"></a>封底估计实例</h1><blockquote>
<ul>
<li>一天: = 24hr <em> 60min </em> 60sec = 25 * 4000 = 10^5 sec</li>
<li>一生: = 1世纪 = 100yr <em> 365 = 3 </em> 10^4 = 3 * 10^9 sec</li>
<li>“50年” = 1.6 * 10^9 sec</li>
<li>三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec</li>
<li>宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec<br>三生三世是10^10s<br>三生三世中的一天，相当于在一天中的1s<br>整个宇宙中的三生三世，就是在三生三世中的0.1s</li>
</ul>
</blockquote>
<p>1亿 = 10^9</p>
<p>复杂度和浮点运算能力flops相除，能得到某算法的时间。</p>
<p>人口普查 n = 10^9<br>\=====================<br>普通PC 1Ghz 10^9 flops<br>Bullesort: O(n^2) ==&gt; (10^9)^2 = 10^18 </p>
<p>时间: 10^18 / 10^9  = 10^9<br>3<em>10^9 = 100yr, 10^9 = 30年<br>\=====================<br>普通PC  10^9 flops<br>Mergesort: O(n\</em>logn) =&gt; (10^9)*log(10^9) = 30 * 10^9</p>
<p>时间; 30 * 10^9 / 10^9 = 30s<br>\=====================<br>天河1A 10^15 flops<br>Bullesort:</p>
<p>时间:20min: 10^3s<br>\=====================</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2017/12/27/gitignore-invalid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/27/gitignore-invalid/" itemprop="url">gitignore-invalid</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-27T08:55:27+08:00">
                2017-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/hello-triangle-three-execises/" itemprop="url">OpenGL绘制三角形附练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T14:56:13+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码已托管在<a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started" target="_blank" rel="noopener">/timtingwei/LearnOpenGL</a></p>
<h1 id="图形管线渲染有哪几个阶段？"><a href="#图形管线渲染有哪几个阶段？" class="headerlink" title="图形管线渲染有哪几个阶段？"></a>图形管线渲染有哪几个阶段？</h1><p>顶点数据(Vertex data[])  -&gt;</p>
<blockquote>
<p>1, <strong>顶点着色器</strong>(Vertex Shader) -&gt;<br>2, 形状(图元)装配(Shape Assembly) -&gt;<br>3, <strong>几何着色器</strong>(Geometry Shader) -&gt;<br>4, 光栅化(Rasterization) -&gt;<br>5, <strong>片段着色器</strong>(Fragment Shader) -&gt;<br>6, 测试与混合(Test And Blending)</p>
</blockquote>
<p>三个着色器可以自己定义。</p>
<p><strong>顶点数据(Vertex data)：</strong></p>
<blockquote>
<ul>
<li>Vertex是一个3D坐标的集合</li>
<li>Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color</li>
</ul>
</blockquote>
<p><strong>顶点着色器(Vertex Shader)：</strong></p>
<blockquote>
<ul>
<li>把3D坐标转换成另外一种3D坐标</li>
<li>允许对Vertex Attribute做基本处理</li>
</ul>
</blockquote>
<p><strong>片段着色器(Fragment Shader)：</strong></p>
<blockquote>
<ul>
<li>计算一个像素最终的颜色</li>
<li>着色器包含3D场景数据(光照，阴影，光的颜色)</li>
</ul>
</blockquote>
<p><strong>Alpha测试和混合(Blending):</strong></p>
<blockquote>
<ul>
<li>测试深度，反应前后。</li>
<li>检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)</li>
</ul>
</blockquote>
<p>补充: 图元(Primitive):</p>
<blockquote>
<ul>
<li>任何一个绘制指令的调用，都把图元传递给OpenGL。</li>
<li>如GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</li>
</ul>
</blockquote>
<h1 id="绘制绘制三角形"><a href="#绘制绘制三角形" class="headerlink" title="绘制绘制三角形"></a>绘制绘制三角形</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>使用GLSL(OpenGL Shading Language)编写顶点着色器<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core          <span class="comment">// 每个着色器起始于版本声明, core代表核心模式</span></span></span><br><span class="line"></span><br><span class="line">layout (location=<span class="number">0</span>) in vec3 aPos;      <span class="comment">// 设定输入变量的位置值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么需要<strong>layout (location=0)</strong>设定位置值？</p>
<blockquote>
<ul>
<li><strong>glVertexAttributPointer</strong>函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。</li>
</ul>
</blockquote>
<p>相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，<a href="https://timtingwei.github.io">着色器中</a>讲解</p>
<h2 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h2><p>编写着色器源码后，</p>
<blockquote>
<p>1, 先创建着色器对象;<br>2, 再把源码附加到着色器对象上;<br>3, 编译并检查</p>
</blockquote>
<p><strong>1, 创建顶点着色器对象</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                         <span class="comment">// ID引用</span></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);   <span class="comment">// 传递着色器类型参数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2, 附源码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>glShaderSource</strong>函数的几个参数：</p>
<blockquote>
<p>0, 着色器对象<br>1, 传递的源码字符数量<br>2, 顶点着色器的真正源码<br>3, 先设置为NULL</p>
</blockquote>
<p><strong>3, 编译</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// 检查编译是否成功</span></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="comment">// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印</span></span><br><span class="line"><span class="keyword">if</span> &#123;!success&#125; &#123;</span><br><span class="line">  glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>同理顶点着色器，编写着色器源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FragColor =  vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量</p>
<h2 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h2><p>1, 创建对象<br>2, 附加源码<br>3, 编译并检查</p>
<p>自己重新写一遍, 并检查错误<br>1, 创建对象尝试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">glCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">glCreateShader(GL_FRAGMENT_SHADER);     <span class="comment">// DE<span class="doctag">BUG:</span>:不需要用着色器对象作为函数的参数，</span></span><br></pre></td></tr></table></figure></p>
<p>查阅<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" target="_blank" rel="noopener">khronos.org - glCreateShader</a></p>
<blockquote>
<ul>
<li>Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.<br>会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。</li>
</ul>
</blockquote>
<p>2, 附源码尝试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(<span class="number">1</span>, fragmentShader, fragmentSource, <span class="literal">NULL</span>)   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">// DE<span class="doctag">BUG:</span>:交换参数位置</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>着色器对象</li>
<li>传递源码字符的数量</li>
</ol>
</blockquote>
<p>3, 尝试编译<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> success;    <span class="comment">// ERROR</span></span><br><span class="line">glCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* infoLog[<span class="number">512</span>];                                <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="comment">// 失败把报错内容储存再infoLog中输出</span></span><br><span class="line">  glGetShaderinfoLog(fragmentShader, &amp;success, &amp;infoLog);   <span class="comment">// ERROR</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPILE::ERROR::FRAGEMENT::SHADER"</span> </span><br><span class="line">            &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glCompileShader(fragmentShader);     <span class="comment">// DE<span class="doctag">BUG:</span>:只要着色器对象一个参数</span></span><br><span class="line"><span class="keyword">int</span> success;                         <span class="comment">// DE<span class="doctag">BUG:</span>: success是一个int类型</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];                   <span class="comment">// DE<span class="doctag">BUG:</span>: char 并非 unsigned cha*</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);   <span class="comment">// DE<span class="doctag">BUG:</span>:获取success在先，才能对success做判断</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="comment">// 失败输出</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建着色器程序"><a href="#创建着色器程序" class="headerlink" title="创建着色器程序"></a>创建着色器程序</h2><p>绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure>
<h2 id="链接着色器对象"><a href="#链接着色器对象" class="headerlink" title="链接着色器对象"></a>链接着色器对象</h2><p>两个着色器对象要链接。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure></p>
<h2 id="编译着色程序"><a href="#编译着色程序" class="headerlink" title="编译着色程序"></a>编译着色程序</h2><p>与之前的着色器编译原理相同，只是调用函数和参数变量改变了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。</p>
<h2 id="删除着色器"><a href="#删除着色器" class="headerlink" title="删除着色器"></a>删除着色器</h2><p>完成以上几步后不要忘记删除着色器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure></p>
<h2 id="输入顶点以及索引"><a href="#输入顶点以及索引" class="headerlink" title="输入顶点以及索引"></a>输入顶点以及索引</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点输入</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>赋值array的时候, 不要忘记{};</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">GLuint indices[] = &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>                <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="comment">// ...                 // 可根据vertices数组, 建立多组索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="创建和绑定顶点数组对象-VAO"><a href="#创建和绑定顶点数组对象-VAO" class="headerlink" title="创建和绑定顶点数组对象(VAO)"></a><strong>创建和绑定顶点数组对象(VAO)</strong></h2><p>VAO = Vertex Array Object</p>
<p>功能:</p>
<blockquote>
<ul>
<li>随后的顶点属性调用都会储存在这个VAO之中。</li>
<li>使得在不同顶点数据和属性设置之间切换变得简单。</li>
</ul>
</blockquote>
<p><strong>存储内容</strong>:</p>
<blockquote>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
</blockquote>
<p>使用注意:</p>
<blockquote>
<ul>
<li><strong>先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针</strong></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);   <span class="comment">// 创建VAO对象</span></span><br><span class="line">glBindVertexArray(VAO);       <span class="comment">// 绑定顶点数组对象</span></span><br></pre></td></tr></table></figure>
<h2 id="创建和绑定顶点缓冲对象-VBO"><a href="#创建和绑定顶点缓冲对象-VBO" class="headerlink" title="创建和绑定顶点缓冲对象(VBO)"></a><strong>创建和绑定顶点缓冲对象(VBO)</strong></h2><p>OpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。</p>
<p>作用:</p>
<blockquote>
<ul>
<li>通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。</li>
<li>一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。</li>
</ul>
</blockquote>
<p><span style="color:blue"><em>我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VBO;</span><br><span class="line">glGenBuffer(<span class="number">1</span>, &amp;VBO);           <span class="comment">// 创建</span></span><br><span class="line"><span class="comment">// 把顶点数组复制到缓存中提供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></p>
<h2 id="索引缓冲对象-EBO"><a href="#索引缓冲对象-EBO" class="headerlink" title="索引缓冲对象(EBO)"></a><strong>索引缓冲对象(EBO)</strong></h2><p>可以创建不同的索引数组，而使用同一个顶点数组。如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint EBO;</span><br><span class="line">glGenBuffer(<span class="number">1</span>, &amp;EBO);                <span class="comment">// 创建</span></span><br><span class="line"><span class="comment">// 把顶点索引复制到缓存中提供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h2 id="设置顶点属性"><a href="#设置顶点属性" class="headerlink" title="设置顶点属性"></a><strong>设置顶点属性</strong></h2><p><img src="/images/vertex_attribute_pointer.png" alt="vertex_attribute_pointer">    </p>
<blockquote>
<ul>
<li>位置数据被储存为32位(4字节)浮点值 =&gt; siezeof(flaot) = 4 types = 32bits</li>
<li>每个位置包含3个这样的值</li>
<li>没有空隙, 紧密排列。</li>
<li>数据中的第一个值再缓冲开始位置。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexattribArray(<span class="number">0</span>);    <span class="comment">// 开启位置为0的顶点属性</span></span><br></pre></td></tr></table></figure>
<p><strong>glVertexAttribPointer参数</strong></p>
<blockquote>
<p>1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style="color:red"><strong>layout (location=0) in vec3 xx</strong></span> 吗？<br>2, 顶点属性的大小。 vec3 =&gt; 3个值组成<br>3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)<br>4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;<br>5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。</p>
<ol>
<li>偏移量。位置数据在数组开头就设置成0</li>
</ol>
</blockquote>
<p>顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。<br>输入的参数顶点属性的位置值。<span style="color:red"><strong>layout (location=0) in vec3 xx</strong></span> </p>
<h2 id="绘制图元"><a href="#绘制图元" class="headerlink" title="绘制图元"></a>绘制图元</h2><p><code>在主循环内部绘制图元。</code></p>
<p>1, 激活程序对象<br>2, 绑定缓存对象<br>3, 绘制<br>4, 解绑缓存对象</p>
<p><strong>绘制两种方式：</strong><br>glDrawArrays();</p>
<blockquote>
<ul>
<li>使用当前绑定的顶点缓存对象进行绘制<br>glDrawElements()</li>
<li>使用当前绑定的索引缓冲对象中的索引进行绘制</li>
</ul>
</blockquote>
<p>第一种，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 使用当前绑定的顶点缓存对象进行绘制</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 解绑缓存对象</span></span><br><span class="line">glBindVertArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二种,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定顶点数组对象 </span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 使用当前绑定的索引缓冲对象中的索引进行绘制</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 解绑缓存对象</span></span><br><span class="line">glBindVertArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><span style="color:blue"><em>VAO有种结合VBO+EBO的意思</em></span><br><strong>再回顾一遍它的存储内容</strong>:</p>
<blockquote>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
</blockquote>
<p><code>退出循环后删除对象，释放缓存</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glDeleteVertexArray(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，</p>
<blockquote>
<p>1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？<br>2, 顶点着色器和片段着色器之间的关系？<br>3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？</p>
</blockquote>
<h2 id="1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形"><a href="#1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形" class="headerlink" title="1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形"></a><strong>1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形</strong></h2><p><strong>glDrawArrays();</strong><br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先设置顶点数组</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个triangle</span></span><br><span class="line">    <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,    <span class="comment">// 连接处</span></span><br><span class="line">    <span class="comment">// 第二个triangle</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左上角</span></span><br><span class="line">    <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>     <span class="comment">// 连接处</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);  <span class="comment">// 从顶点数组索引0开始依次绘制6个顶点</span></span><br></pre></td></tr></table></figure>
<p><strong>glDrawElements();</strong><br>根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点输入</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLuint indices[] = &#123;     <span class="comment">// 索引从0开始</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,               <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>                <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还需要在绑定VAO后绑定VBO和EBO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)  <span class="comment">// 索引数组绘制6个顶点</span></span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><em>这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。</em></span></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp" target="_blank" rel="noopener">练习1源码 - github</a></p>
<hr>
<h2 id="2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO"><a href="#2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO" class="headerlink" title="2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO"></a><strong>2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO</strong></h2><p>// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。</p>
<p><strong>glGenBuffers</strong>(GLsizei n,<br>                GLuint<em> buffers);<br>生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在<em>*Buffers</em></em>中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。</p>
<p><strong>glGenVertexArrays</strong>(GLsizei n,<br>                      GLuint* arrays);<br>返回n个顶点数组对象名字，存储到arrays指针中。</p>
<p><strong>glBindBuffer(GLenum target,<br>               GLuint buffer);</strong><br>绑定一个已经命名的缓存对象。</p>
<p><em>target</em><br><code>----------------------------------------------------------</code><br><code>GL_ARRAY_BUFFER</code>            |     顶点属性<br><code>GL_ELEMENT_ARRAY_BUFFER</code>    |     顶点数组索引<br><code>GL_TEXTURE_BUFFER</code>          |     纹理数据缓存<br><code>GL_UNIFORM_BUFFER</code>          |     Uniform块存储<br><code>----------------------------------------------------------</code></p>
<p><em>buffer</em><br>    缓存对象的名字</p>
<p><strong>glBindVertexArray</strong>(GLuint array);<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>
<p><strong>glBufferData</strong>(GLenum target<br>                 GLsizeiptr size<br>                 const GLvoid * data<br>                 GLenum usage);<br>创建或者初始化一个缓冲对象的数据的储存。</p>
<p><em>target</em><br>     这里是GL_ARRAY_BUFFER</p>
<p><em>size</em><br>   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到</p>
<p><em>data</em><br>   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝</p>
<p><em>usage</em><br>    储存好的数据的使用模式。 <code>GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</code>有这么几种。这里只用于静态绘制</p>
<p><strong>glVertexAttribPointer</strong>(GLuint index,<br>                      GLint size,<br>                       GLenum type,<br>                       GLboolean normalized,<br>                       GLsizei stride,<br>                       const GLvoid * pointer);<br>上面有所解释。现在就够用了。</p>
<p><strong>glEnableVertexAttribArray</strong>(GLuint index);<br>启用设置好的顶点属性数组，<br><em>glDisableVertexAttribArray</em>(GLuint index);<br>关闭</p>
<p><em>index</em><br>   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.</p>
<p><strong>glBindVertexArray</strong>();<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>
<p><strong>glDrawArrays</strong>(GLenum mode,<br>               GLint first,<br>               GLsizei count);<br>练习1中已经出现过，调用之前先要绑定Array;<br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>
<p>代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入两个三角形各自的顶点数组</span></span><br><span class="line">GLfloat firstTriangleVertices[] = &#123;</span><br><span class="line">  <span class="comment">// 第一个triangle</span></span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.1f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.3f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLfloat secondTriangleVertices[] = &#123;</span><br><span class="line">  <span class="comment">// 第二个triangle</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.1f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.3f</span>, <span class="number">0.0f</span>     <span class="comment">// 右下角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>1, 共同以VAOs和VBOs以数组创建<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br></pre></td></tr></table></figure></p>
<p>2, 单独绑定, 复制, 设置顶点属性<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangleVertices),</span><br><span class="line">               firstTriangleVertices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class="line">                        <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理VAOs[1], VBOs[1]..</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangleVertices),</span><br><span class="line">               secondTriangleVertices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class="line">                        <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>3, 单独绘制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==========firstTriangle=========</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// ==========secondTriangle========</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2" target="_blank" rel="noopener">练习2源码</a></p>
<h2 id="3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色"><a href="#3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色" class="headerlink" title="3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色"></a><strong>3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色</strong></h2><p>之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。</p>
<p>// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组<br>// 注意：片段着色器不能放在数组里。<br>// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。</p>
<p>1, GLSL编写橙色和黄色着色器代码<br>2，分别附着，编译，检查着色器，并attach到不同的program<br>3, 用不同的program进行draw</p>
<p><strong>1, GLSL编写橙色和黄色着色器代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段着色器0</span></span><br><span class="line"><span class="keyword">const</span> GLchar* fragmentShaderSource0 = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"out vec4 color;\n"</span></span><br><span class="line">    <span class="string">"void main() &#123;\n"</span></span><br><span class="line">    <span class="string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>   <span class="comment">// orange</span></span><br><span class="line">    <span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器1</span></span><br><span class="line"><span class="keyword">const</span> GLchar* fragmentShaderSource1 = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"out vec4 color;\n"</span></span><br><span class="line">    <span class="string">"void main() &#123;\n"</span></span><br><span class="line">    <span class="string">"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span>   <span class="comment">// yellow</span></span><br><span class="line">    <span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>2，分别附着，编译，检查着色器，并attach到不同的program</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建片段着色器</span></span><br><span class="line">  GLuint fragmentShaderOrange;</span><br><span class="line">  GLuint fragmentShaderYellow;</span><br><span class="line">  GLuint shaderProgramOrange;</span><br><span class="line">  GLuint shaderProgramYellow;</span><br><span class="line">  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  shaderProgramOrange = glCreateProgram();</span><br><span class="line">  shaderProgramYellow = glCreateProgram();</span><br><span class="line">  <span class="comment">// ===========编译第一个片段着色器===================</span></span><br><span class="line">  <span class="comment">// 源码附加到着色器对象上</span></span><br><span class="line">  glShaderSource(fragmentShaderOrange, <span class="number">1</span>, &amp;fragmentShaderSource0, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragmentShaderOrange);</span><br><span class="line">  <span class="comment">// 检测glComplieShader是否编译成功</span></span><br><span class="line">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ===========编译第二个片段黄色着色器===================</span></span><br><span class="line">  <span class="comment">// 源码附加到着色器对象上</span></span><br><span class="line">  glShaderSource(fragmentShaderYellow, <span class="number">1</span>, &amp;fragmentShaderSource1, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragmentShaderYellow);</span><br><span class="line">  <span class="comment">// 检测glComplieShader是否编译成功</span></span><br><span class="line">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把两个着色器对象链接到用来渲染的两个着色程序中</span></span><br><span class="line">  glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class="line">  <span class="comment">// =====连接第一个片段着色器=====</span></span><br><span class="line">  glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class="line">  glLinkProgram(shaderProgramOrange);</span><br><span class="line">  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgramOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// =====连接第二个片段着色器=====</span></span><br><span class="line">  glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class="line">  glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class="line">  glLinkProgram(shaderProgramYellow);</span><br><span class="line">  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgramYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除着色器</span></span><br><span class="line">  glDeleteShader(vertexShader);</span><br><span class="line">  glDeleteShader(fragmentShaderOrange);</span><br><span class="line">  glDeleteShader(fragmentShaderYellow);</span><br></pre></td></tr></table></figure></p>
<p><strong>3, 用不同的program进行draw</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =====激活程序对象绘制第一个triangle======</span></span><br><span class="line">glUseProgram(shaderProgramOrange);      <span class="comment">// 使用第一个片段着色器连接的program</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 从索引0开始依次绘制3个顶点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====激活程序对象绘制第二个triangle======</span></span><br><span class="line">glUseProgram(shaderProgramYellow);      <span class="comment">// 使用第二个片段着色器连接的program</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 从索引0开始依次绘制3个顶点</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3" target="_blank" rel="noopener">练习3源码</a></p>
<p>=======</p>
<p>refwebsite:<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好三角形 - learnopengl-CN</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mituh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/timtingwei" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/timtingwei/" target="_blank" title="douban">
                    
                      <i class="fa fa-fw fa-globe"></i>douban</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mituh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
