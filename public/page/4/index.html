<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="mituh&#39;s notes">
<meta property="og:url" content="https://timtingwei.github.io/page/4/index.html">
<meta property="og:site_name" content="mituh&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mituh&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timtingwei.github.io/page/4/"/>





  <title>mituh's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mituh's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/21/dsacpp/02-E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/dsacpp/02-E/" itemprop="url">02-E</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T22:36:05+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(e) 起泡排序</span><br><span class="line">为了使得向量有序, 要对向量进行排序。</span><br><span class="line"></span><br><span class="line"># 排序器, ADT 统一入口:</span><br><span class="line">	&gt;* 实现</span><br><span class="line">		====================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123;</span><br><span class="line">			int i = 1;</span><br><span class="line">			switch (i) &#123;</span><br><span class="line">				case 1: bubbleSort(lo, hi); break;     // 起泡排序</span><br><span class="line">				case 2: selectionSort(lo, hi); break;  // 选择排序(习题)</span><br><span class="line">				case 3: mergeSort(lo, hi); break;      // 归并排序</span><br><span class="line">				case 4: heapSort(lo, hi); break;       // 堆排序(ch 10)</span><br><span class="line">				default: quickSort(lo, hi); break;     // 快速排序(12)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 起泡排序</span><br><span class="line">	&gt;* 改进思路</span><br><span class="line">		未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。</span><br><span class="line">		在上一趟扫描中, 记录有序对</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/21/dsacpp/02-D4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/dsacpp/02-D4/" itemprop="url">02-D4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T14:05:05+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d4) 有序向量: 二分查找(改进)</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line"># 版本B, 改进思路:</span><br><span class="line">	&gt;* 左右转向成本平衡：</span><br><span class="line">		无论向左还是向右进行一次比较。</span><br><span class="line">	</span><br><span class="line">	&gt;* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半</span><br><span class="line">		1, e &lt;  x: e若存在则在左侧子区间S[lo, mi), 可递归深入</span><br><span class="line">		2, x &lt;= e: e若存在则在右侧子区间S[mi, hi), 可递归深入</span><br><span class="line">		只有当hi - lo = 1时, 判断元素是否命中。</span><br><span class="line">		</span><br><span class="line"># 实现:</span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		=========================  source code =======================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			// 二分平衡查找算法</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;          // 轴点为中点</span><br><span class="line">				if (e &lt; elem[mi]) hi = mi;        // 深入左区间</span><br><span class="line">				else if (elem[mi] &lt;= e) lo = mi;  // 深入右区间</span><br><span class="line">			&#125;</span><br><span class="line">			// hi - lo == 1, 判断当前元素是否命中</span><br><span class="line">			if (e == elem[lo]) return lo;</span><br><span class="line">			else               return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		思路上无问题, 但代码可以简化。</span><br><span class="line">		</span><br><span class="line">	&gt;* 更为简洁的写法</span><br><span class="line">		=====</span><br><span class="line">	    template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">			int mi = (lo + hi) &gt;&gt; 1;               // 轴点为中点</span><br><span class="line">			(e &lt; elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入</span><br><span class="line">			&#125;    // 退出循环时, 区间长度1, elem[lo]为有效元素</span><br><span class="line">			return (e == elem[lo])? lo: -1;</span><br><span class="line">		&#125;        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		====</span><br><span class="line">		</span><br><span class="line">		1, 两种情况if...else 用以下代替</span><br><span class="line">			(cond)? expr1 : expr2;</span><br><span class="line">		2, 在其中使用返回语句</span><br><span class="line">			(cond) ? return expr1 : return expr2;    // ERROR!!</span><br><span class="line">			return (cond) ? expr1 : expr2;           // Right!!</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 语义约定</span><br><span class="line">	&gt;* 为什么要语义约定?</span><br><span class="line">		便于其他高阶操作的调用。</span><br><span class="line">		v.insert(1 + search(e, lo, hi), e);</span><br><span class="line">			：在找到元素索引的下个索引处插入。</span><br><span class="line">	</span><br><span class="line">	&gt;* 思路</span><br><span class="line">		1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)</span><br><span class="line">		2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])</span><br><span class="line">	</span><br><span class="line">	&gt;* 实现, 版本C</span><br><span class="line">		&gt;* 我的尝试</span><br><span class="line">		将原来的 return (e == elem[lo]) ? lo : -1; 改为:</span><br><span class="line">		============= source code ============================</span><br><span class="line">		if (e == elem[lo]) &#123;  // 存在匹配</span><br><span class="line">			while (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩</span><br><span class="line">			return lo;</span><br><span class="line">		&#125; else &#123;  // 无匹配</span><br><span class="line">			return (e &lt; elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩</span><br><span class="line">		&#125;</span><br><span class="line">		=======================================================</span><br><span class="line">		一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩</span><br><span class="line">		</span><br><span class="line">		&gt;* 更优解</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;  // 区间缩短至0</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;                   // 轴点为中点</span><br><span class="line">				(e &lt; elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)</span><br><span class="line">			&#125;    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素</span><br><span class="line">			return --lo;    // 故lo-1 为不大于e的最大秩</span><br><span class="line">		&#125;      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 更优解实现分析</span><br><span class="line">		&gt;* 差别</span><br><span class="line">			1, 循环结束区间宽度0, 而非1</span><br><span class="line">			2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?</span><br><span class="line">			3, 无论成功与否, 返回秩序严格符合定义的语义接口。</span><br><span class="line">			4, 和我的实现比起来, 无需多余的while和if判断</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 版本C, 正确性:</span><br><span class="line">	&gt;* 不变性:</span><br><span class="line">		A[0, lo) &lt;= e &lt; A[hi, n)          // A[hi] 总是大于e的最小者</span><br><span class="line">	&gt;* 初始</span><br><span class="line">		lo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立</span><br><span class="line">	&gt;* 数学归纳两种情况,</span><br><span class="line">		这两种情况不是很清楚。以后可以回过头来看看。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/20/dsacpp/02-D3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/20/dsacpp/02-D3/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-20T09:33:42+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d3) 有序向量: Fibonacci查找</span><br><span class="line"></span><br><span class="line">1, 思路</span><br><span class="line">	向左侧1次, 向右两次。</span><br><span class="line">	表面平衡, 内部极大不平衡。</span><br><span class="line">	比较次数不等, 递归深度却相等。</span><br><span class="line">	</span><br><span class="line">	左侧更深, 右侧更浅。</span><br><span class="line">	递归深度不平衡, 对转向成本不同进行补偿。</span><br><span class="line">	</span><br><span class="line">	若 n = fib(k) - 1, 则mi = fib(k-1) - 1</span><br><span class="line">	前向量fib(k-1) - 1, 后向量fib(k-2) - 1</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2, 实现</span><br><span class="line">	&gt;* 我的尝试, 定义fib类</span><br><span class="line">		====== source code ====</span><br><span class="line">		// ERROR:my test fib</span><br><span class="line">		// 定义fibonacci相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int* _fib_lst; int _size;</span><br><span class="line">			public:</span><br><span class="line">			// 构造函数</span><br><span class="line">			explicit Fib(const int n) : _size(n) &#123;</span><br><span class="line">				emptyFib(n);</span><br><span class="line">				fib(n-1, _fib_lst);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 将数列置空</span><br><span class="line">			void emptyFib(const int n) &#123;</span><br><span class="line">				// 初始化0</span><br><span class="line">				for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">				_fib_lst[i] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 生成fib数列</span><br><span class="line">			int fib(const int n, int* _fib_lst) &#123;</span><br><span class="line">				if (_fib_lst[n] != 0) &#123;</span><br><span class="line">					return _fib_lst[n];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (n &lt; 2) &#123;_fib_lst[n] = n;&#125; else &#123;</span><br><span class="line">						_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);</span><br><span class="line">						return _fib_lst[n];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 获得数列中某一索引的值</span><br><span class="line">			int&amp; get(const int&amp; n) const &#123;return _fib_lst[n];&#125;</span><br><span class="line">			</span><br><span class="line">			int index(const int v) const &#123;</span><br><span class="line">				// 获得某一值在fib数列对应的索引</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					if (v == _fib_lst[i]) return i;</span><br><span class="line">					if (v &lt; _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;    // 在扫描过程中没找到, 返回失败</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 打印数列</span><br><span class="line">			void printFib() const &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;---- print fib series -----\n&quot;;</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					std::cout &lt;&lt; i &lt;&lt;&quot;: _fib_lst[i]&quot;</span><br><span class="line">						&lt;&lt; _fib_lst[i] &lt;&lt; std::endl;	</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; &quot;_size = &quot; &lt;&lt; _size &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		==================================================</span><br><span class="line">		运行总是溢出, 找不到出错位置。</span><br><span class="line">		考虑先right, 后fast</span><br><span class="line"></span><br><span class="line">	&gt;* 根据课件的修改</span><br><span class="line">		=================== source code ==========================</span><br><span class="line">		// 定义fib相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int _size;</span><br><span class="line">			</span><br><span class="line">			public:</span><br><span class="line">			explicit Fib(int n) : _size(n) &#123;&#125;</span><br><span class="line">			int createFib(int n) &#123;</span><br><span class="line">				return (2 &gt; n) ? n: createFib(n-1) + createFib(n-2);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得当前项</span><br><span class="line">			int get() &#123;</span><br><span class="line">				int result = createFib(_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得前一项</span><br><span class="line">			int prev() &#123;</span><br><span class="line">				if (0 &lt; _size - 1) &#123;</span><br><span class="line">				int result = createFib(--_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		===========================================================</span><br><span class="line">		先使用了低效的fib生成函数, 且不储存在一个list中。</span><br><span class="line">		</span><br><span class="line">		以及查找函数</span><br><span class="line">		======================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			Fib fib(hi - lo);</span><br><span class="line">			while (lo &lt; hi) &#123;</span><br><span class="line">				while ((hi - lo) &lt; fib.get()) fib.prev();</span><br><span class="line">				int priv = lo + fib.get() - 1;</span><br><span class="line">				if      (e &lt; elem[priv]) hi = priv;</span><br><span class="line">				else if (elem[priv] &lt; e) lo = priv + 1;</span><br><span class="line">				else                     return priv;</span><br><span class="line">			&#125;</span><br><span class="line">		    return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		本质是选择轴点不同。</span><br><span class="line">	&gt;* 改进fib类</span><br><span class="line">		用动态规划求解fib数列中的某一项</span><br><span class="line">		================= source code ==============================</span><br><span class="line">		int createFib(int n) &#123;</span><br><span class="line">			int f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;</span><br><span class="line">			if (n &lt; 2) &#123;int r = (n) ? g : f; return r;&#125;</span><br><span class="line">			while (0 &lt; n--) &#123;</span><br><span class="line">				g = g + f;</span><br><span class="line">				f = g - f;</span><br><span class="line">			&#125;</span><br><span class="line">			return g;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">3, 查找最优性</span><br><span class="line">	&gt;* 通用策略: </span><br><span class="line">		对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 &lt;= lambda &lt; 1</span><br><span class="line">		二分0.5, fibonacci对应lambda  = 0.6180339</span><br><span class="line">	&gt;* 递推式和微积分求极值</span><br><span class="line">		这个...</span><br><span class="line">		</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">4, 总结</span><br><span class="line">	这个算法花费很长时间去实现, 原因如下：</span><br><span class="line">		1, 面向对象不理解, 为什么定义fib类</span><br><span class="line">		2, 先选择了fast, not right</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/18/temp-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/temp-history/" itemprop="url">中建史考试笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T17:19:59+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目分配"><a href="#题目分配" class="headerlink" title="题目分配"></a>题目分配</h1><p>填空20*2 = 40<br>选择4<br>问答4<br>画图5</p>
<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-中国古代建筑的三种主要结构形式和特点-P4"><a href="#1-中国古代建筑的三种主要结构形式和特点-P4" class="headerlink" title="1, 中国古代建筑的三种主要结构形式和特点? P4"></a>1, 中国古代建筑的三种主要结构形式和特点? P4</h2><pre><code>1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头
2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁
3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。
</code></pre><h2 id="2-进行穿斗式与抬粱式木构架的优缺点比较-P5"><a href="#2-进行穿斗式与抬粱式木构架的优缺点比较-P5" class="headerlink" title="2, 进行穿斗式与抬粱式木构架的优缺点比较? P5"></a>2, 进行穿斗式与抬粱式木构架的优缺点比较? P5</h2><pre><code>穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。
</code></pre><h2 id="3-斗拱是由哪些构件组成的？每种构件的作用如何？P6"><a href="#3-斗拱是由哪些构件组成的？每种构件的作用如何？P6" class="headerlink" title="3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6"></a>3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6</h2><pre><code>a, 斗拱是由斗、拱、昂、翘、升组成的
b, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)
</code></pre><h2 id="4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19"><a href="#4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19" class="headerlink" title="4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19"></a>4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19</h2><pre><code>1, 类型：
    a, 干阑式
    b, 木骨泥墙
2, 实例
    a, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。
    b, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。
</code></pre><h2 id="5-中国古代建筑史上的主要著作"><a href="#5-中国古代建筑史上的主要著作" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="6-《考工记》匠人营国一段原文及如何理解？"><a href="#6-《考工记》匠人营国一段原文及如何理解？" class="headerlink" title="6, 《考工记》匠人营国一段原文及如何理解？"></a>6, 《考工记》匠人营国一段原文及如何理解？</h2><pre><code>原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)
理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）
</code></pre><h2 id="7-《工程做法》的内容和评价？"><a href="#7-《工程做法》的内容和评价？" class="headerlink" title="7, 《工程做法》的内容和评价？"></a>7, 《工程做法》的内容和评价？</h2><pre><code>内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。
 评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。
</code></pre><h2 id="8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？"><a href="#8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？" class="headerlink" title="8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？"></a>8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？</h2><pre><code>背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。
著书人：将作监 李诫
评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。
</code></pre><h2 id="9-北宋是城市结构由里坊制转向厢坊制的起点"><a href="#9-北宋是城市结构由里坊制转向厢坊制的起点" class="headerlink" title="9, 北宋是城市结构由里坊制转向厢坊制的起点"></a>9, 北宋是城市结构由里坊制转向厢坊制的起点</h2><pre><code>北宋城市结构和布局起了根本变化。
唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。
到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。
</code></pre><h2 id="10-宋的基本模数制度：材份制"><a href="#10-宋的基本模数制度：材份制" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折"><a href="#11-宋式殿堂的特点及屋面举折" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"><a href="#12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？" class="headerlink" title="12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"></a>12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？</h2><pre><code>云冈石窟, 龙门石窟
石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。
</code></pre><h2 id="13-唐代建筑的主要特点是什么？"><a href="#13-唐代建筑的主要特点是什么？" class="headerlink" title="13, 唐代建筑的主要特点是什么？"></a>13, 唐代建筑的主要特点是什么？</h2><pre><code>1, 规模宏大，规划严整
2, 建筑群 处理愈加成熟
3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化
4, 设计与施工水平提高
5, 砖石建筑发展
6, 建筑艺术真实成熟
</code></pre><h2 id="14-元代盛行的减柱法是什么意思？举例说明"><a href="#14-元代盛行的减柱法是什么意思？举例说明" class="headerlink" title="14, 元代盛行的减柱法是什么意思？举例说明"></a>14, 元代盛行的减柱法是什么意思？举例说明</h2><pre><code>减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。
元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。
举例：山西洪洞 广胜寺, 山西永济 永乐宫。
</code></pre><h2 id="15-进行明代建筑木构架与唐宋风格比较"><a href="#15-进行明代建筑木构架与唐宋风格比较" class="headerlink" title="15, 进行明代建筑木构架与唐宋风格比较"></a>15, 进行明代建筑木构架与唐宋风格比较</h2><pre><code>1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。
2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。
3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。
4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。
</code></pre><h2 id="16-明清北京城四圈城的名称是什么？"><a href="#16-明清北京城四圈城的名称是什么？" class="headerlink" title="16, 明清北京城四圈城的名称是什么？"></a>16, 明清北京城四圈城的名称是什么？</h2><pre><code>外城, 永定门
内城, 正阳门
皇城, 天安门
紫禁城, 午门
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就"><a href="#17-简述北京故宫的建筑艺术成就" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><h2 id="18-天坛总体布局及祭祀建筑特点"><a href="#18-天坛总体布局及祭祀建筑特点" class="headerlink" title="18, 天坛总体布局及祭祀建筑特点"></a>18, 天坛总体布局及祭祀建筑特点</h2><pre><code>设计特点:
1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)
2, 环境处理
    a, 建筑只占1/20, 融于绿色之中
    b, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近
3, 运用数字和色彩的象征
</code></pre><h2 id="19-佛塔的主要类型是什么？"><a href="#19-佛塔的主要类型是什么？" class="headerlink" title="19, 佛塔的主要类型是什么？"></a>19, 佛塔的主要类型是什么？</h2><pre><code>中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔
1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,
2, 单层塔，山东济南 隋代 神通寺 四门塔,
3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,
4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,
5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。
</code></pre><h2 id="20-简述平板枋（普拍枋）的位置和作用"><a href="#20-简述平板枋（普拍枋）的位置和作用" class="headerlink" title="20, 简述平板枋（普拍枋）的位置和作用"></a>20, 简述平板枋（普拍枋）的位置和作用</h2><pre><code>平板枋置于阑额之上, 可以承受斗拱。
</code></pre><h2 id="21-屋顶做法：收山、推山"><a href="#21-屋顶做法：收山、推山" class="headerlink" title="21, 屋顶做法：收山、推山"></a>21, 屋顶做法：收山、推山</h2><pre><code>推山：是庑殿建筑处理屋顶的一种特殊手法
收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。
</code></pre><h2 id="22-清式彩画常用的三大类是什么？"><a href="#22-清式彩画常用的三大类是什么？" class="headerlink" title="22, 清式彩画常用的三大类是什么？"></a>22, 清式彩画常用的三大类是什么？</h2><pre><code>和玺, 旋子, 苏式
</code></pre><h2 id="23-宋式柱网布局中分心槽是什么意思？"><a href="#23-宋式柱网布局中分心槽是什么意思？" class="headerlink" title="23, 宋式柱网布局中分心槽是什么意思？"></a>23, 宋式柱网布局中分心槽是什么意思？</h2><pre><code>以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。
</code></pre><h2 id="24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？"><a href="#24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？" class="headerlink" title="24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？"></a>24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？</h2><pre><code>外5, 内9;
金厢斗底槽。
</code></pre><h1 id="绘制简图题"><a href="#绘制简图题" class="headerlink" title="绘制简图题"></a>绘制简图题</h1><p>嵩岳寺塔平面和立面 P181 考<br>九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图<br>佛光寺大殿平立剖面 P156<br>晋祠圣母殿平立剖面<br>独乐寺观音阁剖面 P162<br>应县木塔平面、剖面 P176 考<br>北京天坛总平面图 P131<br>清式抬梁式七架无廊结构示意图 P297<br>宋式进深八椽屋的屋面举折做法示意图 P285</p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="5-中国古代建筑史上的主要著作-1"><a href="#5-中国古代建筑史上的主要著作-1" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="10-宋的基本模数制度：材份制-1"><a href="#10-宋的基本模数制度：材份制-1" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折-1"><a href="#11-宋式殿堂的特点及屋面举折-1" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就-1"><a href="#17-简述北京故宫的建筑艺术成就-1" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><hr>
<h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><h2 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h2><p>1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的<code>抬梁式</code>和<code>穿斗式</code>两种主要木结构已经形成。<br>2, 北宋初年浙东木匠<code>喻皓</code>著有《<code>木经</code>》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。<br>3, 北宋末年政府颁布的《营造法式》中规定，把<code>材</code>作为造屋的尺度标准，即将木构架建筑的用料尺寸分成<code>八</code> 等，按照屋宇的大小主次量屋用材。<br>4, 清式彩画分为<code>和玺彩画</code>、<code>旋子彩画</code>、<code>苏式彩画</code><br>5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧<code>推出</code>，从而使四条垂脊形成空间曲线，这种做法称为<code>推山</code> 。<br>6, 应县木塔外观<code>5</code> 层，内部结构层为<code>9层</code>木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>1, 隋大兴城的规划设计者为：（ A ）<br>    <code>A宇文凯</code> B郭守敬 C雷发达 D蒯祥<br>2, 北京故宫天安门前院落的形状为：（ D）<br>    A凹字形 B工字型 C“L型” <code>D“T字形”</code><br>3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）<br>    A八等 B九等 <code>C十一等</code> D十三等<br>4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）<br>    <code>A唐代</code> B宋代 C明代 D清代</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/16/cpp/cpp-notes-0006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/cpp/cpp-notes-0006/" itemprop="url">C++ Zero To One 0.006</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T22:30:14+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 局部变量的销毁顺序</span><br><span class="line">	================= source code ===============================</span><br><span class="line">	void f(int i) &#123;</span><br><span class="line">		Table aa(1);</span><br><span class="line">		Table bb(2);</span><br><span class="line">		if (i &gt; 0) &#123;</span><br><span class="line">			Table cc(3);</span><br><span class="line">		&#125;</span><br><span class="line">		Table dd(4);</span><br><span class="line">	&#125;</span><br><span class="line">	-------------- ./a.out ----------------</span><br><span class="line">	in Table() sz = 1</span><br><span class="line">	in Table() sz = 2</span><br><span class="line">	in Table() sz = 3</span><br><span class="line">	in ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class="line">	in Table() sz = 4</span><br><span class="line">	in ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class="line">	in ~Table() sz = 2</span><br><span class="line">	in ~Table() sz = 1</span><br><span class="line">	=============================================================</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, 构造函数复制</span><br><span class="line"></span><br><span class="line">	&gt;* 直接复制</span><br><span class="line">		======= source code ========</span><br><span class="line">		void h() &#123;</span><br><span class="line">			Table t1;</span><br><span class="line">			// Table t2 = t1;    // ERROR: 复制初始化</span><br><span class="line">			Table t3;</span><br><span class="line">			</span><br><span class="line">			// t3 = t2;          // ERROR: 复制赋值</span><br><span class="line">		&#125;</span><br><span class="line">		==============================</span><br><span class="line">		</span><br><span class="line">		t1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。</span><br><span class="line">		所导致结果是无意义的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&gt;* 清楚定义复制构造函数</span><br><span class="line">		================ source code =======================</span><br><span class="line">		Table::Table(const Table&amp; t) &#123;</span><br><span class="line">			p = new Name[sz = t.sz];</span><br><span class="line">			for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">				p[i] = t.p[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Table&amp; Table::operator=(const Table&amp; t) &#123;</span><br><span class="line">			if (this != &amp;t) &#123;         // 防止自复制</span><br><span class="line">				delete[] p;</span><br><span class="line">				p = new Name[sz = t.sz];</span><br><span class="line">				for (int i = 0; i &lt; sz; i++) &#123;p[i] = t.p[i];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		void f() &#123;</span><br><span class="line">			Table t1(2);</span><br><span class="line">			Table t2 = t1;</span><br><span class="line">			Table t3(t1);</span><br><span class="line">		&#125;</span><br><span class="line">		----------- ./a.out --------------------</span><br><span class="line">		in Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		===================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 原因</span><br><span class="line">		在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。</span><br><span class="line">		</span><br><span class="line">		而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">		</span><br><span class="line">3, 类和数组的关系</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		为什么能对指针类型使用索引?</span><br><span class="line">	</span><br><span class="line">	&gt;* 测试</span><br><span class="line">		========= source code =====================</span><br><span class="line">		class Name &#123;</span><br><span class="line">			const char* s;</span><br><span class="line">		&#125;;</span><br><span class="line">	</span><br><span class="line">		void test_array() &#123;</span><br><span class="line">			Name* t;</span><br><span class="line">			t[0];          // t是指针也是数组</span><br><span class="line">			</span><br><span class="line">			int i = 5;</span><br><span class="line">			int* ptr_i = &amp;i;</span><br><span class="line">			int r = ptr_i[0];     // ptr_i是指针也是数组</span><br><span class="line">			std::cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; std::endl;    // prints r = 5</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 某一类型的指针, 也同样是指向某一类型的数组。</span><br><span class="line">		到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? </span><br><span class="line">		========= source code ===========</span><br><span class="line">		int a = 2, b = 3, c = 4;</span><br><span class="line">		int table_v[] = &#123;a, b, c&#125;;</span><br><span class="line">		std::cout &lt;&lt; *table_v &lt;&lt; std::endl;</span><br><span class="line">		-------./a.out---------------------</span><br><span class="line">		2</span><br><span class="line">		=================================</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/15/essay/about-rest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/essay/about-rest/" itemprop="url">关于休息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T22:56:54+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">人的一生有多少时间是在休息中度过的？</span><br><span class="line"></span><br><span class="line">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class="line">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class="line">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class="line">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class="line">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class="line"></span><br><span class="line">回过头来, 这件事情要是这样, </span><br><span class="line">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class="line">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class="line">因此, 将生活与工作的接口分离是有必要的。</span><br><span class="line"></span><br><span class="line">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class="line">但我希望缓慢能做到。</span><br><span class="line"></span><br><span class="line">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class="line">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class="line">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class="line">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class="line">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class="line">...等等很多。</span><br><span class="line">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class="line">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class="line"></span><br><span class="line">休息是一种智慧。 </span><br><span class="line">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class="line">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class="line">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class="line">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class="line"></span><br><span class="line">对休息也需要重构。</span><br><span class="line">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class="line"></span><br><span class="line">先生活后工作。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/cpp/cpp-notes-0005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/cpp/cpp-notes-0005/" itemprop="url">C++ Zero To One 0.005</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T21:42:33+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, protected能否被实例对象访问</span><br><span class="line"></span><br><span class="line">	&gt;* 发现问题	</span><br><span class="line">		重新实现Vector中, 要对ADT的access进行区别。</span><br><span class="line">		protected能否被实例对象访问?</span><br><span class="line">		protected能否被继承类访问?</span><br><span class="line">	&gt;* 尝试</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		class Base &#123;</span><br><span class="line">		private:</span><br><span class="line">			int i = 0;</span><br><span class="line">			void f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		protected:</span><br><span class="line">			void f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		public:</span><br><span class="line">			void f() &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class="line">				f_prot();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		class Derived : Base &#123;</span><br><span class="line">		public:</span><br><span class="line">			void call_f_prot() &#123;f_prot();&#125;</span><br><span class="line">			// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		int main() &#123;</span><br><span class="line">			Base b;</span><br><span class="line">			Derived d;</span><br><span class="line">			// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class="line">			d.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class="line">			// d.call_f_priv();</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 特点</span><br><span class="line">		protected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class="line">		</span><br><span class="line">		希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class="line">		而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, for循环语句的简单写法</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">	for语句的三个表达式如何写?</span><br><span class="line">	Vector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class="line">	&#123;_elem = new T[_capacity = c];</span><br><span class="line">		for (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class="line">		</span><br><span class="line">	&gt;* 利用for的参数</span><br><span class="line">		for ( declaration-or-expression(optional) ; </span><br><span class="line">			declaration-or-expression(optional) ; </span><br><span class="line">			expression(optional) )</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		const int s = 8;</span><br><span class="line">		int size = 0;</span><br><span class="line">		int elem[s] = &#123;&#125;;</span><br><span class="line">		/*</span><br><span class="line">		for (size = 0; size &lt; s; size++) &#123;</span><br><span class="line">			elem[size] = 2;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		// 第三个参数, 递增size的同时, 给修改elem</span><br><span class="line">		for (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class="line">		// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class="line">		for (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	&gt;* 反思</span><br><span class="line">		某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		Vector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class="line">		Vector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class="line">		============================================================</span><br><span class="line">		对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class="line"></span><br><span class="line">	&gt;* 常量引用</span><br><span class="line">		type const&amp;, type&amp; const之间是什么区别 ?</span><br><span class="line">		先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class="line">		</span><br><span class="line">		让测试代码跑跑。</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		int f() &#123;</span><br><span class="line">		int a = 0, b = 1;</span><br><span class="line">		const int ca = 0, cb = 1;</span><br><span class="line">		</span><br><span class="line">		int&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class="line">		int* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class="line">		const int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class="line">		const int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class="line">		int const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class="line">		const int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class="line">		// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class="line">		// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class="line">		// 引用不能duplicate const</span><br><span class="line">		f1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class="line">		// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class="line">		// cref_a_1++;    // read-only</span><br><span class="line">		</span><br><span class="line">		// 引用指针</span><br><span class="line">		int* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class="line">		// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class="line">		const int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class="line">		// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class="line">		const int* const&amp; cref_cptrca = cptr_ca;</span><br><span class="line">		</span><br><span class="line">		(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class="line">		// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void f1(int const&amp; ic) &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling f1()...\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">		常量引用的写法. 所引用的对象类型为type</span><br><span class="line">		(type) const&amp; ref_t;</span><br><span class="line">		// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class="line">		</span><br><span class="line">		另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class="line">		</span><br><span class="line">	&gt;* 常量指针</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int a = 0, b = 0, c = 0, d = 0;</span><br><span class="line">		int* p_a = &amp;a;                 // 指向int的指针</span><br><span class="line">		// 指针地址可变, 指向的a可变</span><br><span class="line">		(*p_a)++; p_a = &amp;b;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">		const int* p_b = &amp;b;          // 指向const int的指针</span><br><span class="line">		// 指针地址可变, 指向的元素转换成const不可变</span><br><span class="line">		// (*p_b)++;</span><br><span class="line">		p_b = &amp;c;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">		int* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class="line">		// 指针地址不可变, 指向的元素可以变</span><br><span class="line">		(*cp_c)++;</span><br><span class="line">		// cp_c = &amp;d;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">		// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class="line">		const int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class="line">		// 指针地址不可变, 指向值不可变</span><br><span class="line">		// (*cp_cd)++;</span><br><span class="line">		// cp_cd = &amp;a;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">		------------------------ ./a.out ---------------------------</span><br><span class="line">		*p_a = 0, a = 1</span><br><span class="line">		*p_b = 0, b = 0</span><br><span class="line">		*cp_c = 1, c = 1</span><br><span class="line">		*cp_cd = 0, d = 0</span><br><span class="line">		============================================================</span><br><span class="line">		T*               = &amp;a;      // 指针</span><br><span class="line">		const T*         = &amp;ca;     // 指向常量的指针</span><br><span class="line">		T* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class="line">		const T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class="line">		</span><br><span class="line">	&gt;* const_cast&lt;type&gt;();</span><br><span class="line">		=======</span><br><span class="line">		int b = 0;</span><br><span class="line">		const int* p_b= &amp;b;</span><br><span class="line">		*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class="line">		// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class="line">		==========</span><br><span class="line">		一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class="line">		我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class="line">	</span><br><span class="line">	&gt;*  最初的辨析</span><br><span class="line">		T const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class="line">		const T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class="line">		T&amp; const : 非法 </span><br><span class="line">		T const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class="line">		const T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class="line">		T* const : 指针, 指向T的常量指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/movies/the-Truman-show-critic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/movies/the-Truman-show-critic/" itemprop="url">楚门的世界, 写于观后和离前</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T11:29:45+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1, 疑惑</span><br><span class="line">	1) 戏中戏外的时间不同步</span><br><span class="line">		戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class="line">		是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class="line">		大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class="line">		在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class="line">	2) 关于梦醒</span><br><span class="line">		长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class="line">		梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">2, 观点</span><br><span class="line">	1) 戏里戏外都在被安慰</span><br><span class="line">		戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class="line">		有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class="line">		而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class="line">		他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class="line">		</span><br><span class="line">		戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class="line">		通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class="line">		创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class="line"></span><br><span class="line">	2) 构成生活看似真实性的一些元素</span><br><span class="line">		说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class="line">		交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class="line">		独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class="line">		神的安排。</span><br><span class="line"></span><br><span class="line">	3) 二十世纪末的美国科技和科幻能力</span><br><span class="line">		98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class="line">		制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class="line">		楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class="line">		当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class="line"></span><br><span class="line">	4) 如果对现有的生活不再眷恋</span><br><span class="line">		除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/dsacpp/02-D2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/dsacpp/02-D2/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T17:09:13+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d2 有序向量: 二分查找</span><br><span class="line"></span><br><span class="line">	Vector::find(e, lo, hi);</span><br><span class="line">	Vector::search(e, lo, hi);</span><br><span class="line"></span><br><span class="line">	操作参数和接口语义类似。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 统一接口</span><br><span class="line">	&gt;* ADT接口</span><br><span class="line">	======================== source code ==========================</span><br><span class="line">	// ADT接口</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::srand(std::time(0));</span><br><span class="line">		return (std::rand() % 2) ?</span><br><span class="line">			binSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class="line">			: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	================================================================</span><br><span class="line">	可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 语义约定</span><br><span class="line"></span><br><span class="line">	约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class="line">	&gt;* 优点: </span><br><span class="line">		维护自身 V.insert(1 + V.search(e), e)</span><br><span class="line">			即便是失败, 也给出插入新元素的位置。</span><br><span class="line">			若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class="line">	</span><br><span class="line">	&gt;* 约点:</span><br><span class="line">		有序V[lo, hi), 不大于e的最后元素秩</span><br><span class="line">		-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class="line">		V[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 原理</span><br><span class="line"></span><br><span class="line">	&gt;* 减而治之</span><br><span class="line">		待查找区间分成三部分</span><br><span class="line">		S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class="line">	</span><br><span class="line">	&gt;* 三种比较情况</span><br><span class="line">		e &lt; x: 左</span><br><span class="line">		x &lt; e: 右</span><br><span class="line">		e = x: 命中             // 多个解?</span><br><span class="line">	</span><br><span class="line">	&gt;* 二分(折半)策略</span><br><span class="line">		每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实现</span><br><span class="line"></span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		======= source code ======================================</span><br><span class="line">		// 二分查找: 版本A</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">			if (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class="line">				Rank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class="line">				if (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class="line">				if (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class="line">					return (binSearch(elem, e, lo, mi));</span><br><span class="line">				&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		==========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 给出的版本</span><br><span class="line">		==================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">				Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">				if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">				else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">				else                   return mi;    // 在mi命中</span><br><span class="line">			&#125;</span><br><span class="line">		return -1;   // 查找失败</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 分析</span><br><span class="line">		1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class="line">		2, while循环通过hi, lo改变, 改变区间。</span><br><span class="line">		3, if...else 和 else...if什么差别？</span><br><span class="line">	</span><br><span class="line">	&gt;* 技巧</span><br><span class="line">		善用 &quot;&lt;&quot; 比较</span><br><span class="line">			因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实例与复杂度</span><br><span class="line"></span><br><span class="line">	&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class="line">	&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class="line">	</span><br><span class="line">	&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class="line">	递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"># 版本A：查找长度</span><br><span class="line"></span><br><span class="line">	&gt;* 更为精细的评估算法性能:</span><br><span class="line">		考察关键码的比较次数, 查找长度(search length)</span><br><span class="line">	&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class="line">	&gt;* 这个算法 = O(1.5logn)</span><br><span class="line">		向左节点 + 1, 向右节点 +2</span><br><span class="line">		n = 8</span><br><span class="line">		最好, 29/7 = 4+</span><br><span class="line">		最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/cpp/cpp-notes-0004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/cpp/cpp-notes-0004/" itemprop="url">C++ Zero To One 0.004</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T10:28:06+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1, bool和int的隐式转换</span><br><span class="line">	[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt;* 问题起因</span><br><span class="line">		======================= source code =========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">		int count = 0;   // 计数器</span><br><span class="line">		for (int i = i; i &lt; _size; i++)</span><br><span class="line">			count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">		return count;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class="line">	</span><br><span class="line">	&gt;* sizeof(bool) = 1</span><br><span class="line">  </span><br><span class="line">	&gt;* bool-&gt; not bool</span><br><span class="line">		布尔值转赋值给非布尔值, 初始值false时0, true时1 	</span><br><span class="line">	</span><br><span class="line">	&gt;* not bool -&gt; bool</span><br><span class="line">		非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class="line">	</span><br><span class="line">		其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		void f_to_bool() &#123;</span><br><span class="line">		int i1 = 5, i2 = 0;</span><br><span class="line">		int* pi0 = 0;       // 定义空指针</span><br><span class="line">		int* pi1 = &amp;i1;      // 指针指向i1</span><br><span class="line">		int&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class="line">		int&amp; ri1 = i1;      // 引用i1</span><br><span class="line">		</span><br><span class="line">		bool bi = i1;        // prints  bi = 1</span><br><span class="line">		bool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class="line">		bool bpi1 = pi1;     //         bpi1 = 1</span><br><span class="line">		bool bri0 = ri0;     //         bri0 = 0</span><br><span class="line">		bool bri1 = ri1;     //         bri1 = 1</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------------------------  </span><br><span class="line"># 2, 不能返回函数内部初始化的指针</span><br><span class="line">	[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class="line"></span><br><span class="line">	&gt;* 问题</span><br><span class="line">		数据结构学习中, Rank* deduplicate_lower();</span><br><span class="line">		我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class="line">	&gt;* 错误的方法</span><br><span class="line">		函数体内声明定义的指针，返回不了</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int* f() &#123;</span><br><span class="line">			int iarr[] = &#123;&#125;;</span><br><span class="line">			iarr[0] = 2;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out -----------------------------</span><br><span class="line">		warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class="line">		============================================================</span><br><span class="line">		我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class="line">	</span><br><span class="line">	&gt;* 可行的方法</span><br><span class="line">		将指针作为参数传入</span><br><span class="line">		================== source code =============================</span><br><span class="line">		int* f1(int* iarr) &#123;</span><br><span class="line">			*iarr += 1;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class="line">		便于函数之间的调用, 还是需要的。</span><br><span class="line">	</span><br><span class="line">	&gt;* 另一种可行方法: malloc返回指针</span><br><span class="line">		================= source code ============================</span><br><span class="line">		// 强制返回指针, 分配内存却不释放</span><br><span class="line">		int* fun() &#123;</span><br><span class="line">			int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class="line">			for (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class="line">				*(i_ptr+i) = 0;</span><br><span class="line">			// free(i_ptr);  // 释放指针</span><br><span class="line">			return i_ptr;    // 函数返回指针</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"># 3, malloc和free</span><br><span class="line">	[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class="line">  </span><br><span class="line">	&gt; * 概念</span><br><span class="line">		malloc:</span><br><span class="line">		void* malloc (size_t size);</span><br><span class="line">		在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class="line">		free:</span><br><span class="line">		void free(void* ptr);</span><br><span class="line">		重新分配作用域中的memeory, 给未来的分配使用</span><br><span class="line">	</span><br><span class="line">	&gt; * 需要include的库</span><br><span class="line">		#include &lt;stdlib.h&gt;</span><br><span class="line">		#include &lt;stdio.h&gt;</span><br><span class="line">	</span><br><span class="line">	&gt; * 案例</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int main() &#123;</span><br><span class="line">			int i, n;</span><br><span class="line">			char* buffer;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;how long do you want the string?&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">	        buffer = (char*) malloc(i+1);</span><br><span class="line">	        if (buffer==NULL) exit(1);</span><br><span class="line"></span><br><span class="line">	        for (n=0; n &lt; i; n++)</span><br><span class="line">				buffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class="line">			buffer[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;Random string: %s\n&quot;, buffer);</span><br><span class="line">	        free(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		------------------ ./a.out -------------------------------</span><br><span class="line">		how long do you want the string?5</span><br><span class="line">		Random string: nwlrb</span><br><span class="line">		===========================================================</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"># 4, 未声明大小的数组</span><br><span class="line">	[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class="line"></span><br><span class="line">	&gt; * 问题</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int size = 5;</span><br><span class="line">		int iarr[size] = &#123;&#125;;</span><br><span class="line">		------------------- ./a.out ----------------------------------</span><br><span class="line">		error: variable-sized object ‘iarr1’ may not be initialized</span><br><span class="line">		===========================================================</span><br><span class="line">	</span><br><span class="line">	&gt; * const</span><br><span class="line">		=========== source code ==========</span><br><span class="line">		const unsigned int size = 5;</span><br><span class="line">		int iarr1[size] = &#123;&#125;;</span><br><span class="line">		==================================</span><br><span class="line">	</span><br><span class="line">	&gt; * define</span><br><span class="line">		========== source code ==============</span><br><span class="line">		#define ARRAY_SIZE 5;</span><br><span class="line">		// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class="line">		int iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class="line">		======================================</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"># 5, continue 和 break 区别</span><br><span class="line">	[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt; * 概念 </span><br><span class="line">		continue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class="line">		break: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class="line">	</span><br><span class="line">	&gt; * continue实例:</span><br><span class="line">		loop:</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		// 跳过loop剩余部分</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class="line">				continue;&#125;</span><br><span class="line">				// ...</span><br><span class="line">				std::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">    &gt; * break实例:	</span><br><span class="line">		1, loop:</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		// 终止循环</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class="line">				std::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	</span><br><span class="line">		2, switch</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int i = 2;</span><br><span class="line">		switch (i) &#123;</span><br><span class="line">			case 1: std::cout &lt;&lt; &quot;1\n&quot;;</span><br><span class="line">			case 2: std::cout &lt;&lt; &quot;2\n&quot;;         // 选择到这里</span><br><span class="line">			case 3: std::cout &lt;&lt; &quot;3\n&quot;;</span><br><span class="line">			case 4:</span><br><span class="line">			case 5: std::cout &lt;&lt; &quot;45 \n&quot;;</span><br><span class="line">				break;                            // 终止switch</span><br><span class="line">			case 6: std::cout &lt;&lt; &quot;6\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		------------------- ./a.out ------------------------------</span><br><span class="line">		2</span><br><span class="line">		3</span><br><span class="line">		45</span><br><span class="line">		============================================================</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"># if...else 和 if...else if的区别</span><br><span class="line">	[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line">	&gt;* 问题</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">			Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">			if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">			else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">			else                   return mi;    // 在mi命中</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		if, else...if 和 else是什么关系？</span><br><span class="line">		从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class="line">	</span><br><span class="line">	&gt;* if...else</span><br><span class="line">		====</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out ---------------------------</span><br><span class="line">		i &gt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if...else if...else if</span><br><span class="line">		===</span><br><span class="line">		int i = 4;</span><br><span class="line">		if (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		-----</span><br><span class="line">		i &lt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if</span><br><span class="line">		===</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class="line">		if (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class="line">		----------------- ./a.out --------------------------</span><br><span class="line">		i =  6</span><br><span class="line">		i != 7</span><br><span class="line">		====================================================</span><br><span class="line">	&gt;* 各自的作用域辨析</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		bool foo = false, bar = true, baz = true;</span><br><span class="line">		if (foo) &#123;</span><br><span class="line">			// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;if(foo)\n&quot;;</span><br><span class="line">		&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;else if(bar)\n&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class="line">			std::cout &lt;&lt; &quot;else &#123;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class="line">			// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class="line">			std::cout &lt;&lt; &quot;if(baz)\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		---------------------- ./a.out ----------------------------------</span><br><span class="line">		// else if(bar)</span><br><span class="line">		// if(baz)</span><br><span class="line">		==============================================================</span><br><span class="line">		我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class="line">		这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class="line">	&gt;* 总结</span><br><span class="line">		if(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class="line">		如果有一个true, 则不会执行接下来的else; </span><br><span class="line">		如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class="line">		</span><br><span class="line">		因此，对于二分查找来说, </span><br><span class="line">		前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class="line">		</span><br><span class="line">		1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class="line">		2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class="line">		===== source code ======</span><br><span class="line">		int i = 4, count = 0;</span><br><span class="line">		(i == 4) ? count++</span><br><span class="line">			: i = 4;</span><br><span class="line">		========================</span><br><span class="line">		缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class="line">		3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mituh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mituh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
