<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="mituh&#39;s notes">
<meta property="og:url" content="https://timtingwei.github.io/page/5/index.html">
<meta property="og:site_name" content="mituh&#39;s notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mituh&#39;s notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://timtingwei.github.io/page/5/"/>





  <title>mituh's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mituh's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/23/architecture-english-temp2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/architecture-english-temp2/" itemprop="url">architecture-english-temp2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T19:36:32+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-完型填空-10"><a href="#1-完型填空-10" class="headerlink" title="1. 完型填空(10%)"></a>1. 完型填空(10%)</h1><h2 id="绿色建筑"><a href="#绿色建筑" class="headerlink" title="绿色建筑"></a>绿色建筑</h2><p>生态 ecological<br>可循环的 recycle<br>环境的，景观 landscape</p>
<h2 id="建筑的构成"><a href="#建筑的构成" class="headerlink" title="建筑的构成"></a>建筑的构成</h2><p>梁 beam<br>剖面 section<br>柱子 column<br>覆盖 cover/ blanket</p>
<h1 id="2-词义配对-20"><a href="#2-词义配对-20" class="headerlink" title="2. 词义配对(20%)"></a>2. 词义配对(20%)</h1><p>(wood - timber)<br>(aesthetic - creative)<br>(hospital - medical institution)<br>(innovative - originality)<br>(site plan - situation plan)<br>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(architecture experience - architecture apprehension) 理解，领悟,感觉<br>(transform - convert) 改变<br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(perception - understanding) 知觉，理解<br>(guest house - visit house) 参观房间<br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>
<h1 id="3-词义搭配中文-10"><a href="#3-词义搭配中文-10" class="headerlink" title="3. 词义搭配中文(10%)"></a>3. 词义搭配中文(10%)</h1><p>给出单词，选择中文单词。</p>
<p>Beam - 梁<br>Aesthetic - 美学<br>Architect - 建筑师<br>Composition - 构成<br>Staircase - 楼梯<br>Multi-story building - 多层建筑<br>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Scheme - 方案<br>Facade - 立面<br>Material - 材料<br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong><br>Exit - 安全出口<br>Entrance - 玄关<br>Wheelchair ramp - 轮椅坡道<br>Residential building - 住宅</p>
<h1 id="4-英译中-10"><a href="#4-英译中-10" class="headerlink" title="4. 英译中(10%)"></a>4. 英译中(10%)</h1><h2 id="1、第一篇原文："><a href="#1、第一篇原文：" class="headerlink" title="1、第一篇原文："></a>1、第一篇原文：</h2><pre><code>DB:how would you describe your architectural approach?
PV：I&apos;m extremely concerned by the fact that design and architecture has a social impact.
we are called to utilize the resources that are not renewable:space,time,money,life...
because in order to design a building and to build it you need years. so, I believe that
my attitudes are extremely serious and conscious about all those elements. I am not someone
who is playing with the project, or doing any&apos;fun stuff, if you like. I prefer to achieve
something that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.
</code></pre><h2 id="2、第一篇译文"><a href="#2、第一篇译文" class="headerlink" title="2、第一篇译文:"></a>2、第一篇译文:</h2><pre><code>DB：你如何描述你的建筑观点
我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。
</code></pre><h2 id="3、第二篇原文："><a href="#3、第二篇原文：" class="headerlink" title="3、第二篇原文："></a>3、第二篇原文：</h2><pre><code>DB:do you think there is an increasingly &apos;globalized approach&apos; To architecture?
DC:
there shouldn&apos;t be. a building can last for a very long time.
it&apos;s fixed to the ground and it contributes to the idea of &apos;a place&apos;.
however contemporary we feel that we are, we still want to find different characteristics in different places. 
if we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. 
I find it very weak for an architect to disregard the history and  culture of a city and say &apos; I have an international style&apos;. 
there&apos;s absolutely no intellectual justification for that. 
it&apos;s the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.
This romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that&apos;s where character is important, we have to be careful no to just create bland products.
</code></pre><h2 id="4、第二篇译文"><a href="#4、第二篇译文" class="headerlink" title="4、第二篇译文:"></a>4、第二篇译文:</h2><pre><code>你如何评价越来越多的全球化？
</code></pre><p>不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。</p>
<h1 id="Part1-1-2-3-4错误总结"><a href="#Part1-1-2-3-4错误总结" class="headerlink" title="Part1, 1, 2, 3, 4错误总结"></a>Part1, 1, 2, 3, 4错误总结</h1><p>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>
<p>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong></p>
<p>it’s the equivalent of having no variation in cuisine, 这就像没有变换的烹饪</p>
<hr>
<h1 id="part2-5-7总结"><a href="#part2-5-7总结" class="headerlink" title="part2 5, 7总结"></a>part2 5, 7总结</h1><h1 id="5-看图描述-15"><a href="#5-看图描述-15" class="headerlink" title="5. 看图描述(15%)"></a>5. 看图描述(15%)</h1><p>10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分</p>
<p>Sou Fujimoto N HOUSE</p>
<p>1, A home for two plus a dog.    // 两个人的家加上一只狗。<br>2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。<br>5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活</p>
<p>6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动<br>7, And this house fuses with the environment since there are green trees embed in it’s shell.    // 与环境融合, 因为有树在其中.<br>8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念<br>9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间<br>10, But it’s special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>
<p>// 两个人的家加上一只狗。<br>// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>// 第二外壳在覆盖的室外空间内封闭有限的空间。<br>// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。<br>// 方案平面灵活，像在场地上流动。<br>// 与环境融合, 因为有树在其中。<br>// 作为一个实验建筑, N house提出未来住宅的理念。<br>// 传统住宅设计, 倾向于分开外部和内部空间。<br>// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>
<h2 id="自我批改"><a href="#自我批改" class="headerlink" title="自我批改"></a>自我批改</h2><p>A house for two plus a dog.<br>The house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.<br><strong>RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.</strong><br>The outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).<br>The second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~<br>The third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)</p>
<p>The situation plan is flexiable, and seems flowing over the small ground.<br>And the building fuses with environment since there are green trees embed in the shell.<br>As an exam architecture, architect propose an idea about features of future ~????house.~ (residence)<br>In traditional design prosess, architects perfer to seperate of interior space and external space.<br>But (it’s) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).<br>Three shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)</p>
<p>Three shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.</p>
<p>The house for two plus a dog.<br>The house itself is comprised of three shells of progressive size nested inside one another.<br>The outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.<br>Second shells encloses a limited space insided the coverd outdoor space.<br>Third shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.</p>
<p>The (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape</p>
<h1 id="6-中译英-20"><a href="#6-中译英-20" class="headerlink" title="6. 中译英(20%)"></a>6. 中译英(20%)</h1><p>给中文采访的文章，生态学的，绿色建筑；英文回答5个问题<br>尽量多写。</p>
<h1 id="7-描述-15"><a href="#7-描述-15" class="headerlink" title="7. 描述(15%)"></a>7. 描述(15%)</h1><p>家的平面或喜欢的建筑。<br>10句话。每句1分。<br>画两张图。1张图2.5分。</p>
<p>Mention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it’s a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.</p>
<p>Enter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.</p>
<p>客厅 living room<br>主卧 master bedroom<br>客卧 guest bedroom<br>卫生间 bathroom<br>阳台 balcony<br>厨房 kitchen<br>餐厅 dining room<br>书房 study room<br>天台 roof<br>门廊 porch<br>储物室 store room<br>衣帽间 locker room<br>一层平面 ground floor plan</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/21/dsacpp/02-E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/dsacpp/02-E/" itemprop="url">02-E</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T22:36:05+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(e) 起泡排序</span><br><span class="line">为了使得向量有序, 要对向量进行排序。</span><br><span class="line"></span><br><span class="line"># 排序器, ADT 统一入口:</span><br><span class="line">	&gt;* 实现</span><br><span class="line">		====================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123;</span><br><span class="line">			int i = 1;</span><br><span class="line">			switch (i) &#123;</span><br><span class="line">				case 1: bubbleSort(lo, hi); break;     // 起泡排序</span><br><span class="line">				case 2: selectionSort(lo, hi); break;  // 选择排序(习题)</span><br><span class="line">				case 3: mergeSort(lo, hi); break;      // 归并排序</span><br><span class="line">				case 4: heapSort(lo, hi); break;       // 堆排序(ch 10)</span><br><span class="line">				default: quickSort(lo, hi); break;     // 快速排序(12)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 起泡排序</span><br><span class="line">	&gt;* 改进思路</span><br><span class="line">		未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。</span><br><span class="line">		在上一趟扫描中, 记录有序对</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/21/dsacpp/02-D4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/21/dsacpp/02-D4/" itemprop="url">02-D4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T14:05:05+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d4) 有序向量: 二分查找(改进)</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line"># 版本B, 改进思路:</span><br><span class="line">	&gt;* 左右转向成本平衡：</span><br><span class="line">		无论向左还是向右进行一次比较。</span><br><span class="line">	</span><br><span class="line">	&gt;* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半</span><br><span class="line">		1, e &lt;  x: e若存在则在左侧子区间S[lo, mi), 可递归深入</span><br><span class="line">		2, x &lt;= e: e若存在则在右侧子区间S[mi, hi), 可递归深入</span><br><span class="line">		只有当hi - lo = 1时, 判断元素是否命中。</span><br><span class="line">		</span><br><span class="line"># 实现:</span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		=========================  source code =======================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			// 二分平衡查找算法</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;          // 轴点为中点</span><br><span class="line">				if (e &lt; elem[mi]) hi = mi;        // 深入左区间</span><br><span class="line">				else if (elem[mi] &lt;= e) lo = mi;  // 深入右区间</span><br><span class="line">			&#125;</span><br><span class="line">			// hi - lo == 1, 判断当前元素是否命中</span><br><span class="line">			if (e == elem[lo]) return lo;</span><br><span class="line">			else               return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		思路上无问题, 但代码可以简化。</span><br><span class="line">		</span><br><span class="line">	&gt;* 更为简洁的写法</span><br><span class="line">		=====</span><br><span class="line">	    template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">			int mi = (lo + hi) &gt;&gt; 1;               // 轴点为中点</span><br><span class="line">			(e &lt; elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入</span><br><span class="line">			&#125;    // 退出循环时, 区间长度1, elem[lo]为有效元素</span><br><span class="line">			return (e == elem[lo])? lo: -1;</span><br><span class="line">		&#125;        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		====</span><br><span class="line">		</span><br><span class="line">		1, 两种情况if...else 用以下代替</span><br><span class="line">			(cond)? expr1 : expr2;</span><br><span class="line">		2, 在其中使用返回语句</span><br><span class="line">			(cond) ? return expr1 : return expr2;    // ERROR!!</span><br><span class="line">			return (cond) ? expr1 : expr2;           // Right!!</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 语义约定</span><br><span class="line">	&gt;* 为什么要语义约定?</span><br><span class="line">		便于其他高阶操作的调用。</span><br><span class="line">		v.insert(1 + search(e, lo, hi), e);</span><br><span class="line">			：在找到元素索引的下个索引处插入。</span><br><span class="line">	</span><br><span class="line">	&gt;* 思路</span><br><span class="line">		1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)</span><br><span class="line">		2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])</span><br><span class="line">	</span><br><span class="line">	&gt;* 实现, 版本C</span><br><span class="line">		&gt;* 我的尝试</span><br><span class="line">		将原来的 return (e == elem[lo]) ? lo : -1; 改为:</span><br><span class="line">		============= source code ============================</span><br><span class="line">		if (e == elem[lo]) &#123;  // 存在匹配</span><br><span class="line">			while (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩</span><br><span class="line">			return lo;</span><br><span class="line">		&#125; else &#123;  // 无匹配</span><br><span class="line">			return (e &lt; elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩</span><br><span class="line">		&#125;</span><br><span class="line">		=======================================================</span><br><span class="line">		一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩</span><br><span class="line">		</span><br><span class="line">		&gt;* 更优解</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;  // 区间缩短至0</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;                   // 轴点为中点</span><br><span class="line">				(e &lt; elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)</span><br><span class="line">			&#125;    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素</span><br><span class="line">			return --lo;    // 故lo-1 为不大于e的最大秩</span><br><span class="line">		&#125;      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 更优解实现分析</span><br><span class="line">		&gt;* 差别</span><br><span class="line">			1, 循环结束区间宽度0, 而非1</span><br><span class="line">			2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?</span><br><span class="line">			3, 无论成功与否, 返回秩序严格符合定义的语义接口。</span><br><span class="line">			4, 和我的实现比起来, 无需多余的while和if判断</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 版本C, 正确性:</span><br><span class="line">	&gt;* 不变性:</span><br><span class="line">		A[0, lo) &lt;= e &lt; A[hi, n)          // A[hi] 总是大于e的最小者</span><br><span class="line">	&gt;* 初始</span><br><span class="line">		lo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立</span><br><span class="line">	&gt;* 数学归纳两种情况,</span><br><span class="line">		这两种情况不是很清楚。以后可以回过头来看看。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/20/dsacpp/02-D3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/20/dsacpp/02-D3/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-20T09:33:42+08:00">
                2018-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d3) 有序向量: Fibonacci查找</span><br><span class="line"></span><br><span class="line">1, 思路</span><br><span class="line">	向左侧1次, 向右两次。</span><br><span class="line">	表面平衡, 内部极大不平衡。</span><br><span class="line">	比较次数不等, 递归深度却相等。</span><br><span class="line">	</span><br><span class="line">	左侧更深, 右侧更浅。</span><br><span class="line">	递归深度不平衡, 对转向成本不同进行补偿。</span><br><span class="line">	</span><br><span class="line">	若 n = fib(k) - 1, 则mi = fib(k-1) - 1</span><br><span class="line">	前向量fib(k-1) - 1, 后向量fib(k-2) - 1</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2, 实现</span><br><span class="line">	&gt;* 我的尝试, 定义fib类</span><br><span class="line">		====== source code ====</span><br><span class="line">		// ERROR:my test fib</span><br><span class="line">		// 定义fibonacci相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int* _fib_lst; int _size;</span><br><span class="line">			public:</span><br><span class="line">			// 构造函数</span><br><span class="line">			explicit Fib(const int n) : _size(n) &#123;</span><br><span class="line">				emptyFib(n);</span><br><span class="line">				fib(n-1, _fib_lst);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 将数列置空</span><br><span class="line">			void emptyFib(const int n) &#123;</span><br><span class="line">				// 初始化0</span><br><span class="line">				for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">				_fib_lst[i] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 生成fib数列</span><br><span class="line">			int fib(const int n, int* _fib_lst) &#123;</span><br><span class="line">				if (_fib_lst[n] != 0) &#123;</span><br><span class="line">					return _fib_lst[n];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (n &lt; 2) &#123;_fib_lst[n] = n;&#125; else &#123;</span><br><span class="line">						_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);</span><br><span class="line">						return _fib_lst[n];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 获得数列中某一索引的值</span><br><span class="line">			int&amp; get(const int&amp; n) const &#123;return _fib_lst[n];&#125;</span><br><span class="line">			</span><br><span class="line">			int index(const int v) const &#123;</span><br><span class="line">				// 获得某一值在fib数列对应的索引</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					if (v == _fib_lst[i]) return i;</span><br><span class="line">					if (v &lt; _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;    // 在扫描过程中没找到, 返回失败</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 打印数列</span><br><span class="line">			void printFib() const &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;---- print fib series -----\n&quot;;</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					std::cout &lt;&lt; i &lt;&lt;&quot;: _fib_lst[i]&quot;</span><br><span class="line">						&lt;&lt; _fib_lst[i] &lt;&lt; std::endl;	</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; &quot;_size = &quot; &lt;&lt; _size &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		==================================================</span><br><span class="line">		运行总是溢出, 找不到出错位置。</span><br><span class="line">		考虑先right, 后fast</span><br><span class="line"></span><br><span class="line">	&gt;* 根据课件的修改</span><br><span class="line">		=================== source code ==========================</span><br><span class="line">		// 定义fib相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int _size;</span><br><span class="line">			</span><br><span class="line">			public:</span><br><span class="line">			explicit Fib(int n) : _size(n) &#123;&#125;</span><br><span class="line">			int createFib(int n) &#123;</span><br><span class="line">				return (2 &gt; n) ? n: createFib(n-1) + createFib(n-2);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得当前项</span><br><span class="line">			int get() &#123;</span><br><span class="line">				int result = createFib(_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得前一项</span><br><span class="line">			int prev() &#123;</span><br><span class="line">				if (0 &lt; _size - 1) &#123;</span><br><span class="line">				int result = createFib(--_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		===========================================================</span><br><span class="line">		先使用了低效的fib生成函数, 且不储存在一个list中。</span><br><span class="line">		</span><br><span class="line">		以及查找函数</span><br><span class="line">		======================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			Fib fib(hi - lo);</span><br><span class="line">			while (lo &lt; hi) &#123;</span><br><span class="line">				while ((hi - lo) &lt; fib.get()) fib.prev();</span><br><span class="line">				int priv = lo + fib.get() - 1;</span><br><span class="line">				if      (e &lt; elem[priv]) hi = priv;</span><br><span class="line">				else if (elem[priv] &lt; e) lo = priv + 1;</span><br><span class="line">				else                     return priv;</span><br><span class="line">			&#125;</span><br><span class="line">		    return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		本质是选择轴点不同。</span><br><span class="line">	&gt;* 改进fib类</span><br><span class="line">		用动态规划求解fib数列中的某一项</span><br><span class="line">		================= source code ==============================</span><br><span class="line">		int createFib(int n) &#123;</span><br><span class="line">			int f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;</span><br><span class="line">			if (n &lt; 2) &#123;int r = (n) ? g : f; return r;&#125;</span><br><span class="line">			while (0 &lt; n--) &#123;</span><br><span class="line">				g = g + f;</span><br><span class="line">				f = g - f;</span><br><span class="line">			&#125;</span><br><span class="line">			return g;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">3, 查找最优性</span><br><span class="line">	&gt;* 通用策略: </span><br><span class="line">		对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 &lt;= lambda &lt; 1</span><br><span class="line">		二分0.5, fibonacci对应lambda  = 0.6180339</span><br><span class="line">	&gt;* 递推式和微积分求极值</span><br><span class="line">		这个...</span><br><span class="line">		</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">4, 总结</span><br><span class="line">	这个算法花费很长时间去实现, 原因如下：</span><br><span class="line">		1, 面向对象不理解, 为什么定义fib类</span><br><span class="line">		2, 先选择了fast, not right</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/18/temp-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/temp-history/" itemprop="url">中建史考试笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T17:19:59+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目分配"><a href="#题目分配" class="headerlink" title="题目分配"></a>题目分配</h1><p>填空20*2 = 40<br>选择4<br>问答4<br>画图5</p>
<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-中国古代建筑的三种主要结构形式和特点-P4"><a href="#1-中国古代建筑的三种主要结构形式和特点-P4" class="headerlink" title="1, 中国古代建筑的三种主要结构形式和特点? P4"></a>1, 中国古代建筑的三种主要结构形式和特点? P4</h2><pre><code>1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头
2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁
3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。
</code></pre><h2 id="2-进行穿斗式与抬粱式木构架的优缺点比较-P5"><a href="#2-进行穿斗式与抬粱式木构架的优缺点比较-P5" class="headerlink" title="2, 进行穿斗式与抬粱式木构架的优缺点比较? P5"></a>2, 进行穿斗式与抬粱式木构架的优缺点比较? P5</h2><pre><code>穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。
</code></pre><h2 id="3-斗拱是由哪些构件组成的？每种构件的作用如何？P6"><a href="#3-斗拱是由哪些构件组成的？每种构件的作用如何？P6" class="headerlink" title="3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6"></a>3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6</h2><pre><code>a, 斗拱是由斗、拱、昂、翘、升组成的
b, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)
</code></pre><h2 id="4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19"><a href="#4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19" class="headerlink" title="4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19"></a>4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19</h2><pre><code>1, 类型：
    a, 干阑式
    b, 木骨泥墙
2, 实例
    a, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。
    b, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。
</code></pre><h2 id="5-中国古代建筑史上的主要著作"><a href="#5-中国古代建筑史上的主要著作" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="6-《考工记》匠人营国一段原文及如何理解？"><a href="#6-《考工记》匠人营国一段原文及如何理解？" class="headerlink" title="6, 《考工记》匠人营国一段原文及如何理解？"></a>6, 《考工记》匠人营国一段原文及如何理解？</h2><pre><code>原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)
理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）
</code></pre><h2 id="7-《工程做法》的内容和评价？"><a href="#7-《工程做法》的内容和评价？" class="headerlink" title="7, 《工程做法》的内容和评价？"></a>7, 《工程做法》的内容和评价？</h2><pre><code>内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。
 评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。
</code></pre><h2 id="8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？"><a href="#8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？" class="headerlink" title="8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？"></a>8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？</h2><pre><code>背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。
著书人：将作监 李诫
评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。
</code></pre><h2 id="9-北宋是城市结构由里坊制转向厢坊制的起点"><a href="#9-北宋是城市结构由里坊制转向厢坊制的起点" class="headerlink" title="9, 北宋是城市结构由里坊制转向厢坊制的起点"></a>9, 北宋是城市结构由里坊制转向厢坊制的起点</h2><pre><code>北宋城市结构和布局起了根本变化。
唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。
到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。
</code></pre><h2 id="10-宋的基本模数制度：材份制"><a href="#10-宋的基本模数制度：材份制" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折"><a href="#11-宋式殿堂的特点及屋面举折" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"><a href="#12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？" class="headerlink" title="12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"></a>12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？</h2><pre><code>云冈石窟, 龙门石窟
石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。
</code></pre><h2 id="13-唐代建筑的主要特点是什么？"><a href="#13-唐代建筑的主要特点是什么？" class="headerlink" title="13, 唐代建筑的主要特点是什么？"></a>13, 唐代建筑的主要特点是什么？</h2><pre><code>1, 规模宏大，规划严整
2, 建筑群 处理愈加成熟
3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化
4, 设计与施工水平提高
5, 砖石建筑发展
6, 建筑艺术真实成熟
</code></pre><h2 id="14-元代盛行的减柱法是什么意思？举例说明"><a href="#14-元代盛行的减柱法是什么意思？举例说明" class="headerlink" title="14, 元代盛行的减柱法是什么意思？举例说明"></a>14, 元代盛行的减柱法是什么意思？举例说明</h2><pre><code>减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。
元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。
举例：山西洪洞 广胜寺, 山西永济 永乐宫。
</code></pre><h2 id="15-进行明代建筑木构架与唐宋风格比较"><a href="#15-进行明代建筑木构架与唐宋风格比较" class="headerlink" title="15, 进行明代建筑木构架与唐宋风格比较"></a>15, 进行明代建筑木构架与唐宋风格比较</h2><pre><code>1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。
2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。
3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。
4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。
</code></pre><h2 id="16-明清北京城四圈城的名称是什么？"><a href="#16-明清北京城四圈城的名称是什么？" class="headerlink" title="16, 明清北京城四圈城的名称是什么？"></a>16, 明清北京城四圈城的名称是什么？</h2><pre><code>外城, 永定门
内城, 正阳门
皇城, 天安门
紫禁城, 午门
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就"><a href="#17-简述北京故宫的建筑艺术成就" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><h2 id="18-天坛总体布局及祭祀建筑特点"><a href="#18-天坛总体布局及祭祀建筑特点" class="headerlink" title="18, 天坛总体布局及祭祀建筑特点"></a>18, 天坛总体布局及祭祀建筑特点</h2><pre><code>设计特点:
1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)
2, 环境处理
    a, 建筑只占1/20, 融于绿色之中
    b, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近
3, 运用数字和色彩的象征
</code></pre><h2 id="19-佛塔的主要类型是什么？"><a href="#19-佛塔的主要类型是什么？" class="headerlink" title="19, 佛塔的主要类型是什么？"></a>19, 佛塔的主要类型是什么？</h2><pre><code>中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔
1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,
2, 单层塔，山东济南 隋代 神通寺 四门塔,
3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,
4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,
5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。
</code></pre><h2 id="20-简述平板枋（普拍枋）的位置和作用"><a href="#20-简述平板枋（普拍枋）的位置和作用" class="headerlink" title="20, 简述平板枋（普拍枋）的位置和作用"></a>20, 简述平板枋（普拍枋）的位置和作用</h2><pre><code>平板枋置于阑额之上, 可以承受斗拱。
</code></pre><h2 id="21-屋顶做法：收山、推山"><a href="#21-屋顶做法：收山、推山" class="headerlink" title="21, 屋顶做法：收山、推山"></a>21, 屋顶做法：收山、推山</h2><pre><code>推山：是庑殿建筑处理屋顶的一种特殊手法
收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。
</code></pre><h2 id="22-清式彩画常用的三大类是什么？"><a href="#22-清式彩画常用的三大类是什么？" class="headerlink" title="22, 清式彩画常用的三大类是什么？"></a>22, 清式彩画常用的三大类是什么？</h2><pre><code>和玺, 旋子, 苏式
</code></pre><h2 id="23-宋式柱网布局中分心槽是什么意思？"><a href="#23-宋式柱网布局中分心槽是什么意思？" class="headerlink" title="23, 宋式柱网布局中分心槽是什么意思？"></a>23, 宋式柱网布局中分心槽是什么意思？</h2><pre><code>以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。
</code></pre><h2 id="24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？"><a href="#24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？" class="headerlink" title="24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？"></a>24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？</h2><pre><code>外5, 内9;
金厢斗底槽。
</code></pre><h1 id="绘制简图题"><a href="#绘制简图题" class="headerlink" title="绘制简图题"></a>绘制简图题</h1><p>嵩岳寺塔平面和立面 P181 考<br>九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图<br>佛光寺大殿平立剖面 P156<br>晋祠圣母殿平立剖面<br>独乐寺观音阁剖面 P162<br>应县木塔平面、剖面 P176 考<br>北京天坛总平面图 P131<br>清式抬梁式七架无廊结构示意图 P297<br>宋式进深八椽屋的屋面举折做法示意图 P285</p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="5-中国古代建筑史上的主要著作-1"><a href="#5-中国古代建筑史上的主要著作-1" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="10-宋的基本模数制度：材份制-1"><a href="#10-宋的基本模数制度：材份制-1" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折-1"><a href="#11-宋式殿堂的特点及屋面举折-1" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就-1"><a href="#17-简述北京故宫的建筑艺术成就-1" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><hr>
<h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><h2 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h2><p>1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的<code>抬梁式</code>和<code>穿斗式</code>两种主要木结构已经形成。<br>2, 北宋初年浙东木匠<code>喻皓</code>著有《<code>木经</code>》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。<br>3, 北宋末年政府颁布的《营造法式》中规定，把<code>材</code>作为造屋的尺度标准，即将木构架建筑的用料尺寸分成<code>八</code> 等，按照屋宇的大小主次量屋用材。<br>4, 清式彩画分为<code>和玺彩画</code>、<code>旋子彩画</code>、<code>苏式彩画</code><br>5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧<code>推出</code>，从而使四条垂脊形成空间曲线，这种做法称为<code>推山</code> 。<br>6, 应县木塔外观<code>5</code> 层，内部结构层为<code>9层</code>木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>1, 隋大兴城的规划设计者为：（ A ）<br>    <code>A宇文凯</code> B郭守敬 C雷发达 D蒯祥<br>2, 北京故宫天安门前院落的形状为：（ D）<br>    A凹字形 B工字型 C“L型” <code>D“T字形”</code><br>3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）<br>    A八等 B九等 <code>C十一等</code> D十三等<br>4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）<br>    <code>A唐代</code> B宋代 C明代 D清代</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/16/cpp/cpp-notes-0006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/cpp/cpp-notes-0006/" itemprop="url">C++ Zero To One 0.006</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T22:30:14+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 局部变量的销毁顺序</span><br><span class="line">	================= source code ===============================</span><br><span class="line">	void f(int i) &#123;</span><br><span class="line">		Table aa(1);</span><br><span class="line">		Table bb(2);</span><br><span class="line">		if (i &gt; 0) &#123;</span><br><span class="line">			Table cc(3);</span><br><span class="line">		&#125;</span><br><span class="line">		Table dd(4);</span><br><span class="line">	&#125;</span><br><span class="line">	-------------- ./a.out ----------------</span><br><span class="line">	in Table() sz = 1</span><br><span class="line">	in Table() sz = 2</span><br><span class="line">	in Table() sz = 3</span><br><span class="line">	in ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class="line">	in Table() sz = 4</span><br><span class="line">	in ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class="line">	in ~Table() sz = 2</span><br><span class="line">	in ~Table() sz = 1</span><br><span class="line">	=============================================================</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, 构造函数复制</span><br><span class="line"></span><br><span class="line">	&gt;* 直接复制</span><br><span class="line">		======= source code ========</span><br><span class="line">		void h() &#123;</span><br><span class="line">			Table t1;</span><br><span class="line">			// Table t2 = t1;    // ERROR: 复制初始化</span><br><span class="line">			Table t3;</span><br><span class="line">			</span><br><span class="line">			// t3 = t2;          // ERROR: 复制赋值</span><br><span class="line">		&#125;</span><br><span class="line">		==============================</span><br><span class="line">		</span><br><span class="line">		t1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。</span><br><span class="line">		所导致结果是无意义的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&gt;* 清楚定义复制构造函数</span><br><span class="line">		================ source code =======================</span><br><span class="line">		Table::Table(const Table&amp; t) &#123;</span><br><span class="line">			p = new Name[sz = t.sz];</span><br><span class="line">			for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">				p[i] = t.p[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Table&amp; Table::operator=(const Table&amp; t) &#123;</span><br><span class="line">			if (this != &amp;t) &#123;         // 防止自复制</span><br><span class="line">				delete[] p;</span><br><span class="line">				p = new Name[sz = t.sz];</span><br><span class="line">				for (int i = 0; i &lt; sz; i++) &#123;p[i] = t.p[i];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		void f() &#123;</span><br><span class="line">			Table t1(2);</span><br><span class="line">			Table t2 = t1;</span><br><span class="line">			Table t3(t1);</span><br><span class="line">		&#125;</span><br><span class="line">		----------- ./a.out --------------------</span><br><span class="line">		in Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		===================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 原因</span><br><span class="line">		在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。</span><br><span class="line">		</span><br><span class="line">		而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">		</span><br><span class="line">3, 类和数组的关系</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		为什么能对指针类型使用索引?</span><br><span class="line">	</span><br><span class="line">	&gt;* 测试</span><br><span class="line">		========= source code =====================</span><br><span class="line">		class Name &#123;</span><br><span class="line">			const char* s;</span><br><span class="line">		&#125;;</span><br><span class="line">	</span><br><span class="line">		void test_array() &#123;</span><br><span class="line">			Name* t;</span><br><span class="line">			t[0];          // t是指针也是数组</span><br><span class="line">			</span><br><span class="line">			int i = 5;</span><br><span class="line">			int* ptr_i = &amp;i;</span><br><span class="line">			int r = ptr_i[0];     // ptr_i是指针也是数组</span><br><span class="line">			std::cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; std::endl;    // prints r = 5</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 某一类型的指针, 也同样是指向某一类型的数组。</span><br><span class="line">		到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? </span><br><span class="line">		========= source code ===========</span><br><span class="line">		int a = 2, b = 3, c = 4;</span><br><span class="line">		int table_v[] = &#123;a, b, c&#125;;</span><br><span class="line">		std::cout &lt;&lt; *table_v &lt;&lt; std::endl;</span><br><span class="line">		-------./a.out---------------------</span><br><span class="line">		2</span><br><span class="line">		=================================</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/15/essay/about-rest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/essay/about-rest/" itemprop="url">关于休息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T22:56:54+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">人的一生有多少时间是在休息中度过的？</span><br><span class="line"></span><br><span class="line">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class="line">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class="line">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class="line">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class="line">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class="line"></span><br><span class="line">回过头来, 这件事情要是这样, </span><br><span class="line">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class="line">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class="line">因此, 将生活与工作的接口分离是有必要的。</span><br><span class="line"></span><br><span class="line">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class="line">但我希望缓慢能做到。</span><br><span class="line"></span><br><span class="line">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class="line">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class="line">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class="line">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class="line">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class="line">...等等很多。</span><br><span class="line">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class="line">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class="line"></span><br><span class="line">休息是一种智慧。 </span><br><span class="line">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class="line">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class="line">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class="line">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class="line"></span><br><span class="line">对休息也需要重构。</span><br><span class="line">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class="line"></span><br><span class="line">先生活后工作。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/cpp/cpp-notes-0005/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/cpp/cpp-notes-0005/" itemprop="url">C++ Zero To One 0.005</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T21:42:33+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, protected能否被实例对象访问</span><br><span class="line"></span><br><span class="line">	&gt;* 发现问题	</span><br><span class="line">		重新实现Vector中, 要对ADT的access进行区别。</span><br><span class="line">		protected能否被实例对象访问?</span><br><span class="line">		protected能否被继承类访问?</span><br><span class="line">	&gt;* 尝试</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		class Base &#123;</span><br><span class="line">		private:</span><br><span class="line">			int i = 0;</span><br><span class="line">			void f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		protected:</span><br><span class="line">			void f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		public:</span><br><span class="line">			void f() &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class="line">				f_prot();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		class Derived : Base &#123;</span><br><span class="line">		public:</span><br><span class="line">			void call_f_prot() &#123;f_prot();&#125;</span><br><span class="line">			// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		int main() &#123;</span><br><span class="line">			Base b;</span><br><span class="line">			Derived d;</span><br><span class="line">			// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class="line">			d.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class="line">			// d.call_f_priv();</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 特点</span><br><span class="line">		protected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class="line">		</span><br><span class="line">		希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class="line">		而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, for循环语句的简单写法</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">	for语句的三个表达式如何写?</span><br><span class="line">	Vector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class="line">	&#123;_elem = new T[_capacity = c];</span><br><span class="line">		for (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class="line">		</span><br><span class="line">	&gt;* 利用for的参数</span><br><span class="line">		for ( declaration-or-expression(optional) ; </span><br><span class="line">			declaration-or-expression(optional) ; </span><br><span class="line">			expression(optional) )</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		const int s = 8;</span><br><span class="line">		int size = 0;</span><br><span class="line">		int elem[s] = &#123;&#125;;</span><br><span class="line">		/*</span><br><span class="line">		for (size = 0; size &lt; s; size++) &#123;</span><br><span class="line">			elem[size] = 2;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		// 第三个参数, 递增size的同时, 给修改elem</span><br><span class="line">		for (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class="line">		// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class="line">		for (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	&gt;* 反思</span><br><span class="line">		某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		Vector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class="line">		Vector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class="line">		============================================================</span><br><span class="line">		对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class="line"></span><br><span class="line">	&gt;* 常量引用</span><br><span class="line">		type const&amp;, type&amp; const之间是什么区别 ?</span><br><span class="line">		先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class="line">		</span><br><span class="line">		让测试代码跑跑。</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		int f() &#123;</span><br><span class="line">		int a = 0, b = 1;</span><br><span class="line">		const int ca = 0, cb = 1;</span><br><span class="line">		</span><br><span class="line">		int&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class="line">		int* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class="line">		const int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class="line">		const int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class="line">		int const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class="line">		const int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class="line">		// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class="line">		// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class="line">		// 引用不能duplicate const</span><br><span class="line">		f1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class="line">		// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class="line">		// cref_a_1++;    // read-only</span><br><span class="line">		</span><br><span class="line">		// 引用指针</span><br><span class="line">		int* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class="line">		// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class="line">		const int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class="line">		// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class="line">		const int* const&amp; cref_cptrca = cptr_ca;</span><br><span class="line">		</span><br><span class="line">		(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class="line">		// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void f1(int const&amp; ic) &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling f1()...\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">		常量引用的写法. 所引用的对象类型为type</span><br><span class="line">		(type) const&amp; ref_t;</span><br><span class="line">		// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class="line">		</span><br><span class="line">		另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class="line">		</span><br><span class="line">	&gt;* 常量指针</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int a = 0, b = 0, c = 0, d = 0;</span><br><span class="line">		int* p_a = &amp;a;                 // 指向int的指针</span><br><span class="line">		// 指针地址可变, 指向的a可变</span><br><span class="line">		(*p_a)++; p_a = &amp;b;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">		const int* p_b = &amp;b;          // 指向const int的指针</span><br><span class="line">		// 指针地址可变, 指向的元素转换成const不可变</span><br><span class="line">		// (*p_b)++;</span><br><span class="line">		p_b = &amp;c;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">		int* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class="line">		// 指针地址不可变, 指向的元素可以变</span><br><span class="line">		(*cp_c)++;</span><br><span class="line">		// cp_c = &amp;d;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">		// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class="line">		const int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class="line">		// 指针地址不可变, 指向值不可变</span><br><span class="line">		// (*cp_cd)++;</span><br><span class="line">		// cp_cd = &amp;a;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">		------------------------ ./a.out ---------------------------</span><br><span class="line">		*p_a = 0, a = 1</span><br><span class="line">		*p_b = 0, b = 0</span><br><span class="line">		*cp_c = 1, c = 1</span><br><span class="line">		*cp_cd = 0, d = 0</span><br><span class="line">		============================================================</span><br><span class="line">		T*               = &amp;a;      // 指针</span><br><span class="line">		const T*         = &amp;ca;     // 指向常量的指针</span><br><span class="line">		T* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class="line">		const T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class="line">		</span><br><span class="line">	&gt;* const_cast&lt;type&gt;();</span><br><span class="line">		=======</span><br><span class="line">		int b = 0;</span><br><span class="line">		const int* p_b= &amp;b;</span><br><span class="line">		*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class="line">		// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class="line">		==========</span><br><span class="line">		一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class="line">		我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class="line">	</span><br><span class="line">	&gt;*  最初的辨析</span><br><span class="line">		T const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class="line">		const T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class="line">		T&amp; const : 非法 </span><br><span class="line">		T const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class="line">		const T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class="line">		T* const : 指针, 指向T的常量指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/13/movies/the-Truman-show-critic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/movies/the-Truman-show-critic/" itemprop="url">楚门的世界, 写于观后和离前</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T11:29:45+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1, 疑惑</span><br><span class="line">	1) 戏中戏外的时间不同步</span><br><span class="line">		戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class="line">		是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class="line">		大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class="line">		在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class="line">	2) 关于梦醒</span><br><span class="line">		长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class="line">		梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">2, 观点</span><br><span class="line">	1) 戏里戏外都在被安慰</span><br><span class="line">		戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class="line">		有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class="line">		而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class="line">		他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class="line">		</span><br><span class="line">		戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class="line">		通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class="line">		创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class="line"></span><br><span class="line">	2) 构成生活看似真实性的一些元素</span><br><span class="line">		说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class="line">		交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class="line">		独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class="line">		神的安排。</span><br><span class="line"></span><br><span class="line">	3) 二十世纪末的美国科技和科幻能力</span><br><span class="line">		98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class="line">		制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class="line">		楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class="line">		当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class="line"></span><br><span class="line">	4) 如果对现有的生活不再眷恋</span><br><span class="line">		除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://timtingwei.github.io/2018/01/12/dsacpp/02-D2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mituh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mituh's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/dsacpp/02-D2/" itemprop="url">邓俊辉<<数据结构>>-公开课-02-D2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-12T17:09:13+08:00">
                2018-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d2 有序向量: 二分查找</span><br><span class="line"></span><br><span class="line">	Vector::find(e, lo, hi);</span><br><span class="line">	Vector::search(e, lo, hi);</span><br><span class="line"></span><br><span class="line">	操作参数和接口语义类似。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 统一接口</span><br><span class="line">	&gt;* ADT接口</span><br><span class="line">	======================== source code ==========================</span><br><span class="line">	// ADT接口</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::srand(std::time(0));</span><br><span class="line">		return (std::rand() % 2) ?</span><br><span class="line">			binSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class="line">			: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	================================================================</span><br><span class="line">	可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 语义约定</span><br><span class="line"></span><br><span class="line">	约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class="line">	&gt;* 优点: </span><br><span class="line">		维护自身 V.insert(1 + V.search(e), e)</span><br><span class="line">			即便是失败, 也给出插入新元素的位置。</span><br><span class="line">			若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class="line">	</span><br><span class="line">	&gt;* 约点:</span><br><span class="line">		有序V[lo, hi), 不大于e的最后元素秩</span><br><span class="line">		-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class="line">		V[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 原理</span><br><span class="line"></span><br><span class="line">	&gt;* 减而治之</span><br><span class="line">		待查找区间分成三部分</span><br><span class="line">		S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class="line">	</span><br><span class="line">	&gt;* 三种比较情况</span><br><span class="line">		e &lt; x: 左</span><br><span class="line">		x &lt; e: 右</span><br><span class="line">		e = x: 命中             // 多个解?</span><br><span class="line">	</span><br><span class="line">	&gt;* 二分(折半)策略</span><br><span class="line">		每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实现</span><br><span class="line"></span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		======= source code ======================================</span><br><span class="line">		// 二分查找: 版本A</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">			if (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class="line">				Rank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class="line">				if (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class="line">				if (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class="line">					return (binSearch(elem, e, lo, mi));</span><br><span class="line">				&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		==========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 给出的版本</span><br><span class="line">		==================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">				Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">				if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">				else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">				else                   return mi;    // 在mi命中</span><br><span class="line">			&#125;</span><br><span class="line">		return -1;   // 查找失败</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 分析</span><br><span class="line">		1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class="line">		2, while循环通过hi, lo改变, 改变区间。</span><br><span class="line">		3, if...else 和 else...if什么差别？</span><br><span class="line">	</span><br><span class="line">	&gt;* 技巧</span><br><span class="line">		善用 &quot;&lt;&quot; 比较</span><br><span class="line">			因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实例与复杂度</span><br><span class="line"></span><br><span class="line">	&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class="line">	&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class="line">	</span><br><span class="line">	&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class="line">	递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"># 版本A：查找长度</span><br><span class="line"></span><br><span class="line">	&gt;* 更为精细的评估算法性能:</span><br><span class="line">		考察关键码的比较次数, 查找长度(search length)</span><br><span class="line">	&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class="line">	&gt;* 这个算法 = O(1.5logn)</span><br><span class="line">		向左节点 + 1, 向右节点 +2</span><br><span class="line">		n = 8</span><br><span class="line">		最好, 29/7 = 4+</span><br><span class="line">		最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mituh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mituh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
