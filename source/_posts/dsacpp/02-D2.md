---
title: 邓俊辉<<数据结构>>-公开课-02-D2
date: 2018-01-12 17:09:13
tags:
---
```
d2 有序向量: 二分查找

	Vector::find(e, lo, hi);
	Vector::search(e, lo, hi);

	操作参数和接口语义类似。
---------------------------------------------------------------------------------
# 统一接口
	======== source code ====
	template <typename T>
	Rank Vector<T>::search(T const& e, Rank lo, Rank hi) const {
		// int i = rand() % 2;
		// std::cout << "r = " << i << std::endl;
		std::srand(std::time(0));
		return (std::rand() % 2) ?
			binSearch(_elem, e, lo, hi)     // 二分查找算法
			: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法
	}

	template <typename T>
	Rank Vector<T>::binSearch(T* elem, T const& e, Rank lo, Rank hi) const {
		std::cout << "calling binSearch.... " << std::endl;
		return lo;
	}

	template <typename T>
	Rank Vector<T>::fibSearch(T* elem, T const& e, Rank lo, Rank hi) const {
		std::cout << "calling fibSearch... " << std::endl;
		return lo;
	}
	=======
---------------------------------------------------------------------------------
# 语义约定

	约点语义的好处就是, 能够更好的和其他代码配合。
	>* 优点: 
		维护自身 V.insert(1 + V.search(e), e)
			即便是失败, 也给出插入新元素的位置。
			若允许重复元素, 则每组也按照其插入的次序排序。
	
	>* 约点:
		有序V[lo, hi), 不大于e的最后元素秩
		-00 < e < V[lo], 返回 lo - 1 (左侧哨兵)
		V[hi] < e < +00, 返回 hi - 1 (末元素, 右哨兵左邻)
---------------------------------------------------------------------------------
# 版本A: 原理

	>* 减而治之
		待查找区间分成三部分
		S[lo, mi) <= S[mi] <= S(mi, hi)       // S[mi]轴点
	
	>* 三种比较情况
		e < x: 左
		x < e: 右
		e = x: 命中             // 多个解?
	
	>* 二分(折半)策略
		每经过至多两次比较, 或命中, 或将规模缩减一半

```
