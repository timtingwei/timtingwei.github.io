---
title: 算法学习安排
date: 2018-07-30 07:03:03
tags:
---

## 我的安排
水题->数据结构->专项

算法竞赛入门经典 07.12

《数据结构》严蔚敏, 理解+实现, 07.30
每一种结构都找题刷,leetcode(列的比较清晰), 程序员面试经典(可以换个角度思考)
> * 1.基础
二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）
链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）
堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）
排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）
二分查找（一般会深入，如寻找数组总和为K的两个数字）
两个栈实现队列。
图（深度广度优先遍历、单源最短路径、最小生成树）
动态规划问题。
> * 2, 深入
红黑树性质
分治法和动态规划的区别
计算时间复杂度
二叉树和哈希表查找的时间复杂度

理解: 可视化数据结构帮助理解:https://visualgo.net/en

<<algorithm-4th>> 08.06
网课, 课后作业,https://www.coursera.org/learn/algorithms-part1/home/welcome
小橙书后的作业, 只做网上列出部分 https://algs4.cs.princeton.edu/home/

配合刷题, 穿插
程序员面试金典, 配合牛客网练习https://www.nowcoder.com/ta/cracking-the-coding-interview
PAT, HDOJ, POJ, Leedcode中题目, 专题.

`----2018.07.30----`

## 方法总结
下面是引用左程云大佬<<左程云：程序员该如何学习算法？>>的建议:


对于算法，我给大家的建议：

先找到线团，然后进入线团里学着怎么玩。为了进入线团，需要先把基础知识掌握好。《算法和数据结构》（教材），你一定要看完+理解。这里面讲的都是不能再基础的东西了，觉得讲得不好，自己搜维基百科。没办法，如果坚持不下来，你后面就受罪去吧。

然后有一些很经典的书可以迅速让你进入状态，比如我这本《程序员代码面试指南》，还有《剑指offer》，配合在线练习：https://www.nowcoder.com/ta/coding-interviews，
《程序员面试金典》配合在线练习：https://www.nowcoder.com/ta/cracking-the-coding-interview，这些好书。
我在牛客网上还有一个针对小白的扫盲的课程https://www.nowcoder.com/courses/semester/algorithm。

对于线上刷题平台的题目，先不找解答，先自己实现，实现的多烂，复杂度多差，都坚持写完。然后分析出复杂度。接下来去网上找答案，看到复杂度和你一样或比你低的，直接略过。看到比你好的，重点看，一定要理解，然后分析为什么比你的好，如果你真的理解了，你一定能找到别人优化的点。这个过程可能是最奇妙的过程，不要给自己太大压力，这个过程其实可以很欢乐，你有想法并创造出来，练习了自己的coding能力。别人有更好的实现，推翻了你的所有模型和幻想，你幻灭了，却也因此找到了让你血脉喷张方法。这个阶段看似苦，实际上其乐无穷。你在学习别人解法的过程中，又了解了很多算法和数据结构。而且你付出的每一滴汗水，都是结果导向的，可量化的，实实在在的。写写简单的测试函数就可以发现自己方法的运行时间和更好的解法就是没法比。这是一个非常培养自驱力的阶段，这是一个只追求解法更快更强的阶段。你看到很多经典的结构，你学到很多细思极妙的优化。比读那些让你吃力的书更加快乐，也能够一直启发你走下去。你苦苦寻找啊，觉得好的不能再好的方法啊，直到有一天，你突然看到一个更优的解法，相信我，你一定会一整天都在贤者时间里。

<span style="color:red">
**刷题的方法**

1.实现
2.复杂度分析
3.找复杂度低的答案
4.对比优化的点(重点看理解):
(写测试函数)
(了解更多的算法和数据结构)
5.总结(每题都总结到blog)
(结果导向, 可量化)
</span>


<span style="color:red">**(刷题时候碰到新的算法:)**</span>

我不建议刚开始刷题的人就直接在网络上搜集文章开始学习，因为太散了，而且需要花很多时间去鉴别正确与否。当这些内容都掌握之后，再开始在网上搜集各种各样的题，并与网友参加各种各样的讨论，会比较高效。把底子打好之后，对于专项算法的学习就得心应手了，而且会学的很快。 对于很庞大的算法，我个人的习惯是找例子来引导自己的思路，一点一点的接近算法的核心。唯一需要注意的是，一定要写代码，光看没有用的。对于经典算法的学习，大体上分成几个阶段：

第一阶段：对于某一个具体的算法，首先要搞清楚这个算法解决的问题是什么，可能是实现一个具体的功能，也可能是在某些方面，比如时间复杂度或者空间复杂度方面很卓越，总之搞清楚这个算法被研究出来的目的是什么。<span style="color:red">（搞清楚这种算法的接口怎么调用, 再哪些地方应用较多, 复杂度分析)</span>

第二阶段：然后就要弄清楚这个算法的生存环境了，也就是看看你此时研究的东西是不是对别的知识有依赖，应该先把底层依赖的知识理解并掌握。这些问题都解决之后，就进入到算法本身的学习，理解一个算法是一件辛苦的事情，刚开始看必然会产生很多的困惑，比如经常会怀疑作者讲述的内容的重要性？这些内容和这个算法有什么联系呢？经常会有这种摸不着头脑的感觉，其实作者做的铺垫都是为了建立起描述算法主要内容的基础，只有接受和理解这些基础，才能逐渐触碰到算法的精髓，所以耐心是很重要的。(理解底层的理论知识, 用来描述算法的基础, 这方面我以前不太重视, 但现在要按这个方法来)
第三阶段：算法的主要过程看完之后，往往还是会感到困惑，主要是不知道这个过程好在哪，这就进入了下一个阶段，理解作者对这个过程在功能性或者效率卓越这件事上的解释和证明。这才真正触碰到算法最精髓的部分，也就是深度的理解算法的主要过程所带来的好处，这才是最锻炼人理解能力的地方。<span style="color:red">(理解这个算法设计巧妙的地方)</span>
第四阶段：上面几点是算法学习阶段的过程了，接下来就是研究算法的代码实现，自己设计测试用例亲自跑一下代码，以及从代码运行时间的角度分析这个算法的优势，这也是加深对算法的理解的过程。<span style="color:red">(先理解算法的底层内容, 再动手实现代码)</span>
第五阶段：最后是配合相应的题目练习，让自己通过题目练习的方式，会用、善用学习到的算法，并对这个算法产生一定的敏感程度，具体是指看到某些题目时，能够根据题目的特点，产生与该算法的对应，也就是具备举一反三的能力。<span style="color:red">(实现某种算法后, 用他来做题解决问题, 仍然是回到第一部, 但显然第一部的背景比这里所说的大, 这里更多的是指算法题; 通过刷这一类型的题来达到举一反三的能力)</span>


----
ref:
https://m.nowcoder.com/discuss/61529
