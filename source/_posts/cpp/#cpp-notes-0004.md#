---
title: C++ Zero To One 0.004
date: 2018-01-12 10:28:06
tags: [C++]
---


```
# 1, bool和int的隐式转换
	[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)
	
	>* 问题起因
		======================= source code =========================
		template <typename T>
		int Vector<T>::disordered() const {
		int count = 0;   // 计数器
		for (int i = i; i < _size; i++)
			count += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换
		return count;
		}
		=============================================================
		数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。
	
	>* sizeof(bool) = 1
  
	>* bool-> not bool
		布尔值转赋值给非布尔值, 初始值false时0, true时1 	
	
	>* not bool -> bool
		非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;
	
		其他都没什么问题, 值得注意的是, 引用和指针
		=================== source code =============================
		void f_to_bool() {
		int i1 = 5, i2 = 0;
		int* pi0 = 0;       // 定义空指针
		int* pi1 = &i1;      // 指针指向i1
		int& ri0 = i2;      // 引用i2, i2的值为0
		int& ri1 = i1;      // 引用i1
		
		bool bi = i1;        // prints  bi = 1
		bool bpi0 = pi0;     // prints  bpi0 = 0
		bool bpi1 = pi1;     //         bpi1 = 1
		bool bri0 = ri0;     //         bri0 = 0
		bool bri1 = ri1;     //         bri1 = 1
		=============================================================
----------------------------------------------------------------------------------------------------  
# 2, 不能返回函数内部初始化的指针
	[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)

	>* 问题
		数据结构学习中, Rank* deduplicate_lower();
		我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。
	>* 错误的方法
		函数体内声明定义的指针，返回不了
		===================== source code ===========================
		int* f() {
			int iarr[] = {};
			iarr[0] = 2;
			return iarr;
		}
		--------------------- ./a.out -----------------------------
		warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]
		============================================================
		我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。
	
	>* 可行的方法
		将指针作为参数传入
		================== source code =============================
		int* f1(int* iarr) {
			*iarr += 1;
			return iarr;
		}
		===========================================================
		另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??
		便于函数之间的调用, 还是需要的。
	
	>* 另一种可行方法: malloc返回指针
		================= source code ============================
		// 强制返回指针, 分配内存却不释放
		int* fun() {
			int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存
			for (int i = 0; i < sizeof(int*); i++)
				*(i_ptr+i) = 0;
			// free(i_ptr);  // 释放指针
			return i_ptr;    // 函数返回指针
		}
		============================================================
---------------------------------------------------------------------------------------
# 3, malloc和free
	[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)
  
	> * 概念
		malloc:
		void* malloc (size_t size);
		在语句块中分配一个memeory, 返回一个在作用域中的指针
		free:
		void free(void* ptr);
		重新分配作用域中的memeory, 给未来的分配使用
	
	> * 需要include的库
		#include <stdlib.h>
		#include <stdio.h>
	
	> * 案例
		=================== source code ===========================
		int main() {
			int i, n;
			char* buffer;

	        printf("how long do you want the string?");
			scanf("%d", &i);

	        buffer = (char*) malloc(i+1);
	        if (buffer==NULL) exit(1);

	        for (n=0; n < i; n++)
				buffer[n] = rand()%26 + 'a';
			buffer[i] = '\0';

	        printf("Random string: %s\n", buffer);
	        free(buffer);
		}
		------------------ ./a.out -------------------------------
		how long do you want the string?5
		Random string: nwlrb
		===========================================================
------------------------------------------------------------------------------------------
# 4, 未声明大小的数组
	[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)

	> * 问题
		=================== source code ===========================
		int size = 5;
		int iarr[size] = {};
		------------------- ./a.out ----------------------------------
		error: variable-sized object ‘iarr1’ may not be initialized
		===========================================================
	
	> * const
		=========== source code ==========
		const unsigned int size = 5;
		int iarr1[size] = {};
		==================================
	
	> * define
		========== source code ==============
		#define ARRAY_SIZE 5;
		// #define ARRAY_SIZE = 5;    // ERROR
		int iarr[ARRAY_SIZE] = {}
		======================================
-------------------------------------------------------------------------------------------------
# 5, continue 和 break 区别
	[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)
	
	> * 概念 
		continue: 跳过for, range-for, while or do-while, 循环体剩余部分 
		break: 闭合的for, range-for, while, do-while 循环或 switch选择终止
	
	> * continue实例:
		loop:
		=================== source code ============================
		// 跳过loop剩余部分
		for (int i = 0; i < 5; i++) {
			for (int j = 2; j <7; j++) {
				if (j - i == 2) {
				std::cout << "j-i = 2" << std::endl;
				continue;}
				// ...
				std::cout << "after continue " << std::endl;
			}
		}
		============================================================

    > * break实例:	
		1, loop:
		==================== source code ===========================
		// 终止循环
		for (int i = 0; i < 5; i++) {
			for (int j = 2; j <7; j++) {
				if (j - i == 2) {break;}      // 终止内存循环
				std::cout << "j - i = " << j - i << std::endl;
			}
		}
		============================================================
	
		2, switch
		=================== source code ===========================
		int i = 2;
		switch (i) {
			case 1: std::cout << "1\n";
			case 2: std::cout << "2\n";         // 选择到这里
			case 3: std::cout << "3\n";
			case 4:
			case 5: std::cout << "45 \n";
				break;                            // 终止switch
			case 6: std::cout << "6\n";
		}
		------------------- ./a.out ------------------------------
		2
		3
		45
		============================================================

# if...else 和 if...else if的区别

```
