---
title: C++ Zero To One 0.004
date: 2018-01-12 10:28:06
tags: [C++]
---


```
# bool和int的隐式转换
  [cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)
  ## 问题起因
    ======================= source code ============================
    template <typename T>
	int Vector<T>::disordered() const {
	  int count = 0;   // 计数器
      for (int i = i; i < _size; i++)
         count += (_elem[i-1] > _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换
      return count;
    }
	================================================================
	数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。

  ## sizeof(bool) = 1
  
  ## bool-> not bool
    布尔值转赋值给非布尔值, 初始值false时0, true时1 	
	
  ## not bool -> bool
    非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;
	
	其他都没什么问题, 值得注意的是, 引用和指针
	  =================== source code =============================
	  void f_to_bool() {
	  int i1 = 5, i2 = 0;
	  int* pi0 = 0;       // 定义空指针
	  int* pi1 = &i1;      // 指针指向i1
	  int& ri0 = i2;      // 引用i2, i2的值为0
	  int& ri1 = i1;      // 引用i1

	  bool bi = i1;        // prints  bi = 1
	  bool bpi0 = pi0;     // prints  bpi0 = 0
	  bool bpi1 = pi1;     //         bpi1 = 1
	  bool bri0 = ri0;     //         bri0 = 0
	  bool bri1 = ri1;     //         bri1 = 1
	  =============================================================
  
# 不能返回函数内部初始化的指针

  ## 1, 问题
    数据结构学习中, Rank* deduplicate_lower();
	我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。
  ## 2, 错误的方法
    函数体内声明定义的指针，返回不了
	===================== source code ===============================
	int* f() {
      int iarr[] = {};
      iarr[0] = 2;
      return iarr;
    }
	--------------------- ./a.out ----------------------------------- 
	warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]
	=================================================================
	我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。
	
  ## 3, 可行的方法
    将指针作为参数传入
	================== source code =================================
	int* f1(int* iarr) {
      *iarr += 1;
	  return iarr;
    }
	===============================================================
    另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??
	便于函数之间的调用, 还是需要的。
	
  ## 4, 另一种可行方法: malloc返回指针
    ================= source code ==================================
	// 强制返回指针, 分配内存却不释放
	int* fun() {
	  int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存
		for (int i = 0; i < sizeof(int*); i++)
		  *(i_ptr+i) = 0;
        // free(i_ptr);  // 释放指针
      return i_ptr;    // 函数返回指针
    }
	================================================================
	
# malloc和free
  
  ## 概念
  
    malloc:
	  void* malloc (size_t size);
	  在语句块中分配一个memeory, 返回一个在作用域中的指针
	free:
	  void free(void* ptr);
	  重新分配作用域中的memeory, 给未来的分配使用
  
  ## 需要include的库
    #include <stdlib.h>
    #include <stdio.h>
  ## 案例
    =================== source code ===============================
	int main() {
      int i, n;
	  char* buffer;

	  printf("how long do you want the string?");
	  scanf("%d", &i);

      buffer = (char*) malloc(i+1);
	  if (buffer==NULL) exit(1);

      for (n=0; n < i; n++)
	    buffer[n] = rand()%26 + 'a';
	  buffer[i] = '\0';

      printf("Random string: %s\n", buffer);
	  free(buffer);
	}
	------------------ ./a.out ------------------------------------
	how long do you want the string?5
	Random string: nwlrb
	===============================================================

# 未声明大小的数组

  ## 问题
	=================== source code ==============================
	int size = 5;
	int iarr[size] = {};
	------------------- ./a.out ----------------------------------
	error: variable-sized object ‘iarr1’ may not be initialized
	=============================================================
	
  ## const
    =========== source code ==========
	const unsigned int size = 5;
	int iarr1[size] = {};
	==================================
  ## define
    ========== source code ==============
	#define ARRAY_SIZE 5;
	// #define ARRAY_SIZE = 5;    // ERROR
	int iarr[ARRAY_SIZE] = {}
	======================================

# continue 和 break 区别
  
  # 概念 
    continue: 跳过for, range-for, while or do-while, 循环体剩余部分 
	break: 闭合的for, range-for, while, do-while 循环或 switch选择终止
  # continue实例:
	loop:
	=================== source code ==============================
	// 跳过loop剩余部分
	for (int i = 0; i < 5; i++) {
	  for (int j = 2; j <7; j++) {
        if (j - i == 2) {
          std::cout << "j-i = 2" << std::endl;
          continue;}
        // ...
        std::cout << "after continue " << std::endl;
      }
    }
	==============================================================
	
  
  # break实例:
	
	1, loop:
    ==================== source code ==============================
	// 终止循环
	for (int i = 0; i < 5; i++) {
	  for (int j = 2; j <7; j++) {
        if (j - i == 2) {break;}      // 终止内存循环
        std::cout << "j - i = " << j - i << std::endl;
      }
    }
	===============================================================
	
	2, switch
	=================== source code ===============================
	int i = 2;
	switch (i) {
      case 1: std::cout << "1\n";
      case 2: std::cout << "2\n";         // 选择到这里
      case 3: std::cout << "3\n";
      case 4:
      case 5: std::cout << "45 \n";
	    break;                            // 终止switch
      case 6: std::cout << "6\n";
	}
	------------------- ./a.out ----------------------------------
	2
	3
	45
	==============================================================
```
