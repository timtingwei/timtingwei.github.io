<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[《算法》第四版笔记 创建对象 和 为对象赋值区别]]></title>
      <url>/2018/08/09/20180809/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/timtingwei/coursera-algorithms-part1/blob/master/ch1/1-3/Stack_debug.java" target="_blank" rel="noopener">Stack(debug版本) - github</a></p>
<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>测试函数中的foreach语句不能遍历<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String t : s) &#123;</span><br><span class="line">  System.out.println(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在StackIterator类中, 测试hasNext()方法, print出 “in hasNext() false”, 也就是说迭代不会开始<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"in hasNext()"</span> + (current != <span class="keyword">null</span>));</span><br><span class="line">  <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在main函数中, 测试isEmpty(), 这个函数会判断 链表中first指针, 是否为null, 结果打印出 true<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;String&gt; s = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">System.out.println(s.isEmpty());</span><br><span class="line">s.push(<span class="string">"Truing"</span>);</span><br><span class="line">s.push(<span class="string">"Dijkstra"</span>);</span><br><span class="line">s.push(<span class="string">"Kruthun"</span>);</span><br><span class="line">System.out.println(s.isEmpty());</span><br></pre></td></tr></table></figure></p>
<p>找到问题是出在push()函数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item elem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 向栈中添加元素</span></span><br><span class="line">  Node oldFirst = first;</span><br><span class="line">  <span class="comment">// Node first = new Node();           // 这样写的逻辑更直观</span></span><br><span class="line">  first = <span class="keyword">new</span> Node();                   <span class="comment">// debug: why? 与上一行的区别</span></span><br><span class="line">  first.next = oldFirst;</span><br><span class="line">  first.item = elem;</span><br><span class="line">  ++N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red">疑惑, 构造一个对象时, 下面两行代码的区别?</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item elem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 向栈中添加元素</span></span><br><span class="line">  Node oldFirst = first;</span><br><span class="line">  <span class="comment">// Node first = new Node();           // bug</span></span><br><span class="line">  first = <span class="keyword">new</span> Node();                   <span class="comment">// ok: why? 与上一行的区别</span></span><br><span class="line">  first.next = oldFirst;</span><br><span class="line">  first.item = elem;</span><br><span class="line">  ++N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一行导致, first对象指向null, 而下一行的first != null</p>
<hr>
<h2 id="重新在push方法种进行debug后"><a href="#重新在push方法种进行debug后" class="headerlink" title="重新在push方法种进行debug后"></a>重新在push方法种进行debug后</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item elem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 向栈中添加元素</span></span><br><span class="line">  Node oldFirst = first;</span><br><span class="line">  <span class="comment">// Node first = new Node();</span></span><br><span class="line">  first = <span class="keyword">new</span> Node();                   <span class="comment">// debug: why? 与上一行的区别</span></span><br><span class="line">  System.out.println(<span class="string">"first ?= null : "</span> + (first == <span class="keyword">null</span>));</span><br><span class="line">  System.out.println(<span class="string">"oldFirst ?= null : "</span> + (oldFirst == <span class="keyword">null</span>));</span><br><span class="line">  first.next = oldFirst;</span><br><span class="line">  first.item = elem;</span><br><span class="line">  ++N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空链表push两次:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java Stack</span><br><span class="line">first ?= <span class="keyword">null</span> : <span class="keyword">false</span></span><br><span class="line">oldFirst ?= <span class="keyword">null</span> : <span class="keyword">true</span></span><br><span class="line">first ?= <span class="keyword">null</span> : <span class="keyword">false</span></span><br><span class="line">oldFirst ?= <span class="keyword">null</span> : <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item elem)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 向栈中添加元素</span></span><br><span class="line">  Node oldFirst = first;</span><br><span class="line">  Node first = <span class="keyword">new</span> Node();</span><br><span class="line">  <span class="comment">// first = new Node();                   // debug: why? 与上一行的区别</span></span><br><span class="line">  System.out.println(<span class="string">"first ?= null : "</span> + (first == <span class="keyword">null</span>));</span><br><span class="line">  System.out.println(<span class="string">"oldFirst ?= null : "</span> + (oldFirst == <span class="keyword">null</span>));</span><br><span class="line">  first.next = oldFirst;</span><br><span class="line">  first.item = elem;</span><br><span class="line">  ++N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空链表push两次:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java Stack</span><br><span class="line">first ?= <span class="keyword">null</span> : <span class="keyword">false</span></span><br><span class="line">oldFirst ?= <span class="keyword">null</span> : <span class="keyword">true</span></span><br><span class="line">first ?= <span class="keyword">null</span> : <span class="keyword">false</span></span><br><span class="line">oldFirst ?= <span class="keyword">null</span> : <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="问题更进一步"><a href="#问题更进一步" class="headerlink" title="问题更进一步"></a>问题更进一步</h2><p>因此, 这两种写法的区别就在于:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node oldFirst = first;       <span class="comment">// oldFirst指向first对象的引用</span></span><br><span class="line">Node first = <span class="keyword">new</span> Node();     <span class="comment">// first对象被重新构造, oldFirst指向null</span></span><br><span class="line">first.next = oldFirst;</span><br></pre></td></tr></table></figure></p>
<p>此时, 如果oldFirst指向null的话, 将oldFirst作为first的后继, 是不符合我的原意的。</p>
<p>正确的写法是:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node oldFirst = first;     <span class="comment">// 只是用来保存first对象的引用</span></span><br><span class="line">first = <span class="keyword">new</span> Node();        <span class="comment">// first指向新的引用对象</span></span><br><span class="line">first.next = oldFirst;     <span class="comment">// first.next结点对象指向oldFirst的引用</span></span><br></pre></td></tr></table></figure></p>
<p>但为什么既然<br>oldFirst -&gt; 原来的first对象引用<br>first-&gt;新的对象<br>oldFirst ?-&gt; 新的结点对象     // why?</p>
<p>如何oldFirst指向新的结点对象的话, 那么对first赋值新的后继, 是永远只能赋值给它自己本身的。。</p>
]]></content>
      
        
        <tags>
            
            <tag> 算法, Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中对String对象赋值]]></title>
      <url>/2018/08/07/20180807/</url>
      <content type="html"><![CDATA[<p>在学习《算法》的时候, P42中提到<br><code>赋值语句不会创建新的对象, 而只是创建另一个指向某个已经存在的对象的引用</code><br>并且,<br><code>在Java中, 所有的非原始数据类型都是对象, 包括数组</code></p>
<p>Java中原始的数据类型有: byte，short，int，long，char，float，double和boolean。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这些基本类型可以分为四组：</span><br><span class="line"></span><br><span class="line">整数 - 包括：byte，short，int和long，用于整数有符号数字。</span><br><span class="line">浮点数 - 包括float和double，表示具有分数精度的数字。</span><br><span class="line">字符 - 包括字符，表示字符集中的符号，如字母和数字。</span><br><span class="line">布尔(Boolean) - 此组包括布尔值，它是表示 true/false 值的特殊类型。</span><br></pre></td></tr></table></figure>
<hr>
<p>回到刚才的问题上, 但在练习中出现了如下代码, </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrintString_04.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintString_04</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String string1 = new String("hello");</span></span><br><span class="line">    String string1 = <span class="string">"hello"</span>;</span><br><span class="line">    String string2 = string1;    <span class="comment">// string2是string1的引用?</span></span><br><span class="line">    string2 = <span class="string">"world"</span>;           <span class="comment">// 修改string2, string1为何不发生改变？</span></span><br><span class="line">    StdOut.println(string1);</span><br><span class="line">    StdOut.println(string2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String string1 = "hello";</span></span><br><span class="line"><span class="comment">String string2 = string1;    // string2确实是指向string1的引用</span></span><br><span class="line"><span class="comment">string2 = "world";           // 创建新的对象"wolrd", 此时string2指向新对象的引用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><span style="corlor:red">Java中的String对象不可变, 对对象赋值是指向等号右边对象的引用, 但对String对象赋值时, 等号右边的双引号中的字符串, 实际上是新创建了一个对象, 指向了新对象的引用。</span></p>
<p>主要困惑我的地方，一开始没看清楚String和42页左下角Counter对象在赋值时候的区别。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter c1 = <span class="keyword">new</span> Counter(<span class="string">"ones"</span>);</span><br><span class="line">c1.increment();</span><br><span class="line">Counter c2 = c1;</span><br><span class="line">c2.increment();</span><br><span class="line">StdOut.println(c1);</span><br></pre></td></tr></table></figure></p>
<p>那段代码的第三行,<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Count c2 = c1;   <span class="comment">// c1是不是创建新的对象的，c2指向的就是c1的地址</span></span><br></pre></td></tr></table></figure></p>
<p>而<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string2 = &quot;world&quot;;  // 看似差不多, 实际上&quot;world&quot;是个新对象, string2指向新对象</span><br></pre></td></tr></table></figure></p>
<p>目前, 因为String的不变性, 我暂时把String理解成和原始数据类型一样来操作, 就可以了.</p>
<p>ref:<br><a href="https://blog.csdn.net/ilvest/article/details/64904520" target="_blank" rel="noopener">https://blog.csdn.net/ilvest/article/details/64904520</a><br><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Java, String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置jdk环境和classpath]]></title>
      <url>/2018/08/06/config-jdk-path/</url>
      <content type="html"><![CDATA[<p>学《Algorithms》这本书的时候, 教材有一套自己的标准库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Getting started. To use this class, you must have StdIn.class in your Java classpath.</span><br><span class="line">If you used our autoinstaller, you should be all set. </span><br><span class="line">Otherwise, either download stdlib.jar and add to your Java classpath or download StdIn.java and put a copy in your working directory.</span><br></pre></td></tr></table></figure></p>
<p>ref:<a href="https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdIn.html" target="_blank" rel="noopener">https://introcs.cs.princeton.edu/java/stdlib/javadoc/StdIn.html</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -l /usr/bin/java</span><br><span class="line">lrwxr-xr-x  1 root  wheel  74 Jun 17 16:18 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</span><br></pre></td></tr></table></figure>
<p>这个只是替身路径, Go to这个路径, 展开后在<br><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home</code>找到真实路径</p>
<p>编辑~/.bash_profile中(我的是这个)<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home <span class="comment">#jdk安装路径   </span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span> </span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/stdlib.jar</span><br></pre></td></tr></table></figure></p>
<p>需要把从《Algorithms》上下载下来的stdlib.jar放入JAVA_HOME的lib文件中.</p>
<p>保存并<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Java, 配置, Mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1033. 旧键盘打字(20)-PAT乙级]]></title>
      <url>/2018/08/04/PAT-basic-1033/</url>
      <content type="html"><![CDATA[<h2 id="1033-旧键盘打字-20-（20-point-s-）"><a href="#1033-旧键盘打字-20-（20-point-s-）" class="headerlink" title="1033 旧键盘打字(20)（20 point(s)）"></a>1033 旧键盘打字(20)（20 point(s)）</h2><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在2行中分别给出坏掉的那些键、以及应该输入的文字。<br>其中对应英文字母的坏键以大写给出；<br>每段文字是不超过10^5^个字符的串。<br>可用的字符包括字母[a-z, A-Z]、数字0-9、以及下划线“_”（代表空格）、“,”、“.”、“-”、“+”（代表上档键）。<br>题目保证第2行输入的文字串非空。</p>
<p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>7+IE.<br>7_This_is_a_test.</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>_hs_s_a_tst</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>只有打出和打不出两种情况。<br>打不出分成: 数字字符对应, 英文字符 对应 坏键大写, ‘+’导致所有大写字符都打不出.<br>每次输入一个字符去和坏键对比, 打印出ok的字符</p>
<p>case2 error:</p>
<p>没有一个字符能被打出的情况<br>abcd<br>abcd</p>
<p>+<br>+</p>
<p>+<br>aabb22BSa2</p>
<p>排除不可用字母 <span style="color:red"> 这是我想到的一个边界情况, 不可用字符需要被当作无效输入跳过的 </span><br>abc<br>a\bsd_\,</p>
<p>debug case2: 第一行 为空 的情况!! <span style="color:red">怎么也没想到是第一行空, 也就是没有损坏键的情况</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入如下:</span><br><span class="line"></span><br><span class="line">abcd</span><br><span class="line">输出:</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// debug case 2: 可用字符就这么几个 -&gt; 不是这个原因</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_ok</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="string">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (<span class="string">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'Z'</span>)</span><br><span class="line">      || (<span class="string">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">      || (ch == <span class="string">','</span> || ch == <span class="string">'.'</span> || ch == <span class="string">'-'</span> || ch == <span class="string">'+'</span> || ch == <span class="string">'_'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bad, input;</span><br><span class="line">  getline(<span class="built_in">cin</span>, bad); <span class="built_in">cin</span> &gt;&gt; input;  <span class="comment">// debug: 改用空行</span></span><br><span class="line">  <span class="comment">// cin &gt;&gt; bad &gt;&gt; input;           // case2: 通不过的原因, 第一行可能是空行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_ok(input[i])) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bad.length(); j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input[i] == bad[j]) &#123;ok = <span class="number">0</span>; <span class="keyword">break</span>;&#125;   <span class="comment">// 直接对应相等</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalpha</span>(input[i]) &amp;&amp; (<span class="built_in">toupper</span>(input[i]) == bad[j]))  &#123;</span><br><span class="line">        ok = <span class="number">0</span>; <span class="keyword">break</span>;       <span class="comment">// 字符i是字母, 转成大写对应相等</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bad[j] == <span class="string">'+'</span> &amp;&amp; <span class="built_in">isupper</span>(input[i])) &#123;</span><br><span class="line">        ok = <span class="number">0</span>; <span class="keyword">break</span>;       <span class="comment">// 坏键是+, 对应i是大写</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) <span class="built_in">cout</span> &lt;&lt; input[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1032. 挖掘机技术哪家强(20)-PAT乙级]]></title>
      <url>/2018/08/04/PAT-basic-1032/</url>
      <content type="html"><![CDATA[<h2 id="1032-挖掘机技术哪家强-20"><a href="#1032-挖掘机技术哪家强-20" class="headerlink" title="1032 挖掘机技术哪家强(20)"></a>1032 挖掘机技术哪家强(20)</h2><p>为了用事实说明挖掘机技术到底哪家强，PAT组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在第1行给出不超过10^5^的正整数N，即参赛人数。<br>随后N行，每行给出一位参赛者的信息和成绩，<br>包括其所代表的学校的编号（从1开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>2 150</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>思路: 用数组存各个学校的总分, 计算完成之后, 得出总分最高的索引和总分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">int</span> scores[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, max_i = <span class="number">-1</span>, max_score = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// memset(scores, 0, sizeof(scores));   // 这句造成编译错误</span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j, tmp_s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; tmp_s;</span><br><span class="line">    scores[j] += tmp_s;</span><br><span class="line">    <span class="keyword">if</span> (scores[j] &gt; max_score) &#123; max_i = j; max_score = scores[j];&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max_i &lt;&lt; <span class="string">" "</span> &lt;&lt; max_score &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1027. 打印沙漏(20)-PAT乙级]]></title>
      <url>/2018/08/02/PAT-basic-1027/</url>
      <content type="html"><![CDATA[<h2 id="1027-打印沙漏-20"><a href="#1027-打印沙漏-20" class="headerlink" title="1027 打印沙漏(20)"></a>1027 打印沙漏(20)</h2><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure></p>
<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>19 *</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>S(a) = 1, 3, 5,  7, 9,<br>S(b) = 1, 7, 17 …<br>当n的值越过表b的某值时, 对应的星号的一种情况, 例如在[7, 17)都是不算1, 上下各两行.<br>因此只要计算前x项奇数*2+1的总和.</p>
<p>题中n&lt;=1000,</p>
<p>(1+n) * (n/2)/2 = 500;<br>x = 31       (实际上我的x是调试出来的 :b)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算前31项奇数之和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n; <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;n, &amp;ch);</span><br><span class="line">  <span class="keyword">int</span> i, j = <span class="number">1</span>, sum = <span class="number">1</span>, p;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">    j += <span class="number">2</span>;</span><br><span class="line">    sum += j*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) &#123;p = n - (sum-(j*<span class="number">2</span>)); <span class="keyword">break</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> line = i--;</span><br><span class="line">  <span class="comment">// 上打印line行, 下打印line-1行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = line; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; line-i; j++) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>+i*<span class="number">2</span>; j++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= line; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; line-i; j++)  <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>+i*<span class="number">2</span>; j++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1026. 程序运行时间（20)-PAT乙级]]></title>
      <url>/2018/08/02/PAT-basic-1026/</url>
      <content type="html"><![CDATA[<h2 id="1026-程序运行时间-15"><a href="#1026-程序运行时间-15" class="headerlink" title="1026 程序运行时间(15)"></a>1026 程序运行时间(15)</h2><p>要获得一个C语言程序的运行时间，常用的方法是调用头文件time.h，其中提供了clock()函数，可以捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。<br>同时还有一个常数CLK_TCK，给出了机器时钟每秒所走的时钟打点数。<br>于是为了获得一个函数f的运行时间，我们只要</p>
<p>在调用f之前先调用clock()，获得一个时钟打点数C1；<br>在f执行完成后再调用clock()，获得另一个时钟打点数C2；<br>两次获得的时钟打点数之差(C2-C1)就是f运行所消耗的时钟打点数，<br>再除以常数CLK_TCK，就得到了以秒为单位的运行时间。</p>
<p>这里不妨简单假设常数CLK_TCK为100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在一行中顺序给出2个整数C1和C2。注意两次获得的时钟打点数肯定不相同，即C1 &lt; C2，并且取值在[0, 10^7^]。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在一行中输出被测函数运行的时间。运行时间必须按照“hh:mm:ss”（即2位的“时:分:秒”）格式输出；不足1秒的时间四舍五入到秒。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>123 4577973</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>12:42:59</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>时分秒转换问题</p>
<p>根据打点数之差, CLK得到秒, 将秒转化为hh:mm:ss, 三次除以60(错误)<br>case 1通不过.</p>
<p>清晰的思路: 计算得到总共多少秒, hh:总秒数/3600取整, mm:剩余秒数/60取整, ss:剩余秒数四舍五入</p>
<p><span style="color:red">这种看似简单的题目, 一旦出现没有预计到的问题, 容易东拼西凑的去完成.<br>因此刷题的时候还是先想清楚算法思路, 再开始动手, 更重要的是要注重数据结构, 别一味的铺张代码</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> c1, c2;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;c1, &amp;c2);</span><br><span class="line">  <span class="keyword">double</span> c = (c2-c1) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> h, m, s;</span><br><span class="line">  h = c/<span class="number">3600</span>;</span><br><span class="line">  c = c-h*<span class="number">3600</span>;</span><br><span class="line">  m = c/<span class="number">60</span>;</span><br><span class="line">  c = c-m*<span class="number">60</span>;</span><br><span class="line">  s = <span class="built_in">floor</span>(c+<span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>, h, m, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也贴一下, 之前错误的版本。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> tm[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CT = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> c1, c2;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;c1, &amp;c2);</span><br><span class="line">  <span class="keyword">double</span> s = (c2 - c1) / CT;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">int</span> hh, mm, ss;</span><br><span class="line">  hh = s/<span class="number">3600</span>;</span><br><span class="line">  mm = (s/<span class="number">3600</span>-hh)*<span class="number">3600</span>/<span class="number">60</span>;</span><br><span class="line">  ss = <span class="built_in">floor</span>(((s/<span class="number">3600</span>-hh)*<span class="number">3600</span>/<span class="number">60</span> - mm) * <span class="number">60</span> + <span class="number">0.5</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>, hh, mm, ss);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1024. 科学计数法（20)-PAT乙级]]></title>
      <url>/2018/08/02/PAT-basic-1024/</url>
      <content type="html"><![CDATA[<h2 id="1024-科学计数法-20-（20-point-s-）"><a href="#1024-科学计数法-20-（20-point-s-）" class="headerlink" title="1024 科学计数法 (20)（20 point(s)）"></a>1024 科学计数法 (20)（20 point(s)）</h2><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式[+-][1-9]”.”[0-9]+E[+-][0-9]+，即数字的整数部分只有1位，小数部分至少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出。</p>
<p>现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，并保证所有有效位都被保留。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个输入包含1个测试用例，即一个以科学计数法表示的实数A。该数字的存储长度不超过9999字节，且其指数的绝对值不超过9999。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每个测试用例，在一行中按普通数字表示法输出A，并保证所有有效位都被保留，包括末尾的0。</p>
<h2 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h2><p>+1.23400E-03</p>
<h2 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h2><p>0.00123400</p>
<h2 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h2><p>-1.2E+10</p>
<h2 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h2><p>-12000000000</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>(可最后用前面计算出的数值, 配合小数点拼出了一个string, 这种做法十分不满意, 需要重新做一遍)<br>第一个正负号作为输出时, +不输出, -输出负作为开头,<br>把符号和E中间的数组放入字符串<br>E后符号-, 小数点向左移动位置, 整数部分数字个数 in<br>  符号+, 小数点向右移动位置, 小数部分数字个数 fn</p>
<p>符号后字符串转化成整数, syb_n,</p>
<p>第二个[+-]决定, back/front, fn/in, 小数点左移/右移</p>
<p>flag == 0:<br>-1.23E+03   fn=2, syb_n=3, 末尾添1个0<br>-1.230<br>-1.2E+10    fn=1, syb_n=10, back=syb_n-fn=9  push_back 9个0, .右移syb_n</p>
<p>-1.234E+03  fn=3, syb_n=3，末尾添入0个0 syb_n-fn&gt;0添syb-n个0<br>-1.234</p>
<p>flag == 1;<br>+17.56E-01  in=2, syb_n=1, 1-2+1=0 不添0, 小数点左移1位  添入几个0 syb_n-in+1 &lt;= 0 不添<br>+17.56E-02  in=2, syb_n=2, 2-2+1=0, 添1个0 小数点左移2位  front=sys_n-in+1, .左移syb_n</p>
<p>*/</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  c = getchar();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">'-'</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">  <span class="built_in">string</span> s;     <span class="comment">// 数组和小数点部分</span></span><br><span class="line">  <span class="keyword">int</span> in = <span class="number">0</span>, fn = <span class="number">0</span>, ok = <span class="number">0</span>;   <span class="comment">// 科学计数法的整数和小数部分个数, 转换标示</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) &amp;&amp; c != <span class="string">'E'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;ok = <span class="number">1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">    s.push_back(c);</span><br><span class="line">    ok ? fn++ : in++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读第二个正负号</span></span><br><span class="line">  c = getchar();</span><br><span class="line">  <span class="keyword">int</span> flag = (c == <span class="string">'+'</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 读syb_n字符</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; syb_v;</span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) &amp;&amp; (c != <span class="string">'\n'</span>) &amp;&amp; (c != <span class="string">'\r'</span>)) &#123;</span><br><span class="line">    syb_v.push_back(c - <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算syb_n</span></span><br><span class="line">  <span class="keyword">int</span> syb_n = <span class="number">0</span>, k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = syb_v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    syb_n += k * syb_v[i];</span><br><span class="line">    k *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> front = syb_n-in+<span class="number">1</span>, back = syb_n-fn;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (front &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"0."</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; front<span class="number">-1</span>; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (back &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> len = s.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == len+back) <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; back; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1020. 月饼 (25)-PAT乙级]]></title>
      <url>/2018/08/02/PAT-basic-1020/</url>
      <content type="html"><![CDATA[<h2 id="1020-月饼-25-（25-point-s-）"><a href="#1020-月饼-25-（25-point-s-）" class="headerlink" title="1020 月饼 (25)（25 point(s)）"></a>1020 月饼 (25)（25 point(s)）</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p>
<p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>3 20<br>18 15 10<br>75 72 45<br>输出样例：</p>
<p>94.50</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>计算各种月饼每吨的售价, 优先每吨售价最高的月饼填满需求, 剩下的用售价次高的填满<br>采用优先队列, dq放每个月饼结点, 价格越高结点会被排在更前面</p>
<p><span style="color:red">注意一下测试点3(case 3)通不过的情况, 如果都供应完了, 还没达到市场需求的情况, 按当前供应量来计算价格</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cake</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> num, tot;</span><br><span class="line">  <span class="keyword">double</span> each_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Cake c1, <span class="keyword">const</span> Cake c2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.each_d &lt;= c2.each_d;     <span class="comment">// 每吨的价格越高权重越高</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Cake&gt; cakes;</span><br><span class="line">priority_queue&lt;Cake, <span class="built_in">vector</span>&lt;Cake&gt;, cmp &gt; dq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, D;   <span class="comment">// 种类数和市场需求</span></span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; D;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    Cake tmp_c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tmp_c.num;</span><br><span class="line">    cakes.push_back(tmp_c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cakes[i].tot;</span><br><span class="line">    cakes[i].each_d = cakes[i].tot / cakes[i].num;</span><br><span class="line">    dq.push(cakes[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> now_d = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// debug case3: 如果都供应完了, 还没达到市场需求的情况</span></span><br><span class="line">    <span class="keyword">if</span> (dq.empty()) <span class="keyword">break</span>;</span><br><span class="line">    Cake cmax = dq.top();</span><br><span class="line">    <span class="keyword">if</span> (D - now_d &gt;= cmax.num) &#123;   <span class="comment">// 如果需求量比当前最有优价格的供货量大</span></span><br><span class="line">      now_d += cmax.num;</span><br><span class="line">      ans += cmax.each_d * cmax.num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 只需要提供一部分</span></span><br><span class="line">      ans += (D - now_d) * cmax.each_d;</span><br><span class="line">      now_d = D;    <span class="comment">// 供应部分后, 满足市场需求</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dq.pop();   <span class="comment">// 队首月饼供应完毕</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1019. 数字黑洞（20)-PAT乙级]]></title>
      <url>/2018/08/02/PAT-basic-1019/</url>
      <content type="html"><![CDATA[<h2 id="1019-数字黑洞-20"><a href="#1019-数字黑洞-20" class="headerlink" title="1019 数字黑洞 (20)"></a>1019 数字黑洞 (20)</h2><p>给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。</p>
<p>例如，我们从6767开始，将得到</p>
<p>7766 - 6677 = 1089\ 9810 - 0189 = 9621\ 9621 - 1269 = 8352\ 8532 - 2358 = 6174\ 7641 - 1467 = 6174\ … …</p>
<p>现给定任意4位正整数，请编写程序演示到达黑洞的过程。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入给出一个(0, 10000)区间内的正整数N。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。</p>
<h2 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h2><p>6767</p>
<h2 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h2><p>7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174</p>
<h2 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h2><p>2222</p>
<h2 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h2><p>2222 - 2222 = 0000</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路:<br>模拟, 需要递减sort, 再递增排序<br>字符串转整数用于计算, 整数转字符串用于判断和表示<br>后来才记起来c++有 std::stoi/stol/stoll函数..<br>以及c++11新出的std::to_string()函数;</p>
<p><span style="color:red">最近刷题总是拿捏不好什么时候用c, 什么时候用c++, 这个问题还需要做题和看更多代码来得出一些心得。</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_str1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> a, <span class="keyword">const</span> <span class="keyword">char</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt;= b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_str2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> a, <span class="keyword">const</span> <span class="keyword">char</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt;= b;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">convert_int</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从(末尾*10+前一位)*10</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">string</span>::iterator p = s.end()<span class="number">-1</span>; p &gt;= s.begin(); p--) &#123;</span><br><span class="line">    ans += (*p - <span class="string">'0'</span>) * i;</span><br><span class="line">    i *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cout &lt;&lt; ans &lt;&lt; "\n";</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert_str</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 转成4位字符串,</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">ans_s</span><span class="params">(<span class="number">4</span>, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> (h) &#123;</span><br><span class="line">    ans_s[i--] = h % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">    h /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s1;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">  s1 = convert_str(convert_int(s1));   <span class="comment">// debug: 0~999需要处理</span></span><br><span class="line">  <span class="built_in">string</span> s2 = s1;</span><br><span class="line">  sort(s1.begin(), s1.end(), cmp_str1);</span><br><span class="line">  sort(s2.begin(), s2.end(), cmp_str2);</span><br><span class="line">  <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; s1 &lt;&lt; <span class="string">" = 0000"</span> &lt;&lt; <span class="string">"\n"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (s1 != <span class="string">"6174"</span>) &#123;</span><br><span class="line">    s2 = s1;</span><br><span class="line">    sort(s1.begin(), s1.end(), cmp_str1);</span><br><span class="line">    sort(s2.begin(), s2.end(), cmp_str2);</span><br><span class="line">    <span class="keyword">int</span> d = convert_int(s1) - convert_int(s2);</span><br><span class="line">    <span class="built_in">string</span> tmp = convert_str(d);               <span class="comment">// debug:按照四位格式输出</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; s2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; tmp &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    s1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1017. A除以B（20)-PAT乙级]]></title>
      <url>/2018/07/31/PAT-basic-1017/</url>
      <content type="html"><![CDATA[<h2 id="1017-A除以B-20"><a href="#1017-A除以B-20" class="headerlink" title="1017. A除以B (20)"></a>1017. A除以B (20)</h2><p>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，<br>使得A = B * Q + R成立。</p>
<h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入在1行中依次给出A和B，中间以1空格分隔。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>在1行中依次输出Q和R，中间以1空格分隔。</p>
<h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><p>123456789050987654321 7</p>
<h2 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h2><p>17636684150141093474 3</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>思路:<br>  1, 用数组储存大整数, 模拟大整数除以1位数<br>  2, 更省空间和减少循环次数的做法: 用C++字符串读取, 模拟手动除法, 首位整数 / B, 如果得到不是0就输出, 余数*10+下一位; </p>
<p><span stype="color:red"><br>2优点在于,<br>边计算边输出;<br>首个索引与循环分开计算, 减少在循环内的判断;<br>对边界条件的定义处理在一个if语句中;<br>用string可以减少指针带来的诸多问题<br></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bs[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b, q = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, bs, &amp;b);</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(bs);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = r * <span class="number">10</span> + bs[i] - <span class="string">'0'</span>;</span><br><span class="line">    q = x / b;</span><br><span class="line">    r = x % b;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; q == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ans[cnt++] = q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123; <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]); &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" %d\n"</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> a; <span class="keyword">int</span> b;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">int</span> len = a.length();</span><br><span class="line">  <span class="keyword">int</span> f = (a[<span class="number">0</span>] - <span class="string">'0'</span>) / b;</span><br><span class="line">  <span class="keyword">if</span> ((f != <span class="number">0</span> &amp;&amp; len &gt; <span class="number">1</span>)|| len == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line">  <span class="keyword">int</span> temp = (a[<span class="number">0</span>] - <span class="string">'0'</span>) % b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    f = (temp * <span class="number">10</span> + a[i] - <span class="string">'0'</span>) / b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f;</span><br><span class="line">    temp = (temp * <span class="number">10</span> + a[i] - <span class="string">'0'</span>) % b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; temp &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> PAT, 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1018. 锤子剪刀布 (20)-PAT乙级]]></title>
      <url>/2018/07/30/PAT-basic-1018/</url>
      <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h2><p>输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><p>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>10<br>C J<br>J B<br>C B<br>B B<br>B C<br>C C<br>C B<br>J B<br>B C<br>J J</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output:"></a>Sample output:</h2><p>5 3 2<br>2 3 5<br>B B</p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h2><p>虽然考虑到了9中组合, 但写的时候思路不清晰, 甚至没有把胜出时候的手势放入数组.<br>冗杂在于<br>1, 一开始想把它放进一个struct, 但实际上只拥有六个整型, 为什么不放到数组里?<br>2, getMax函数纠结了好久, 实际有更为简单的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">score</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> w = <span class="number">0</span>, f = <span class="number">0</span>, e = <span class="number">0</span>;    <span class="comment">// 胜负平</span></span><br><span class="line">  <span class="keyword">int</span> C = <span class="number">0</span>, J = <span class="number">0</span>, B = <span class="number">0</span>;    <span class="comment">// 胜的时候出的手势</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> motion[<span class="number">4</span>] = <span class="string">"BCJ"</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// a,b,c谁最大, 返回0,1,2; 并列返回字典序列</span></span><br><span class="line">  x.clear();</span><br><span class="line">  <span class="keyword">int</span> m;</span><br><span class="line">  m = max(a, b); m = max(m, c);</span><br><span class="line">  <span class="keyword">if</span> (m == a) x.push_back(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (m == b) x.push_back(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (m == c) x.push_back(<span class="number">2</span>);</span><br><span class="line">  sort(x.begin(), x.end());</span><br><span class="line">  <span class="keyword">return</span> motion[x[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>], b[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  score jia, yi;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T) == <span class="number">1</span> &amp;&amp; T) &#123;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, a, b);</span><br><span class="line">      <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">'J'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'J'</span>) &#123; jia.e++; yi.e++; &#125;    <span class="comment">// 平局</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'C'</span>) &#123; jia.f++; yi.w++; yi.C++; &#125;  <span class="comment">// 乙胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'B'</span>) &#123; jia.w++; yi.f++; jia.J++; &#125;  <span class="comment">// jia胜</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'C'</span>) &#123; jia.e++; yi.e++; &#125;    <span class="comment">// 平局</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'J'</span>) &#123; jia.w++; yi.f++; jia.C++; &#125;  <span class="comment">// jia胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'B'</span>) &#123; yi.w++; jia.f++; yi.B++; &#125;  <span class="comment">// yi胜</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">'B'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'B'</span>) &#123; jia.e++; yi.e++; &#125;    <span class="comment">// 平局</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'J'</span>) &#123; jia.f++; yi.w++; yi.J++; &#125;  <span class="comment">// yi胜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">'C'</span>) &#123; yi.f++; jia.w++; jia.B++; &#125;  <span class="comment">// jia胜</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, jia.w, jia.e, jia.f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, yi.w, yi.e, yi.f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, getMax(jia.B, jia.C, jia.J));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %c\n"</span>, getMax(yi.B, yi.C, yi.J));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h2><p>将字符转换为整数进行计算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00  平   10 甲   20 乙</span><br><span class="line">01  乙   11 平   21 甲</span><br><span class="line">02  甲   12 乙   22 平</span><br></pre></td></tr></table></figure></p>
<p>可以发现, -2, 1时, 甲胜;  -1, 2时, 甲负<br>甲乙胜负可以转换, 平局可以通过总局数得到, 因此只需要记录甲的胜负</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_c_i = &#123;&#125;;    <span class="comment">// 将字符转换成整数, 用于索引和计算</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[<span class="number">4</span>] = <span class="string">"BCJ"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="keyword">int</span> jia[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;, yi[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T) == <span class="number">1</span> &amp;&amp; T) &#123;</span><br><span class="line">    s_c_i[<span class="string">'J'</span>] = <span class="number">0</span>, s_c_i[<span class="string">'C'</span>] = <span class="number">1</span>, s_c_i[<span class="string">'B'</span>] = <span class="number">2</span>;  <span class="comment">// 将字符转换成整数用于计算</span></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>, f = <span class="number">0</span>, ct = T;                        <span class="comment">// 甲胜利, 失败, 总局数</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">      <span class="keyword">char</span> sa, sb;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">      <span class="keyword">int</span> d = s_c_i[sa] - s_c_i[sb];</span><br><span class="line">      <span class="keyword">if</span> (d == <span class="number">-2</span> || d == <span class="number">1</span>) &#123;    <span class="comment">// 甲胜</span></span><br><span class="line">        w++; jia[s_c_i[sa]]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">-1</span> || d == <span class="number">2</span>) &#123;   <span class="comment">// 甲负, 乙胜</span></span><br><span class="line">        f++; yi[s_c_i[sb]]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, w, ct-w-f, f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, f, ct-w-f, w);</span><br><span class="line">    <span class="keyword">int</span> jiamax = (jia[<span class="number">0</span>] &gt;= jia[<span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    jiamax = (jia[jiamax] &gt;= jia[<span class="number">2</span>]) ? jiamax : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> yimax = (yi[<span class="number">0</span>] &gt;= yi[<span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    yimax = (yi[yimax] &gt;= yi[<span class="number">2</span>]) ? yimax : <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[jiamax]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %c\n"</span>, str[yimax]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h2><p><span style="color:red"><br>只记录甲的胜负, 计算出乙胜负平; 六种排列组合; 三个计数器放在数组中, 用 ?:判断哪个位置计数最高<br>能用数组解决的不用struct的, 能用原子类型解决的不用数组;<br></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[<span class="number">4</span>] = &#123;<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'J'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="keyword">int</span> win = <span class="number">0</span>, fail = <span class="number">0</span>;   <span class="comment">// 只记录甲的胜负</span></span><br><span class="line">  <span class="keyword">int</span> winjia[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;, winyi[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">  <span class="keyword">int</span> ct = T;</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">char</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 六种排列组合</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">'B'</span> &amp;&amp; b == <span class="string">'C'</span>) &#123;</span><br><span class="line">      win++; winjia[<span class="number">0</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'B'</span> &amp;&amp; b == <span class="string">'J'</span>) &#123;</span><br><span class="line">      fail++; winyi[<span class="number">2</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'C'</span> &amp;&amp; b == <span class="string">'B'</span>) &#123;</span><br><span class="line">      fail++; winyi[<span class="number">0</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'C'</span> &amp;&amp; b == <span class="string">'J'</span>) &#123;</span><br><span class="line">      win++; winjia[<span class="number">1</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'J'</span> &amp;&amp; b == <span class="string">'B'</span>) &#123;</span><br><span class="line">      win++; winjia[<span class="number">2</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'J'</span> &amp;&amp; b == <span class="string">'C'</span>) &#123;</span><br><span class="line">      fail++; winyi[<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, win, ct-win-fail, fail);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, fail, ct-win-fail, win);</span><br><span class="line">  <span class="keyword">int</span> jiamax = (winjia[<span class="number">0</span>] &gt;= winjia[<span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  jiamax = (winjia[jiamax] &gt;= winjia[<span class="number">2</span>]) ? jiamax : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> yimax = (winyi[<span class="number">0</span>] &gt;= winyi[<span class="number">1</span>]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  yimax = (winyi[yimax] &gt;= winyi[<span class="number">2</span>]) ? yimax : <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%c"</span>, str[jiamax]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" %c\n"</span>, str[yimax]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[算法学习安排]]></title>
      <url>/2018/07/30/algorithm-learning/</url>
      <content type="html"><![CDATA[<h2 id="我的安排"><a href="#我的安排" class="headerlink" title="我的安排"></a>我的安排</h2><p>水题-&gt;数据结构-&gt;专项</p>
<p>一, 算法竞赛入门经典 07.12</p>
<p>二, 《数据结构》严蔚敏, 理解+实现, 07.30<br>每一种结构都找题刷,leetcode(列的比较清晰), 程序员面试经典(可以换个角度思考)</p>
<blockquote>
<ul>
<li>1.基础<br>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）<br>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）<br>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）<br>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）<br>二分查找（一般会深入，如寻找数组总和为K的两个数字）<br>两个栈实现队列。<br>图（深度广度优先遍历、单源最短路径、最小生成树）<br>动态规划问题。</li>
<li>2, 深入<br>红黑树性质<br>分治法和动态规划的区别<br>计算时间复杂度<br>二叉树和哈希表查找的时间复杂度</li>
</ul>
</blockquote>
<p>理解: 可视化数据结构帮助理解:<a href="https://visualgo.net/en" target="_blank" rel="noopener">https://visualgo.net/en</a></p>
<p>三, 《algorithm-4th》 08.06<br>网课, 课后作业,<a href="https://www.coursera.org/learn/algorithms-part1/home/welcome" target="_blank" rel="noopener">https://www.coursera.org/learn/algorithms-part1/home/welcome</a><br>小橙书后的作业, 只做网上列出部分 <a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">https://algs4.cs.princeton.edu/home/</a></p>
<p>四, 配合刷题<br>程序员面试金典, 配合牛客网练习<a href="https://www.nowcoder.com/ta/cracking-the-coding-interview" target="_blank" rel="noopener">https://www.nowcoder.com/ta/cracking-the-coding-interview</a><br>PAT, HDOJ, POJ, Leedcode中题目, 专题.</p>
<p><code>----2018.07.30----</code></p>
<h2 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h2><p>下面是引用左程云大佬&lt;&lt;左程云：程序员该如何学习算法？&gt;&gt;的建议:</p>
<p>对于算法，我给大家的建议：</p>
<p>先找到线团，然后进入线团里学着怎么玩。为了进入线团，需要先把基础知识掌握好。《算法和数据结构》（教材），你一定要看完+理解。这里面讲的都是不能再基础的东西了，觉得讲得不好，自己搜维基百科。没办法，如果坚持不下来，你后面就受罪去吧。</p>
<p>然后有一些很经典的书可以迅速让你进入状态，比如我这本《程序员代码面试指南》，还有《剑指offer》，配合在线练习：<a href="https://www.nowcoder.com/ta/coding-interviews，" target="_blank" rel="noopener">https://www.nowcoder.com/ta/coding-interviews，</a><br>《程序员面试金典》配合在线练习：<a href="https://www.nowcoder.com/ta/cracking-the-coding-interview，这些好书。" target="_blank" rel="noopener">https://www.nowcoder.com/ta/cracking-the-coding-interview，这些好书。</a><br>我在牛客网上还有一个针对小白的扫盲的课程<a href="https://www.nowcoder.com/courses/semester/algorithm。" target="_blank" rel="noopener">https://www.nowcoder.com/courses/semester/algorithm。</a></p>
<p>对于线上刷题平台的题目，先不找解答，先自己实现，实现的多烂，复杂度多差，都坚持写完。然后分析出复杂度。接下来去网上找答案，看到复杂度和你一样或比你低的，直接略过。看到比你好的，重点看，一定要理解，然后分析为什么比你的好，如果你真的理解了，你一定能找到别人优化的点。这个过程可能是最奇妙的过程，不要给自己太大压力，这个过程其实可以很欢乐，你有想法并创造出来，练习了自己的coding能力。别人有更好的实现，推翻了你的所有模型和幻想，你幻灭了，却也因此找到了让你血脉喷张方法。这个阶段看似苦，实际上其乐无穷。你在学习别人解法的过程中，又了解了很多算法和数据结构。而且你付出的每一滴汗水，都是结果导向的，可量化的，实实在在的。写写简单的测试函数就可以发现自己方法的运行时间和更好的解法就是没法比。这是一个非常培养自驱力的阶段，这是一个只追求解法更快更强的阶段。你看到很多经典的结构，你学到很多细思极妙的优化。比读那些让你吃力的书更加快乐，也能够一直启发你走下去。你苦苦寻找啊，觉得好的不能再好的方法啊，直到有一天，你突然看到一个更优的解法，相信我，你一定会一整天都在贤者时间里。</p>
<p><span style="color:red"><br><strong>刷题的方法</strong></span></p>
<p>1.实现<br>2.复杂度分析<br>3.找复杂度低的答案<br>4.对比优化的点(重点看理解):<br>(写测试函数)<br>(了解更多的算法和数据结构)<br>5.总结(每题都总结到blog)<br>(结果导向, 可量化)<br></p>
<p><span style="color:red"><strong>(刷题时候碰到新的算法:)</strong></span></p>
<p>我不建议刚开始刷题的人就直接在网络上搜集文章开始学习，因为太散了，而且需要花很多时间去鉴别正确与否。当这些内容都掌握之后，再开始在网上搜集各种各样的题，并与网友参加各种各样的讨论，会比较高效。把底子打好之后，对于专项算法的学习就得心应手了，而且会学的很快。 对于很庞大的算法，我个人的习惯是找例子来引导自己的思路，一点一点的接近算法的核心。唯一需要注意的是，一定要写代码，光看没有用的。对于经典算法的学习，大体上分成几个阶段：</p>
<p>第一阶段：对于某一个具体的算法，首先要搞清楚这个算法解决的问题是什么，可能是实现一个具体的功能，也可能是在某些方面，比如时间复杂度或者空间复杂度方面很卓越，总之搞清楚这个算法被研究出来的目的是什么。<span style="color:red">（搞清楚这种算法的接口怎么调用, 再哪些地方应用较多, 复杂度分析)</span></p>
<p>第二阶段：然后就要弄清楚这个算法的生存环境了，也就是看看你此时研究的东西是不是对别的知识有依赖，应该先把底层依赖的知识理解并掌握。这些问题都解决之后，就进入到算法本身的学习，理解一个算法是一件辛苦的事情，刚开始看必然会产生很多的困惑，比如经常会怀疑作者讲述的内容的重要性？这些内容和这个算法有什么联系呢？经常会有这种摸不着头脑的感觉，其实作者做的铺垫都是为了建立起描述算法主要内容的基础，只有接受和理解这些基础，才能逐渐触碰到算法的精髓，所以耐心是很重要的。(理解底层的理论知识, 用来描述算法的基础, 这方面我以前不太重视, 但现在要按这个方法来)<br>第三阶段：算法的主要过程看完之后，往往还是会感到困惑，主要是不知道这个过程好在哪，这就进入了下一个阶段，理解作者对这个过程在功能性或者效率卓越这件事上的解释和证明。这才真正触碰到算法最精髓的部分，也就是深度的理解算法的主要过程所带来的好处，这才是最锻炼人理解能力的地方。<span style="color:red">(理解这个算法设计巧妙的地方)</span><br>第四阶段：上面几点是算法学习阶段的过程了，接下来就是研究算法的代码实现，自己设计测试用例亲自跑一下代码，以及从代码运行时间的角度分析这个算法的优势，这也是加深对算法的理解的过程。<span style="color:red">(先理解算法的底层内容, 再动手实现代码)</span><br>第五阶段：最后是配合相应的题目练习，让自己通过题目练习的方式，会用、善用学习到的算法，并对这个算法产生一定的敏感程度，具体是指看到某些题目时，能够根据题目的特点，产生与该算法的对应，也就是具备举一反三的能力。<span style="color:red">(实现某种算法后, 用他来做题解决问题, 仍然是回到第一部, 但显然第一部的背景比这里所说的大, 这里更多的是指算法题; 通过刷这一类型的题来达到举一反三的能力)</span></p>
<hr>
<p>ref:<br><a href="https://m.nowcoder.com/discuss/61529" target="_blank" rel="noopener">https://m.nowcoder.com/discuss/61529</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[OJ题目分类]]></title>
      <url>/2018/07/30/oj-classify/</url>
      <content type="html"><![CDATA[<h2 id="HDOJ"><a href="#HDOJ" class="headerlink" title="HDOJ:"></a>HDOJ:</h2><p>模拟题, 枚举<br>1002 1004 1013 1015 1017 1020 1022 1029 1031 1033 1034 1035 1036 1037 1039 1042 1047 1048 1049 1050 1057 1062 1063 1064 1070 1073 1075 1082 1083 1084 1088 1106 1107 1113 1117 1119 1128 1129 1144 1148 1157 1161 1170 1172 1177 1197 1200 1201 1202 1205 1209 1212(大数取模) 1216（链表）1218 1219 1225 1228 1229 1230 1234 1235 1236 1237 1239 1250<br>1256 1259 1262 1263 1265 1266 1276 1279 1282 1283 1287 1296 1302 1303 1304 1305 1306 1309 1311 1314<br>复杂模拟</p>
<p>搜索，递归求解<br>1010 1016 1026 1043(双广) 1044 (BFS+DFS) 1045 1067 1072 1104 1175 1180 1195 1208 1226 1238 1240 1241 1242 1258 1271 1312 1317<br>博奕<br>1079</p>
<p>动态规划<br>1003 1024 1025 1028 1051 1058 1059 1069 1074 1078 1080 1081 1085 1087 1114 1158 1159 1160 1171 1176 1181 1203 1224 1227 1231 1244 1248 1253 1254 1283 1300</p>
<p>数学，递推，规律<br>1005 1006 1012 1014 1018 1019 1021 1023 1027 1030 1032 1038 1041 1046 1059 1060 1061 1065 1066 1071(微积分) 1097 1098 1099 1100 1108 1110 1112 1124 1130 1131 1132 1134 1141 1143 1152 1155(物理题) 1163 1165 1178 1194 1196(lowbit) 1210 1214 1200 1221 1223 1249 1261 1267 1273 1290 1291 1292 1294 1297 1313 1316<br>数论<br>1164 1211 1215 1222 1286 1299</p>
<p>计算几何<br>1086 1115 1147<br>贪心<br>1009 1052 1055 1257</p>
<p>并查集<br>1198 1213 1232 1272<br>线段树,离散化<br>1199 1255<br>图论<br>最短路相关的问题 1142 1162 1217 1301<br>二分图问题 1054 1068 1150 1151 1281<br>其他<br>1053 (huffman) 1102(MST) 1116（欧拉回路） 1233(MST) 1269（强连通）<br>数据结构<br>1103（堆+模拟）1166（数状树组）1247 1251 1285（Topol） 1298<br>汉诺塔系列<br>1207<br>最近顶点对 1007</p>
<p>1500 DP<br>1501 DP<br>1502 DP or 记忆化<br>1503 DP<br>1504 模拟<br>1505 DP<br>1506 DP<br>1507 2分匹配<br>1508 记忆化容易点<br>1509 模拟<br>1510 DP<br>1511 搜索可以过<br>1512 左偏树<br>1513 DP<br>1514 DP<br>1515 DFS<br>1516 DP<br>1517 博奕<br>1518 搜索<br>1519 DP（不确定）<br>1520 树状DP<br>1521 数学题，母函数什么的。其实都可以过<br>1522 稳定婚姻<br>1523 DP<br>1524 博弈<br>1525 博弈<br>1526 Maxflow<br>1527 博弈<br>1528 2分匹配<br>1529 简单题<br>1530 最大团<br>1531 差分约束<br>1532 Maxflow 入门题<br>1533 KM Or 最小费用流<br>1534 差分约束<br>1535 差分约束<br>1536 博弈<br>1537 模拟 加置换群的理论 CODE可以短些，其实没必要。。。<br>1538 很有意思的题目。据说是Microsoft亚洲总裁面试的题目<br>1539 搜索<br>1540 线段树<br>1541 树状数组<br>1542 离散，线段树<br>1543 线段树<br>1544 简单的<br>1545 DP <a href="http://acm.hdu.edu.cn/forum/htm_data/18/0608/2050.html" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/htm_data/18/0608/2050.html</a><br>1546 搜索<br>1547 模拟<br>1548 模拟<br>1551 2分答案<br>1553<br>1554<br>1555 简单<br>1556 技巧。数学<br>1557 搜索<br>1558 并查 + 线段判交<br>1559 DP<br>1560 减支 + 搜索<br>1561 树状DP<br>1562 暴力 between 1000 and 9999<br>1563 简单<br>1564 博弈。<br>1565 状态DP<br>1566 数学<br>1567 模拟<br>1568 大数<br>1569 最小割<br>1570 数学<br>1571 最段路<br>1572 搜索<br>1573 数学<br>1574 DP<br>1575 2分<br>1576 数论<br>1577 模拟，处理精度<br>1579 记忆化<br>1580 DP<br>1582 搜索<br>1583 模拟<br>1584 搜索<br>1585<br>1586<br>1587 简单题目<br>1591 模拟<br>1592 简单<br>1593 数学<br>1594 数学<br>1595 图论<br>1596 图论<br>1597 图论<br>1598 图论<br>1599 图论</p>
<p>基础题：1000、1001、1004、1005、1008、1012、1013、1014、1017、1019、1021、1028、1029、1032、1037、1040、1048、1056、1058、1061、1070、1076、1089、1090、1091、1092、1093、1094、1095、1096、1097、1098、1106、1108、1157、1163、1164、1170、1194、1196、1197、1201、1202、1205、1219、1234、1235、1236、1248、1266、1279、1282、1283、1302、1303、1323、1326、1330、1334、1335、1339、1390、1391、1393、1395、1397、1405、1406、1407、1408、1412、1418、1420、1465、1491、1555、1562、1563、1570、1587、1673、1678、1708、1718、1720、1785、1799、1859、1862、1877、1898、1976、1977、1985、1994、2000、2001、2002、2003、2004、2005、2006、2007、2008、2009、2010、2011、2012、2013、2014、2015、2016、2017、2018、2019、2020、2021、2022、2023、2024、2025、2026、2027、2028、2029、2030、2031、2032、2033、2034、2035、2039、2040、2042、2043、2048、2049、2051、2053、2055、2056、2057、2060、2061、2071、2073、2075、2076、2078、2081、2083、2088、2090、2092、2093、2095、2096、2097、2098、2099、2101、2103、2106、2107、2109、2113、2114、2115、2123、2131、2132、2133、2135、2136、2137、2138、2139、2143、2148、2153、2156、2161、2162、2164、2178、2186、2192、2200、2201、2212、2304、2309、2317、2401、2500、2502、2503、2504、2519、2520、2521、2523、2524、2535、2537、2539、2547、2548、2549、2550、2551、2552、2555、2560、2561、2562、2566、2567、2568、2700、2710、</p>
<p>DP：1003、1024、1029、1069、1074、1087、1114、1159、1160、1171、1176、1203、1231、1257、1260、1284、1421、1789、1978、2059、2084、2159、2191、2544、2571、2602、2709、<br>搜索：1010、1015、1016、1026、1072、1075、1175、1180、1181、1238、1239、1240、1241、1242、1253、1254、1312、1372、1548、1597、1671、1677、1728、1800、1983、2102、2141、2553、2563、2605、2612、2614、1616、2717<br>贪心：1009、1045、1049、1050、1051、1052、1257、1800、2037、2111、2124、2187、2391、2570<br>数学题：1018、1065、1071、1115、1141、1162、1212、1220、1492、1593、1701、1722、1798、1840、1999、2036、2080、2086、2089、2105、2108、2134、2303、2393、2438、2529、2547、2548、2552、2554、2601、2603、2701、<br>递推：1133、1143、1207、1249、1267、1284、1290、1297、1396、1992、1995、1996、2013、2014、2044、2045、2046、2047、2050、2064、2065、2067、2068、2070、2077、2085、2151、2154、2160、2190、2501、2512、2563、2569、2709、2716、<br>字符串：1020、1039、1043、1062、1073、1075、1088、1113、1161、1200、1251、1256、1288、1321、1328、1379、1804、1860、1982、1984、2017、2024、2025、2026、2027、2043、2052、2054、2072、2074、2087、2131、2137、2140、2163、2203、2206、2352、2500、2549、2564、2565、2567、2572、2609、2607、2707、2708、2719、2721、2723、<br>大数：1002、1042、1133、1250、1297、1715、1753、1865、2100、<br>胡搞：1022、1027、1030、1035、1128、1165、1209、1210、1215、1222、1228、1229、1230、1237、1259、1276、1286、1337、1342、1361、1370、1506、1577、1597、1702、1716、1727、1868、1870、1896、1981、1986、1987、1988、1997、1998、1999、2058、2062、2089、2090、2094、2104、2116、2117、2135、2175、2183、2184、2197、2303、2368、2370、2374、2511、2522、2527、2600、2615、2703、2711、2714、2715、2725、<br>博弈：1077、1404、1517、1524、1525、1527、1536、1564、1729、1730、1846、1847、1848、1849、1850、2147、2149、2176、2177、2188<br>母函数：1085、1171、1398、2079、2082、2110、2152、2189、2566、<br>hash：1264、1280、1425、1496、1800、2522、2600、</p>
<hr>
<h2 id="POJ"><a href="#POJ" class="headerlink" title="POJ"></a>POJ</h2><p>初期:<br>一.基本算法:<br>     (1)枚举. (poj1753,poj2965)<br>     (2)贪心(poj1328,poj2109,poj2586)<br>     (3)递归和分治法.<br>     (4)递推.<br>     (5)构造法.(poj3295)<br>     (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)<br>二.图算法:<br>     (1)图的深度优先遍历和广度优先遍历.<br>     (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)<br>        (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)<br>     (3)最小生成树算法(prim,kruskal)<br>        (poj1789,poj2485,poj1258,poj3026)<br>     (4)拓扑排序 (poj1094)<br>     (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)<br>     (6)最大流的增广路算法(KM算法). (poj1459,poj3436)<br>三.数据结构.<br>     (1)串 (poj1035,poj3080,poj1936)<br>     (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)<br>     (3)简单并查集的应用.<br>     (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)<br>        (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)<br>     (5)哈夫曼树(poj3253)<br>     (6)堆<br>     (7)trie树(静态建树、动态建树) (poj2513)<br>四.简单搜索<br>     (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)<br>     (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)<br>     (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)<br>五.动态规划<br>     (1)背包问题. (poj1837,poj1276)<br>     (2)型如下表的简单DP(可参考lrj的书 page149):<br>       1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)<br>       2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)<br>         (poj3176,poj1080,poj1159)<br>       3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)<br>六.数学<br>     (1)组合数学:<br>        1.加法原理和乘法原理.<br>        2.排列组合.<br>        3.递推关系.<br>          (POJ3252,poj1850,poj1019,poj1942)<br>     (2)数论.<br>        1.素数与整除问题<br>        2.进制位.<br>        3.同余模运算.<br>          (poj2635, poj3292,poj1845,poj2115)<br>     (3)计算方法.<br>        1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)<br>七.计算几何学.<br>     (1)几何公式.<br>     (2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)<br>     (3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)<br>         (poj1408,poj1584)<br>     (4)凸包. (poj2187,poj1113)</p>
<p>中级:<br>一.基本算法:<br>     (1)C++的标准模版库的应用. (poj3096,poj3007)<br>     (2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)<br>二.图算法:<br>     (1)差分约束系统的建立和求解. (poj1201,poj2983)<br>     (2)最小费用最大流(poj2516,poj2516,poj2195)<br>     (3)双连通分量(poj2942)<br>     (4)强连通分支及其缩点.(poj2186)<br>     (5)图的割边和割点(poj3352)<br>     (6)最小割模型、网络流规约(poj3308, )<br>三.数据结构.<br>     (1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)<br>     (2)静态二叉检索树. (poj2482,poj2352)<br>     (3)树状树组(poj1195,poj3321)<br>     (4)RMQ. (poj3264,poj3368)<br>     (5)并查集的高级应用. (poj1703,2492)<br>     (6)KMP算法. (poj1961,poj2406)<br>四.搜索<br>     (1)最优化剪枝和可行性剪枝<br>     (2)搜索的技巧和优化 (poj3411,poj1724)<br>     (3)记忆化搜索(poj3373,poj1691)</p>
<p>五.动态规划<br>     (1)较为复杂的动态规划(如动态规划解特别的施行商问题等)<br>         (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)<br>     (2)记录状态的动态规划. (POJ3254,poj2411,poj1185)<br>     (3)树型动态规划(poj2057,poj1947,poj2486,poj3140)<br>六.数学<br>     (1)组合数学:<br>        1.容斥原理.<br>        2.抽屉原理.<br>        3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).<br>        4.递推关系和母函数.<br>    (2)数学.<br>        1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)<br>        2.概率问题. (poj3071,poj3440)<br>        3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)<br>     (3)计算方法.<br>        1.0/1分数规划. (poj2976)<br>        2.三分法求解单峰(单谷)的极值.<br>        3.矩阵法(poj3150,poj3422,poj3070)<br>        4.迭代逼近(poj3301)<br>     (4)随机化算法(poj3318,poj2454)<br>     (5)杂题.<br>         (poj1870,poj3296,poj3286,poj1095)</p>
<p>七.计算几何学.<br>        (1)坐标离散化.<br>        (2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).<br>            (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)<br>        (3)多边形的内核(半平面交)(poj3130,poj3335)<br>        (4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)</p>
<p>高级:<br>一.基本算法要求:<br>      (1)代码快速写成,精简但不失风格<br>          (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)<br>      (2)保证正确性和高效性. poj3434<br>二.图算法:<br>      (1)度限制最小生成树和第K最短路. (poj1639)<br>      (2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)<br>         (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446<br>      (3)最优比率生成树. (poj2728)<br>      (4)最小树形图(poj3164)<br>      (5)次小生成树.<br>      (6)无向图、有向图的最小环<br>三.数据结构.<br>      (1)trie图的建立和应用. (poj2778)<br>      (2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法<br>          (RMQ+dfs)).(poj1330)<br>      (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的<br>          目的). (poj2823)<br>      (4)左偏树(可合并堆).<br>      (5)后缀树(非常有用的数据结构,也是赛区考题的热点).<br>         (poj3415,poj3294)<br>四.搜索<br>      (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)<br>      (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A<em>算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)<br>      (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA</em>算法. (poj3131,poj2870,poj2286)<br>五.动态规划<br>      (1)需要用数据结构优化的动态规划.<br>         (poj2754,poj3378,poj3017)<br>      (2)四边形不等式理论.<br>      (3)较难的状态DP(poj3133)<br>六.数学<br>      (1)组合数学.<br>        1.MoBius反演(poj2888,poj2154)<br>        2.偏序关系理论.<br>      (2)博奕论.<br>        1.极大极小过程(poj3317,poj1085)<br>        2.Nim问题.<br>七.计算几何学.<br>      (1)半平面求交(poj3384,poj2540)<br>      (2)可视图的建立(poj2966)<br>      (3)点集最小圆覆盖.<br>      (4)对踵点(poj2079)<br>      八.综合题.<br>      (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)</p>
<p>以及补充<br>Dp状态设计与方程总结</p>
<p>1.不完全状态记录</p>
<p><1>青蛙过河问题</1></p>
<p><2>利用区间dp<br>2.背包类问题</2></p>
<p><1> 0-1背包，经典问题</1></p>
<p><2>无限背包，经典问题</2></p>
<p><3>判定性背包问题</3></p>
<p><4>带附属关系的背包问题</4></p>
<p><5> + -1背包问题</5></p>
<p><6>双背包求最优值</6></p>
<p><7>构造三角形问题</7></p>
<p><8>带上下界限制的背包问题(012背包)<br>3.线性的动态规划问题</8></p>
<p><1>积木游戏问题</1></p>
<p><2>决斗（判定性问题）</2></p>
<p><3>圆的最大多边形问题</3></p>
<p><4>统计单词个数问题</4></p>
<p><5>棋盘分割</5></p>
<p><6>日程安排问题</6></p>
<p><7>最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)</7></p>
<p><8>方块消除游戏(某区间可以连续消去求最大效益)</8></p>
<p><9>资源分配问题</9></p>
<p><10>数字三角形问题</10></p>
<p><11>漂亮的打印</11></p>
<p><12>邮局问题与构造答案</12></p>
<p><13>最高积木问题</13></p>
<p><14>两段连续和最大</14></p>
<p><15>2次幂和问题</15></p>
<p><16>N个数的最大M段子段和</16></p>
<p><17>交叉最大数问题<br>4.判定性问题的dp(如判定整除、判定可达性等)   </17></p>
<p><1>模K问题的dp</1></p>
<p><2>特殊的模K问题，求最大(最小)模K的数</2></p>
<p><3>变换数问题<br>5.单调性优化的动态规划</3></p>
<p><1>1-SUM问题</1></p>
<p><2>2-SUM问题</2></p>
<p><3>序列划分问题(单调队列优化)<br>6.剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)</3></p>
<p><1>凸多边形的三角剖分问题</1></p>
<p><2>乘积最大问题</2></p>
<p><3>多边形游戏(多边形边上是操作符,顶点有权值)</3></p>
<p><4>石子合并(N^3/N^2/NLogN各种优化)<br>7.贪心的动态规划</4></p>
<p><1>最优装载问题</1></p>
<p><2>部分背包问题</2></p>
<p><3>乘船问题</3></p>
<p><4>贪心策略</4></p>
<p><5>双机调度问题Johnson算法<br>8.状态dp</5></p>
<p><1>牛仔射击问题(博弈类)</1></p>
<p><2>哈密顿路径的状态dp</2></p>
<p><3>两支点天平平衡问题</3></p>
<p><4>一个有向图的最接近二部图<br>9.树型dp</4></p>
<p><1>完美服务器问题(每个节点有3种状态)</1></p>
<p><2>小胖守皇宫问题</2></p>
<p><3>网络收费问题</3></p>
<p><4>树中漫游问题</4></p>
<p><5>树上的博弈</5></p>
<p><6>树的最大独立集问题</6></p>
<p><7>树的最大平衡值问题</7></p>
<p><8>构造树的最小环 </8></p>
<p><a href="http://hi.baidu.com/goodmorning0610/blog/item/562ee61b22bb461c8718bf49.html" target="_blank" rel="noopener">http://hi.baidu.com/goodmorning0610/blog/item/562ee61b22bb461c8718bf49.html</a> </p>
<p>1、     排序</p>
<p>1423, 1694, 1723, 1727, 1763, 1788, 1828, 1838, 1840, 2201, 2376, 2377, 2380,<br>1318, 1877, 1928, 1971, 1974, 1990, 2001, 2002, 2092, 2379, </p>
<p>1002（需要字符处理，排序用快排即可） 1007（稳定的排序） 2159（题意较难懂） 223<br>1 2371（简单排序） 2388（顺序统计算法） 2418（二叉排序树）</p>
<p>2、    搜索、回溯、遍历</p>
<p>1022 1111d 1118 1129 1190 1562 1564 1573 1655 2184 2225 2243 2312 2362 2378 238<br>6    1010,1011,1018,1020,1054,1062,1256,1321,1363,1501，1650,1659,1664,1753,2078<br>,2083,2303,2310,2329</p>
<p>简单：1128, 1166, 1176, 1231, 1256, 1270, 1321, 1543, 1606, 1664, 1731, 1742,<br>1745, 1847, 1915, 1950, 2038, 2157, 2182, 2183, 2381, 2386, 2426,<br>不易：1024, 1054, 1117, 1167, 1708, 1746, 1775, 1878, 1903, 1966, 2046, 2197,<br>2349,<br>推荐：1011, 1190, 1191, 1416, 1579, 1632, 1639, 1659, 1680, 1683, 1691, 1709,<br>1714, 1753, 1771, 1826, 1855, 1856, 1890, 1924, 1935, 1948, 1979, 1980, 2170,<br>2288, 2331, 2339, 2340,1979（和迷宫类似） 1980（对剪枝要求较高）</p>
<p>3、    历法</p>
<p>1008 2080 （这种题要小心）</p>
<p>4、    枚举</p>
<p>1012，1046， 1387， 1411， 2245， 2326， 2363， 2381，1054（剪枝要求较高），16<br>50 （小数的精度问题）</p>
<p>5、     数据结构的典型算法</p>
<p>容易：1182, 1656, 2021, 2023, 2051, 2153, 2227, 2236, 2247, 2352, 2395,<br>不易：1145, 1177, 1195, 1227, 1661, 1834,<br>推荐：1330, 1338, 1451, 1470, 1634, 1689, 1693, 1703, 1724, 1988, 2004, 2010,<br>2119, 2274, 1125(弗洛伊德算法) ，2421（图的最小生成树）</p>
<p>6、    动态规划</p>
<p>1037 A decorative fence、</p>
<p>1050 To the Max、</p>
<p>1088 滑雪、</p>
<p>1125 Stockbroker Grapevine、</p>
<p>1141 Brackets Sequence、</p>
<p>1159 Palindrome、</p>
<p>1160 Post Office、</p>
<p>1163 The Triangle、</p>
<p>1458 Common Subsequence、</p>
<p>1579 Function Run Fun、</p>
<p>1887 Testing the CATCHER、</p>
<p>1953 World Cup Noise、</p>
<p>2386 Lake Counting</p>
<p>7、    贪心</p>
<p>1042, 1065, 1230, 1323, 1477, 1716, 1784,1328 1755（或用单纯形方法），2054，10<br>17， 1328，1862， 1922 ，2054， 2209， 2313， 2325， 2370。</p>
<p>8、    模拟</p>
<p>容易：1006, 1008, 1013, 1016, 1017, 1169, 1298, 1326, 1350, 1363, 1676, 1786,<br>1791, 1835, 1970, 2317, 2325, 2390, </p>
<p>不易：1012, 1082, 1099, 1114, 1642, 1677, 1684, 1886,1281 1928 2083 2141 2015</p>
<p>9、     递归</p>
<p>1664</p>
<p>10、字符串处理</p>
<p>1488, 1598, 1686, 1706, 1747, 1748, 1750, 1760, 1782, 1790, 1866, 1888, 1896,<br>1951, 2003, 2121, 2141, 2145, 2159, 2337, 2359, 2372, 2406, 2408, 1016 1051 11<br>26 1318 1572 1917 1936 2039 2083 2136 2271 2317 2330，2121 2403</p>
<p>11、数论</p>
<p>1006,1014,1023,1061,1152,1183,1730,2262</p>
<p>12、几何有关的题目</p>
<p>凸包：1113, 1228, 1794, 2007, 2187,1113 wall，2187 beauty contest</p>
<p>容易：1319, 1654, 1673, 1675, 1836, 2074, 2137, 2318,<br>不易：1685, 1687, 1696, 1873, 1901, 2172, 2333,</p>
<p>13、任意精度运算、数字游戏、高精度计算</p>
<p>1001 1023 1047 1060 1079 1131 1140 1142 1207 1220 1284 1289 1306 1316 1338 140<br>5 1454 1503 1504 1519 1565 1650 1969 2000 2006 2081 2247 2262 2305 2316 2389 </p>
<p>1001, 1220, 1405, 1503,1001（高精度乘法） 2413(高精度加法，还有二分查找)</p>
<p>14、概率统计</p>
<p>1037,1050</p>
<p>15、小费用最大流、最大流</p>
<p>2195 going home，2400 supervisor, supervisee，1087 a plug for UNIX，1149 PIGS，<br>1273 drainage ditches，1274 the perfect stall，1325 machine schedule，1459 pow<br>er network，2239 selecting courses</p>
<p>16、压缩存储的DP</p>
<p>1038 bugs integrated inc，1185 炮兵阵地，2430 lazy cow</p>
<p>17、最长公共子串（LCS）</p>
<p>1080 human gene functions，1159 palindrome，1458 common subsequence，2192 zipp<br>er</p>
<p>18、图论及组合数学</p>
<p>2421 Constructing Roads、</p>
<p>2369 Permutations、</p>
<p>2234 Matches Game、</p>
<p>2243 Knight Moves、</p>
<p>2249 Binomial Showdown、</p>
<p>2255 Tree Recovery、</p>
<p>2084 Game of Connections、</p>
<p>1906 Three powers、</p>
<p>1833 排列、</p>
<p>1850 Code、</p>
<p>1562 Oil Deposits、</p>
<p>1496 Word Index、</p>
<p>1306 Combinations、</p>
<p>1125 Stockbroker Grapevine、</p>
<p>1129 Channel Allocation、</p>
<p>1146 ID Codes、</p>
<p>1095 Trees Made to Order、找规律</p>
<p>2247 Humble Numbers、</p>
<p>2309 BST、</p>
<p>2346 Lucky tickets、</p>
<p>2370 Democracy in danger、</p>
<p>2365 Rope、</p>
<p>2101 Honey and Milk Land<br>2028 When Can We Meet?、</p>
<p>2084 Game of Connections、</p>
<p>1915 Knight Moves、</p>
<p>1922 Ride to School、</p>
<p>1941 The Sierpinski Fractal、</p>
<p>1953 World Cup Noise、</p>
<p>1958 Strange Towers of Hanoi、</p>
<p>1969 Count on Canton、</p>
<p>1806 Manhattan 2025、</p>
<p>1809 Regetni、</p>
<p>1844 Sum、</p>
<p>1870 Bee Breeding、</p>
<p>1702 Eva\’s Balance、</p>
<p>1728 A flea on a chessboard、</p>
<p>1604 Just the Facts、</p>
<p>1642 Stacking Cubes、</p>
<p>1656 Counting Black、</p>
<p>1657 Distance on Chessboard、</p>
<p>1662 CoIns、</p>
<p>1663 Number Steps、</p>
<p>1313 Booklet Printing、</p>
<p>1316 Self Numbers、</p>
<p>1320 Street Numbers、</p>
<p>1323 Game Prediction、</p>
<p>1338 Ugly Numbers、</p>
<p>1244 Slots of Fun、</p>
<p>1250 Tanning Salon、</p>
<p>1102 LC-Display、</p>
<p>1147 Binary codes、</p>
<p>1013 Counterfeit Dollar、</p>
<p>19、博弈类</p>
<p>1067 取石子游戏、</p>
<p>1740 A New Stone Game、</p>
<p>2234 Matches Game、</p>
<p>1082 Calendar Game 、</p>
<p>2348 Euclid\’s Game、</p>
<p>2413 How many Fibs?、</p>
<p>2419 Forest</p>
<p>20、简单、模拟题<br>1001 Exponentiation 、</p>
<p>1002 487-3279、</p>
<p>1003 Hangover 、</p>
<p>1701 Dissatisfying Lift、</p>
<p>2301 Beat the Spread!、</p>
<p>2304 Combination Lock、</p>
<p>2328 Guessing Game、</p>
<p>2403 Hay Points 、</p>
<p>2406 Power Strings、</p>
<p>2339 Rock, Scissors, Paper、</p>
<p>2350 Above Average、</p>
<p>2218 Does This Make Me Look Fat?、</p>
<p>2260 Error Correction、</p>
<p>2262 Goldbach\’s Conjecture、</p>
<p>2272 Bullseye、</p>
<p>2136 Vertical Histogram、</p>
<p>2174 Decoding Task、</p>
<p>2183 Bovine Math Geniuses、</p>
<p>2000 Gold Coins、</p>
<p>2014 Flow Layout、</p>
<p>2051 Argus、</p>
<p>2081 Calendar、</p>
<p>1918 Ranking List、</p>
<p>1922 Ride to School、</p>
<p>1970 The Game、</p>
<p>1972 Dice Stacking、</p>
<p>1974 The Happy Worm、</p>
<p>1978 Hanafuda Shuffle、</p>
<p>1979 Red and Black、</p>
<p>1617 Crypto Columns、</p>
<p>1666 Candy Sharing Game、</p>
<p>1674 Sorting by Swapping、</p>
<p>1503 Integer Inquiry、</p>
<p>1504 Adding Reversed Numbers、</p>
<p>1528 Perfection、</p>
<p>1546 Basically Speaking、</p>
<p>1547 Clay Bully、</p>
<p>1573 Robot Motion、</p>
<p>1575 Easier Done Than Said?、</p>
<p>1581 A Contesting Decision、</p>
<p>1590 Palindromes、</p>
<p>1454 Factorial Frequencies、</p>
<p>1363 Rails、</p>
<p>1218 THE DRUNK JAILER、</p>
<p>1281 MANAGER、</p>
<p>1132 Border、</p>
<p>1028 Web Navigation、</p>
<p>21、初等数学</p>
<p>1003 Hangover、</p>
<p>1045 Bode Plot、</p>
<p>1254 Hansel and Grethel、</p>
<p>1269 Intersecting Lines、</p>
<p>1401 Factorial、</p>
<p>1410 Intersection、</p>
<p>2363 Blocks 、</p>
<p>2365 Rope、</p>
<p>2242 The Circumference of the Circle、</p>
<p>2291 Rotten Ropes、</p>
<p>2295 A DP Problem、</p>
<p>2126 Factoring a Polynomial、</p>
<p>2191 Mersenne Composite Numbers、</p>
<p>2196 Specialized Four-Digit Numbers、</p>
<p>1914 Cramer\’s Rule、</p>
<p>1835 宇航员、</p>
<p>1799 Yeehaa!、</p>
<p>1607 Deck、</p>
<p>1244 Slots of Fun、</p>
<p>1269 Intersecting Lines、</p>
<p>1299 Polar Explorer、</p>
<p>1183 反正切函数的应用、</p>
<p>22、匹配</p>
<p>1274, 1422, 1469, 1719, 2060, 2239,</p>
<p>经典<br>1011（搜索好题）<br>1012（学会打表）<br>1013<br>1019（它体现了很多此类问题的特点）<br>1050（绝对经典的dp）<br>1088（dp好题）<br>1157（花店，经典的dp）<br>1163（怎么经典的dp那么多呀？？？）<br>1328（贪心）<br>1458（最长公共子序列）<br>1647（很好的真题，考临场分析准确和下手迅速）<br>1654（学会多边形面积的三角形求法）<br>1655（一类无根树的dp问题）<br>1804（逆序对）<br>2084（经典组合数学问题）<br>2187（用凸包求最远点对，求出凸包后应该有O(N)的求法，可我就是调不出来）<br>2195（二分图的最佳匹配）<br>2242（计算几何经典）<br>2295（等式处理）<br>2353（dp，但要记录最佳路径）<br>2354（立体解析几何）<br>2362（搜索好题）<br>2410（读懂题是关键）<br>2411（经典dp）</p>
<p>趣味<br>1067（很难的数学，但仔细研究，是一片广阔的领域）<br>1147（有O(n)的算法，需要思考）<br>1240（直到一棵树的先序和后序遍历，那么有几种中序遍历呢？dp）<br>1426（是数论吗？错，是图论！）<br>1648（别用计算几何，用整点这个特点绕过精度的障碍吧）<br>1833（找规律）<br>1844（貌似dp或是搜索，其实是道有趣的数学题）<br>1922（贪心，哈哈）<br>2231<br>2305（不需要高精度噢）<br>2328（要仔细噢）<br>2356（数论知识）<br>2359（约瑟夫问题变种）<br>2392（有趣的问题）</p>
<p>很繁的题<br>1001<br>1008<br>1087（构图很烦，还有二分图的最大匹配）<br>1128（USACO）<br>1245<br>1329<br>1550（考的是读题和理解能力）<br>1649（dp）<br>2200（字符串处理+枚举）<br>2358（枚举和避免重复都很烦）<br>2361（仔细仔细再仔细）</p>
<p>难题<br>1014（数学证明比较难，但有那种想法更重要）<br>1037（比较难的dp）<br>1405（高精度算法也分有等级之分，不断改进吧）<br>2002（不知道有没有比O(n^2*logn)更有的算法？）<br>2054（极难，很强的思考能力）<br>2085（组合数学）<br>2414（dp，但要剪枝）<br>2415（搜索）<br>2423（计算几何+统计）</p>
<p>多解题<br>1002（可以用排序，也可以用统计的方法）<br>1338（搜索和dp都可以）<br>1664（搜索和dp都练一练吧）<br>2082（这可是我讲的题噢）<br>2352（桶排和二叉树都行）</p>
<p>Note:<br>1011: 很经典的剪支<br>1014: 难在数学上<br>1017: 严格的数学证明貌似不容易<br>1021: 有点繁,考察对图形进行各种旋转的处理<br>1083: 巧妙的思考角度<br>1150: 分奇偶讨论,lg(n)算法<br>1218: 三行就够了,虽然简单,但也有优劣之别<br>1505: 二分加贪心<br>1654: 做法也许很多吧,本人用有向面积做的<br>1674: 计算圈的个数(算是graph 吧)<br>1700: 数学证明不容易<br>1742: O(m*n)的算法<br>1863: 要耐心地慢慢写…^_^<br>1988: 并查集<br>2051: 堆<br>2078: 不难，但剪支可以做到很好<br>2082::O(n),你想到了吗？<br>2084: 卡特兰数<br>2182: 线段树<br>2195: 最小费用最大流<br>2234: 经典博弈算法<br>2236: 并查集<br>2299: 二分思想<br>2395: Kruskal 最小生成树的拓展<br>2406: KMP<br>2411: 用二进制串来表示状态</p>
<hr>
<h2 id="PAT-advanced-level"><a href="#PAT-advanced-level" class="headerlink" title="PAT-advanced level"></a>PAT-advanced level</h2><p>简单题:<br>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>
<p>1001 A+B<br>1002 多项式相加<br>1005 简单hash<br>1006 选极值<br>1008 模拟电梯<br>1009 多项式乘法<br>1011 选极值<br>1019 数字/字符处理<br>1024 数字/字符处理<br>1027 数字/字符处理，简单hash<br>1031 数字/字符处理<br>1035 简单hash<br>1036 选极值<br>1037 简单模拟<br>1040 数字/字符处理<br>1046 数字/字符处理<br>1050 数字/字符处理<br>1058 数字/字符处理<br>1060 数字/字符处理</p>
<p>模拟题:<br>这类题也相对简单，需要使用到一些简单的数据结构或者相对复杂的逻辑流程实现。</p>
<p>1022 倒排索引<br>1023 数字/字符处理<br>1032 链表<br>1049 计算数字中的1<br>1051 模拟栈<br>1052 链表<br>1054 dominant color<br>1056 模拟分组淘汰赛</p>
<p>排队模拟<br>下面三道模拟题是针对排队模型处理的：</p>
<p>1014 排队问题<br>1017 排队问题<br>1026 排队问题</p>
<p>排序模拟<br>这几道模拟题侧重在使用排序方法：</p>
<p>1012 排序<br>1016 排序，模拟电话账单计算<br>1025 排序<br>1028 排序<br>1029 归并排序<br>1038 递归，排序<br>时间优化</p>
<p>这几道题需要做好时间优化才能ac。<br>1044 搜索，时间优化<br>1039 倒排索引，hash，时间优化<br>1047 倒排索引，hash，时间优化<br>1055 排序，时间优化</p>
<p>素数判定<br>1015 素数<br>1059 素数</p>
<p>图<br>1003 最短路径<br>1018 最短路径<br>1030 最短路径<br>1034 dfs</p>
<p>搜索<br>1010 二分搜索，优化剪枝<br>1013 并查集/dfs<br>1021 并查集，dfs，图的直径<br>1054 dfs，优化剪枝</p>
<p>树<br>1004 dfs，树遍历<br>1020 二叉树遍历<br>1043 二叉树遍历</p>
<p>Hash<br>1041 hash<br>1042 hash<br>1048 hash</p>
<p>分治<br>1007 最大子连续序列</p>
<p>贪心<br>1033 贪心</p>
<p>动态规划<br>1045 DP，最长递增子序列</p>
<p>树状数组<br>树状数组是一种神奇的数据结构，在1057题中其神奇的效果得到了很好的体现。</p>
<p>1057 树状数组，模拟栈，二分搜索</p>
<hr>
<h2 id="PAT-advanced-level-liuchuo"><a href="#PAT-advanced-level-liuchuo" class="headerlink" title="PAT-advanced level(liuchuo)"></a>PAT-advanced level(liuchuo)</h2><p>PAT甲级真题目录（按题型整理）</p>
<p>最短路径</p>
<ol>
<li>Emergency (25)-PAT甲级真题（Dijkstra算法）</li>
<li>Public Bike Management (30)-PAT甲级真题（Dijkstra + DFS）</li>
<li>Travel Plan (30)-PAT甲级真题（Dijkstra + DFS，输出路径，边权）</li>
<li>All Roads Lead to Rome (30)-PAT甲级真题-Dijkstra + DFS</li>
<li>Online Map (30)-PAT甲级真题（Dijkstra + DFS）</li>
</ol>
<p>树的遍历</p>
<ol>
<li>Counting Leaves (30)-PAT甲级真题(bfs,dfs,树的遍历，层序遍历)</li>
<li>Tree Traversals (25)-PAT甲级真题</li>
<li>Path of Equal Weight (30)-PAT甲级真题(树的遍历)</li>
<li>Total Sales of Supply Chain (25)-PAT甲级真题（dfs,bfs,树的遍历）</li>
<li>Tree Traversals Again (25)-PAT甲级真题</li>
<li>Highest Price in Supply Chain (25)-PAT甲级真题</li>
<li>The Largest Generation (25)-PAT甲级真题（bfs,dfs,树的遍历）</li>
<li>Invert a Binary Tree (25)-PAT甲级真题</li>
<li>Lowest Price in Supply Chain (25)-PAT甲级真题(dfs,bfs,树的遍历)</li>
<li>Counting Nodes in a BST (30)-PAT甲级真题（二叉树的遍历，dfs）</li>
<li>Pre- and Post-order Traversals (30)-PAT甲级真题（前序后序转中序）</li>
</ol>
<p>图的遍历</p>
<ol>
<li>Battle Over Cities (25)-PAT甲级真题（图的遍历，统计强连通分量的个数，dfs）</li>
<li>Deepest Root (25)-PAT甲级真题（图的遍历，dfs，连通分量的个数）</li>
<li>Head of a Gang (30)-PAT甲级真题（图的遍历dfs）</li>
<li>Gas Station (30)-PAT甲级真题（Dijkstra）</li>
<li>Forwards on Weibo (30)-PAT甲级真题（图的遍历bfs）</li>
</ol>
<p>深度优先搜索</p>
<ol>
<li>Integer Factorization (30)-PAT甲级真题（dfs深度优先）</li>
</ol>
<p>广度优先搜索</p>
<ol>
<li>Acute Stroke (30)-PAT甲级真题（广度优先搜索）</li>
</ol>
<p>哈希、散列</p>
<ol>
<li>Find Coins (25)-PAT甲级真题(Hash散列)</li>
<li>String Subtraction (20)-PAT甲级真题（哈希）</li>
<li>To Buy or Not to Buy (20)-PAT甲级真题</li>
<li>Broken Keyboard (20)-PAT甲级试题</li>
</ol>
<p>动态规划</p>
<ol>
<li>Maximum Subsequence Sum (25)-PAT甲级真题（动态规划dp）</li>
<li>Longest Symmetric String (25)-PAT甲级真题（动态规划）</li>
<li>Favorite Color Stripe (30)-PAT甲级真题</li>
<li>Find More Coins (30)-PAT甲级真题（01背包）</li>
</ol>
<p>排序</p>
<ol>
<li>The Best Rank (25)-PAT甲级真题</li>
<li>Phone Bills (25)-PAT甲级真题</li>
<li>PAT Ranking (25)-PAT甲级真题</li>
<li>List Sorting (25)-PAT甲级真题</li>
<li>The World’s Richest (25)-PAT甲级真题</li>
<li>Talent and Virtue (25)-PAT甲级真题</li>
<li>PAT Judge (25)-PAT甲级真题</li>
<li>Graduate Admission (30)-PAT甲级真题</li>
<li>List Grades (25)-PAT甲级真题</li>
</ol>
<p>STL的使用</p>
<ol>
<li>Digital Library (30)-PAT甲级真题（map映射）</li>
<li>Course List for Student (25)-PAT甲级真题</li>
<li>Student List for Course (25)-PAT甲级真题</li>
<li>The Dominant Color (20)-PAT甲级真题</li>
<li>Set Similarity (25)-PAT甲级真题</li>
<li>Speech Patterns (25)-PAT甲级真题（map应用）</li>
<li>Mars Numbers (20)-PAT甲级真题</li>
</ol>
<p>链表处理</p>
<ol>
<li>Sharing (25)-PAT甲级真题</li>
<li>Linked List Sorting (25)-PAT甲级真题</li>
<li>Reversing Linked List (25)-PAT甲级真题</li>
<li>Deduplication on a Linked List (25)-PAT甲级真题</li>
</ol>
<p>大整数</p>
<ol>
<li>Have Fun with Numbers (20)-PAT甲级真题（大整数运算）</li>
<li>Palindromic Number (25)-PAT甲级真题（大整数相加）</li>
</ol>
<p>二叉搜索树</p>
<ol>
<li>Is It a Binary Search Tree (25)-PAT甲级真题<br>Complete Binary Search Tree (30)-PAT甲级真题</li>
<li>Build A Binary Search Tree (30)-PAT甲级真题</li>
</ol>
<p>平衡二叉树</p>
<ol>
<li>Root of AVL Tree (25)-PAT甲级真题</li>
</ol>
<p>堆排序</p>
<ol>
<li>Insertion or Heap Sort (25)-PAT甲级真题（堆排序）</li>
</ol>
<p>贪心算法</p>
<ol>
<li>To Fill or Not to Fill (25)-PAT甲级真题（贪心算法）</li>
<li>Magic Coupon (25)-PAT甲级真题（贪心算法）</li>
<li>Recover the Smallest Number (30)-PAT甲级真题（贪心算法）</li>
<li>Sort with Swap(0,*) (25)-PAT甲级真题（贪心算法）</li>
<li>Mooncake (25)-PAT甲级真题</li>
</ol>
<p>并查集</p>
<ol>
<li>Social Clusters (30)-PAT甲级真题（并查集）</li>
<li>Family Property (25)-PAT甲级真题（并查集）</li>
<li>Birds in Forest (25)-PAT甲级真题（并查集）</li>
</ol>
<p>树状数组</p>
<ol>
<li>Stack (30)-PAT甲级真题（树状数组）</li>
</ol>
<hr>
<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><p>参考leetcode-cpp</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Remove Duplicates from Sorted Array<br>Remove Duplicates from Sorted Array II<br>Longest Consecutive Sequence<br>Two Sum<br>3Sum<br>3Sum Closest<br>4Sum<br>Remove Element<br>Move Zeroes<br>Next Permutation<br>Permutation Sequence<br>Valid Sudoku<br>Trapping Rain Water<br>Rotate Image<br>Plus One<br>Climbing Stairs<br>Set Matrix Zeroes<br>Gas Station<br>Candy<br>Majority Element<br>Rotate Array<br>Contains Duplicate<br>Contains Duplicate II<br>Contains Duplicate III<br>Product of Array Except Self<br>Game of Life<br>Increasing Triplet Subsequence</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>Reverse Linked List<br>Odd Even Linked List<br>Add Two Numbers<br>Reverse Linked List II<br>Partition List<br>Remove Duplicates from Sorted List<br>Remove Duplicates from Sorted List II<br>Rotate List<br>Remove Nth Node From End of List<br>Swap Nodes in Pairs<br>Reverse Nodes in k-Group<br>Copy List with Random Pointer<br>Linked List Cycle<br>Linked List Cycle II<br>Reorder List<br>LRU Cache<br>Palindrome Linked List</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Valid Palindrome<br>Implement strStr()<br>String to Integer (atoi)<br>Add Binary<br>Longest Palindromic Substring<br>Regular Expression Matching<br>Wildcard Matching<br>Longest Common Prefix<br>Valid Number<br>Integer to Roman<br>Roman to Integer<br>Count and Say<br>Anagrams<br>Valid Anagram<br>Simplify Path<br>Length of Last Word<br>Isomorphic Strings<br>Word Pattern</p>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>Min Stack<br>Valid Parentheses<br>Longest Valid Parentheses<br>Largest Rectangle in Histogram<br>Evaluate Reverse Polish Notation<br>Implement Stack using Queues</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>Implement Queue using Stacks</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>Binary Tree Preorder Traversal<br>Binary Tree Inorder Traversal<br>Binary Tree Postorder Traversal<br>Binary Tree Level Order Traversal<br>Binary Tree Level Order Traversal II<br>Binary Tree Right Side View<br>Invert Binary Tree<br>Binary Search Tree Iterator<br>Binary Tree Zigzag Level Order Traversal<br>Recover Binary Search Tree<br>Same Tree<br>Symmetric Tree<br>Balanced Binary Tree<br>Flatten Binary Tree to Linked List<br>Populating Next Right Pointers in Each Node II</p>
<h4 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h4><p>Construct Binary Tree from Preorder and Inorder Traversal<br>Construct Binary Tree from Inorder and Postorder Traversal</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>Unique Binary Search Trees<br>Unique Binary Search Trees II<br>Validate Binary Search Tree<br>Convert Sorted Array to Binary Search Tree<br>Convert Sorted List to Binary Search Tree<br>LCA of BST<br>Kth Smallest Element in a BST</p>
<h4 id="二叉树的递归"><a href="#二叉树的递归" class="headerlink" title="二叉树的递归"></a>二叉树的递归</h4><p>Minimum Depth of Binary Tree<br>Maximum Depth of Binary Tree<br>Path Sum<br>Path Sum II<br>Binary Tree Maximum Path Sum<br>Populating Next Right Pointers in Each Node<br>Sum Root to Leaf Numbers<br>LCA of Binary Tree</p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>Range Sum Query - Mutable</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>Insertion Sort List</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>Merge Two Sorted Arrays<br>Merge Two Sorted Lists<br>Merge k Sorted Lists<br>Sort List</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>Sort Colors<br>Kth Largest Element in an Array</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>First Missing Positive</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>H-Index</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>Maximum Gap</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Largest Number</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>Search for a Range<br>Search Insert Position<br>Search in Rotated Sorted Array<br>Search in Rotated Sorted Array II<br>Search a 2D Matrix<br>Search a 2D Matrix II<br>Find Minimum in Rotated Sorted Array<br>Find Minimum in Rotated Sorted Array II<br>Median of Two Sorted Arrays<br>H-Index II</p>
<h3 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h3><p>Subsets<br>Subsets II<br>Permutations<br>Permutations II<br>Combinations<br>Letter Combinations of a Phone Number</p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>Word Ladder<br>Word Ladder II<br>Surrounded Regions<br>总结</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>Additive Number<br>Palindrome Partitioning<br>Unique Paths<br>Unique Paths II<br>N-Queens<br>N-Queens II<br>Restore IP Addresses<br>Combination Sum<br>Combination Sum II<br>Combination Sum III<br>Generate Parentheses<br>Sudoku Solver<br>Word Search<br>总结</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>Pow(x,n)<br>Sqrt(x)</p>
<h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>Jump Game<br>Jump Game II<br>Best Time to Buy and Sell Stock<br>Best Time to Buy and Sell Stock II<br>Longest Substring Without Repeating Characters<br>Container With Most Water<br>Patching Array</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>Triangle<br>Maximum Subarray<br>Maximum Product Subarray<br>Longest Increasing Subsequence<br>Palindrome Partitioning II<br>Maximal Rectangle<br>Best Time to Buy and Sell Stock III<br>Best Time to Buy and Sell Stock IV<br>Best Time to Buy and Sell Stock with Cooldown<br>Interleaving String<br>Scramble String<br>Minimum Path Sum<br>Edit Distance<br>Decode Ways<br>Distinct Subsequences<br>Word Break<br>Word Break II<br>Dungeon Game<br>House Robber<br>House Robber II<br>House Robber III<br>Range Sum Query - Immutable<br>Range Sum Query 2D - Immutable</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>Clone Graph</p>
<h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><p>Reverse Bits<br>Repeated DNA Sequences<br>Number of 1 Bits<br>Gray Code<br>Single Number<br>Single Number II<br>Single Number III<br>Power of Two<br>Missing Number<br>Maximum Product of Word Lengths<br>Bitwise AND of Numbers Range<br>Power of Three<br>Rectangle Area</p>
<h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><p>Happy Number<br>Ugly Number<br>Ugly Number II<br>Super Ugly Number<br>Fraction to Recurring Decimal<br>Factorial Trailing Zeroes<br>Nim Game</p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>Reverse Integer<br>Palindrome Number<br>Insert Interval<br>Merge Intervals<br>Minimum Window Substring<br>Multiply Strings<br>Substring with Concatenation of All Words<br>Pascal’s Triangle<br>Pascal’s Triangle II<br>Spiral Matrix<br>Spiral Matrix II<br>ZigZag Conversion<br>Divide Two Integers<br>Text Justification<br>Max Points on a Line</p>
<hr>
<p>ref:<br><a href="http://www.cnblogs.com/kuangbin/archive/2011/07/26/2117153.html" target="_blank" rel="noopener">http://www.cnblogs.com/kuangbin/archive/2011/07/26/2117153.html</a><br><a href="https://www.cnblogs.com/kuangbin/archive/2011/07/29/2120667.html" target="_blank" rel="noopener">https://www.cnblogs.com/kuangbin/archive/2011/07/29/2120667.html</a><br><a href="https://soulmachine.gitbooks.io/algorithm-essentials/content/cpp/linear-list/linked-list/reverse-linked-list.html" target="_blank" rel="noopener">https://soulmachine.gitbooks.io/algorithm-essentials/content/cpp/linear-list/linked-list/reverse-linked-list.html</a><br><a href="https://www.liuchuo.net/archives/2502" target="_blank" rel="noopener">https://www.liuchuo.net/archives/2502</a><br><a href="https://soulmachine.gitbooks.io/algorithm-essentials/content/cpp/" target="_blank" rel="noopener">https://soulmachine.gitbooks.io/algorithm-essentials/content/cpp/</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UVa 136-Ugly Numbers]]></title>
      <url>/2018/07/29/UVa-136-Ugly-Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>丑数是指不能被2, 3, 5以外的其他素数整除的数。把丑数从小到大排列起来, 结果如下:<br><code>1,2,3,4,5,6,8,9,10,12,15,...</code><br>求第1500个丑数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>There is no input to this program.</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>The 1500’th ugly number is <number>.</number></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路:<br>  1, 按照我原先的思路, 首先想到, 把除235以外的1500个素数给计算出来, 再从5开始判断是否会被其中的某个数整除, <code>1500*1500*1500(n^3);</code><br>  2, 使用优先队列, 用已有的丑数, 生成新的丑数;<br>  已经有丑数x, 计算2x, 3x, 5x, (他们一定不能被除了235外的其他素数整除, 如果能整除, 其他素数就不是素数 )<br>  用优先队列dq存放已生成的丑数, 队首是最小数,<br>  生成新的丑数后队首出dq栈, 判断生成数是否已经在之前出现过(使用set)<br>  没出现过的加入ugly_set, push入dq栈队尾<br>  入完ugly_set栈, 检测数量是不是到了1500   // 这里存在bug1</p>
<p>bug1: 检测ugly_set数量是1500存在bug, 因为有的丑数还没有去生成新丑数时, 丑数数量已经足够, 但实际上, 这些还没生成的丑数中, 存在比已经生成丑数更小的丑数, 因此直接让他生成1500次, 1500次的pq队首代表第1500个丑数.<br>bug2: The 1500’th ugly number is -1735655424. 需要定义LL</p>
<p>skill1: priority_queue<int, vector<int="">, cmp&gt; pq来定义优先队列, cmp用结构体重载()来实现<br>skill2: set是一个自带排序的数据结构<br>skill3: 对于set类型的s, s.count(a), 可以判断集合s中是否存在元素a<br>skill4: long long写起来麻烦, 可以 <code>typedef long long LL;</code>定义简写的长整型</int,></p>
<p><span style="color:red"><strong><br>归纳:<br>新的丑数用旧的数生成, 把旧的丑数, 放在优先队列里, 数越小权重越高.<br>不是用set来计数, 而是用pq出队列的次数来计数ugly number的数量, set只是用来判断生成数是否之前出现过.
</strong></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;     // priority_queue定义在头文件queue中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> LL a, <span class="keyword">const</span> LL b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;   <span class="comment">// a&gt;b, a的优先级比b小, 返回true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;LL&gt; ugly;</span><br><span class="line"><span class="comment">// priority_queue&lt;LL&gt; pq;   // priority_queue&lt;LL&gt; pq; 这样定义数越大优先级越高</span></span><br><span class="line">priority_queue&lt;LL, <span class="built_in">vector</span>&lt;LL&gt;, cmp &gt; pq;</span><br><span class="line"><span class="comment">// priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq;   // 等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> multi[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">1500</span>;</span><br><span class="line">  pq.push(<span class="number">1</span>); ugly.insert(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">    LL x = pq.top(); pq.pop();</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The 1500'th ugly number is %lld.\n"</span>, x);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      LL x2 = x * multi[j];</span><br><span class="line">      <span class="keyword">if</span> (!ugly.count(x2)) &#123; pq.push(x2); ugly.insert(x2);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对set进行排序(set已经排序好了, 不需要重排)</span></span><br><span class="line">  <span class="comment">// set&lt;int&gt;::iterator it = ugly.end();</span></span><br><span class="line">  <span class="comment">// printf("The 1500'th ugly number is %d.\n", *(--it));  // 不是用set来计数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> UVa, 优先队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git Request 提交, 合并]]></title>
      <url>/2018/07/06/git-request-commit-and-merge/</url>
      <content type="html"><![CDATA[<p>最近和学长<a href="https://github.com/HankDaly" target="_blank" rel="noopener">HankDaly</a>共同contribute一个项目。<br>涉及到三个操作:<br>1, HankDaly从我的github上获取代码<br>2, HankDaly修改代码并提交给我<br>3, 我对代码进行审核合并到项目中</p>
<h2 id="1-HankDaly从我的github上获取代码-从项目维护者那获取代码"><a href="#1-HankDaly从我的github上获取代码-从项目维护者那获取代码" class="headerlink" title="1, HankDaly从我的github上获取代码(从项目维护者那获取代码)"></a>1, HankDaly从我的github上获取代码(从项目维护者那获取代码)</h2><p>a, 在github上fork项目, timtingwei/cppd  =&gt; HankDaly/cppd<br>b, HankDaly, clone自己的项目到本地<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/HankDaly/cppd.git</span><br></pre></td></tr></table></figure></p>
<h2 id="2-HankDaly修改代码并提交给我"><a href="#2-HankDaly修改代码并提交给我" class="headerlink" title="2, HankDaly修改代码并提交给我"></a>2, HankDaly修改代码并提交给我</h2><p>a, 完成修改后, git push origin master 上传本地当前分支代码到远程master分支<br>b, 打开github, 在自己远程仓库的项目中, 找到pull request, 新建一个pull request<br>c, 选择自己要request的分支, 和base分支, 当前默认都为master<br><img src="/images/pull-request-new-requset.png" alt="我拿自己fork HankDaly/test 做的实验"><br>d, 创建这次pull request</p>
<h2 id="3-我对代码进行审核合并到项目中"><a href="#3-我对代码进行审核合并到项目中" class="headerlink" title="3, 我对代码进行审核合并到项目中"></a>3, 我对代码进行审核合并到项目中</h2><p>在没有冲突的情况下可以直接在github上合并。<br>在冲突情况下必须手动pull下来, diff后修改矛盾, 再merge, pull request会自动消失。</p>
<p>这里主要做的事情是, 手动在另外一个branch中, 审阅request上来的代码, 再与master合并</p>
<p>这里我前面在pull的时候, 总没有git checkout -b hank-master</p>
<p>我所推测的步骤应该是:</p>
<p>a, 切换到一个专门用于审阅request的分支<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b hank-master</span><br></pre></td></tr></table></figure></p>
<p>b, 在当前分支下, 拉下来学长的push<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull https://github.com/HankDaly/cppd.git</span><br></pre></td></tr></table></figure></p>
<p>没有conflict的话可以直接pull下来。</p>
<p>如果这里有confilict<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFLICT</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>手动将confilict改完, 就是保存一份没有冲突的</p>
<p>c, 提交对代码的改动<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"merge hank's code"</span></span><br></pre></td></tr></table></figure></p>
<p>d, 切换到master分支合并代码<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hank-master</span><br></pre></td></tr></table></figure></p>
<p>e, 提交到远程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>什么时候会出现conflict?<br>我改动的同时, request也改动了相同的代码。</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建筑结构选型]]></title>
      <url>/2018/07/04/archi-structure/</url>
      <content type="html"><![CDATA[<p>仍然需要补充的内容:<br>排架 图<br>框架 图<br>绘制3例悬挂结构体系的高层建筑立面示意 p139 战略放弃</p>
<h1 id="名词解释-4-5-简图"><a href="#名词解释-4-5-简图" class="headerlink" title="名词解释 4 * 5 简图"></a>名词解释 4 * 5 简图</h1><h2 id="1-刚架-用力学简图附加说明"><a href="#1-刚架-用力学简图附加说明" class="headerlink" title="1, 刚架(用力学简图附加说明):"></a>1, 刚架(用力学简图附加说明):</h2><p>梁柱之间刚性连接的结构, 适合于单层的体育馆<br><img src="/images/gang-jia.png" alt=""></p>
<h2 id="2-必考-筒中筒-p135"><a href="#2-必考-筒中筒-p135" class="headerlink" title="2, 必考: 筒中筒 p135"></a>2, 必考: 筒中筒 p135</h2><p>在高层建筑中, 可把电梯间, 楼梯间以及设备井道的墙布置成钢筋混凝土墙, 它既可承受竖向荷载, 又可承受水平力作用。<br>在高层建筑中, 可充分利用建筑物圆周的景观和采光。<br>楼.电梯等服务性用房常位于房屋的中部, 因此由钢筋混凝土组成的楼, 电梯间便成了核心筒(实腹内筒), 外侧的密集的柱子形成空腹外筒<br><img src="/images/tong-zhong-tong.png" alt=""></p>
<h2 id="3-必考-框架核心筒结构"><a href="#3-必考-框架核心筒结构" class="headerlink" title="3, 必考: 框架核心筒结构:"></a>3, 必考: 框架核心筒结构:</h2><p>筒中筒结构外部柱距较为密集, 常常不能满足建筑设计要求, 有时建筑柱子布距离要满足柱距在4~5m或更大,<br>周边柱不形成筒的工作状态, 筒相当于空间框架的作用, 这种结构称为框架核心筒结构<br><img src="/images/kuang-jia-he-xin-tong.png" alt=""></p>
<h2 id="框筒-框架核心筒-结构与套筒-筒中筒-比较"><a href="#框筒-框架核心筒-结构与套筒-筒中筒-比较" class="headerlink" title="*, 框筒(框架核心筒)结构与套筒(筒中筒)比较"></a>*, 框筒(框架核心筒)结构与套筒(筒中筒)比较</h2><ul>
<li>框筒结构柱距8.4m以上       50m * 50m 6根柱子</li>
<li>套筒结构住距3m以内         50m * 50m 12以上</li>
<li>框架核心筒比套筒柱子少 </li>
</ul>
<h2 id="框筒-框架-筒-区别"><a href="#框筒-框架-筒-区别" class="headerlink" title="*, 框筒 框架+筒 区别"></a>*, 框筒 框架+筒 区别</h2><p>框架-核心筒是结构体系中心一个筒结构，外围是框架<br>就是框架和筒体成的结构<br>框筒一般指是用比较密的柱子，配合深梁或者支撑构成筒体，不管有多少柱子都还是筒，<br>框架核心筒里面的筒即可以是实腹的墙体构成的筒，也可以是这个框筒。</p>
<h2 id="4-气压式薄膜结构-气胀式"><a href="#4-气压式薄膜结构-气胀式" class="headerlink" title="4, 气压式薄膜结构(气胀式)"></a>4, 气压式薄膜结构(气胀式)</h2><p>也称为气胀式薄膜结构, 在若干充气肋 和 充气被 的密闭空间中保持空气压力, 直接落地承重或者搁置在结构构件上承重<br><img src="/images/qi-ya-shi-bo-mo-jie-gou.png" alt=""></p>
<p>气承式, 不断的向壳体内鼓风, 在较高的室内气压作用下使其自行撑起, 以承受自重和外荷载的结构.<br><img src="/images/qi-cheng-shi-bo-mo-jie-gou.png" alt=""></p>
<h2 id="5-剪力墙结构"><a href="#5-剪力墙结构" class="headerlink" title="5, 剪力墙结构"></a>5, 剪力墙结构</h2><p>一般在高层建筑中, 将建筑物外墙和永久性内隔墙布置成钢筋混凝土结构, 既能承受竖向荷载, 又能承受水平力</p>
<h2 id="6-框支剪力墙-p130"><a href="#6-框支剪力墙-p130" class="headerlink" title="6, 框支剪力墙 p130"></a>6, 框支剪力墙 p130</h2><p>在沿街住宅和商户中, 在底层需要大空间的公共建筑中, 将部分底层剪力墙改成框架柱, 以满足使用要求, 但不利于抗震<br><img src="/images/kuang-zhi-jian-li-qiang.png" alt=""></p>
<h2 id="8-桁架"><a href="#8-桁架" class="headerlink" title="8, 桁架:"></a>8, 桁架:</h2><p>由杆件通过<code>焊接, 铆接 或 螺栓连接</code> 而成的支撑横梁结构, 杆件主要承受<code>拉力和压力</code>, 可充分发挥材料的作用, 减轻结构自重;<br>材料: 钢, 木 和 混凝土<br><img src="/images/heng-jia-1.png" alt=""></p>
<p><img src="/images/heng-jia-2.png" alt=""></p>
<h2 id="9-屋架"><a href="#9-屋架" class="headerlink" title="9, 屋架:"></a>9, 屋架:</h2><p>屋面的结构承重桁架, 由上弦杆和腹杆组成。<br>材料: 钢, 木, 栓<br>式样: 三角形, 梯形, 弧形<br><img src="/images/wu-jia.png" alt=""></p>
<h2 id="a-刚架"><a href="#a-刚架" class="headerlink" title="a, 刚架:"></a>a, 刚架:</h2><p>梁柱之间刚性连接的结构, 适合于单层的体育馆<br><img src="/images/gang-jia.png" alt=""></p>
<h2 id="b-排架"><a href="#b-排架" class="headerlink" title="b, 排架:"></a>b, 排架:</h2><p>梁柱之间为铰接的单层结构</p>
<h2 id="c-框架"><a href="#c-框架" class="headerlink" title="c, 框架:"></a>c, 框架:</h2><p>多层多跨的刚架结构</p>
<h2 id="d-拱"><a href="#d-拱" class="headerlink" title="d, 拱:"></a>d, 拱:</h2><p>是主要受轴向力为主的结构形式, 形状为弧形<br>结构特点:<br>1, 拱是一种 推力结构, 在竖向的荷载下产生水平推力<br>2, 拱是一种无矩结构, 通过合理拱轴 可以使杆件无弯矩<br>3, 拱可以充分利用材料抗压强度, 断面小, 跨度大</p>
<p>拱的支座处理:<br>1, 水平推力直接由拉杆承担</p>
<p>2, 由框架承受</p>
<p>3, 刚性水平构件承受推力</p>
<p>4, 由基础承受</p>
<p><img src="/images/gong.png" alt=""></p>
<h1 id="画图解释-5-10"><a href="#画图解释-5-10" class="headerlink" title="画图解释 5 * 10"></a>画图解释 5 * 10</h1><h2 id="必考-纽约世贸大厦平面"><a href="#必考-纽约世贸大厦平面" class="headerlink" title="必考: 纽约世贸大厦平面"></a>必考: 纽约世贸大厦平面</h2><ul>
<li>边长为63m</li>
<li>平面为方 </li>
<li>结构形式采用套筒, 实腹外筒和空腹内筒</li>
<li>上层柱子间距13m, 下层柱柱子采用并柱, 间距大</li>
<li>网状的轻桁架和主桁架支持地板。桁架相错互相连结。它们与外墙的拱间以及与核心的钢柱焊在一起。</li>
<li>地板与外墙的拱间通过粘弹阻尼器连在一起，这样来使得建筑内的人不会感觉到震动。<br><img src="/images/nyk-xiersi-plan.png" alt=""></li>
</ul>
<h2 id="必考-西尔斯大厦平面"><a href="#必考-西尔斯大厦平面" class="headerlink" title="必考: 西尔斯大厦平面"></a>必考: 西尔斯大厦平面</h2><ul>
<li>平面为方 </li>
<li>采用空腹组合筒, 9个筒高低错落</li>
<li>边长为68.7m, 由9个22.9米见方的正方形组成。</li>
<li>地上110层，地下一层，框剪结构，采用挤密桩</li>
<li>50层平面, 90层平面<br><img src="/images/nyk-xiersi-plan.png" alt=""></li>
</ul>
<h2 id="壳体结构-分别由母线和旋转轴形成的椭圆壳-双曲壳和锥形壳-轴测图-p47"><a href="#壳体结构-分别由母线和旋转轴形成的椭圆壳-双曲壳和锥形壳-轴测图-p47" class="headerlink" title="壳体结构: 分别由母线和旋转轴形成的椭圆壳, 双曲壳和锥形壳 轴测图 p47"></a>壳体结构: 分别由母线和旋转轴形成的椭圆壳, 双曲壳和锥形壳 轴测图 p47</h2><p><img src="/images/qiao-ti-jie-gou.png" alt=""></p>
<h2 id="网架-双层双曲交叉索网体系轴测图"><a href="#网架-双层双曲交叉索网体系轴测图" class="headerlink" title="网架: 双层双曲交叉索网体系轴测图"></a>网架: 双层双曲交叉索网体系轴测图</h2><p><img src="/images/wang-jia.png" alt=""></p>
<h2 id="垂直桁架-绘制高层建筑垂直桁架结构体系的结构示意图-p139"><a href="#垂直桁架-绘制高层建筑垂直桁架结构体系的结构示意图-p139" class="headerlink" title="垂直桁架: 绘制高层建筑垂直桁架结构体系的结构示意图 p139"></a>垂直桁架: 绘制高层建筑垂直桁架结构体系的结构示意图 p139</h2><p>具有很强刚度, 充分利用材料, 把部分框架改为竖向放置的桁架<br><img src="/images/chui-zhi-heng-jia.png" alt=""></p>
<h2 id="绘制3例悬挂结构体系的高层建筑立面示意-p139"><a href="#绘制3例悬挂结构体系的高层建筑立面示意-p139" class="headerlink" title="绘制3例悬挂结构体系的高层建筑立面示意 p139"></a>绘制3例悬挂结构体系的高层建筑立面示意 p139</h2><h2 id="网壳结构"><a href="#网壳结构" class="headerlink" title="网壳结构"></a>网壳结构</h2><p>肋环型网格: 节点刚性连接, 适用于中.小跨度的穹顶<br><img src="/images/wang-qiao-jie-gou.png" alt=""></p>
<h1 id="大题-30"><a href="#大题-30" class="headerlink" title="大题 30"></a>大题 30</h1><p>3选1必考</p>
<h2 id="耶鲁大学冰球馆"><a href="#耶鲁大学冰球馆" class="headerlink" title="耶鲁大学冰球馆"></a>耶鲁大学冰球馆</h2><p>建筑师： 美国建筑师, 沙里宁<br>主要结构: 悬索结构.<br>结构形式分析:上面是拱, 侧边是悬索, 悬索拉在拱和边梁之间。钢索挂在正中一道拱形脊梁和圈梁之上, 场内可容纳3000名观众, 冰球馆的外形像一只古怪的海龟似的结构<br>尺度关系: 在图中表示, 16050, 69500<br>效果图, 剖面图<br><img src="/images/yelu.png" alt=""></p>
<h2 id="杜勒斯机场"><a href="#杜勒斯机场" class="headerlink" title="杜勒斯机场"></a>杜勒斯机场</h2><p>建筑师: 沙里宁<br>主要结构: 悬索结构<br>结构分析: 候机楼有两层楼巨型钢筋混凝土柱墩, 一排稍高, 一排稍低, 在相对的柱墩子上张挂着40多的钢索, 刚墩上铺屋面板, 钢索中部下垂, 形成自然的凹面曲线屋顶, 柱墩向外倾斜, 屋面向上翘起。具有动势, 很有气派。<br>尺度关系: 矩形平面, 长182.5m, 进深45.6m</p>
<p>平面(简图,画柱子), 剖面(高度15), 透视<br><img src="/images/dulesi.png" alt=""></p>
<h2 id="代代木体育馆"><a href="#代代木体育馆" class="headerlink" title="代代木体育馆"></a>代代木体育馆</h2><p>建筑师: 丹下健三<br>主要结构: 柱墩+悬索, 悬索分为主索和侧索<br>结构分析: 代代木竞技场采用高张力缆索为主体的悬索屋顶结构，创造出带有紧张感和灵动感的大型内部空间。其特异的外部形状加之装饰性的表现，可以追溯到作为日本古代原型的神社形式和竖穴式住居，具有原始的想像力。<br>尺度关系: 主跨度为126m，横向索跨度为44m, 高度40m</p>
<p>平面(示意), 透视+剖面<br><img src="/images/daidaimu.png" alt=""></p>
<h1 id="刷"><a href="#刷" class="headerlink" title="刷"></a>刷</h1><p>1桁架: 杆件通过 焊接 铆接 螺栓连接 而成的<code>支撑横梁结构</code>, 承受 拉力和压力, 充分发挥材料特性, <code>减轻结构自重</code><br><code>材料: 钢, 木和混凝土</code><br>屋架: 屋面的<code>结构承重</code>桁架结构, 由<code>上弦杆和腹杆</code>组成<br><code>材料: 钢, 木和混凝土</code><br>1刚架: 梁柱之间通过刚性连接而成的结构, <code>适用于单层体育馆</code><br>1排架: 梁柱之间通过铰接而成的结构<br>框架: 多层多跨的刚架结构</p>
<p>1拱: 主要受轴心力作用的结构, 形状为弧形</p>
<p>结构特点:<br>推力结构, 在竖向荷载下产生水平推力<br>无弯矩, 通过合理的拱轴, 可以使得杆件无弯矩<br>充分利用材料抗压强度, 断面小, 跨度大</p>
<p>剪力墙:在高层建筑中, 将建筑物外墙和建筑永久性内隔墙布置成钢筋混凝土结构, <code>既能承受竖向荷载, 又能承受水平荷载</code><br>框支剪力墙: 在高层建筑底层商铺或住宅, 需要底层更多空间时, 将部分剪力墙改成框架柱, 形成框支剪力墙, 避震性不好</p>
<p>框架核心筒 (框筒): 结构体系中心是一个筒结构, 外围是框架<br>筒中筒    (套筒): 实腹内筒, 空腹外筒</p>
<p>框筒 框架核心筒的区别<br>框架核心筒外围是框架<br>框架核心筒中的筒, 实腹墙体构成的筒, 也可以是框筒</p>
<p>气压式薄膜结构: 在若干 充气肋和充气被的作用下，使得结构内部充满压力, 直接落地或搁置在构件上承受外部荷载<br>气承式薄膜结构: 向壳体鼓风使内部充满压力, 在较高的室内压力作用下, 使构件鼓起承受自重荷载.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[建筑设备复习]]></title>
      <url>/2018/06/26/archi-equiptment/</url>
      <content type="html"><![CDATA[<p><code>1   填空 12 * 2</code><br><code>2-6 简答 5 * 13</code><br><code>7   问答 21</code></p>
<h1 id="1-1-1-给水系统的分类-组成-供水方式"><a href="#1-1-1-给水系统的分类-组成-供水方式" class="headerlink" title="1.1.1 给水系统的分类, 组成, 供水方式"></a>1.1.1 给水系统的分类, 组成, 供水方式</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按其供水对象可分为: 生活给水系统, 生产给水系统, 消防给水系统</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>引入管, 管道系统, 给水附件, 消防设备, 升压与贮水设备, 给水局部处理设备</p>
<h2 id="给水方式"><a href="#给水方式" class="headerlink" title="给水方式"></a>给水方式</h2><p>直接给水方式/ 设有水箱的给水方式/ 设水泵的给水方式/ 设贮水池, 水泵, 水箱的给水方式/ 分区给水方式/ 气压给水方式/<br>在初步确定给水方式时, 对层高不超过3.5m的民用建筑, 所需的压力可估算: 1层100kpa, 2层120kpa, 3层以上每增加一层, 增加40kpa</p>
<h1 id="1-3-1-给水系统-p15"><a href="#1-3-1-给水系统-p15" class="headerlink" title="1.3.1 给水系统 p15"></a>1.3.1 给水系统 p15</h1><h2 id="高层建筑给水系统为什么用竖向分区供水"><a href="#高层建筑给水系统为什么用竖向分区供水" class="headerlink" title="高层建筑给水系统为什么用竖向分区供水?"></a>高层建筑给水系统为什么用竖向分区供水?</h2><p>高层建筑用水标准较高, 使用人数较多, 建筑高度大, 功能复杂, 对防震, 防沉降, 防渗漏等要求高。<br>高层建筑若采用同一给水系统供水, 则垂直方向管线过长, 下层管道中的净水压力过大,<br>必然会增大压力损失, 使管道(附近)易漏水, 启用龙头和阀门易产生水锤和噪声, 影响高层供水的安全可靠性, 因此采用竖向分区供水</p>
<h2 id="a-并联方式"><a href="#a-并联方式" class="headerlink" title="a, 并联方式"></a>a, 并联方式</h2><h3 id="高位水箱并联给水方式"><a href="#高位水箱并联给水方式" class="headerlink" title="高位水箱并联给水方式"></a>高位水箱并联给水方式</h3><p>各区设置水箱, 水泵集中布置在地下层或底层<br>特点:<br>优: 各区独立运行互不干扰/ 能耗小/ 供水可靠/ 水泵集中布置便于管理<br>缺: 水泵型号较多, 投资较大/ 分区水箱占楼层使用面积大</p>
<h3 id="分区无水箱给水方式"><a href="#分区无水箱给水方式" class="headerlink" title="分区无水箱给水方式"></a>分区无水箱给水方式</h3><p>分区设置变频调速水泵或多台并联水泵, 且集中布置在地下室或底层<br>根据各区用水量调节水泵转速 或 运行后向各区供水<br>特点:<br>优: 供水可靠性强/ 设备集中设置, 便于管理/ 无高位水箱不占上层面积<br>缺: 水泵型号多, 投资大/ 水泵控制调节复杂</p>
<h2 id="b-串联给水方式"><a href="#b-串联给水方式" class="headerlink" title="b, 串联给水方式"></a>b, 串联给水方式</h2><p>分区设置水箱和水泵, 水泵分散布置<br>自下区水箱抽水供上区用水<br>特点:<br>优: 设备和管道较简单, 投资省, 能耗小<br>缺: 水泵设置在上层, 对防振动和噪声要求高/ 各区水箱增加结构负荷/ 上区供水受下区限制/ 供水可靠性差</p>
<h2 id="c-减压给水方式"><a href="#c-减压给水方式" class="headerlink" title="c, 减压给水方式"></a>c, 减压给水方式</h2><p>分区设置水箱/ 由设置在地下室或底层的水泵将水加压至最高层水箱/ 上层供下层用水/ 利用水箱减压<br>特点:<br>优: 水泵台数少, 设备管理维护简单<br>缺: 水泵扬程较大/ 运行费用高/ 最高层水箱容积较大, 增加了结构负荷/ 下层供水压力损耗较大, 不够节能 </p>
<h1 id="2-2-1-自然循环热水供暖系统-p59"><a href="#2-2-1-自然循环热水供暖系统-p59" class="headerlink" title="2.2.1 自然循环热水供暖系统 p59"></a>2.2.1 自然循环热水供暖系统 p59</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h2><p>1, 冷水管向系统内充满水<br>2, 锅炉开始加热<br>3, 当水温升高后, 堆高度开始降低, 热水沿供水管上升至散热器<br>4, 在散热器中散热后温度降低<br>5, 沿回水管流回锅炉再加热, 循环往复</p>
<h2 id="供暖系统的任务是什么"><a href="#供暖系统的任务是什么" class="headerlink" title="供暖系统的任务是什么?"></a>供暖系统的任务是什么?</h2><p>为了满足生活, 生产的要求, 营造舒适的生活环境或者一定的生产环境, 维持一定的室内温度, 必须不断地向室内提供一定数量的热量以弥补其散失的热量</p>
<h1 id="2-2-2-机械循环热水供暖系统-p61"><a href="#2-2-2-机械循环热水供暖系统-p61" class="headerlink" title="2.2.2 机械循环热水供暖系统 p61"></a>2.2.2 机械循环热水供暖系统 p61</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>1, 因为采用循环水泵为水循环提供动力, 所以循环作用压力大</li>
<li>2, 系统的作用半径大, 水的流速大, 管径较小, 启动容易, 供暖方式多, 应用广泛</li>
</ul>
<h2 id="a-机械供暖与自然供暖的区别"><a href="#a-机械供暖与自然供暖的区别" class="headerlink" title="a, 机械供暖与自然供暖的区别"></a>a, 机械供暖与自然供暖的区别</h2><h3 id="1-循环动力不同"><a href="#1-循环动力不同" class="headerlink" title="1, 循环动力不同:"></a>1, 循环动力不同:</h3><ul>
<li>机械: 水泵; </li>
<li>自然: 密度差 <h3 id="2-膨胀水箱的连接点和作用不同"><a href="#2-膨胀水箱的连接点和作用不同" class="headerlink" title="2, 膨胀水箱的连接点和作用不同"></a>2, 膨胀水箱的连接点和作用不同</h3></li>
<li>机械: 循环水泵入口前的回水管, 作用在于吸收和补充膨胀与收缩的水量, 排气以及起到定压的作用</li>
<li>自然: 供水立管的最高点, 作用在于吸收系统中热水膨胀体积, 补充水量不足和排气<h3 id="3-排气途径不同"><a href="#3-排气途径不同" class="headerlink" title="3, 排气途径不同"></a>3, 排气途径不同</h3></li>
<li>机械: 随着水流一起流动</li>
<li>自然: 逆着水流方向浮升</li>
</ul>
<h2 id="b-机械供暖的主要方式-需要仔细看看"><a href="#b-机械供暖的主要方式-需要仔细看看" class="headerlink" title="b, 机械供暖的主要方式(需要仔细看看)"></a>b, 机械供暖的主要方式(需要仔细看看)</h2><h3 id="垂直式"><a href="#垂直式" class="headerlink" title="垂直式"></a>垂直式</h3><p>上供下回<br>下供下回<br>中供式<br>下供上回</p>
<h3 id="水平式"><a href="#水平式" class="headerlink" title="水平式"></a>水平式</h3><p>水平单管顺流式,<br>单管跨越式</p>
<h3 id="水平式优点"><a href="#水平式优点" class="headerlink" title="水平式优点"></a>水平式优点</h3><ul>
<li>1, 安装简单, 穿楼板的立管少, 可逐层安装供暖系统</li>
<li>2, 顶层不需专设膨胀水箱, 可利用楼梯间.厕所设置, 造价比垂直式低</li>
</ul>
<h3 id="水平式问题"><a href="#水平式问题" class="headerlink" title="水平式问题"></a>水平式问题</h3><ul>
<li>1, 排气, 必须安装气阀</li>
</ul>
<h2 id="c-异程式与同程式"><a href="#c-异程式与同程式" class="headerlink" title="c, 异程式与同程式"></a>c, 异程式与同程式</h2><p>异程式: 每根立管都与锅炉.供.回水管组成循环环路, 而通过各根立管的循环环路的长度都是不同的<br>同程式: 增加了回水管长度, 使各分立管的循环环路的长度相等</p>
<h3 id="同程式优缺点"><a href="#同程式优缺点" class="headerlink" title="同程式优缺点"></a>同程式优缺点</h3><p>优: 有利于环路间的阻力平衡, 热量分配易于达到设计要求,<br>缺: 用的金属管材较多, 施工时地沟深度增加</p>
<h2 id="d-供热系统中散热器-膨胀水箱-疏水器的种类及作用有哪些？"><a href="#d-供热系统中散热器-膨胀水箱-疏水器的种类及作用有哪些？" class="headerlink" title="d, 供热系统中散热器, 膨胀水箱, 疏水器的种类及作用有哪些？"></a>d, 供热系统中散热器, 膨胀水箱, 疏水器的种类及作用有哪些？</h2><h3 id="散热器种类"><a href="#散热器种类" class="headerlink" title="散热器种类"></a>散热器种类</h3><p>种类</p>
<ul>
<li>1, 铸铁散热器(圆翼型, 长翼型, 柱型)</li>
<li>2, 钢制散热器(闭式钢率片, 板型, 铁制柱型, 篇管)</li>
<li>3, 其他材质散热器<br>功能:<br>具体一定温度的热媒所携带的热量是通过散热器不断地传给室内空气和物体的热量通过散热器壁面以对流, 辐射方式传递给室内</li>
</ul>
<h3 id="膨胀水箱作用"><a href="#膨胀水箱作用" class="headerlink" title="膨胀水箱作用"></a>膨胀水箱作用</h3><p>用来储存热水供暖系统加热的膨胀水量, 还起着排气作用, 恒定供暖系统的压力</p>
<h3 id="疏水器种类"><a href="#疏水器种类" class="headerlink" title="疏水器种类"></a>疏水器种类</h3><p>种类</p>
<ul>
<li>1, 机械型疏水器(浮筒式, 钟型浮水式, 吊桶式)</li>
<li>2, 热水型疏水器(脉冲式, 热动力式, 孔板式)</li>
<li>3, 恒温型疏水器(双金属片式, 波纹管式, 液体膨胀式)<br>作用:<br>自动阻止蒸汽遗漏而且迅速地排出用热设备及管道中的凝水, 同时能排除系统中积留的空气和不凝气体。</li>
</ul>
<h1 id="3-1-3-高层建筑防火排烟-p115"><a href="#3-1-3-高层建筑防火排烟-p115" class="headerlink" title="3.1.3 高层建筑防火排烟 p115"></a>3.1.3 高层建筑防火排烟 p115</h1><h2 id="a-防火分区和防烟分区"><a href="#a-防火分区和防烟分区" class="headerlink" title="a, 防火分区和防烟分区"></a>a, 防火分区和防烟分区</h2><h3 id="1-防火分区"><a href="#1-防火分区" class="headerlink" title="(1)防火分区"></a>(1)防火分区</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p>采用防火分隔措施划分的局部区域</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>1, 可有效防止火灾时火势蔓延和烟气传播</li>
<li>2, 便于人员疏散和火灾的扑救</li>
<li>3, 减少火灾的损失<h4 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h4></li>
<li>1, 两个防火分区之间应水平设置 <code>防火墙``防火卷帘``防火门</code>等装置对火势进行阻隔</li>
<li>2, 每个防火分区最大建筑面积: 一类1000m2, 二类1500m2, 地下室500m2</li>
<li>3, 高层建筑, 设有火灾自动报警系统和自动灭火系统, 且采用不燃烧或难燃烧材料装修, 地上防火分区&lt;=4000m2, 地下部分 &lt;= 2000m2</li>
<li>4, 高层建筑与裙房之间设有防火墙等防火分隔设施时, 裙房防火分区 &lt;= 2500m2</li>
<li>5, 当设有自动喷水灭火系统: 最大面积增加一倍</li>
</ul>
<h3 id="2-防烟分区"><a href="#2-防烟分区" class="headerlink" title="(2)防烟分区"></a>(2)防烟分区</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><p>在火灾发生时候, 将烟气控制在一定范围内</p>
<h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求:"></a>要求:</h4><ul>
<li>1, 防烟分区不应跨越防火分区</li>
<li>2, 每个防烟分区的建筑面积 &lt;= 500m2</li>
<li>3, 走道, 净高不超过房间的6.0m, 采用挡烟垂璧, 隔墙突出 &gt;= 0.50的梁划分防烟分区</li>
</ul>
<h2 id="b-防-排烟方式"><a href="#b-防-排烟方式" class="headerlink" title="b, 防.排烟方式"></a>b, 防.排烟方式</h2><h3 id="自然排烟"><a href="#自然排烟" class="headerlink" title="自然排烟"></a>自然排烟</h3><p>优: 不需要动力/经济方便<br>缺: 易受到室外风力影响, 火势猛烈时, 火焰可能从开口部位向上蔓延</p>
<h3 id="机械排烟"><a href="#机械排烟" class="headerlink" title="机械排烟"></a>机械排烟</h3><p>定义:使用排烟风机进行强制排烟<br>优: 不受室外风力影响, 工作可靠<br>缺: 初期投资多</p>
<h1 id="3-2-4-空气处理设备-p125"><a href="#3-2-4-空气处理设备-p125" class="headerlink" title="3.2.4 空气处理设备 p125"></a>3.2.4 空气处理设备 p125</h1><h2 id="a-空气净化-加热-冷却-加湿-除湿"><a href="#a-空气净化-加热-冷却-加湿-除湿" class="headerlink" title="a, 空气净化, 加热, 冷却, 加湿, 除湿"></a>a, 空气净化, 加热, 冷却, 加湿, 除湿</h2><h3 id="空气过滤器"><a href="#空气过滤器" class="headerlink" title="空气过滤器"></a>空气过滤器</h3><p>粗效过滤器, 中效过滤器, 高效过滤器</p>
<h3 id="空气加热器"><a href="#空气加热器" class="headerlink" title="空气加热器"></a>空气加热器</h3><p>表面式, 电加热</p>
<h3 id="空气冷却器"><a href="#空气冷却器" class="headerlink" title="空气冷却器"></a>空气冷却器</h3><p>表面式空气冷却: 结构同表面式空气加热器, 不同的是冷冻水或制冷剂作为冷媒。</p>
<ul>
<li>以冷冻水作为冷媒, 水冷式空气冷却器</li>
<li>以制冷剂作为冷媒, 直接蒸发式空气冷却器<br>喷水室:<h3 id="空气加湿器"><a href="#空气加湿器" class="headerlink" title="空气加湿器"></a>空气加湿器</h3>蒸汽喷管加湿器/电加湿器<h3 id="除湿设备"><a href="#除湿设备" class="headerlink" title="除湿设备"></a>除湿设备</h3>加热通风除湿:将湿度较低的室外空气加热送入室内, 从室内排除同等数量的潮湿空气<br>冷冻除湿: 利用制冷设备, 除掉空气中析出的凝结水, 再将空气温度升高达到除湿目的<br>液体吸湿剂除湿: 将盐水溶液与空气直接接触, 空气中的水分被盐分吸收, 从而到达吸湿目的<br>固体吸湿剂: 空气经过吸湿材料的表面或孔隙, 空气中的水分被吸附, 常用的是硅胶和氯化钙<h3 id="热交换器"><a href="#热交换器" class="headerlink" title="热交换器"></a>热交换器</h3><h2 id="b-装配式空调机组"><a href="#b-装配式空调机组" class="headerlink" title="b, 装配式空调机组"></a>b, 装配式空调机组</h2>将多种空气处理设备及风机, 阀门等制成带箱体的单元段, 根据工程需要组合, 实现多种空气处理要求的设备<h2 id="c-空调制冷设备"><a href="#c-空调制冷设备" class="headerlink" title="c, 空调制冷设备"></a>c, 空调制冷设备</h2></li>
</ul>
<h3 id="蒸汽压缩式制冷系统"><a href="#蒸汽压缩式制冷系统" class="headerlink" title="蒸汽压缩式制冷系统"></a>蒸汽压缩式制冷系统</h3><p>组成: 冷压缩机, 冷凝器, 膨胀阀, 蒸发器<br>工作过程: 来自蒸发器的低温低压制冷剂蒸汽被吸入压缩机, 压缩成高温高压制冷剂蒸汽, 进入冷凝器中放出热量, 冷凝程高压液体, 然后经膨胀阀节流降压后变成低温低压液体进入蒸发器, 在蒸发器中液体制冷剂蒸发吸收被冷却介质的热量, 变成低温低压气体再回到压缩机, 进行下一个循环。被冷却介质失去热量, 温度下降, 获得空调的冷媒水或冷风.</p>
<h3 id="吸收式制冷系统"><a href="#吸收式制冷系统" class="headerlink" title="吸收式制冷系统"></a>吸收式制冷系统</h3><p>组成: 发生器, 冷凝器, 膨胀阀, 蒸发器, 吸收器<br>工作过程: 与蒸汽压缩式一样, 都是利用液体在汽化时要吸收热量来实现制冷, 不同的是, 蒸汽压缩式制冷消耗机械能, 吸收式制冷消耗热能使能量从低温热源转移到高温热源</p>
<h3 id="制冷剂组"><a href="#制冷剂组" class="headerlink" title="制冷剂组"></a>制冷剂组</h3><p>就是将全部或部分制冷设备组装成一个整体, 直接向用户提供冷凝水。</p>
<h3 id="循环水冷却系统"><a href="#循环水冷却系统" class="headerlink" title="循环水冷却系统"></a>循环水冷却系统</h3><p>大中型制冷系统冷凝器释放出的热量, 一般采用循环水冷却系统将散热量带走, 以保证制冷机组正常运行</p>
<h3 id="大温差技术"><a href="#大温差技术" class="headerlink" title="大温差技术"></a>大温差技术</h3><p>空调送风或送水的温差比常规空调系统采用的温差大</p>
<h1 id="4-1-2-建筑电气系统的分类-p144"><a href="#4-1-2-建筑电气系统的分类-p144" class="headerlink" title="4.1.2 建筑电气系统的分类 p144"></a>4.1.2 建筑电气系统的分类 p144</h1><p>组成: 建筑电气系统一般由 用电设备/供配电线路/ 控制和保护装置<br>分类:<br>根据 -&gt; 电能的产生, 分配, 传输和消耗使用,      类 -&gt; 供配电系统/用电系统<br>根据 -&gt; 用电设备的特点和系统中所传递能量的类型, 类 -&gt; 建筑照明系统/建筑动力系统/建筑弱电系统</p>
<h2 id="a-建筑的供配电系统"><a href="#a-建筑的供配电系统" class="headerlink" title="a, 建筑的供配电系统"></a>a, 建筑的供配电系统</h2><h3 id="电能产生-输送和分配"><a href="#电能产生-输送和分配" class="headerlink" title="电能产生, 输送和分配"></a>电能产生, 输送和分配</h3><h4 id="1-电能产生-输送和分配"><a href="#1-电能产生-输送和分配" class="headerlink" title="(1)电能产生, 输送和分配"></a>(1)电能产生, 输送和分配</h4><p>电能的产生, 输送, 分配和使用的全过程是同时进行</p>
<h4 id="2-发电厂"><a href="#2-发电厂" class="headerlink" title="(2)发电厂"></a>(2)发电厂</h4><p>定义: 将各种形式的能量转换为电能的工厂<br>分类: 火力发电厂, 水力, 风力, 原子核能</p>
<h4 id="3-电能输送"><a href="#3-电能输送" class="headerlink" title="(3)电能输送"></a>(3)电能输送</h4><p>特点: 当发电厂除送电能一定时, 采用的送电电压越高, 线路损耗越低<br>所以, 远距离书店必须采用高压输电线</p>
<h4 id="4-电能用户"><a href="#4-电能用户" class="headerlink" title="(4)电能用户"></a>(4)电能用户</h4><p>定义: 把电能转化为其他形式能量的设备</p>
<h3 id="电路系统的电压和频率"><a href="#电路系统的电压和频率" class="headerlink" title="电路系统的电压和频率"></a>电路系统的电压和频率</h3><h4 id="1-电压等级"><a href="#1-电压等级" class="headerlink" title="(1)电压等级"></a>(1)电压等级</h4><p>我国规定交流电网的额定电压等级: 220V, 380V, 3KV, 6KV, 10KV, 3KV,110KV, 220KV<br>1k及以上的电压称为高压, 1kv以下称为低压</p>
<h4 id="2-各种电压等级的使用范围"><a href="#2-各种电压等级的使用范围" class="headerlink" title="(2)各种电压等级的使用范围"></a>(2)各种电压等级的使用范围</h4><h4 id="3-额定电压和频率"><a href="#3-额定电压和频率" class="headerlink" title="(3)额定电压和频率:"></a>(3)额定电压和频率:</h4><p>使用工频交流电频率为50hz, 线/相电压为380/220V</p>
<h3 id="民用建筑供电系统"><a href="#民用建筑供电系统" class="headerlink" title="民用建筑供电系统"></a>民用建筑供电系统</h3><p>小范围: 变电室, 6~10kv -&gt; 低压380/220V<br>大型:   高压变电所, 6~10kv -&gt; 经过几路高压配电线将电能分到变电所, 380/220v</p>
<h3 id="电力负荷的分类"><a href="#电力负荷的分类" class="headerlink" title="电力负荷的分类"></a>电力负荷的分类</h3><p>定义: 根据供电可靠性及中断供电所造成的损失或者影响<br>分类: 一级负荷, 二级负荷, 三级负荷<br>一级负荷: 1, 中断供电将造成人身伤害/2, 中断供电将造成重大影响和重大损失/ 3, 破坏有重大影响的用电单位的正常工作, 或造成秩序混乱<br>二级负荷: </p>
<ul>
<li>1, 造成较大影响或损失/2, 将影响重要用电单位的正常工作或造成秩序混乱</li>
<li>要求: 要用两个独立电源系统供电, 只有一个电源供电时, 必须使用两个回路<br>三级负荷: 可接约定供电<h2 id="b-电气照明系统"><a href="#b-电气照明系统" class="headerlink" title="b, 电气照明系统"></a>b, 电气照明系统</h2>定义: 凡是建筑物内外将电能转换为光能, 以保证人们正常的生活, 生产和工作学习活动, 满足着视力和装饰要求的照明设施<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3>电气系统: 电能的产生, 输送, 分配, 控制和消耗使用的整个系统<br>照明系统: 光能的产生, 传播, 分配, 控制和消耗系统<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3>正常照明, 事故照明, 警卫值班照明, 节日彩灯和装饰照明</li>
</ul>
<h2 id="c-建筑动力系统"><a href="#c-建筑动力系统" class="headerlink" title="c, 建筑动力系统"></a>c, 建筑动力系统</h2><h3 id="电动机种类和应用"><a href="#电动机种类和应用" class="headerlink" title="电动机种类和应用"></a>电动机种类和应用</h3><p>交流电动机: 笼式异步电动机/ 绕线转子电动机<br>直流电动机: 串励式/ 并励式/ 复励式</p>
<p>异步电动机构造简单, 价格便宜, 启动方便, 在建筑动力系统中得到广泛应用.</p>
<h3 id="异步电动机的启动"><a href="#异步电动机的启动" class="headerlink" title="异步电动机的启动"></a>异步电动机的启动</h3><p>电动机从接通电源开始转动, 到转速增至额定转速的过程</p>
<h3 id="异步电动机的启动方法"><a href="#异步电动机的启动方法" class="headerlink" title="异步电动机的启动方法"></a>异步电动机的启动方法</h3><p>异步电动机的启动方法由它的结构和其所接的电影容量大小决定</p>
<h2 id="d-建筑弱电系统"><a href="#d-建筑弱电系统" class="headerlink" title="d, 建筑弱电系统"></a>d, 建筑弱电系统</h2><p>强电: 以安倍为单位<br>弱电: 以毫安为计量单位</p>
<p>功能: 主要进行信息的传递和交换<br>主要包括: 火灾自动报警, 消防联动系统, 电话通信系统, 建筑广播, 共用电视天线, 有线电视系统, 智能化建筑综合布线和安防系统</p>
<h1 id="4-4-2-保护接地与保护接零-p188"><a href="#4-4-2-保护接地与保护接零-p188" class="headerlink" title="4.4.2 保护接地与保护接零 p188"></a>4.4.2 保护接地与保护接零 p188</h1><p>保护接地: 电气设备的某部分(设备可导电外壳)用金属导体与大地作良好的电气连接</p>
<p>保护接零: 电源中性点接地的系统中, 将电气设备不带电的金属部分与零线作良好的接触</p>
<p>中性线和零线的区别: 发电机, 变压器, 电动机和电器等的绕组中心以及带电源的串联回路中有一点, 此点与外部各接线端间的电压的绝对值均相等, 这一点称为中性点或中点。 当中性点接地时, 该点称为零点. 由中性点引出的导线称为中心线, 由零点引出的导线称为零线</p>
<p>接地体: 埋入地中并直接与大地接触的金属导体<br>自然接地体: 兼作接地用的直接与大地接触的各种金属构件, 金属井管, 钢筋混凝土建筑物的基础, 金属管道和设备<br>人工接地体: 转为接地埋入地中的圆钢, 角钢<br>接地线: 连接设备接地部分与接地体的金属导线<br>接地装置: 接地体和接地线的总和</p>
<h2 id="a-接地概述"><a href="#a-接地概述" class="headerlink" title="a, 接地概述"></a>a, 接地概述</h2><h3 id="1-电气接地作用"><a href="#1-电气接地作用" class="headerlink" title="(1) 电气接地作用"></a>(1) 电气接地作用</h3><p>如果电气设备某处绝缘损坏而使外壳带点时, 一旦人触及电气绝缘损坏的外壳, 如果没有接地装置, 利用”并联分流”作用, 接地电流将同时沿着接地体和人体两条通路分流。接地电阻越小, 流经人体的电流也就越小; 如果接地电阻小于某个定值, 流过人体的电流也就小于伤害人体的电流值, 使人体避免触电的危险</p>
<h3 id="2-接地电阻"><a href="#2-接地电阻" class="headerlink" title="(2)接地电阻"></a>(2)接地电阻</h3><p>指电流从埋入地中的接地体散流到周围土壤时, 接地体与大地远处的电位差与该电流之比, 而不是接地体的表面电阻。</p>
<h3 id="3-电气”地”或”大地”"><a href="#3-电气”地”或”大地”" class="headerlink" title="(3)电气”地”或”大地”"></a>(3)电气”地”或”大地”</h3><p>接地电流在大地中散逸时, 在各个有不同的电位梯度地方称为电气上的”地”或”大地”</p>
<h2 id="b-接地类型"><a href="#b-接地类型" class="headerlink" title="b, 接地类型"></a>b, 接地类型</h2><ul>
<li>工作接地: 电气设备在正常和事故情况下可靠地工作而进行的接地</li>
<li>保护接地: 在中性点不接地或没有中性线的低压系统中, 将电气设备在正常情况下不带电的金属外壳部分与接地体之间作良好的金属连接</li>
<li>保护接零: 在电源中性点接地系统中, 将在正常情况下电气设备不带电的金属外壳, 框架等与零线作良好的金属连接</li>
<li>重复接地: 采用保护接零时, 除系统的中性点工作接地外, 将零线上的一点或多点与地再作金属连接</li>
<li>屏蔽接地: 为使干扰电场在金属屏蔽层感应所产生的电荷导入带地, 而将金属屏蔽层接地</li>
<li>专用电气设备的接地: 设备接地</li>
</ul>
<h2 id="c-常见保护接地方式"><a href="#c-常见保护接地方式" class="headerlink" title="c, 常见保护接地方式"></a>c, 常见保护接地方式</h2><p>分类: IT, TT, TN<br>IT&amp;TT的设备外露可导电部分经各自的保护线直接接地(保护接地)<br>TN系统的设备外露可导电部分经过公共的保护线与电源中性点直接电气连接(接零保护)</p>
<h1 id="5-2-火灾自动报警系统-p237"><a href="#5-2-火灾自动报警系统-p237" class="headerlink" title="5.2 火灾自动报警系统 p237"></a>5.2 火灾自动报警系统 p237</h1><h2 id="自动报警系统组成"><a href="#自动报警系统组成" class="headerlink" title="自动报警系统组成"></a>自动报警系统组成</h2><p>触发器, 火灾报警装置, 消防控制设备, 电源</p>
<h2 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h2><p>火灾自动报警系统必须与消防系统联动控制, 包括了固定灭火装置的联动控制, 防排烟设备的联动控制, 应急与消防疏散指示系统, 火灾应急广播与警报装置, 消防专用电话和消防电梯的联动控制.</p>
<h2 id="控制器工作原理"><a href="#控制器工作原理" class="headerlink" title="控制器工作原理"></a>控制器工作原理</h2><p>提供火灾探测器稳定的直流电源, 监视连接的探测器有无故障, 保证探测器长期, 稳定有效, 工作;<br>当火灾探测器探测火情后, 迅速处理, 执行控制</p>
<h1 id="非重点题目"><a href="#非重点题目" class="headerlink" title="非重点题目"></a>非重点题目</h1><h2 id="通气管有哪几种类型"><a href="#通气管有哪几种类型" class="headerlink" title="通气管有哪几种类型"></a>通气管有哪几种类型</h2><p>伸顶通气管, 器具通气管, 环形, 专用通气立管, 主通气立管, 副通气立管, 结合通气管</p>
<h2 id="在什么条件下设置消防水池"><a href="#在什么条件下设置消防水池" class="headerlink" title="在什么条件下设置消防水池"></a>在什么条件下设置消防水池</h2><ul>
<li>生产, 生活用水量达到最大时, 市政给水管道, 赴水管或天然水源不能满足室内外消防用水量</li>
<li>市政给水管道为枝状或只有一条进水管, 且消防用水量之和超过25 L/S</li>
</ul>
<h2 id="高层建筑热水供暖系统的方式有哪些-2-2-4"><a href="#高层建筑热水供暖系统的方式有哪些-2-2-4" class="headerlink" title="高层建筑热水供暖系统的方式有哪些? 2.2.4"></a>高层建筑热水供暖系统的方式有哪些? 2.2.4</h2><p>竖向分区式, 双线式供暖系统, 单双管混合式系统</p>
<h2 id="燃煤锅炉的基本构造有哪些-其工作过程可分为几部分-2-5"><a href="#燃煤锅炉的基本构造有哪些-其工作过程可分为几部分-2-5" class="headerlink" title="燃煤锅炉的基本构造有哪些? 其工作过程可分为几部分? 2.5"></a>燃煤锅炉的基本构造有哪些? 其工作过程可分为几部分? 2.5</h2><h3 id="锅炉基本构造"><a href="#锅炉基本构造" class="headerlink" title="锅炉基本构造"></a>锅炉基本构造</h3><h4 id="气锅-gt-封闭汽水系统"><a href="#气锅-gt-封闭汽水系统" class="headerlink" title="气锅 =&gt; 封闭汽水系统"></a>气锅 =&gt; 封闭汽水系统</h4><p>锅筒, 管束, 水冷壁, 集筒, 下降管</p>
<h4 id="炉子-gt-燃烧设备"><a href="#炉子-gt-燃烧设备" class="headerlink" title="炉子 =&gt; 燃烧设备"></a>炉子 =&gt; 燃烧设备</h4><p>煤斗, 炉排, 除渣板, 送风装置</p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>燃料的燃烧过程, 烟气向水的传热过程和水的受热汽化过程</p>
<h2 id="建筑内消火栓系统由哪些主要部分组成-建筑内消火栓系统供水方式有几种"><a href="#建筑内消火栓系统由哪些主要部分组成-建筑内消火栓系统供水方式有几种" class="headerlink" title="建筑内消火栓系统由哪些主要部分组成? 建筑内消火栓系统供水方式有几种?"></a>建筑内消火栓系统由哪些主要部分组成? 建筑内消火栓系统供水方式有几种?</h2><p>组成: 消防水源, 消防供水设备, 室内消防给水管道, 室内消火栓<br>方式: </p>
<ul>
<li>无加压泵和水箱的消火栓给水系统</li>
<li>设有水箱的消火栓给水系统</li>
<li>设有消防水泵和消防水箱的消火栓给水系统</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[建筑设备复习]]></title>
      <url>/2018/06/26/archi-equipment/</url>
      <content type="html"><![CDATA[<p><code>1   填空 12 * 2</code><br><code>2-6 简答 5 * 13</code><br><code>7   问答 21</code></p>
<h1 id="1-1-1-给水系统的分类-组成-供水方式"><a href="#1-1-1-给水系统的分类-组成-供水方式" class="headerlink" title="1.1.1 给水系统的分类, 组成, 供水方式"></a>1.1.1 给水系统的分类, 组成, 供水方式</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按其供水对象可分为: 生活给水系统, 生产给水系统, 消防给水系统</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>引入管, 管道系统, 给水附件, 消防设备, 升压与贮水设备, 给水局部处理设备</p>
<h2 id="给水方式"><a href="#给水方式" class="headerlink" title="给水方式"></a>给水方式</h2><h1 id="1-3-1-给水系统-p15"><a href="#1-3-1-给水系统-p15" class="headerlink" title="1.3.1 给水系统 p15"></a>1.3.1 给水系统 p15</h1><h2 id="高层建筑给水系统为什么用竖向分区供水"><a href="#高层建筑给水系统为什么用竖向分区供水" class="headerlink" title="高层建筑给水系统为什么用竖向分区供水?"></a>高层建筑给水系统为什么用竖向分区供水?</h2><p>高层建筑用水标准较高, 使用人数较多, 建筑高度大, 功能复杂, 对防震, 防沉降, 防渗漏等要求高。<br>高层建筑若采用同一给水系统供水, 则垂直方向管线过长, 下层管道中的净水压力过大,<br>必然会增大压力损失, 使管道(附近)易漏水, 启用龙头和阀门易产生水锤和噪声, 影响高层供水的安全可靠性, 因此采用竖向分区供水</p>
<h2 id="a-并联方式"><a href="#a-并联方式" class="headerlink" title="a, 并联方式"></a>a, 并联方式</h2><h3 id="高位水箱并联给水方式"><a href="#高位水箱并联给水方式" class="headerlink" title="高位水箱并联给水方式"></a>高位水箱并联给水方式</h3><p>各区设置水箱, 水泵集中布置在地下层或底层<br>特点:<br>优: 各区独立运行互不干扰/ 能耗小/ 供水可靠/ 水泵集中布置便于管理<br>缺: 水泵型号较多, 投资较大/ 分区水箱占楼层使用面积大</p>
<h3 id="分区无水箱给水方式"><a href="#分区无水箱给水方式" class="headerlink" title="分区无水箱给水方式"></a>分区无水箱给水方式</h3><p>分区设置变频调速水泵或多台并联水泵, 且集中布置在地下室或底层<br>根据各区用水量调节水泵转速 或 运行后向各区供水<br>特点:<br>优: 供水可靠性强/ 设备集中设置, 便于管理/ 无高位水箱不占上层面积<br>缺: 水泵型号多, 投资大/ 水泵控制调节复杂</p>
<h2 id="b-串联给水方式"><a href="#b-串联给水方式" class="headerlink" title="b, 串联给水方式"></a>b, 串联给水方式</h2><p>分区设置水箱和水泵, 水泵分散布置<br>自下区水箱抽水供上区用水<br>特点:<br>优: 设备和管道较简单, 投资省, 能耗小<br>缺: 水泵设置在上层, 对防振动和噪声要求高/ 各区水箱增加结构负荷/ 上区供水受下区限制/ 供水可靠性差</p>
<h2 id="c-减压给水方式"><a href="#c-减压给水方式" class="headerlink" title="c, 减压给水方式"></a>c, 减压给水方式</h2><p>分区设置水箱/ 由设置在地下室或底层的水泵将水加压至最高层水箱/ 上层供下层用水/ 利用水箱减压<br>特点:<br>优: 水泵台数少, 设备管理维护简单<br>缺: 水泵扬程较大/ 运行费用高/ 最高层水箱容积较大, 增加了结构负荷/ 下层供水压力损耗较大, 不够节能 </p>
<h1 id="2-2-1-自然循环热水供暖系统-p59"><a href="#2-2-1-自然循环热水供暖系统-p59" class="headerlink" title="2.2.1 自然循环热水供暖系统 p59"></a>2.2.1 自然循环热水供暖系统 p59</h1><p>原理:<br>1, 冷水管向系统内充满水<br>2, 锅炉开始加热<br>3, 当水温升高后, 堆高度开始降低, 热水沿供水管上升至散热器<br>4, 在散热器中散热后温度降低<br>5, 沿回水管流回锅炉再加热, 循环往复</p>
<h1 id="2-2-2-机械循环热水供暖系统-p61"><a href="#2-2-2-机械循环热水供暖系统-p61" class="headerlink" title="2.2.2 机械循环热水供暖系统 p61"></a>2.2.2 机械循环热水供暖系统 p61</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>1, 因为采用循环水泵为水循环提供动力, 所以循环作用压力大</li>
<li>2, 系统的作用半径大, 水的流速大, 管径较小, 启动容易, 供暖方式多, 应用广泛</li>
</ul>
<h2 id="a-机械供暖与自然供暖的区别"><a href="#a-机械供暖与自然供暖的区别" class="headerlink" title="a, 机械供暖与自然供暖的区别"></a>a, 机械供暖与自然供暖的区别</h2><h3 id="1-循环动力不同"><a href="#1-循环动力不同" class="headerlink" title="1, 循环动力不同:"></a>1, 循环动力不同:</h3><ul>
<li>机械: 水泵; </li>
<li>自然: 密度差 <h3 id="2-膨胀水箱的连接点和作用不同"><a href="#2-膨胀水箱的连接点和作用不同" class="headerlink" title="2, 膨胀水箱的连接点和作用不同"></a>2, 膨胀水箱的连接点和作用不同</h3></li>
<li>机械: 循环水泵入口前的回水管, 作用在于吸收和补充膨胀与收缩的水量, 排气以及起到定压的作用</li>
<li>自然: 供水立管的最高点, 作用在于吸收系统中热水膨胀体积, 补充水量不足和排气<h3 id="3-排气途径不同"><a href="#3-排气途径不同" class="headerlink" title="3, 排气途径不同"></a>3, 排气途径不同</h3></li>
<li>机械: 随着水流一起流动</li>
<li>自然: 逆着水流方向浮升</li>
</ul>
<h2 id="b-机械供暖的主要方式-需要仔细看看"><a href="#b-机械供暖的主要方式-需要仔细看看" class="headerlink" title="b, 机械供暖的主要方式(需要仔细看看)"></a>b, 机械供暖的主要方式(需要仔细看看)</h2><h3 id="垂直式"><a href="#垂直式" class="headerlink" title="垂直式"></a>垂直式</h3><p>上供下回<br>下供下回<br>中供式<br>下供上回</p>
<h3 id="水平式"><a href="#水平式" class="headerlink" title="水平式"></a>水平式</h3><p>水平单管顺流式,<br>单管跨越式</p>
<h3 id="水平式优点"><a href="#水平式优点" class="headerlink" title="水平式优点"></a>水平式优点</h3><ul>
<li>1, 安装简单, 穿楼板的立管少, 可逐层安装供暖系统</li>
<li>2, 顶层不需专设膨胀水箱, 可利用楼梯间.厕所设置, 造价比垂直式低</li>
</ul>
<h2 id="水平式问题"><a href="#水平式问题" class="headerlink" title="水平式问题"></a>水平式问题</h2><ul>
<li>1, 排气, 必须安装气阀</li>
</ul>
<h2 id="c-异程式与同程式"><a href="#c-异程式与同程式" class="headerlink" title="c, 异程式与同程式"></a>c, 异程式与同程式</h2><p>异程式: 每根立管都与锅炉.供.回水管组成循环环路, 而通过各根立管的循环环路的长度都是不同的<br>同程式: 增加了回水管长度, 使各分立管的循环环路的长度相等</p>
<h2 id="同程式优缺点"><a href="#同程式优缺点" class="headerlink" title="同程式优缺点"></a>同程式优缺点</h2><p>优: 有利于环路间的阻力平衡, 热量分配易于达到设计要求,<br>缺: 用的金属管材较多, 施工时地沟深度增加</p>
<h1 id="3-1-3-高层建筑防火排烟-p115"><a href="#3-1-3-高层建筑防火排烟-p115" class="headerlink" title="3.1.3 高层建筑防火排烟 p115"></a>3.1.3 高层建筑防火排烟 p115</h1><h2 id="a-防火分区和防烟分区"><a href="#a-防火分区和防烟分区" class="headerlink" title="a, 防火分区和防烟分区"></a>a, 防火分区和防烟分区</h2><h3 id="1-防火分区"><a href="#1-防火分区" class="headerlink" title="(1)防火分区"></a>(1)防火分区</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p>采用防火分隔措施划分的局部区域</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>1, 可有效防止火灾时火势蔓延和烟气传播</li>
<li>2, 便于人员疏散和火灾的扑救</li>
<li>3, 减少火灾的损失<h4 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h4></li>
<li>1, 两个防火分区之间应水平设置 <code>防火墙``防火卷帘``防火门</code>等装置对火势进行阻隔</li>
<li>2, 每个防火分区最大建筑面积: 一类1000m2, 二类1500m2, 地下室500m2</li>
<li>3, 高层建筑, 设有火灾自动报警系统和自动灭火系统, 且采用不燃烧或难燃烧材料装修, 地上防火分区&lt;=4000m2, 地下部分 &lt;= 2000m2</li>
<li>4, 高层建筑与裙房之间设有防火墙等防火分隔设施时, 裙房防火分区 &lt;= 2500m2</li>
<li>5, 当设有自动喷水灭火系统: 最大面积增加一倍</li>
</ul>
<h3 id="2-防烟分区"><a href="#2-防烟分区" class="headerlink" title="(2)防烟分区"></a>(2)防烟分区</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><p>在火灾发生时候, 将烟气控制在一定范围内</p>
<h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求:"></a>要求:</h4><ul>
<li>1, 防烟分区不应跨越防火分区</li>
<li>2, 每个防烟分区的建筑面积 &lt;= 500m2</li>
<li>3, 走道, 净高不超过房间的6.0m, 采用挡烟垂璧, 隔墙突出 &gt;= 0.50的梁划分防烟分区</li>
</ul>
<h2 id="b-防-排烟方式"><a href="#b-防-排烟方式" class="headerlink" title="b, 防.排烟方式"></a>b, 防.排烟方式</h2><h3 id="自然排烟"><a href="#自然排烟" class="headerlink" title="自然排烟"></a>自然排烟</h3><p>优: 不需要动力/经济方便<br>缺: 易受到室外风力影响, 火势猛烈时, 火焰可能从开口部位向上蔓延</p>
<h3 id="机械排烟"><a href="#机械排烟" class="headerlink" title="机械排烟"></a>机械排烟</h3><p>定义:使用排烟风机进行强制排烟<br>优: 不受室外风力影响, 工作可靠<br>缺: 初期投资多</p>
<h1 id="3-2-4-空气处理设别-p125"><a href="#3-2-4-空气处理设别-p125" class="headerlink" title="3.2.4 空气处理设别 p125"></a>3.2.4 空气处理设别 p125</h1><h2 id="a-空气净化-加热-冷却-加湿-除湿"><a href="#a-空气净化-加热-冷却-加湿-除湿" class="headerlink" title="a, 空气净化, 加热, 冷却, 加湿, 除湿"></a>a, 空气净化, 加热, 冷却, 加湿, 除湿</h2><h2 id="b-装配式空调机组"><a href="#b-装配式空调机组" class="headerlink" title="b, 装配式空调机组"></a>b, 装配式空调机组</h2><h2 id="c-空调制冷设备"><a href="#c-空调制冷设备" class="headerlink" title="c, 空调制冷设备"></a>c, 空调制冷设备</h2><h1 id="4-1-2-建筑电气系统的分类-p144"><a href="#4-1-2-建筑电气系统的分类-p144" class="headerlink" title="4.1.2 建筑电气系统的分类 p144"></a>4.1.2 建筑电气系统的分类 p144</h1><p>组成: 建筑电气系统一般由 用电设备/供配电线路/ 控制和保护装置<br>分类:<br>根据 -&gt; 电能的产生, 分配, 传输和消耗使用,      类 -&gt; 供配电系统/用电系统<br>根据 -&gt; 用电设备的特点和系统中所传递能量的类型, 类 -&gt; 建筑照明系统/建筑动力系统/建筑弱电系统</p>
<h2 id="a-建筑的供配电系统"><a href="#a-建筑的供配电系统" class="headerlink" title="a, 建筑的供配电系统"></a>a, 建筑的供配电系统</h2><h3 id="电能产生-输送和分配"><a href="#电能产生-输送和分配" class="headerlink" title="电能产生, 输送和分配"></a>电能产生, 输送和分配</h3><h3 id="电路系统的电压和频率"><a href="#电路系统的电压和频率" class="headerlink" title="电路系统的电压和频率"></a>电路系统的电压和频率</h3><h3 id="民用建筑供电系统"><a href="#民用建筑供电系统" class="headerlink" title="民用建筑供电系统"></a>民用建筑供电系统</h3><h3 id="电力负荷的分类"><a href="#电力负荷的分类" class="headerlink" title="电力负荷的分类"></a>电力负荷的分类</h3><h2 id="b-电气照明系统"><a href="#b-电气照明系统" class="headerlink" title="b, 电气照明系统"></a>b, 电气照明系统</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><h2 id="c-建筑动力系统"><a href="#c-建筑动力系统" class="headerlink" title="c, 建筑动力系统"></a>c, 建筑动力系统</h2><h3 id="电动机种类和应用"><a href="#电动机种类和应用" class="headerlink" title="电动机种类和应用"></a>电动机种类和应用</h3><h3 id="异步电动机的启动"><a href="#异步电动机的启动" class="headerlink" title="异步电动机的启动"></a>异步电动机的启动</h3><h3 id="异步电动机的启动方法"><a href="#异步电动机的启动方法" class="headerlink" title="异步电动机的启动方法"></a>异步电动机的启动方法</h3><h2 id="d-建筑弱点系统"><a href="#d-建筑弱点系统" class="headerlink" title="d, 建筑弱点系统"></a>d, 建筑弱点系统</h2><p>强电: 以安倍为单位<br>弱电: 以毫安为计量单位</p>
<p>功能: 主要进行信息的传递和交换<br>主要包括: 火灾自动报警, 消防联动系统, 电话通信系统, 建筑广播, 共用电视天线, 有线电视系统, 智能化建筑综合布线和安防系统</p>
<h1 id="4-4-2-保护接地与保护接零-p188"><a href="#4-4-2-保护接地与保护接零-p188" class="headerlink" title="4.4.2 保护接地与保护接零 p188"></a>4.4.2 保护接地与保护接零 p188</h1><p>保护接地: 电气设备的某部分(设备可导电外壳)用金属导体与大地作良好的电气连接</p>
<p>保护接零: 电源中性点接地的系统中, 将电气设备不带电的金属部分与零线作良好的接触</p>
<p>接地体:<br>自然接地体:<br>人工接地体:<br>接地线:<br>接地装置:</p>
<h2 id="a-接地概述"><a href="#a-接地概述" class="headerlink" title="a, 接地概述"></a>a, 接地概述</h2><h2 id="b-接地类型"><a href="#b-接地类型" class="headerlink" title="b, 接地类型"></a>b, 接地类型</h2><h3 id="工作接地"><a href="#工作接地" class="headerlink" title="工作接地"></a>工作接地</h3><h3 id="保护接地"><a href="#保护接地" class="headerlink" title="保护接地"></a>保护接地</h3><h3 id="保护接零"><a href="#保护接零" class="headerlink" title="保护接零"></a>保护接零</h3><h2 id="c-常见保护接地方式"><a href="#c-常见保护接地方式" class="headerlink" title="c, 常见保护接地方式"></a>c, 常见保护接地方式</h2><h1 id="5-2-火灾自动报警系统-p237"><a href="#5-2-火灾自动报警系统-p237" class="headerlink" title="5.2 火灾自动报警系统 p237"></a>5.2 火灾自动报警系统 p237</h1><h2 id="自动报警系统组成"><a href="#自动报警系统组成" class="headerlink" title="自动报警系统组成"></a>自动报警系统组成</h2><p>触发器, 火灾报警装置, 消防控制设备, 电源</p>
<h2 id="控制器工作原理"><a href="#控制器工作原理" class="headerlink" title="控制器工作原理"></a>控制器工作原理</h2><p>提供火灾探测器稳定的直流电源, 监视连接的探测器有无故障, 保证探测器长期, 稳定有效, 工作;<br>当火灾探测器探测火情后, 迅速处理, 执行控制</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[建筑材料复习]]></title>
      <url>/2018/06/25/archi-materials/</url>
      <content type="html"><![CDATA[<p>单项 多项 判断 简答</p>
<h1 id="ch1-材料的基本性质"><a href="#ch1-材料的基本性质" class="headerlink" title="ch1 材料的基本性质"></a>ch1 材料的基本性质</h1><h2 id="材料密度-P5"><a href="#材料密度-P5" class="headerlink" title="材料密度 P5"></a>材料密度 P5</h2><p>密度: 材料在绝对密实状态下, 单位体积的质量<br>表观密度: 自然状态下单位体积的质量</p>
<p>堆积密度: 粉状材料(水泥) 或 粒状材料(砂, 石)在堆积状态下, 单位体积的质量<br>密实度: 材料体积内固体物质所充实的程度<br>孔隙率: 孔隙体积 与 自然状态下的体积之比 百分数<br>空隙率: 散粒材料 空隙体积 与 堆积体积之比</p>
<h2 id="材料的孔隙特征-P7"><a href="#材料的孔隙特征-P7" class="headerlink" title="材料的孔隙特征 P7"></a>材料的孔隙特征 P7</h2><ul>
<li>孔隙特征: 孔隙是否封闭及孔隙的粗细</li>
<li>直接反映材料的致密程度，会影响强度, 吸水性, 抗渗性</li>
</ul>
<p>隔声, 绝热, 防潮的各自特征 </p>
<ul>
<li>隔声: 孔隙开放 且 粗</li>
<li>绝热: 孔隙封闭 且 细</li>
<li>防潮: 孔隙封闭 且 细</li>
</ul>
<h1 id="ch2-天然石材"><a href="#ch2-天然石材" class="headerlink" title="ch2 天然石材"></a>ch2 天然石材</h1><h2 id="岩石的基本分类-P19"><a href="#岩石的基本分类-P19" class="headerlink" title="岩石的基本分类 P19"></a>岩石的基本分类 P19</h2><p>火成岩, 沉积岩, 变质岩</p>
<p>珊瑚属于（沉积岩）</p>
<h2 id="火成岩的分类-p19"><a href="#火成岩的分类-p19" class="headerlink" title="火成岩的分类 p19"></a>火成岩的分类 p19</h2><p>深成岩, 喷出岩, 火山岩<br>概念看一看</p>
<h2 id="岩石的物理性能-P20"><a href="#岩石的物理性能-P20" class="headerlink" title="岩石的物理性能 P20"></a>岩石的物理性能 P20</h2><p>大概的密度 2.50-2.70g/cm3</p>
<h2 id="常用岩石-P22"><a href="#常用岩石-P22" class="headerlink" title="常用岩石 P22"></a>常用岩石 P22</h2><p>仔细看看</p>
<p>花岗岩</p>
<ul>
<li>抗压强度高, 耐久性高, 公认是一种优良的建筑结构及装饰材料, 为许多大型建筑所采用</li>
<li>材质坚硬, 耐磨性好</li>
<li>耐酸材料</li>
<li>室内室外都可以</li>
</ul>
<p>大理石</p>
<ul>
<li>易被酸性腐蚀</li>
<li>抛光材料</li>
<li>不能挂在外面, 地面和..</li>
</ul>
<p>砂岩</p>
<ul>
<li>质地较软, 不耐酸腐蚀</li>
</ul>
<h2 id="石材的加工-P26"><a href="#石材的加工-P26" class="headerlink" title="石材的加工 P26"></a>石材的加工 P26</h2><p>简单看一下</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>毛石 -&gt; 料石及荒料 -&gt; 板材</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><p>毛石: 毛石是在采石场爆破后直接得到的形状不规则的石块<br>石料: 六面体石块, 略经雕琢而成<br>板材: 用致密岩石凿平厚度不大的石材称为板材</p>
<h1 id="ch3-烧土制品及玻璃"><a href="#ch3-烧土制品及玻璃" class="headerlink" title="ch3 烧土制品及玻璃"></a>ch3 烧土制品及玻璃</h1><h2 id="烧结普通砖-P31"><a href="#烧结普通砖-P31" class="headerlink" title="烧结普通砖 P31"></a>烧结普通砖 P31</h2><p>仔细看一看<br>经采土, 调制, 制坯, 干燥, 焙烧, 冷却 成为烧结普通砖</p>
<p>标准尺寸 <code>240mm*115mm*53mm</code></p>
<p>外观+尺寸</p>
<h2 id="烧结空心砖-和-空心砌块-P36"><a href="#烧结空心砖-和-空心砌块-P36" class="headerlink" title="烧结空心砖 和 空心砌块 P36"></a>烧结空心砖 和 空心砌块 P36</h2><p>仔细看一看<br>烧结空心砖的尺寸: 365mm, 240mm, 115mm<br>空心砌块: 超过烧结空心砖的尺寸</p>
<p>117.凡是空洞率大于（ B ）的砖称为空心砖。  B.15%<br>118.烧结多孔砖的强度等级按( C )来评定。  C.抗压强度<br>120.(A) 主要用于非承重的填充墙和隔墙。  A.烧结空心砖</p>
<h2 id="建筑陶瓷-P39"><a href="#建筑陶瓷-P39" class="headerlink" title="建筑陶瓷 P39"></a>建筑陶瓷 P39</h2><p>想象发挥</p>
<p>122.建筑陶瓷的主要原料是( B )   B.黏土</p>
<p>124.通常所说的“马赛克”是指（ C ）。  C．陶瓷锦砖</p>
<h2 id="其他玻璃-P46"><a href="#其他玻璃-P46" class="headerlink" title="其他玻璃 P46"></a>其他玻璃 P46</h2><p>安全玻璃: 钢化玻璃, 夹丝玻璃, 夹层玻璃<br>节能玻璃: 中空玻璃<br>简单看一下: 概念+意义+用途</p>
<p>123.建筑玻璃中用量最大的是( A )。  A.平板玻璃<br>125.下列关于玻璃的基本知识叙述不正确的一项是（ C ）。 C．玻璃在冲击作用下易破碎，是典型的塑性材料</p>
<h1 id="ch4-气硬性胶凝材料"><a href="#ch4-气硬性胶凝材料" class="headerlink" title="ch4 气硬性胶凝材料"></a>ch4 气硬性胶凝材料</h1><h2 id="气硬性凝胶材料和水硬性材料的区别-P54"><a href="#气硬性凝胶材料和水硬性材料的区别-P54" class="headerlink" title="气硬性凝胶材料和水硬性材料的区别 P54"></a>气硬性凝胶材料和水硬性材料的区别 P54</h2><p>气硬性:</p>
<ul>
<li>1, 只能在空气中硬化, 也只能在空气中保持或提高强度, 如 石灰, 石膏, 水玻璃</li>
<li>2,  地上或者干燥环境, 不宜用于潮湿环境和水中</li>
</ul>
<p>水硬性:</p>
<ul>
<li>1, 不仅能在空气中, 而且能更好地在水中硬化, 保持提高强度, 如 水泥</li>
<li>2, 既适用于地上或干燥环境, 也适用于地下或水中 </li>
</ul>
<h1 id="ch5-水泥-P64"><a href="#ch5-水泥-P64" class="headerlink" title="ch5 水泥 P64"></a>ch5 水泥 P64</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h2><p>硅酸盐水泥和普通硅酸盐水泥</p>
<h2 id="水泥的生产过程-P65图"><a href="#水泥的生产过程-P65图" class="headerlink" title="水泥的生产过程 P65图"></a>水泥的生产过程 P65图</h2><ul>
<li>1, 生料的配制和磨细, (石灰岩, 黏土, 铁矿粉)</li>
<li>2, 生料经煅烧, 使之部分熔融而形成熟料;</li>
<li>3, 将熟料, 石灰石或者高炉矿渣与适量石膏共同磨细, 即成为硅酸盐水泥</li>
</ul>
<h2 id="水泥的物理性能-P67-support"><a href="#水泥的物理性能-P67-support" class="headerlink" title="水泥的物理性能 P67 support::"></a>水泥的物理性能 P67 support::</h2><ul>
<li>密度和表观密度<br>密度: 决定于熟料的矿物组成, 一般在3.1 ~ 3.2g/cm3之间, 水泥受潮密度降低<br>表观密度: 一般在900-1300kg/m3之间, 紧密状态可达1400-1700kg/m3, 水泥越细表观密度越小</li>
<li>细度: 越细与水反应的表面积越大, 水化作用既迅速又完全, 凝结速度加快</li>
<li>凝结时间: 初凝和终凝, 开始失去可塑性和完全失去可塑性</li>
<li>体积安定性: 水泥在硬化过程中, 体积均匀发生变化的性能</li>
<li>强度: 抗压和抗折强度, 分为不同的强度等级</li>
</ul>
<p>细度:</p>
<ul>
<li>62.硅酸盐水泥细度用（ B ）表示。  B．比表面积<br>初凝:</li>
<li>56.硅酸盐水泥标准规定，初凝时间不得早于（ A ）。  A.45min    </li>
</ul>
<h2 id="腐蚀和防止腐蚀的方法-P70"><a href="#腐蚀和防止腐蚀的方法-P70" class="headerlink" title="腐蚀和防止腐蚀的方法 P70"></a>腐蚀和防止腐蚀的方法 P70</h2><p>腐蚀: 软水腐蚀, 一般酸性水腐蚀, 碳酸腐蚀, 硫酸盐腐蚀</p>
<p>68.水泥石中引起腐蚀的组分主要是（ A ）。  A.氢氧化钙和水化铝酸钙<br>71.海水中的( A ) 对水泥石有腐蚀作用。  A.硫酸盐</p>
<p>防腐: </p>
<ul>
<li>1, 选择适当水泥品种</li>
<li>2, 尽量提高水泥密实度, 减少渗透作用</li>
<li>3, 设置耐腐蚀性强, 且不透水的防护层, 如耐酸石材, 沥青</li>
</ul>
<h2 id="为什么掺入混合料-p71"><a href="#为什么掺入混合料-p71" class="headerlink" title="为什么掺入混合料 p71"></a>为什么掺入混合料 p71</h2><p>提高产量, 降低成本, 改善水泥性能, 调节水泥强度等级, 扩大使用范围, 保护环境</p>
<p>69.掺活性混合材料的水泥抗碳化能力差的原因是由于水泥石中(  B ) 的原因。  B.Ca(OH)2含量低<br>70.普通硅酸水泥中掺入少量混合材料的主要作用是( A)   A 扩大其强度等级范围，以利于合理选用</p>
<h2 id="特种水泥-p75"><a href="#特种水泥-p75" class="headerlink" title="特种水泥 p75"></a>特种水泥 p75</h2><p>快硬水泥<br>白色和彩色水泥<br>膨胀水泥<br>快硬硫铝酸盐水泥</p>
<h1 id="ch6-混凝土和砂浆"><a href="#ch6-混凝土和砂浆" class="headerlink" title="ch6 混凝土和砂浆"></a>ch6 混凝土和砂浆</h1><h2 id="混凝土配比-p82-图"><a href="#混凝土配比-p82-图" class="headerlink" title="混凝土配比 p82 图"></a>混凝土配比 p82 图</h2><p>石头, 沙子, 水泥浆, 空气<br>水泥约占混凝土总重的10%~15%, 其余均为砂, 石骨料,  砂石比例为1:2, 空气的体积含量1%~3%</p>
<h2 id="各自作用"><a href="#各自作用" class="headerlink" title="各自作用 ????"></a>各自作用 ????</h2><p>水泥: 胶结作用, 所少沙与石间摩擦的润滑作用<br>骨料: 其功用是构成混凝土骨架, 减少水泥用量和减小混凝土体积收缩<br>空气: ????</p>
<p>25.普通混凝土是由哪四种基本材料组成，它们各起何作用？<br>答：水、水泥、砂(细骨料)、石子( 粗骨料)是普通混凝土的四种基本组成材料。<br>水和水泥形成水泥浆，在混凝土中赋予拌合混凝土以流动性；<br>粘接粗、细骨料形成整体<br>填充骨料的间隙，提高密实度。<br>砂和石子构成混凝土的骨架，有效抵抗水泥浆的干缩；<br>砂石颗粒逐级填充，形成理想的密实状态，节约水泥浆的用量。</p>
<h2 id="骨料的颗粒组成-p83"><a href="#骨料的颗粒组成-p83" class="headerlink" title="骨料的颗粒组成 p83"></a>骨料的颗粒组成 p83</h2><p>级配: 指混凝土所用骨料的粗细分级和组成情况</p>
<p>粗,细颗粒含量适当, 骨料的空隙率较小, 同时颗粒总表面积较小</p>
<h2 id="和易性-p86"><a href="#和易性-p86" class="headerlink" title="和易性 p86"></a>和易性 p86</h2><p>概念: 在搅拌, 运输, 浇灌过程中易于操作, 能保持均匀而不发生离析的性能</p>
<p>流动性, 黏聚性, 保水性</p>
<p>坍落度测定: 分成三层捣实, 提起筒后, 最高点与坍落筒的高差<br>55.坍落度是流动性(亦称稠度)的指标，坍落度值越大，流动性越大。( √ )</p>
<p>75.减水剂能使混凝土拌和物在不增加水泥用量的条件下，改善和易性，降低( B)  B.泌水性</p>
<p>89.混凝土拌合物的流动性能够反映（ A ）。  A.混凝土拌合物的稀稠程度及充满模板的能力<br>90.当混凝土拌合物流动性偏小时，应采取( A )办法来调整。  A.保证水灰比不变的情况下，增加水泥浆数量<br>91.在配制混凝土时如拌合物流动性过大，就需要(D)。  D.保持砂率不变，加砂和石子<br>92.当混凝土拌合物流动性偏大时，应采取（ B ）办法来调整。  B.保证砂率不变，增加砂石用量<br>93.混凝土拌合物的保水性能够反映( B )。  B.混凝土拌合物的稳定性<br>93.混凝土拌合物的粘聚性能反映（ C ）   C.混凝土拌合物的均匀性</p>
<h2 id="混凝土的种类和使用场合"><a href="#混凝土的种类和使用场合" class="headerlink" title="混凝土的种类和使用场合"></a>混凝土的种类和使用场合</h2><p>多孔混凝土: 砌块, 保温套, 隔热层<br>耐热混凝土: 高温环境<br>耐酸混凝土: 酸雨和软水腐蚀的环境</p>
<h2 id="砂浆分类"><a href="#砂浆分类" class="headerlink" title="砂浆分类"></a>砂浆分类</h2><p>抹面, 防水, 装饰砂浆</p>
<p>装饰砂浆中有:</p>
<ul>
<li>水磨石, 水刷石, 人造大理石</li>
</ul>
<p>64.砂浆试件尺寸采用(70.7×70.7×70.7)mm立方体试件。( √ )</p>
<p>32.根据建筑部位的不同，如何选择抹面砂浆？<br>答：用于砖墙的底层抹灰，多用石灰砂浆；用于板条墙或板条顶棚的底层抹灰多用混合砂浆或石灰砂浆；混凝土墙、梁、柱、顶板等底层抹灰多用混合砂浆、麻刀石灰浆或纸筋石灰浆。<br>在容易碰撞或潮湿的地方，应采用水泥砂浆。如墙裙、踢脚板、地面、雨棚、窗台以及水池、水井等处一般多用1׃2.5的水泥砂浆。</p>
<h1 id="ch7-金属材料"><a href="#ch7-金属材料" class="headerlink" title="ch7 金属材料"></a>ch7 金属材料</h1><h2 id="拉伸的过程-P109"><a href="#拉伸的过程-P109" class="headerlink" title="拉伸的过程 P109"></a>拉伸的过程 P109</h2><p>弹性阶段 -&gt; 屈服阶段(最低应力:屈服点) -&gt; 强化阶段</p>
<p>屈服点: 屈服阶段的最低应力<br>屈服强度: 塑性变形为 0.2% 时应力</p>
<h2 id="冷加工和热加工的概念"><a href="#冷加工和热加工的概念" class="headerlink" title="冷加工和热加工的概念"></a>冷加工和热加工的概念</h2><p>冷: 经过冷拉, 冷拔, 冷轧, 性能发生显著改变, 表现为强度提高, 塑性减小, 变硬变脆<br>热: 对刚才进行加热和冷却的一种处理方法, 改变钢的结构, 消除冷加工内应力, 改善刚才机械性能</p>
<h2 id="碳素钢-钢材成分"><a href="#碳素钢-钢材成分" class="headerlink" title="碳素钢 钢材成分"></a>碳素钢 钢材成分</h2><p>性能决定于含碳量的多少, 以及硅锰磷硫<br>有害: 磷硫含量多, 影响塑性, 使得钢变脆<br>有用: 硅锰提高, 强度和硬度提高<br>人为调整: 含碳量高, 强度高, 但塑性小, 硬度大, 性脆, 不容易加工</p>
<h1 id="ch8-木材"><a href="#ch8-木材" class="headerlink" title="ch8 木材"></a>ch8 木材</h1><h2 id="宏观构造"><a href="#宏观构造" class="headerlink" title="宏观构造:"></a>宏观构造:</h2><p>树皮, 木质部和髓心</p>
<h2 id="吸声材料的分类-p165"><a href="#吸声材料的分类-p165" class="headerlink" title="吸声材料的分类 p165"></a>吸声材料的分类 p165</h2><p>多孔性吸声材料, 薄板振动吸声结构, 共振吸声结构, 穿孔板组合共振吸声结构, 柔性吸声材料</p>
<h1 id="ch9-涂料"><a href="#ch9-涂料" class="headerlink" title="ch9 涂料"></a>ch9 涂料</h1><h2 id="涂料的种类-p170"><a href="#涂料的种类-p170" class="headerlink" title="涂料的种类 p170"></a>涂料的种类 p170</h2><p>溶剂型, 水溶性, 乳胶漆</p>
<h2 id="油漆的类型-p180"><a href="#油漆的类型-p180" class="headerlink" title="油漆的类型 p180"></a>油漆的类型 p180</h2><p>天然漆, 调和漆, 清漆, 瓷漆, 喷漆, 夜光油漆, 有机耐高温漆</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><h2 id="拉伸-p114"><a href="#拉伸-p114" class="headerlink" title="拉伸 p114"></a>拉伸 p114</h2><p><strong>考</strong><br>ch7<br>钢材拉伸的图 P110<br>冷加工的图 P114<br>解读对应过程和点</p>
<p>0-&gt;a, 弹性阶段<br>a-&gt;b, 屈服阶段, 发生塑性变形, 最低应力点为屈服点<br>b-&gt;c, 强化阶段, 最大应力值为抗拉强度<br>c-&gt;g, 冷加工阶段, 强度提高, 塑性减小<br>颈缩阶段</p>
<p>屈服强度: 塑性变形为 0.2% 时应力</p>
<h2 id="石膏-p57"><a href="#石膏-p57" class="headerlink" title="石膏 p57"></a>石膏 p57</h2><p>气硬性: 只能在空气中硬化, 也只能在空气中保持或提高强度<br>性能: 质地轻, 容易加工, 装饰效果较好, 是一种凝结, 硬化快的凝胶材料<br>适用场合: 地上或者干燥环境, 不适用于潮湿环境和水中</p>
<h2 id="混凝土-p82"><a href="#混凝土-p82" class="headerlink" title="混凝土 p82 ????"></a>混凝土 p82 <code>????</code></h2><p>级配p83: 指混凝土所用骨料的粗细分级和组成情况<br>比例p82: 水泥约占混凝土总重的10%~15%, 其余均为砂, 石骨料,  砂石比例为1:2, 空气的体积含量1%~3%</p>
<p>影响混凝土强度因素p89: 水泥强度和水灰比, 骨料的质量, 养护条件, 龄期 <code>????</code><br>改善方法: 高标号水泥, 低水灰比, 强制搅拌, 加压震荡提高强度; 采用蒸汽养护, 可加速混凝土强度发展</p>
<p>84.在原材料一定的情况下，决定混凝土强度的最主要因素是( A ) 。  B.水灰比<br>90.当混凝土拌合物流动性偏小时，应采取( A )办法来调整。  A.保证水灰比不变的情况下，增加水泥浆数量<br>101.混凝土配合比设计中的三个基本参数分别是（ A ）。  A.水灰比、砂率、单位用水量</p>
<h2 id="水泥-p65"><a href="#水泥-p65" class="headerlink" title="水泥 p65"></a>水泥 p65</h2><p>材料: </p>
<ul>
<li>石灰岩, 黏土, 铁矿粉</li>
</ul>
<p>影响水泥强度:</p>
<ul>
<li>水, 沙子, 水泥砂浆</li>
<li>硅酸三钙含量多, 粉磨较细的水泥, 强度增长快, 最终强度也高</li>
<li>56.国标规定硅酸盐水泥的强度等级是以水泥胶砂试件在(C)龄期的强度来评定的。  C. 3d 和28d</li>
</ul>
<p><strong>考</strong><br>水化热反应 p69</p>
<ul>
<li>放热, 在凝结硬化过程中放出热量, 强度影响<br>影响因素:</li>
<li>水泥熟料的矿物组成和细度(越细, 与水反应越快)</li>
<li>水灰比(主要成分, 加水量要大大超过水泥充分水分的用水量)</li>
<li>温度和湿度(温度升高, 水化速度加快)</li>
</ul>
<p><strong>考</strong> 水泥的生产过程 P65图</p>
<ul>
<li>1, 生料的配制和磨细, (石灰岩, 黏土, 铁矿粉)</li>
<li>2, 生料经煅烧, 使之部分熔融而形成熟料;</li>
<li>3, 将熟料, 石灰石或者高炉矿渣与适量石膏共同磨细, 即成为硅酸盐水泥</li>
</ul>
<h2 id="石灰-p55"><a href="#石灰-p55" class="headerlink" title="石灰 p55"></a>石灰 p55</h2><p>水化与熟化的过程的概念？ p5</p>
<p>熟化: </p>
<ul>
<li>生石灰加水生成氢氧化钙</li>
<li>加水过多温度下降, 熟的速度减慢</li>
</ul>
<p>硬化:</p>
<ul>
<li>1, 在干燥过程中, 水分蒸发, 氢氧化钙从过饱和溶液中逐渐析出, 形成结晶</li>
<li>2, CaOH2吸收CO2, 生成不溶解于水的碳酸钙结晶, 并放出水分</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>《建筑材料》期末考试题库1<br>单选题<br>1.木材、玻璃纤雄、矿棉的掏透都是( D )。  D.纤维状构造<br>2.下列各种材料的构造属于纤维状的是( D )。  D.木材<br>3.材料的孔隙状况应属于材料的（ A ）。  A.物理性质<br>4.孔隙按其连通性可以分为（ A ）。  A.连通孔、封闭孔、半连通孔<br>4.材料的密度应属于材料的（ A ）。  A.物理性质<br>5.在材料表观密度的体积构成中包括（ B ）。  B．闭口孔隙体积<br>6.材料的密实体积V，自然体积V0堆积体积V1三者的大小关系是( C )。  C.Vl≥V0≥V<br>7.密度是指材料在( C )下单位体积的质量。  C.绝对密实状态、<br>8.材料在绝对密实状态下，单位体积的质量称为( A)。  A.密度<br>9.材料的( D )是指粉状、颗粒状或纤维状材料在堆积状态下单位体积的质量。  D.堆积密度<br>10.材料的( C )是材料在自然状态下，单位体积的质量。  C.表观密度<br>11.对于某一种材料来说，无论环境怎样变化，其( B )都是一定值。  B.密度<br>12.材料的密度（ρ），表现密度（ρ′）及体积密度（ρо）存在如下关系：（B ）。B．ρ≥ρ′≥ρ<br>13.对于颗粒状外形不规则的坚硬颗粒，如砂或石子，其体积可采用排水法测得，故对此类材料一般采用(B )表示。  B.表观密度<br>14.散粒材料的堆积体积内，颗粒之间的空隙体积所占的比例称为（ B ）。  空隙率<br>15.材料的体积内，孔隙体积所占的比例称为( A )。  A.孔隙率<br>16.质量为 M 的湿砂，吸水率为W，其中干砂的质量为( A)<br>17.增加加气硅砌块的孔隙率，该加气硅砌块的吸水率( A )。  A.增大<br>18.某材料吸水饱和后的质量为25(20)克，烘干到恒重时的质量为20(16)克，则材料的质量吸水率为( A )。  A.25%<br>19.材料吸水后，将使材料的( C )降低。  C.强度和保温性<br>20.在100g吸水率为3%的湿砂中，其中水的质量为( D )。  D.2.9g<br>21.在100g 吸水率为4%的湿砂中，折算为干砂的质量为(D)克。  D. 100/(1 + 0.04)<br>22.材料在吸水饱和状态下，抵抗多次冻融循环，不破坏、强度也不显著降低的性质指的是（ C ）。C.抗冻性<br>23.材料受热时吸收热量，冷却时放出热量的性质称为（ C ）。  C.热容<br>24.材料的厚度加大则材料的导热系数（ C ）  C．不变<br>25.当润湿角≥90°时，此种材料( C )。  C.水与材料间作用力小于水分子间的作用力<br>26.下列概念中，( D )表明材料的耐水性。  D.软化系数<br>27.在冲击、震动荷载作用下，材料可吸收较大的能量产生一定的变形而不破坏的性质称为（  D  ） D.韧性<br>28.下列各组胶凝材料均是气硬性胶凝材料的是（ A ）。  A.石灰、石膏、水玻璃<br>29.石灰的主要成分为(A)。  B. Ca0<br>30.生石灰加水之后水化成熟石灰的过程称为( C)   C.石灰的熟化<br>31.过火石灰产生的原因是由于( B )。  B.缎烧温度过高、缎烧时间过长<br>32.石灰浆的硬化包括干燥硬化、结晶硬化、碳酸花硬化，其中，对硬化增长起主导作用的是（ B ）B.结晶硬化<br>33.石灰在使用前一般要进行陈伏，这是为了（ C ）  C．消除过火石灰的危害<br>34.( A )在空气中凝结硬化是受到干燥、结晶和碳化的作用。  A.石灰浆体<br>35.由于石灰浆体硬化时( C )，以及硬化速度慢等缺点，所以不宜单独使用。  C.体积收缩大</p>
<p>36.建筑石膏的化学成分是( B )。  B.β型半水石膏<br>37.建筑石膏的主要成分是（ B ）。  B.硫酸钙<br>38.用最最多、用途最广的石膏是( A)。  A.建筑石膏<br>39.建筑石膏凝结硬化时 ，最主要的特点是( D )。  D. 凝结硬化快<br>40.下列关于建筑石膏性质说法有误的一项是( A )。  A.耐水性、抗冻性都非常好</p>
<p>41.水玻璃在使用时，掺入一定量的Na2SiF6，其目的是为了( C  ) 。  C.促硬<br>42.水玻璃是( C )的水溶液。  C.Na2O·nSi02<br>43.水玻璃在空气中与CO2发生反应，生成的物质是（ A ）。   A.硅胶</p>
<p>44.素有“建筑工业的粮食”之称的建筑材料的是（ B  ）。  B.水泥<br>45.下列各类水泥，用量最大，应用最为广泛的是（ A  ）。  A．硅酸盐水泥<br>46.酸盐水泥一般适用( B )。  B.一般建筑工程<br>47.硅酸盐水泥适用于(  A  )混凝土工程。  A.快硬高强<br>48.( A )适用于一般土建工程中现浇混凝土及钢筋混凝土结构。  A.硅酸盐水泥<br>49.下列工程中，(A)宜选用硅酸盐水泥。  A.预应力混凝土<br>50.在海工工程中使用的混凝土工程宜优先选用（ A ）硅酸盐水泥。  A．矿渣<br>51.在正常使用条件下的预应力混凝土工程宜优先选用（ D ）水泥。  D．硅酸盐<br>52.在严寒地区水位升降范围内使用的混凝土工程宜优先选用（ D ）硅酸盐水泥。  D．普通<br>53.硅酸盐水化热高的特点决定了硅酸盐水泥不宜用于（ B ）。  B.大体积混凝土工程<br>54.相比较来讲，对于抢修工程或早期强度要求高的工程宜优先选用（ A ）。   A．铝酸盐水泥<br>55.硅酸盐水泥石在温度为 250℃时，水化物开始脱水，水泥石强度下降，因此硅酸盐水泥不宜单独用于( B)。  B.耐热混凝土工程<br>56.硅酸盐水泥标准规定，初凝时间不得早于（ A ）。  A.45min<br>56.国标规定硅酸盐水泥的强度等级是以水泥胶砂试件在(C)龄期的强度来评定的。  C. 3d 和28d<br>56.下列不是废品水泥的一项是（ D ）   D.水泥包装未标注工厂名称<br>57.国家规范中规定，水泥(B)检验不合格时，需按废品处理。  D.初凝时间<br>58.一般情况下，水泥水化反应时的温度不低于（ D  ）。  D．0℃<br>59.硅酸盐水泥的水化速度表现为( A)   A.早期快后期慢<br>60.水泥的水化热指的是( B)   B.水泥在水化过程中放出的热量<br>61.水泥细度指的是( B )。  B.水泥颗粒粗细的程度<br>62.硅酸盐水泥细度用（ B ）表示。  B．比表面积<br>62.用来表示硅酸盐水泥细度的指标是（  B  ）   B．比表面积<br>63.作为水泥混合材料的激发剂，主要是指氢氧化钙和（ A ）。  A．石膏<br>64.国家标准规定，用( A )检验水泥的体积安定性中氧化钙的有害作用。  A.沸煮法<br>64.水泥体积安定性指的是（ C ）。  C.水泥凝结硬化过程中，体积变化是否均匀适当的性质<br>65.体积安定性不良的水泥应作( B )处理。  B.废品<br>66.水泥石体积安定性不良的原因是（ D  ）。<br>A.游离氧化钙过多  B.游离氧化镁过多  C.掺人的石膏过多  D.以上都是<br>67.水泥石体积安定性不良的主要原因之一是（ C）含量过多。  C．CaSO4·2H2O<br>68.水泥石中引起腐蚀的组分主要是（ A ）。  A.氢氧化钙和水化铝酸钙<br>69.掺活性混合材料的水泥抗碳化能力差的原因是由于水泥石中(  B ) 的原因。  B.Ca(OH)2含量低<br>70.普通硅酸水泥中掺入少量混合材料的主要作用是( A)   A 扩大其强度等级范围，以利于合理选用<br>71.海水中的( A ) 对水泥石有腐蚀作用。  A.硫酸盐</p>
<p>72.配置混凝土时，水泥的选用主要考虑（ B ）。  B．品种和强度等级<br>73.相对来讲，决定混凝土成本的材料是( B)   B.水泥<br>74.混凝土和钢筋可以共同工作，是由于两者具有几乎相等的(  B  )   B.线膨胀系数<br>75.减水剂能使混凝土拌和物在不增加水泥用量的条件下，改善和易性，降低( B)  B.泌水性<br>76.下列关于坍落度说法有误的一项是( B)   B.坍落度是保水性的指标<br>77.混凝土的水灰比是根据( D )要求确定的。  D.( A+C )<br>78.混凝土的强度等级是根据(C)标准值来确定的。  C.立方体抗压强度<br>79.测定混凝土强度的标准试件尺寸为( B )。  B.15×15×15cm<br>80.测定混凝土立方体抗压强度时，立方体试件应养护的时间是(  )  D.28d<br>81.混凝土的抗冻性用抗冻等级(F)来表示，抗冻等级在( A)以土的混凝土简称为抗冻混凝土。 A.F50<br>82.混凝土的抗冻性用抗冻等级 F 来表示，抗冻等级为F8的混凝土表示其( C )。  C.抗冻融循环次数为8次<br>83.配置混凝土时，为了满足耐久性质的要求，应控制的技术指标有( A ) 。  A.最大水灰比<br>83.配置混凝土时，确定砂率主要应考虑的是（   A  ）。   A.混凝土的工作性和节约水泥两个方面<br>84.在原材料一定的情况下，决定混凝土强度的最主要因素是( A ) 。  B.水灰比<br>85.炎热夏季施工的混凝土工程，常采用外加剂是( B )。  B.缓凝剂<br>86.(A )是能够提高混凝土早期强度，并对后期强度无显著影响的外加剂。  A.早强剂<br>87.混凝土的抗冻性用抗冻等级来表示，抗冻等级为F20的混凝土表示其( C)。 C.抗冻融循环次数为 20<br>88．混凝土拌合物在一定的施工条件和环境下，是否易于各种施工工序的操作．以获得均匀密实混凝土的性能称为（ C  ）。  C.和易性<br>89.混凝土拌合物的流动性能够反映（ A ）。  A.混凝土拌合物的稀稠程度及充满模板的能力<br>90.当混凝土拌合物流动性偏小时，应采取( A )办法来调整。  A.保证水灰比不变的情况下，增加水泥浆数量<br>91.在配制混凝土时如拌合物流动性过大，就需要(D)。  D.保持砂率不变，加砂和石子<br>92.当混凝土拌合物流动性偏大时，应采取（ B ）办法来调整。  B.保证砂率不变，增加砂石用量<br>93.混凝土拌合物的保水性能够反映( B )。  B.混凝土拌合物的稳定性<br>93.混凝土拌合物的粘聚性能反映（ C ）   C.混凝土拌合物的均匀性<br>94.混凝土的抗渗性达不到要求，可掺加外加剂（ B ）。  B.松香热聚物<br>95.碱骨料是指含有（ B ）的拌合混凝土用天然骨料。  B.活性二氧化硅<br>96.砂的内部不但含水饱和，其表面还被一层水膜覆裹，颗粒间被水所充盈的状态称为( C )  C.湿润状态<br>96.砂的内部和表层均含水达到饱和状态，而表面的开口孔隙及面层却处于无水状态称为（ D ） D.饱和面干状态<br>97.砂在干燥的环境中自然堆放达到干燥状态往往是（ B ）。  B．气干状态<br>98.砂率指的是（ A ）。  A.每立方米混凝土中砂的质量和砂石的总质量之比<br>98.砂率的高低表示（ A ）。   A.混凝土拌合物中细骨料所占比列的多少<br>99.配置混凝土时，为了满足耐久性质的要求，应控制的技术指标是( A )。  A.最大水灰比<br>100.配合比正常的普通混凝土受压时，最可能发生的破坏形式是( C )  C.水泥石与粗骨料的结合面先发生破坏<br>101.混凝土配合比设计中的三个基本参数分别是（ A ）。  A.水灰比、砂率、单位用水量<br>102.单位用水量在水灰比和水泥用量不变的情况下，能够反映( A )  A.水泥浆量与骨料用量之间的比例关系<br>103.在原材料一定的情况下，影响混凝土耐久性的关键因素是( D )。  D.A+B<br>104.试拌调整混凝土时，发现拌和物的保水性较差，应采用(A) 的措施。  A.增加砂率<br>105.能够显著提高硬化混凝土抗冻耐久性的外加剂是( C )。  C.引气剂<br>107.配置某强度的等级的水泥混合砂浆，已确定水泥用量为145kg/m3，石灰膏用量为( B ) kg/m3。 B.155—205<br>107.在容易碰撞或潮湿的地方抹面时，易选用（  A  ）。   A.水泥砂浆<br>107.所谓的“混凝土的第五组分”指的是（ D ）  D.外加剂<br>16.下列各种混凝土外加剂主要用来调节混凝土凝结时间的是(  A  )  A.早强剂</p>
<p>108.将砖、石、砌块等粘结成为砌体的砂浆称为（ D ）。  D．砌筑砂浆<br>109.检验砂浆强度时，采用的配合比的个数不应少于（ B ）。  B.3<br>110.用于砌筑潮湿环境以及强度要求较高的砌体时，宜选用（ A ）。  A.水泥砂浆<br>111.砖在使用过程中的盐析现象称为（ A ）。  A.泛霜<br>112.在砂浆中掺人石灰膏，可明显提高砂浆的( C )。  C.保水性<br>113.影响砂浆强度的因素较多，实验证明，当材料质量一定时，砌筑砂浆的强度主要取决于( D)。  D.水泥用量与水泥强度<br>114.抹面砂浆通常可以分为两层或三层进行施工，若采用两层进行施工，省去的一层应为 ( B)  B.中层砂浆<br>115.砂浆的保水性用( B )表示。  B.分层度<br>116.用来表示砂浆流动性的是( A )  A.沉入度</p>
<p>117.凡是空洞率大于（ B ）的砖称为空心砖。  B.15%<br>118.烧结多孔砖的强度等级按( C )来评定。  C.抗压强度<br>119.烧结多孔砖的强度等级按( C )来评定。  C.抗压强度<br>120.(A) 主要用于非承重的填充墙和隔墙。  A.烧结空心砖<br>121.非承重外墙应优先选用(C)。  C.烧结空心砖<br>122.建筑陶瓷的主要原料是( B )   B.黏土<br>123.建筑玻璃中用量最大的是( A )。  A.平板玻璃<br>124.通常所说的“马赛克”是指（ C ）。  C．陶瓷锦砖<br>125.下列关于玻璃的基本知识叙述不正确的一项是（ C ）。 C．玻璃在冲击作用下易破碎，是典型的塑性材料</p>
<p>126.低碳钢受拉破环时经历四个阶段，其中第一阶段应是（ B ）。  B．弹性阶段<br>126.低碳钢受拉破环时经历四个阶段，其中最后一个阶段应是（ D ）。  D．颈缩阶段<br>127.用来表征钢材塑性变形能力的指标是（ D  ）。  D．伸长率<br>128.钢材在常温下承受弯曲变形的能力称为（ A ）。  A．冷弯性能<br>129.钢材承受交变荷载反复作用时，可能在最大应力远低于屈服强度的情况下突然破坏，这种破坏称为（ A ）。  A．疲劳破坏<br>130.下列关于钢材性能与含硅量关系说法错误的是（ D ）。  D.若含硅量超过1％时，会增大钢材的可焊性。<br>130.通常用来表示建筑钢材强度的指标是（  A   ）。  A.屈服点和抗拉强度<br>131.经过冷加工强化处理的钢筋性能说法正确的是（ A ）。  A．强度提高，塑性和冲击韧性下降<br>132.严寒地区使用的钢材，应选用( D ) 。  D.脆性临界温度低于环境最低温度的钢材<br>133.钢材随时间延长而表现出强度提高，塑性和冲击韧性下降，这种现象称为( B )。  B.时效<br>134.使钢材的强度、硬度提高，塑性和韧性显著降低，还可以显著加大钢材的冷脆性的合金元素是( C )。  C.磷<br>135.钢材在热加工过程中造成晶体的分离引起钢材断裂，形成热脆现象的元素是( B )。  B.硫<br>136.普通碳素钢按屈服点、质量等级及脱氧方法划分为若干个牌号，随牌号提高，钢材( C )。  C.强度提高，伸长率降低<br>137.Q235-C的钢材，其质量要比Q235 -A的钢材( A )。  A.质量好<br>138.冷加工后的钢材随搁置时间延长而表现出强度提高，塑性和冲击韧性下降的现象称为(B)。 B.自然时效<br>139.下列关于钢材性能与硫元素关系说法错误的是(  )  C.非金属硫化物夹杂于钢中，会提高钢材的各种机械性能<br>140.屈服强度为235MPa，质量等级为A级的沸腾钢牌号为(C )。  C.Q235—A•F<br>141.下列各种钢锭脱氧程度最弱的是( A )。  A.沸腾钢<br>142.钢材锈蚀时，钢材的体积将（ B ）。  B．增大</p>
<p>143.石油原油经蒸馏等工艺提炼出各种轻质油及润滑油后的残留物再进一步加工得到的沥青是（ A ）。  A.石油沥青<br>144.最直接影响沥青的柔软性、抗裂性及施工难度等性能的组分是（ A ）。  A．油分<br>145.石油沥青中的组分有：油分、树脂、沥青质。(A)含量的多少直接影响沥青的柔软性、抗裂性及施工难度。  A.油分<br>145.决定着沥青的粘结力、黏度、温度稳定性和硬度等性能的组分是（ C ）   C.沥青质<br>146.建筑石油沥青的塑性是用( D)表示的。  D.延度<br>147.建筑石油沥青的黏性是用(A) 表示的。  A.针入度<br>148.建筑石油沥青的牌号愈高，则( A )。  A.黏性愈小<br>149.建筑工程中最常用的主要是( B )。  B.石油沥青和煤沥青<br>150.建筑石油沥青划分不同的标号的依据是( D )，每个标号沥青应保证相应的溶解度、蒸发损失率、蒸发后针人度比、闪点等指标。  D.针入度<br>151.石油沥青的塑性是指( C)  C.石油沥青在外力作用下产生变形而不破坏，除去外力后仍保持变形后的形状不变的性质<br>152．乳化沥青的主要组成为（ A ）。   A．沥青、水、乳化剂<br>153.石油沥青过于黏稠而需要稀释，一般采用( A )。  A.石油产品系统的轻质油<br>154.石油沥青塑性是（ C ）。  C.石油沥青在外力作用下产生变形而不破坏，除去外力后仍保持变形后的形状不变的性质<br>155.道路石油沥青牌号与黏性和塑性关系说法正确的一项是（ A ）。 A．沥青牌号越高，黏性越小，塑性越好<br>156.下列关于建筑石油沥青的相关叙述有误的一项是（ C ）。 C．建筑石油沥青的软化点过高夏季易流淌，过低冬季易硬脆甚至开裂<br>157.下列关于改性沥青相关叙述有误的一项是（ C ）。 C．虽然橡胶的品种不同，掺人的方法也有所不同，但各种橡胶沥青的性能几乎一样</p>
<p>《建筑材料》期末考试题库2<br>判断题<br>1.材料化学组成的不同是造成其性能各异的主要原因。( √ )<br>1.建筑材料的微观结构主要有晶体、玻璃体和胶体等形式。（ √ ）<br>2.软化系数越大，材料的耐水性能越差。( × )<br>3.软化系数越小，材料的耐水性能越差。( √ )<br>4.材料随含水率的增加，材料的密度不变，导热系数增加。( √ )<br>5.材料随含水率的增加，材料的密度不变，导热系数降低。( × )<br>6.一般来说，材料的亲水性越强，孔隙率越小，连通的毛细孔隙越多，其吸水率越小。( × )<br>7.材料的导热系数与其厚度有关。( × )<br>8.材料的导热系数与其厚度无关。( √ )<br>9.一般情况下，金属材料的导热系数要大于非金属材料。( √ )<br>10.我国相关规范把材料按耐燃性分为非燃烧材料、难燃烧材料和可燃材料。( √ )<br>11.粗大孔主要影响材料的密度、强度等性能；毛细孔主要影响材料的吸水性、抗冻性等性能。( √ )<br>12.跪性是指当外力达到一定限度时，材料发生无先兆的突然破坏，且破坏时无明显变形的性质。( √ )<br>13.塑性是指当外力达到一定限度时，材料发生无先兆的突然破坏，且破坏时无明显变形的性质。( × )<br>14.脆性材料力学性能的特点是抗压强度远小于抗拉强度，破坏时的极限应变值极大。( × )<br>15.材料的开口孔隙率(开口孔隙体积与材料在自然状态下体积之比的百分数)的大小，可根据该材料的质量吸水率来确定。( × )<br>16.材料随含水率的增加，材料的密度不变，导热系数降低。( × )<br>17.钢材的耐久性，主要决定于其抗锈蚀性，而沥青的耐久性则主要取决于其大气稳定性和温度敏感性。(√)<br>22.一般情况下， 大试件的强度往往大于小试件的强度。(  ×  )<br>17.强度试验时，加荷速度越快，所测强度值越低。（ × ）</p>
<p>18.根据硬化的条件不同分为气硬性胶凝材料和水硬性胶凝材料两类。( √ )<br>18.气硬性胶凝材料是指只能在空气中凝结、硬化，保持和发展强度的胶凝材料。( √ )<br>19.生石灰吸湿性和保水性都非常差，绝对不能作为干燥剂使用。( × )<br>20.生石灰具有强烈的消解能力，水化时需要吸收非常大的热量。( × )<br>21.欠火石灰会引起石灰的后期熟化，抹灰后会造成起鼓和开裂。( × )<br>22.过火石灰会引起石灰的后期熟化，抹灰后会造成起鼓和开裂。( √ )</p>
<p>23.石膏硬化时体积微膨胀，硬化后孔隙率降低。( × )<br>24.石灰膏在使用前，一般要陈伏两周以上，主要目的是消除过火石灰。( √ )<br>23.陈伏期间，石灰浆表面应敷盖一层水，以隔绝空气，防止石灰浆表面碳化。(  √ )<br>25.石灰膏体的硬化是由于干燥硬化、结晶硬化和碳化硬化作用完成的。( √ )<br>26.石灰膏体的硬化是由于干燥硬化和碳化硬化作用完成的。( × )<br>27.建筑石膏强度不随时间的变化而变化，因此可以长期存放。( × )</p>
<p>28.水玻璃硬化后有很高的耐酸性能，这是因为硬化后的水玻璃主要化学组成是SiO2。( √ )<br>29.水玻璃的模数和密度对于凝结、硬化速度影响较大。( √ )</p>
<p>30.体积安定性不合格的水泥可降低强度等级使用。( × )<br>31.体积安定性不合格的水泥为废品水泥，不得使用于工程中。( √ )<br>32.初凝不合格的水泥为不合格品，可降低强度等级使用。( × )<br>33.初凝不和格的水泥为废品，不得在工程中使用。( √ )<br>34.作为水泥混合材料的激发剂，主要指氢氧化钙和石膏。( √ )<br>35.经过反应形成的化合物— 硅酸二钙、硅酸三钙、铝酸三钙、铁铝酸四钙、氢氧化钙，通称为水泥熟料的矿物组成。( × )<br>36.经过反应形成的化合物——硅酸二钙 、硅酸三钙、铝酸三钙、铁铝酸四钙，通称为水泥熟料的矿物组成。( √ )<br>36.水泥熟料的矿物组成有硅酸三钙 、硅酸二钙、铝酸三钙和铁铝酸四钙。( √ )<br>37.硅酸盐水泥与水作用，生成的主要水化产物有：水化硅酸钙与水化铁酸钙凝胶，氢氧化钙、水化铝酸钙和水化硫铝酸钙晶体。( √ )<br>38.影响硅酸盐水泥凝结硬化最主要因素是水灰比，与环境的温度和湿度无关。（ × ）<br>38.通常水花越细，凝结硬化速度越快，强度也越高。( √ )<br>39.生产硅酸盐水泥时，第一步先生产出水泥熟料。( √ )<br>39.掺入到水泥或混凝土中的人工或天然矿物材料称为混合材料。（  √ )<br>40.水泥的水化硬化一般在28d内发展速度较慢，28d后发展速度较快。（ × ）<br>41.水泥放热量大小及速度与水泥熟料的矿物组成和细度没有任何关系。（ × ）<br>42.水泥的抗拉强度较高，一般是抗压强度的10~20倍。( × )<br>43.水泥石中的毛细管、孔隙是引起水泥石腐蚀加剧的内在原因之一。( √ )<br>44.袋装水泥储存3个月后，强度增加约20%~40%。( × )<br>45.当侵蚀作用比较强烈时，应在水泥制品表面加做保护层。（ √ ）<br>46.高铝水泥早期的水化热非常小，因此，施工时环境温度越高越好。（ × ）</p>
<p>27.从广义上讲，提凝土是以胶凝材料、粗细骨料及其它外掺材料按适当比例拌制、成型、养护、硬化而成的人工石材。( √ )<br>47.混凝土对粗骨料的基本要求是颗粒的总表面积要小和颗粒大小搭配要合理，以达到水泥的节约和逐级填充形成最大的密实度。这两项要求分别用最大粒径和颗粒级配表示。( √ )<br>48.混凝土对砂的基本要求是颗粒的总表面积要小和颗粒大小搭配要合理，以达到水泥的节约和逐级填充形成最大的密实度。这两项要求分别用最大粒径和颗粒级配表示。( × )<br>49.坍落度是流动性(亦称稠度)的指标，坍落度值越大，流动性越小。( × )<br>50.混凝土用的粗骨料，其最大粒径不得超过构件截面最小尺寸的1/4，且不得超过钢筋最小净间距的3/4。( √ )<br>51.混凝土拌合物的工作性包括和易性、粘聚性、保水性三个方面的技术要求。( × )<br>52.混凝土拌合物的工作性包括流动性、粘聚性、保水性三个方面的技术要求。( √ )<br>53.配合比设计的过程是一逐步满足混凝土的强度、工作性、耐久性、节约水泥等设计自标的过程。( √ )<br>54.按胶凝材料不同，可分为特重混凝土、重凝土、轻混凝土、特轻混凝土。( × )<br>55.坍落度是流动性(亦称稠度)的指标，坍落度值越大，流动性越大。( √ )<br>56.在混凝土拌合物流动性不变的前提下，所需水泥浆总体积为最小的砂率称其为合理砂率。( × )<br>57.砂和石子构成混凝土的骨架，在混凝土中赋予拌合混凝土流动性。( × )<br>57.常将人工破碎而成的石子称为碎石，而将天然形成的石子称为卵石。（ √ ）<br>58.水、水泥、砂(细骨料)、石子(粗骨料)是普通混凝土的四种基本组成材料。（ √ ）<br>59.判断砂粗细程度的指标是细度模数，细度模数越小，砂越粗。（ × ）<br>60.影响混凝土拌合物工作性的因素主要有组成材料和环境条件，而与时间无关。（ × ）<br>61.增大混凝土拌合物的水灰比，可降低硬化混凝土的孔隙率，增加水泥与骨料间的粘结力，强度得以提高。(×)<br>28.普通混凝土受压时，最可能发生的破坏形式是骨料先破坏。(  ×  )<br>61.混凝土随着龄期的延续，强度会持续下降。（ × ）</p>
<p>62.砌筑砂浆掺人石灰膏而制得混合砂浆其目的是改善和易性。( √ )<br>63.砌筑砂浆强度主要取决于水泥强度与水泥用量。( √ )<br>64.砂浆试件尺寸采用(70.7×70.7×70.7)mm立方体试件。( √ )<br>65.砂浆试件尺寸采用(50×50×50)mm立方体试件。( × )<br>66.砂浆的保水性用“分层度”表示。分层度大于30mm的砂浆，容易发生干缩裂缝。( × )<br>67.砂浆的保水性用“分层度”表示。分层度大于30mm的砂浆，容易产生离析，不便于施工。( √ )<br>68.砌筑砂浆强度与水灰比有关。( × )<br>69.砂浆的流动性也叫做稠度，是指在自重或外力作用下流动的性能。( √ )<br>70.砂浆的粘结力与砖石的表面状态、洁净程度、湿润情况及施工养护条件等有关。( √ )<br>71.建筑砂浆是由无机胶凝材料、细骨料和水，有时也掺人某些掺合料组成。（ √ ）<br>29.建筑砂浆根据用途分类，可分为砌筑砂浆、抹面砂浆。(  √ )<br>72.拌合砂浆用水，应选用无有害杂质的洁净水来拌制砂浆。（ √ ）<br>73.当原材料质量一定时，砂浆的强度主要取决于砂子的用量。（ × ）</p>
<p>74.熔融制品是将适当成分的原料经熔融、成型、冷却而得到的产品。（ √ ）<br>75.小砌块采用自然养护时，必须养护3天方可使用。（ × ）<br>76.烧结多孔砖和烧结空心砖都可做为承重墙体材料。( × )<br>77.空心砖和多孔砖都可做为承重墙体材料。( × )<br>78.烧结空心砖主要用于非承重的填充墙和隔墙。( √ )<br>78.蒸压粉煤灰砖强度非常低，因此不得用于工业与民用建筑的基础、墙体。( × )<br>79.烧结多孔砖因其强度较高，一般用于砌筑六层以下建筑物的承重墙，烧结空心砖主要用于非承重的填充墙和隔墙。( √ )<br>80.泛霜是烧结砖在使用过程中的一种盐析现象。( √ )<br>81.通常釉面砖不宜用于室内。( × )<br>82.加气混凝土砌块最适合用于温度长期高于80℃的建筑部位。( × )</p>
<p>30.玻璃是以黏土为主要原料，经成型、干燥、蜡烧而得到的产品。(  ×  )</p>
<p>83.含碳量在2％以下，含有害杂质较少的铁—碳合金称为钢。（ √ ）<br>84.钢材的冲击韧性随温度的降低而增大，并与温度成线性关系。（ × ）<br>85.在大跨度、承受动荷载和冲击荷载的结构中使用碳素钢要比使用低合金高强度结构钢节约钢材20％～30％。（ × ）<br>86.低合金钢适用于经受动荷载的钢结构。〔 √ )<br>87.合金钢中碳元素仍然是与技术性能密切相关的合金几索。〔 √ )<br>88.结构设计时软钢以 EMBED Equation.3  作为设计计算取值的依据。( × )<br>88.结构设计时一般以屈服强度作为强度取值的依据。( √ )<br>89.钢中P的危害主要是冷脆性。( √ )<br>90.钢中S的危害主要是冷脆性。( × )<br>91.钢筋经冷加工时效，可获得强度提高而塑性降低的效果。( √ )<br>92.钢筋经冷加工后，其屈服强度提高而硬度减小。( × )<br>93.钢筋经冷加上时效，可获得强度提高而塑性降低的效果。( √ )<br>94.钢中碳的含量越少则强度越低、塑性越差。( × )<br>95.结构设计时一般以£y作为强度取值的依据。而对屈服现象不明显的中碳和高碳钢(硬钢)，则规定以产生残余变形为原标距长度的0.2%所对应的应力值作为屈服强度，称为条件屈服点，用£0.2表示。(√)<br>96.屈服强度和抗拉强度之比能反映钢材的利用率和结构的安全可靠性。( √ )<br>97.钢号为Q235—A·F中的F代表钢所含合金元素。( × )<br>98.钢号为Q235—A·b的钢其性能好于钢号为Q235—D·b的钢。( × )<br>99.钢筋焊接时，应尽量避免不同国家的进口钢筋之间或进口钢筋与国产钢筋之间的焊接。( √ )<br>100.低合金钢适用于经受动荷载的钢结构。( √ )<br>32.沥青的电绝缘性非常的差。(  ×  )<br>101.道路及建筑沥青的牌号低，其软化点高。( √ )<br>102.沥青的温度敏感性用软化点表示。软化点越高，则温度敏感性越大。( × )<br>103.沥青的温度敏感性用软化点表示。软化点越高，则温度敏感性越小。( √ )<br>104.石油沥青的塑性用延度表示。延度越大，塑性越差。( × )<br>105.石油沥青的塑性用延度表示。延度越大，塑性越好。( √ )<br>106.石油沥青的塑性用针人度表示，针人度越大，塑性越好。（ × ）<br>107.建筑石油沥青针人度小(赫性较大)，软化点较高( 耐热性较好)，但延伸度较小(塑性较小)。( √ )<br>108.通常，道路石油沥青牌号越低，则黏性越小(即针入度越大)，塑性越好(即延度越大)，温度敏感性越大(即软化点越低)。( × )<br>109.石油沥青的粘滞性大小与组分及温度无关。( × )<br>110.黏稠石油沥青的针入度值越小，表明其黏度越小。( × )<br>111.石油沥青的粘滞性大小与组分及温度无关。（ × ）<br>112.闪点是指加热沥青至挥发出的可燃气体和空气的混合物，在规定条件下与火焰接触，初次闪火时的沥青温度。（ √ ）<br>113.由于涂料涂刷后靠其中的液体成分形成涂膜，因此固体含量多少与成膜厚度及涂膜质量无任何关系。（ × ）<br>《建筑材料》期末考试题库3<br>简答题<br>1.材料的密度、体积密度和堆积密度分别指的是什么?<br>答: (1)密度是指材料在绝对密实状态下，单位体积的质量。<br>(2)体积密度是材料在自然状态下，单位体积的质量。<br>(3)材料的堆积密度是指粉状、颗粒状或纤维状材料在堆积状态下单位体积的质量。<br>1.什么是材料的弹性?<br>答：材料的弹性是指材料在外力作用下发生变形，当外力解除后，能完全恢复到变形前形状的性质。这种变形称为弹性变形或可恢复变形。</p>
<p>2.材料与水有关的性质主要有哪些？<br>答：材料与水有关的性质主要有：材料的亲水性和憎水性以及材料的吸水性、吸湿性、耐水性、抗冻性、抗渗性等。</p>
<p>3.什么是材料的吸水性，影响材料吸水性的主要因素有哪些？<br>答：材料的吸水性是指材料在水中吸收水分达饱和的能力。<br>影响材料的吸水性的主要因素有材料本身的化学组成、结构和构造状况，尤其是孔隙状况。一般来说，材料的亲水性越强，孔隙率越大，连通的毛细孔隙越多，其极水率越大。</p>
<p>4.亲水材料与憎水材料各指什么？<br>答：若润湿角θ≤90°，说明材料与水之间的作用力要大于水分子之间的作用力，故材料可被水浸润，称该种材料是亲水的。反之，当润湿角。&gt;90°，说明材料与水之间的作用力要小于水分子之间的作用力，则材料不可被水浸润，称该种材料是憎水的。<br>5.影响材料强度测量值的因素有哪些？<br>答：影响材料强度测量值的因素有：试件的形状和大小；加荷速度；温度；含水状态；表面状况。</p>
<p>6.石灰主要有哪些用途？<br>答：石灰的用途主要有：<br>①粉刷墙壁和配制石灰砂浆或水泥混合砂浆。<br>②配制灰土和三合土。<br>③生产无熟料水泥、硅酸盐制品和碳化石灰板。</p>
<p>7.什么是过火石灰？什么是欠火石灰？它们各有何危害？<br>答：当人窑石灰石块度较大，锻烧温度较高时，石灰石块的中心部位达到分解温度时，其表面已超过分解温度，得到的石灰称其为过石灰。若缎烧温度较低，大块石灰石的中心部位不能完全分解，此时称其为欠火石灰。<br>过火石灰熟化十分缓慢，其可能在石灰应用之后熟化，其体积膨胀，造成起鼓开裂，影响工程质量。欠火石灰则降低了石灰的质量，也影响了石灰石的产灰量。</p>
<p>8.什么是石灰的陈伏？陈伏期间石灰浆表面为什么要敷盖一层水？<br>答：为了消除过火石灰在使用中造成的危害，石灰膏(乳)应在储灰坑中存放半个月以上，然后方可使用。这一过程叫作“陈伏”。<br>陈伏期间，石灰浆表面应敷盖一层水，以隔绝空气，防止石灰浆表面碳化。</p>
<p>9.什么是石灰的熟化？石灰熟化的特点如何？<br>答：石灰的熟化是指生石灰(CaO)加水之后水化为熟石灰[Ca(OH)2]的过程。<br>石灰熟化的特点：生石灰具有强烈的消解能力，水化时放出大量的热。生石灰水化时体积增大。</p>
<p>10.什么是石灰的熟化？生石灰熟化的方法有哪两种？<br>答：石灰的熟化是指生石灰(CaO)加水之后水化为熟石灰[Ca(OH)2]的过程。<br>生石灰熟化的方法有淋灰法和化灰法。</p>
<p>11.什么是水玻璃硅酸盐模数？与水玻璃的性质有何关系？<br>答：水玻璃的模数表示水玻璃中SiO2与碱金属氧化物物质的量之间的比。<br>水玻璃的模数对于凝结、硬化速度影响较大。当模数高时，硅胶容易析出，水玻璃凝结硬化快； 而当模数低时，则凝结、硬化都比较慢。</p>
<p>12.何谓普通硅酸盐水泥，其与硅酸盐水泥比较其应用性质有何异同？<br>答：凡有硅酸盐水泥熟料、6%~15%混合材料、适量石膏磨细制成的水硬性胶凝材料，称为普通硅酸盐水泥。<br>普通硅酸盐水泥中掺入混合材料的量较少，其矿物组成的比例仍在硅酸盐水泥的范围内，所以其性能应用范围与同强度等级的硅酸盐水泥相近。与硅酸盐水泥比较，早期硬化速度稍慢，强度略低；抗冻性、耐磨性及抗碳化性能稍差；耐腐蚀性稍好，水化热略低。</p>
<p>13.硅酸盐水泥有哪些特性?<br>答：硅酸盐水泥的特性有：强度高；水化热高；抗冻性好；碱度高、抗碳化能力强；干缩小；耐磨性好；耐腐蚀性差；耐热性差；湿热养护效果差。</p>
<p>14.水泥的细度指的是什么，水泥的细度对水泥的性质有什么影响？<br>答：水泥的细度是指水泥颗粒粗细的程度。<br>水泥的细度对水泥性质的影响：水泥越细，凝结硬化速度越快，强度（特别是早期强度）越高，收缩也增大。但水泥越细，越易吸收空气中水分而受潮形成絮团，反而会使水泥活性降低。此外，提高水泥的细度要增加粉磨时的能耗，降低粉磨设备的生产率，增加成本。</p>
<p>15.硅酸盐水泥的凝结时间、初凝时间、终凝时间各指什么？<br>答：硅酸盐水泥的凝结时间：水泥从加水开始到失去流动性，即从可塑状态发展到固体状态所需要的时间。<br>初凝时间：从水泥加水拌和时起到水泥浆开始失去塑性所需要的时间。<br>终凝时间：从水泥加水拌合时起到水泥浆完全失去可塑性，并开始具有强度的时间。</p>
<p>16.影响硅酸盐系水泥凝结硬化的主要因素有哪些？<br>答：影响硅酸盐系水泥凝结硬化的主要因素：水泥的熟料矿物组成及细度、水灰比、石膏的掺量、环境温度和湿度、龄期和外加剂。</p>
<p>17.何谓水泥体积安定性？水泥体积安定性不良一般是由哪些原因造成的？<br>答：水泥凝结硬化过程中，体积变化是否均匀适当的性质称为水泥体积安定性。<br>水泥体积安定性不良，一般是由于熟料中所含游离氧化钙、游离氧化镁过多或掺人的石膏过多等原因造成的。</p>
<p>18.防止水泥石腐蚀的措施有哪些？<br>答：防止水泥石腐蚀的措施：<br>(1)根据环境侵蚀特点，合理选用水泥品种；(2)提高水泥石的密实度；(3)表面加作保护层。</p>
<p>19.水泥石腐蚀的原因是什么？如何克服水泥石的腐蚀？<br>答：水泥石腐蚀的原因是：<br>引起水泥石腐蚀的外部因素是侵蚀介质。而内在因素一是水泥石中含有易引起腐蚀的组分，即Ca(OH)2和水化铝酸钙；二是水泥石不密实。侵蚀性介质不仅在水泥石表面起作用，而且易于通过毛细管和孔隙进人水泥石内部引起严重破坏。<br>克服腐蚀的措施：合理选择水泥品种，提高水泥石的密实度，表面做保护层。</p>
<p>20.与硅酸盐水泥相比，矿渣硅酸盐水泥在性能上有哪些不同？其适用如何？<br>答：矿渣硅酸盐水泥的特性：保水性差，泌水性大，耐热性高，耐海水、硫酸盐腐蚀。<br>矿渣硅酸盐水泥适用：耐热混凝土；大体积混凝土；蒸汽养护混凝土；耐海水、软水、硫酸盐腐蚀的混凝土。</p>
<p>21.混凝土中水泥的选用主要考虑哪些因素？<br>答：水泥的选用，主要考虑的是水泥的品种和强度等级。<br>水泥的品种应根据工程的特点和所处的环境气候条件，特别是应针对工程竣工后可能遇到的环境影响因素进行分析，并考虑当地水泥的供应情况作出选择。</p>
<p>22.什么是石子的连续级配，采用连续级配的石子对混凝土性能有哪些影响？<br>答：石子的连续级配是指石子的粒径从大到小连续分级，每一级都占适当的比例。<br>连续级配的颗粒大小搭配连续合理，用其配置的混凝土拌合物公正性好，不易发生离析，在工程中应用较多。但其缺点是，当最大粒径较大时，天然形成的连续级配往往与理论最佳值有偏差，且在运输、堆放过程中易发生离析，影响到级配的均匀合理性。</p>
<p>23.混凝土拌合物的工作性在哪些方面有所体现?<br>答：混凝土拌合物的工作性在搅拌时体现为各种组成材料易于均匀混合，均匀卸出；在运输过程中体现为拌合物不离析，稀稠程度不变化；在浇筑过程中体现为易于浇筑、振实、流满模板；在硬化过程中体现为能保证水泥水化以及水泥石和骨料的良好粘结。</p>
<p>24.什么是混凝土拌合物的工作性？混凝土拌合物包括哪三个方面的技术要求？<br>答：工作性又称和易性，是指混凝土拌合物在一定的施工条件和环境下，是否易于各种施工工序的操作，以获得均匀密实混凝土的性能。<br>目前普遍认为，它应包括流动性、粘聚性、保水性三个方面的技术要求。</p>
<p>25.普通混凝土是由哪四种基本材料组成，它们各起何作用？<br>答：水、水泥、砂(细骨料)、石子( 粗骨料)是普通混凝土的四种基本组成材料。<br>水和水泥形成水泥浆，在混凝土中赋予拌合混凝土以流动性；粘接粗、细骨料形成整体；填充骨料的间隙，提高密实度。砂和石子构成混凝土的骨架，有效抵抗水泥浆的干缩；砂石颗粒逐级填充，形成理想的密实状态，节约水泥浆的用量。</p>
<p>26.混凝土采用减水剂可取得哪些经济、技术效果？<br>答：混凝土采用减水剂取得经济、技术效果：<br>(1)增大流动性；(2)提高强度；(3)节约水泥；(4)改善粘聚性、保水性，提高密实度，改善耐久性，降低和延缓水化热。</p>
<p>27.什么是混凝土的立方体抗压强度标准值？有何实用意义？<br>答：混凝土立方体抗压强度的标准值是指按标准试验方法测得的立方体抗压强度总体分布中的一个值，强度低于该值的百分率不超过5%(即具有95%的强度保证率)。<br>为便于设计和施工选用混凝土，将混凝土按立方体抗压强度的标准值分成若干等级，即强度等级。混凝土立方体抗压强度是确定混凝土强度等级的依据。</p>
<p>28.什么是混凝土引气剂？对混凝土的哪些性能有明显改善？改善的机理是什么？<br>答：引气剂是在混凝土搅拌过程中，能引入大量分布均匀的微小气泡，以减少混凝土拌合物泌水离析、改善工作性，并能显著提高硬化混凝土抗冻耐久性的外加剂。<br>引气剂也是一种憎水型表面活性剂，掺人混凝土中后，在搅拌作用下能引人大量直径在20μm以下的微小气泡，吸附在骨料表面或填充于水泥硬化过程中形成的泌水通道中，这些微小气泡从混凝土搅拌一直到硬化都会稳定存在于混凝土中。在混凝土拌合物中，骨料表面的这些气泡会起到滚珠轴承的作用，减小摩擦，增大混凝土拌合物的流动性，同时气泡对水的吸咐作用也使粘聚性、保水性得到改善。在硬化混凝土中，气泡填充于泌水开口孔隙中，会阻隔外界水的渗入。而气泡的弹性，则有利于释放孔隙中水结冰引起的体积膨胀，因而大大提高混凝土的抗冻性、抗渗性等耐久性指标。</p>
<p>29.提高混凝土耐久性的措施有哪些？<br>答：(1)选择合适品种的水泥；<br>(2)控制混凝土的最大水灰比和最小水泥用量；<br>(3)选用质量良好的骨料，并注意颗粒级配的改善；<br>(4)掺加外加剂；<br>(5)严格控制混凝土施工质量，保证混凝土的均匀、密实。</p>
<p>30.砂浆的和易性包括哪些含义？各用什么指标表示？<br>答：砂浆的和易性包括流动性和保水性。流动性用“沉入度”表示。保水性用“分层度”表示。<br>31.对抹面砂浆有哪些要求？<br>答：对抹面砂浆要求具有良好的和易性，容易抹成均匀平整的薄层，便于施工。还应有较高的粘结力，砂浆层应能与底面粘结牢固，长期不致开裂或脱落。处于潮湿环境或易受外力作用部位(如地面、墙裙等)，还应具有较高的耐水性和强度。</p>
<p>32.根据建筑部位的不同，如何选择抹面砂浆？<br>答：用于砖墙的底层抹灰，多用石灰砂浆；用于板条墙或板条顶棚的底层抹灰多用混合砂浆或石灰砂浆；混凝土墙、梁、柱、顶板等底层抹灰多用混合砂浆、麻刀石灰浆或纸筋石灰浆。<br>在容易碰撞或潮湿的地方，应采用水泥砂浆。如墙裙、踢脚板、地面、雨棚、窗台以及水池、水井等处一般多用1׃2.5的水泥砂浆。</p>
<p>33.为什么工程上常以抗压强度作为砂浆的主要技术指标？<br>答：砂浆在砌体中主要起传递荷载的作用，并经受周围环境介质作用，因此砂浆应具有一定的黏结强度、抗压强度和耐久性。试验证明：砂浆的黏结强度、耐久性均随抗压强度的增大而提高，即它们之间有一定的相关性，而且抗压强度的试验方法较为成熟，测试较为简单准确，所以工程上常以抗压强度作为砂浆的主要技术指标。</p>
<p>34.烧结普通砖的技术要求有哪几项？<br>答：烧结普通砖的技术要求有：规格；外观质量；强度；泛霜和石灰爆裂。</p>
<p>35.釉面砖为什么不宜用于室外？<br>答：釉面砖为多孔精陶，坯体吸水率较大，吸水后产生湿涨，而其表面釉面湿涨性很小，用于室外，经常受大气温、湿度影响及日晒雨淋，坯体湿涨应力超过表面釉层的抗拉强度，会造成釉层裂缝、剥落，产生影响建筑物的饰面效果。</p>
<p>36.低合金结构钢有何特点？采用这种钢有什么技术、经济意义？<br>答：低合金结构钢的特点：强度高、耐磨性好、耐腐蚀性强、耐低温。<br>采用低合金结构钢的技术、经济意义：<br>综合技术性能高，尤其适用于大跨度、承受动荷载和冲击荷载的结构。<br>与使用碳素钢相比，可节约钢材20%—30%，而成本增加并不很高。</p>
<p>37.低碳钢受拉经历哪四个阶段？结构设计时一般以什么强度作为强度取值的依据？<br>答：低碳钢受拉经历四个阶段：弹性阶段、屈服阶段、强化阶段和颈缩阶段。<br>结构设计时一般以屈服强度作为强度取值的依据。</p>
<p>38.什么是钢材的屈强比？它在建筑设计中有何实际意义?<br>答：钢材的屈强比，即屈服强度和抗拉强度之比。<br>它能反映钢材的利用率和结构的安全可靠性，屈强比愈小，反映钢材受力超过屈服点工作时的可靠性愈大，因而结构的安全性愈高。但屈强比太小，则反映钢材不能有效地被利用，造成钢材浪费。</p>
<p>39.建筑钢材有哪些优缺点？<br>答：建筑钢材材质均匀，具有较高的强度、有良好的塑性和韧性、能承受冲击和振动荷载、可焊接或铆接、易于加工和装配，钢结构安全可靠、构建自重小，所以被广泛应用于建筑工程中。但钢材也存在易锈蚀及耐火性差等缺点。</p>
<p>40.碳元素对钢材性能的影响如何？<br>答：碳元素是决定钢材性质的主要元素。钢材随含碳量的增加，强度和硬度相应提高，而塑性和韧性相应降低。当含量超过1%时，钢材的极限强度开始下降。此外，含碳量过高还会增加钢的冷脆性和时效敏感性，降低抗腐蚀性和可焊性。</p>
<p>41.石油沥青的组分有哪些?各组分的性能和作用如何？<br>答：石油沥青的组分有：油分、树脂、沥青质。<br>各组分的性能和作用：<br>油分含量的多少直接影响沥青的柔软性、抗裂性及施工难度；中性树脂赋予沥青具有一定的塑性、可流动性和黏结性，其含量增加，沥青的黏结力和延伸性增加；酸性树脂能改善沥青对矿物材料的浸润性，特别是提高了与碳酸盐类岩石的黏附性及增强了沥青的可乳化性；沥青质决定着沥青的黏结力、黏度、温度敏感性和硬度等。沥青质含量增加时，沥青的黏度和粘结力增加，硬度和软化点提高。</p>
<p>42.矿物填充料为何能够改性沥青？<br>答：矿物填充料掺入沥青中后，能被沥青包裹形成稳定的混合物，由于沥青对矿物填充料的湿润和吸附作用，沥青可能成单分子状排列在矿物颗粒（或纤维）表面，形成结合力牢固的沥青薄膜，具有较高的黏性和耐热性等。因而提高沥青的黏结能力、柔韧性和耐热性，减少了沥青的温度敏感性，并且可以节省沥青。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac添加PATH环境变量]]></title>
      <url>/2018/06/20/append-path-on-mac/</url>
      <content type="html"><![CDATA[<p>用常规方法安装好npm之后,<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm --version</span><br><span class="line">bash: npm: commmand not found</span><br></pre></td></tr></table></figure></p>
<p>以为是没有安装后，换用brewhome<a href="参考 - brewhome官网">https://brew.sh/index_zh-cn.html</a>进行安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ brew --version</span><br></pre></td></tr></table></figure></p>
<p>依旧 command not found</p>
<p>注意到，warning:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">==&gt; Cleaning up /Library/Caches/Homebrew...</span><br><span class="line">==&gt; Migrating /Library/Caches/Homebrew to /Users/htwt/Library/Caches/Homebrew...</span><br><span class="line">==&gt; Deleting /Library/Caches/Homebrew...</span><br><span class="line">Already up-to-date.</span><br><span class="line">Warning: /usr/<span class="built_in">local</span>/bin is not <span class="keyword">in</span> your PATH.</span><br><span class="line">==&gt; Installation successful!</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure>
<p>需要手动添加一个PATH<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9</span><br></pre></td></tr></table></figure></p>
<p>现在npm, brew都可以直接用了</p>
<p>另外一种方法是修改 ~/.bash_profile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># export local bin</span><br><span class="line">export PATH=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>接着,<br>$ source ~/.bash_profile</p>
<p>但接着又出现了新的问题, 每次重启emacs, 重启terminal之后, 都需要 source ~/.bash_profile</p>
<p>解决方法如下:<br>1, 搞清楚用的是哪个shell,<br>$ echo $SHELL<br>/bin/bash</p>
<p>2, zsh对应~/.zshrc, bash对应~/.bashrc,<br>添加入source ~/.bash_profile</p>
<p>这样的话， 在每次打开shell时候都能自动加载了</p>
<hr>
<p>ref:</p>
]]></content>
      
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2018/06/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[architecture-english-temp2]]></title>
      <url>/2018/01/23/architecture-english-temp2/</url>
      <content type="html"><![CDATA[<h1 id="1-完型填空-10"><a href="#1-完型填空-10" class="headerlink" title="1. 完型填空(10%)"></a>1. 完型填空(10%)</h1><h2 id="绿色建筑"><a href="#绿色建筑" class="headerlink" title="绿色建筑"></a>绿色建筑</h2><p>生态 ecological<br>可循环的 recycle<br>环境的，景观 landscape</p>
<h2 id="建筑的构成"><a href="#建筑的构成" class="headerlink" title="建筑的构成"></a>建筑的构成</h2><p>梁 beam<br>剖面 section<br>柱子 column<br>覆盖 cover/ blanket</p>
<h1 id="2-词义配对-20"><a href="#2-词义配对-20" class="headerlink" title="2. 词义配对(20%)"></a>2. 词义配对(20%)</h1><p>(wood - timber)<br>(aesthetic - creative)<br>(hospital - medical institution)<br>(innovative - originality)<br>(site plan - situation plan)<br>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(architecture experience - architecture apprehension) 理解，领悟,感觉<br>(transform - convert) 改变<br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(perception - understanding) 知觉，理解<br>(guest house - visit house) 参观房间<br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>
<h1 id="3-词义搭配中文-10"><a href="#3-词义搭配中文-10" class="headerlink" title="3. 词义搭配中文(10%)"></a>3. 词义搭配中文(10%)</h1><p>给出单词，选择中文单词。</p>
<p>Beam - 梁<br>Aesthetic - 美学<br>Architect - 建筑师<br>Composition - 构成<br>Staircase - 楼梯<br>Multi-story building - 多层建筑<br>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Scheme - 方案<br>Facade - 立面<br>Material - 材料<br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong><br>Exit - 安全出口<br>Entrance - 玄关<br>Wheelchair ramp - 轮椅坡道<br>Residential building - 住宅</p>
<h1 id="4-英译中-10"><a href="#4-英译中-10" class="headerlink" title="4. 英译中(10%)"></a>4. 英译中(10%)</h1><h2 id="1、第一篇原文："><a href="#1、第一篇原文：" class="headerlink" title="1、第一篇原文："></a>1、第一篇原文：</h2><pre><code>DB:how would you describe your architectural approach?
PV：I&apos;m extremely concerned by the fact that design and architecture has a social impact.
we are called to utilize the resources that are not renewable:space,time,money,life...
because in order to design a building and to build it you need years. so, I believe that
my attitudes are extremely serious and conscious about all those elements. I am not someone
who is playing with the project, or doing any&apos;fun stuff, if you like. I prefer to achieve
something that is bringing happiness because of its beauty, because of its harmony,because of the evidence that it is the right thing to do.
</code></pre><h2 id="2、第一篇译文"><a href="#2、第一篇译文" class="headerlink" title="2、第一篇译文:"></a>2、第一篇译文:</h2><pre><code>DB：你如何描述你的建筑观点
我非常关注某种事实是关于设计和建筑学的对社会有影响的 。我们被要求使用(不可再生的资源)，时间， 金钱，生命...因为为了设计一个建筑并(建成它需要花费很长的时间)，因此对这些设计要素来说，我相信(我的态度极其严肃)。我不是那些玩弄项目，或者做一些很有趣的东西，(如果你喜欢的话)。我更倾向去(实现给人们带来快乐的建筑)，因为它的美，因为它的和谐，(因为证据表明**我们**是对的)。
</code></pre><h2 id="3、第二篇原文："><a href="#3、第二篇原文：" class="headerlink" title="3、第二篇原文："></a>3、第二篇原文：</h2><pre><code>DB:do you think there is an increasingly &apos;globalized approach&apos; To architecture?
DC:
there shouldn&apos;t be. a building can last for a very long time.
it&apos;s fixed to the ground and it contributes to the idea of &apos;a place&apos;.
however contemporary we feel that we are, we still want to find different characteristics in different places. 
if we go to  mexico we want to see architecture that tells us something about the place, the culture. When we build in a city we have a responsibility in a way to join in and understand why buildings are the way they are in that city,what they add. 
I find it very weak for an architect to disregard the history and  culture of a city and say &apos; I have an international style&apos;. 
there&apos;s absolutely no intellectual justification for that. 
it&apos;s the equivalent of having no variation in cuisine, you may as well just place all the different types of food in a blender and consume it as a protein rich shake.
This romantic notion of different styles and approaches is important, it means something to people and when architecture should move you, that&apos;s where character is important, we have to be careful no to just create bland products.
</code></pre><h2 id="4、第二篇译文"><a href="#4、第二篇译文" class="headerlink" title="4、第二篇译文:"></a>4、第二篇译文:</h2><pre><code>你如何评价越来越多的全球化？
</code></pre><p>不应该是这样的。一栋建筑(不能够长时间持续存在)。建筑被固定到(场地)上并且有助于激发(场地)的概念。然而，现如今我们觉得我们正是这样，我们仍然希望去寻找不同的特性在不同的场地中。如果我们去墨西哥，我们希望能看到能(向我们述说当地的一些事)，(比如文化)。当我们建造一座城市时，在某种程度上我们有责任去加入，并且(理解建筑在城市中的原因)，这是他们所增加的。我发现如果一位建筑师忽视了(历史)和文脉并宣称(他用于国际化风格)是他妈很不好的。而且完全没有合理的理由去解释这些（就他妈是扯蛋）。这就像(没有营养的烹饪)，你只是把所有不同种类的食物统统塞到搅拌机里，并把它作为(含有蛋白质的料理)（奶昔）。这些浪漫的概念对于不同的风格和方法是至关重要的，这对于人们来说意味着某些事情，并且当建筑能(走近你)（打动）的时候，这才是重要的特性。我们必须注意，不要创造一个（让人感到脱下裤子就给我看这个）平庸的产品和建筑。</p>
<h1 id="Part1-1-2-3-4错误总结"><a href="#Part1-1-2-3-4错误总结" class="headerlink" title="Part1, 1, 2, 3, 4错误总结"></a>Part1, 1, 2, 3, 4错误总结</h1><p>(art - meaningful)   <strong>ERROR::creative piece</strong><br>(stone thick wall - ???) 厚的石墙  <strong>ERROR::masonry wide division</strong><br>(creative - ??)   <strong>ERROR::ingenious</strong><br>(commercial enterpise - ind?? ) 商业的  <strong>ERROR::industrial</strong></p>
<p>Balcony - ??    <strong>ERROR::Balcony - 阳台</strong><br>Subdued architecture - ??   <strong>ERROR:: 平缓的建筑</strong></p>
<p>it’s the equivalent of having no variation in cuisine, 这就像没有变换的烹饪</p>
<hr>
<h1 id="part2-5-7总结"><a href="#part2-5-7总结" class="headerlink" title="part2 5, 7总结"></a>part2 5, 7总结</h1><h1 id="5-看图描述-15"><a href="#5-看图描述-15" class="headerlink" title="5. 看图描述(15%)"></a>5. 看图描述(15%)</h1><p>10句话组成，每句一分，两张图（平面，立面，透视），每张图2.5分</p>
<p>Sou Fujimoto N HOUSE</p>
<p>1, A home for two plus a dog.    // 两个人的家加上一只狗。<br>2, The house itself is comprised of three shells of progressive size nested inside one another.    // 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>3, The outermost shell covers the entire premises, creating a covered, semi-indoor garden.   // 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>4, Second shell encloses a limited space inside the covered outdoor space.    // 第二外壳在覆盖的室外空间内封闭有限的空间。<br>5, Third shell creates a smaller interior space. Residents build their life inside this gradation of domain.  // 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活</p>
<p>6, The situation plan is flexiable and seems flowing over the small ground.   // 方案平面灵活，像在场地上流动<br>7, And this house fuses with the environment since there are green trees embed in it’s shell.    // 与环境融合, 因为有树在其中.<br>8, As an exam architecutre, N house propose an idea about the features of the future residence.  // 作为一个实验建筑, N house提出未来住宅的理念<br>9, In the traditional residence design, architects prefer to separate of internal space and external space.   // 传统住宅设计, 倾向于分开外部和内部空间<br>10, But it’s special to N house, because Fujimoto remove the limitation between outdoor and indoor when he making this scheme, so that combine the internal space and external space.  // 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>11, Three nested shells eventually mean infinite nesting because the whole world is made up of infinite nesting. And here are only three of them that are given barely visible shape. // 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>
<p>// 两个人的家加上一只狗。<br>// 这座房子本身由三个累进大小的贝壳组成，它们相互嵌套在一起。<br>// 最外层的外壳覆盖了整个房屋，形成了一个覆盖着的半室内花园。<br>// 第二外壳在覆盖的室外空间内封闭有限的空间。<br>// 第三层外壳创造了更小的内部空间。居民们在这片土地上建造他们的生活。<br>// 方案平面灵活，像在场地上流动。<br>// 与环境融合, 因为有树在其中。<br>// 作为一个实验建筑, N house提出未来住宅的理念。<br>// 传统住宅设计, 倾向于分开外部和内部空间。<br>// 但对于Nhouse是特殊的, Fujimoto在做方案的时候, 消除了室内外的界限, 以致于使得内部和外部结合起来。<br>// 三层壳的嵌套最终以为着无限嵌套, 因为整个世界是由无限的嵌套组成的。因此这里只有给出了三个可见的形状。</p>
<h2 id="自我批改"><a href="#自我批改" class="headerlink" title="自我批改"></a>自我批改</h2><p>A house for two plus a dog.<br>The house itself ~comprises~ (is comprised of)three shells of progressive size nested inside one another.<br><strong>RIGHT::The house itself is comprised of three shells of progressive size nested indside one another.</strong><br>The outermost shell covers ~a prises~ (the entire premises) , creating a coverd, semi-indoor ~space~(garden).<br>The second shell (encloses a) limited space (inside the covered outdoor space.) ~, outdoor~<br>The third shell (creates a smaller interior space. Residents build their life inside this gradation of domain)</p>
<p>The situation plan is flexiable, and seems flowing over the small ground.<br>And the building fuses with environment since there are green trees embed in the shell.<br>As an exam architecture, architect propose an idea about features of future ~????house.~ (residence)<br>In traditional design prosess, architects perfer to seperate of interior space and external space.<br>But (it’s) special to N house, Fojimoto removed the ~line~ (limitation) between indoor and outdoor(when he making this scheme, so that combined the internal and external space).<br>Three shells eventually (mean infinite nesting)~nested one another infinitely~. Because the world is (made up of) infinite (nesting).(And here are only three of them are given barely visible shape.)</p>
<p>Three shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are only three of them are given barely visible shape.</p>
<p>The house for two plus a dog.<br>The house itself is comprised of three shells of progressive size nested inside one another.<br>The outermost shell covers ~a primese~(entire premises), creating a covered, semi-indoor garden.<br>Second shells encloses a limited space insided the coverd outdoor space.<br>Third shell ~create~(creates) a smaller interior (space). ~The ??~(Residents) build their life ~in~ (inside) this gradation of domain.</p>
<p>The (nested) shells eventually mean infinite nesting because the world is made up of infinite nesting. And here are (only) three of them (that are )given (barely) ~visiable~(visible) shape</p>
<h1 id="6-中译英-20"><a href="#6-中译英-20" class="headerlink" title="6. 中译英(20%)"></a>6. 中译英(20%)</h1><p>给中文采访的文章，生态学的，绿色建筑；英文回答5个问题<br>尽量多写。</p>
<h1 id="7-描述-15"><a href="#7-描述-15" class="headerlink" title="7. 描述(15%)"></a>7. 描述(15%)</h1><p>家的平面或喜欢的建筑。<br>10句话。每句1分。<br>画两张图。1张图2.5分。</p>
<p>Mention to my house in my homeland, it consists of four parts building. There are primary building, secondary buding, garden and garage respectively. If you guest my home, you will approach the entrance after a trail. In the north, the primary building is the living space for my family member,includes kitchen, dining room, bedroom, study room, etc. And the edge of primary building, it is a two-car garage. In the west, the secondary building build up with store room, sport room and living room, etc. In the center it’s a gargen, the deciduous trees surrounded the garden. Since my father perfer to live close to the trees, I grew up in an environment of nature.</p>
<p>Enter the primary building, the ground floor room is design for cooking and deal with three meals a day, it will be a party place when friends and relatives to visit. My parents living on the second floor at the master room, and I living on the third floor. There are a porch connects guest room and my room. This building also has a roof garden, not only act balcony, but also provide more space for free activities.</p>
<p>客厅 living room<br>主卧 master bedroom<br>客卧 guest bedroom<br>卫生间 bathroom<br>阳台 balcony<br>厨房 kitchen<br>餐厅 dining room<br>书房 study room<br>天台 roof<br>门廊 porch<br>储物室 store room<br>衣帽间 locker room<br>一层平面 ground floor plan</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[02-E]]></title>
      <url>/2018/01/21/dsacpp/02-E/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(e) 起泡排序</span><br><span class="line">为了使得向量有序, 要对向量进行排序。</span><br><span class="line"></span><br><span class="line"># 排序器, ADT 统一入口:</span><br><span class="line">	&gt;* 实现</span><br><span class="line">		====================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::sort(Rank lo, Rank hi) &#123;</span><br><span class="line">			int i = 1;</span><br><span class="line">			switch (i) &#123;</span><br><span class="line">				case 1: bubbleSort(lo, hi); break;     // 起泡排序</span><br><span class="line">				case 2: selectionSort(lo, hi); break;  // 选择排序(习题)</span><br><span class="line">				case 3: mergeSort(lo, hi); break;      // 归并排序</span><br><span class="line">				case 4: heapSort(lo, hi); break;       // 堆排序(ch 10)</span><br><span class="line">				default: quickSort(lo, hi); break;     // 快速排序(12)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 起泡排序</span><br><span class="line">	&gt;* 改进思路</span><br><span class="line">		未必要对未确定序列的全序进行扫描, 其中有一部分可能是有序的, 也可能剩余序列完全有序。</span><br><span class="line">		在上一趟扫描中, 记录有序对</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02-D4]]></title>
      <url>/2018/01/21/dsacpp/02-D4/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d4) 有序向量: 二分查找(改进)</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line"># 版本B, 改进思路:</span><br><span class="line">	&gt;* 左右转向成本平衡：</span><br><span class="line">		无论向左还是向右进行一次比较。</span><br><span class="line">	</span><br><span class="line">	&gt;* 轴点mi为中点, 每查找深入一层, 问题规模缩减一半</span><br><span class="line">		1, e &lt;  x: e若存在则在左侧子区间S[lo, mi), 可递归深入</span><br><span class="line">		2, x &lt;= e: e若存在则在右侧子区间S[mi, hi), 可递归深入</span><br><span class="line">		只有当hi - lo = 1时, 判断元素是否命中。</span><br><span class="line">		</span><br><span class="line"># 实现:</span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		=========================  source code =======================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			// 二分平衡查找算法</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;          // 轴点为中点</span><br><span class="line">				if (e &lt; elem[mi]) hi = mi;        // 深入左区间</span><br><span class="line">				else if (elem[mi] &lt;= e) lo = mi;  // 深入右区间</span><br><span class="line">			&#125;</span><br><span class="line">			// hi - lo == 1, 判断当前元素是否命中</span><br><span class="line">			if (e == elem[lo]) return lo;</span><br><span class="line">			else               return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		思路上无问题, 但代码可以简化。</span><br><span class="line">		</span><br><span class="line">	&gt;* 更为简洁的写法</span><br><span class="line">		=====</span><br><span class="line">	    template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (1 &lt; hi - lo) &#123;</span><br><span class="line">			int mi = (lo + hi) &gt;&gt; 1;               // 轴点为中点</span><br><span class="line">			(e &lt; elem[mi]) ? hi = mi : lo = mi;    // 在哪个区间上深入</span><br><span class="line">			&#125;    // 退出循环时, 区间长度1, elem[lo]为有效元素</span><br><span class="line">			return (e == elem[lo])? lo: -1;</span><br><span class="line">		&#125;        // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		====</span><br><span class="line">		</span><br><span class="line">		1, 两种情况if...else 用以下代替</span><br><span class="line">			(cond)? expr1 : expr2;</span><br><span class="line">		2, 在其中使用返回语句</span><br><span class="line">			(cond) ? return expr1 : return expr2;    // ERROR!!</span><br><span class="line">			return (cond) ? expr1 : expr2;           // Right!!</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 语义约定</span><br><span class="line">	&gt;* 为什么要语义约定?</span><br><span class="line">		便于其他高阶操作的调用。</span><br><span class="line">		v.insert(1 + search(e, lo, hi), e);</span><br><span class="line">			：在找到元素索引的下个索引处插入。</span><br><span class="line">	</span><br><span class="line">	&gt;* 思路</span><br><span class="line">		1, 有多个元素匹配时, 返回最大秩(不大于e的最后一个元素秩)</span><br><span class="line">		2, 未匹配元素时, 返回小于e的最大者秩(含哨兵[lo - 1])</span><br><span class="line">	</span><br><span class="line">	&gt;* 实现, 版本C</span><br><span class="line">		&gt;* 我的尝试</span><br><span class="line">		将原来的 return (e == elem[lo]) ? lo : -1; 改为:</span><br><span class="line">		============= source code ============================</span><br><span class="line">		if (e == elem[lo]) &#123;  // 存在匹配</span><br><span class="line">			while (elem[lo+1] == elem[lo]) lo++;  // 返回最大秩</span><br><span class="line">			return lo;</span><br><span class="line">		&#125; else &#123;  // 无匹配</span><br><span class="line">			return (e &lt; elem[lo]) ? lo - 1 : lo;  // 返回小于e的最大者秩</span><br><span class="line">		&#125;</span><br><span class="line">		=======================================================</span><br><span class="line">		一次while循环找到最大匹配的索引, 一次判断确定不匹配时返回秩</span><br><span class="line">		</span><br><span class="line">		&gt;* 更优解</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binBlcSearch(T* elem, const T&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;  // 区间缩短至0</span><br><span class="line">				int mi = (lo + hi) &gt;&gt; 1;                   // 轴点为中点</span><br><span class="line">				(e &lt; elem[mi]) ? hi = mi : lo = mi + 1;    // [lo, mi), (mi, hi)</span><br><span class="line">			&#125;    // 退出循环时, 区间长度0, A[lo = hi]为大于e的最小元素</span><br><span class="line">			return --lo;    // 故lo-1 为不大于e的最大秩</span><br><span class="line">		&#125;      // 相对于binSearch A版本, 最好(坏)情况下更坏(好)</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 更优解实现分析</span><br><span class="line">		&gt;* 差别</span><br><span class="line">			1, 循环结束区间宽度0, 而非1</span><br><span class="line">			2, 转入右侧子向量时, 左边界取作mi + 1而非mi, elem[mi]看似遗漏?</span><br><span class="line">			3, 无论成功与否, 返回秩序严格符合定义的语义接口。</span><br><span class="line">			4, 和我的实现比起来, 无需多余的while和if判断</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 版本C, 正确性:</span><br><span class="line">	&gt;* 不变性:</span><br><span class="line">		A[0, lo) &lt;= e &lt; A[hi, n)          // A[hi] 总是大于e的最小者</span><br><span class="line">	&gt;* 初始</span><br><span class="line">		lo = 0且hi = n, A[0, lo) = A[hi, n) = 空集, 自然成立</span><br><span class="line">	&gt;* 数学归纳两种情况,</span><br><span class="line">		这两种情况不是很清楚。以后可以回过头来看看。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-D3]]></title>
      <url>/2018/01/20/dsacpp/02-D3/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(d3) 有序向量: Fibonacci查找</span><br><span class="line"></span><br><span class="line">1, 思路</span><br><span class="line">	向左侧1次, 向右两次。</span><br><span class="line">	表面平衡, 内部极大不平衡。</span><br><span class="line">	比较次数不等, 递归深度却相等。</span><br><span class="line">	</span><br><span class="line">	左侧更深, 右侧更浅。</span><br><span class="line">	递归深度不平衡, 对转向成本不同进行补偿。</span><br><span class="line">	</span><br><span class="line">	若 n = fib(k) - 1, 则mi = fib(k-1) - 1</span><br><span class="line">	前向量fib(k-1) - 1, 后向量fib(k-2) - 1</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">2, 实现</span><br><span class="line">	&gt;* 我的尝试, 定义fib类</span><br><span class="line">		====== source code ====</span><br><span class="line">		// ERROR:my test fib</span><br><span class="line">		// 定义fibonacci相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int* _fib_lst; int _size;</span><br><span class="line">			public:</span><br><span class="line">			// 构造函数</span><br><span class="line">			explicit Fib(const int n) : _size(n) &#123;</span><br><span class="line">				emptyFib(n);</span><br><span class="line">				fib(n-1, _fib_lst);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 将数列置空</span><br><span class="line">			void emptyFib(const int n) &#123;</span><br><span class="line">				// 初始化0</span><br><span class="line">				for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">				_fib_lst[i] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 生成fib数列</span><br><span class="line">			int fib(const int n, int* _fib_lst) &#123;</span><br><span class="line">				if (_fib_lst[n] != 0) &#123;</span><br><span class="line">					return _fib_lst[n];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (n &lt; 2) &#123;_fib_lst[n] = n;&#125; else &#123;</span><br><span class="line">						_fib_lst[n] = fib(n-1, _fib_lst)  + fib(n-2, _fib_lst);</span><br><span class="line">						return _fib_lst[n];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// 获得数列中某一索引的值</span><br><span class="line">			int&amp; get(const int&amp; n) const &#123;return _fib_lst[n];&#125;</span><br><span class="line">			</span><br><span class="line">			int index(const int v) const &#123;</span><br><span class="line">				// 获得某一值在fib数列对应的索引</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					if (v == _fib_lst[i]) return i;</span><br><span class="line">					if (v &lt; _fib_lst[i]) return -1;    // 比当扫描值大还没找到, 返回失败</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;    // 在扫描过程中没找到, 返回失败</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 打印数列</span><br><span class="line">			void printFib() const &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;---- print fib series -----\n&quot;;</span><br><span class="line">				for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">					std::cout &lt;&lt; i &lt;&lt;&quot;: _fib_lst[i]&quot;</span><br><span class="line">						&lt;&lt; _fib_lst[i] &lt;&lt; std::endl;	</span><br><span class="line">				&#125;</span><br><span class="line">				std::cout &lt;&lt; &quot;_size = &quot; &lt;&lt; _size &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		==================================================</span><br><span class="line">		运行总是溢出, 找不到出错位置。</span><br><span class="line">		考虑先right, 后fast</span><br><span class="line"></span><br><span class="line">	&gt;* 根据课件的修改</span><br><span class="line">		=================== source code ==========================</span><br><span class="line">		// 定义fib相关的类</span><br><span class="line">		class Fib &#123;</span><br><span class="line">			int _size;</span><br><span class="line">			</span><br><span class="line">			public:</span><br><span class="line">			explicit Fib(int n) : _size(n) &#123;&#125;</span><br><span class="line">			int createFib(int n) &#123;</span><br><span class="line">				return (2 &gt; n) ? n: createFib(n-1) + createFib(n-2);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得当前项</span><br><span class="line">			int get() &#123;</span><br><span class="line">				int result = createFib(_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 获得前一项</span><br><span class="line">			int prev() &#123;</span><br><span class="line">				if (0 &lt; _size - 1) &#123;</span><br><span class="line">				int result = createFib(--_size - 1);</span><br><span class="line">				return result;</span><br><span class="line">				&#125;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		===========================================================</span><br><span class="line">		先使用了低效的fib生成函数, 且不储存在一个list中。</span><br><span class="line">		</span><br><span class="line">		以及查找函数</span><br><span class="line">		======================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			Fib fib(hi - lo);</span><br><span class="line">			while (lo &lt; hi) &#123;</span><br><span class="line">				while ((hi - lo) &lt; fib.get()) fib.prev();</span><br><span class="line">				int priv = lo + fib.get() - 1;</span><br><span class="line">				if      (e &lt; elem[priv]) hi = priv;</span><br><span class="line">				else if (elem[priv] &lt; e) lo = priv + 1;</span><br><span class="line">				else                     return priv;</span><br><span class="line">			&#125;</span><br><span class="line">		    return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		本质是选择轴点不同。</span><br><span class="line">	&gt;* 改进fib类</span><br><span class="line">		用动态规划求解fib数列中的某一项</span><br><span class="line">		================= source code ==============================</span><br><span class="line">		int createFib(int n) &#123;</span><br><span class="line">			int f = 0, g = 1;          // fib(0) = 0; fib(1) = 1;</span><br><span class="line">			if (n &lt; 2) &#123;int r = (n) ? g : f; return r;&#125;</span><br><span class="line">			while (0 &lt; n--) &#123;</span><br><span class="line">				g = g + f;</span><br><span class="line">				f = g - f;</span><br><span class="line">			&#125;</span><br><span class="line">			return g;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">3, 查找最优性</span><br><span class="line">	&gt;* 通用策略: </span><br><span class="line">		对任何A[0, n), 总是取得A[lambda*n]作为轴点, 0 &lt;= lambda &lt; 1</span><br><span class="line">		二分0.5, fibonacci对应lambda  = 0.6180339</span><br><span class="line">	&gt;* 递推式和微积分求极值</span><br><span class="line">		这个...</span><br><span class="line">		</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">4, 总结</span><br><span class="line">	这个算法花费很长时间去实现, 原因如下：</span><br><span class="line">		1, 面向对象不理解, 为什么定义fib类</span><br><span class="line">		2, 先选择了fast, not right</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中建史考试笔记]]></title>
      <url>/2018/01/18/temp-history/</url>
      <content type="html"><![CDATA[<h1 id="题目分配"><a href="#题目分配" class="headerlink" title="题目分配"></a>题目分配</h1><p>填空20*2 = 40<br>选择4<br>问答4<br>画图5</p>
<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-中国古代建筑的三种主要结构形式和特点-P4"><a href="#1-中国古代建筑的三种主要结构形式和特点-P4" class="headerlink" title="1, 中国古代建筑的三种主要结构形式和特点? P4"></a>1, 中国古代建筑的三种主要结构形式和特点? P4</h2><pre><code>1.穿斗式：用穿枋把竹子串联起来，形成一榀一榀的房架；檩条直接搁置在柱头
2.抬梁式：柱上搁置梁头，梁头上搁置檩条，梁上再用矮柱支撑起较短的梁
3.井平式：用天然原木或者经过加工成为方木，多角形的幕僚层叠成为房屋墙体，木头围成矩形木框，层层叠叠，木头承重。
</code></pre><h2 id="2-进行穿斗式与抬粱式木构架的优缺点比较-P5"><a href="#2-进行穿斗式与抬粱式木构架的优缺点比较-P5" class="headerlink" title="2, 进行穿斗式与抬粱式木构架的优缺点比较? P5"></a>2, 进行穿斗式与抬粱式木构架的优缺点比较? P5</h2><pre><code>穿斗式木构架用料小，整体性强，但柱子排列密，只有当室内空间尺度不大时才能使用。而抬梁式构架可采用跨度较大的梁，以减少柱子的数量，取得室内较大空间。
</code></pre><h2 id="3-斗拱是由哪些构件组成的？每种构件的作用如何？P6"><a href="#3-斗拱是由哪些构件组成的？每种构件的作用如何？P6" class="headerlink" title="3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6"></a>3, 斗拱是由哪些构件组成的？每种构件的作用如何？P6</h2><pre><code>a, 斗拱是由斗、拱、昂、翘、升组成的
b, 华拱：向外悬挑的短臂梁，是斗拱的主干部分；斗：拱与昂的支座垫块；昂：斜的悬臂梁，和华拱的作用相同（斗拱中斜置的构件，起杠杆作用。）(唐宋以前，斗拱的结构作用特别明显，布置疏朗，用料硕大，明清以后，斗拱的装饰作用加强，排列丛密，用料变小)
</code></pre><h2 id="4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19"><a href="#4-简述原始氏族社会有代表性的两种房屋遗址类型及实例-P17-19" class="headerlink" title="4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19"></a>4, 简述原始氏族社会有代表性的两种房屋遗址类型及实例 P17, 19</h2><pre><code>1, 类型：
    a, 干阑式
    b, 木骨泥墙
2, 实例
    a, 浙江余姚河姆渡遗址：距今六七千年，我国最早采用榫卯木结构房屋。长23m, 宽8米的木构架建筑遗址，体量相当大的干阑式建筑。
    b, 西安半坡遗址：山西西安半坡村遗址，南北300余米，东西200余米，分成居住区、墓葬区和制陶场三个区域。石器工具，建筑从半穴居进展到地面建筑。
</code></pre><h2 id="5-中国古代建筑史上的主要著作"><a href="#5-中国古代建筑史上的主要著作" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="6-《考工记》匠人营国一段原文及如何理解？"><a href="#6-《考工记》匠人营国一段原文及如何理解？" class="headerlink" title="6, 《考工记》匠人营国一段原文及如何理解？"></a>6, 《考工记》匠人营国一段原文及如何理解？</h2><pre><code>原文: 匠人营国,方九里,旁三门。国中九经九纬,经涂九轨。左祖右社,前朝后市,市朝一夫。(经涂九轨,环涂七轨,野涂五轨。环涂以为诸侯经涂,野涂以为都经涂。)
理解: 匠人（工匠）营（营造）国（都城），方九里（四方长宽都是九里），旁三门（左右两旁各开三道城门），国中（城内）九经九纬（南北向和东西向都是九条街道），经（南北的）涂（涂同途，道路）九轨（每条道路都可以容纳九辆马车并排行驶），左祖右舍（城中布局左边是宗庙，右边是民居），面朝后市（前部是朝庭，后部是集市），市朝一夫（集市对着大片的农田。一夫，指方百步的农田或百亩农田）
</code></pre><h2 id="7-《工程做法》的内容和评价？"><a href="#7-《工程做法》的内容和评价？" class="headerlink" title="7, 《工程做法》的内容和评价？"></a>7, 《工程做法》的内容和评价？</h2><pre><code>内容：列举了27种单体建筑的大木作法，并对斗栱、装修、石作、铜作、画作、雕銮作等做法和用工，用料都作了规定。
 评价：对加快设计与施工进度及掌握工料都有很大的帮助，而设计工作可集中精力于提高总体布置和装修大样的质量，是一份珍贵的研究清代建筑的档案资料。
</code></pre><h2 id="8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？"><a href="#8-《营造法式》的主要内容、著书人、历史背景、历史评价如何？" class="headerlink" title="8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？"></a>8, 《营造法式》的主要内容、著书人、历史背景、历史评价如何？</h2><pre><code>背景：两宋手工业与商业发达，使建筑水平达到了新的高度，但政治混乱，国力衰弱。《营造法式》是王安石变法的产物，目的是为了掌握设计与施工标准，节省国家财政开支，保证工程质量，《营造法式》是当时朝廷曾下令指定的各种财政，经济条例之一。
著书人：将作监 李诫
评价：是我国古代最完整的建筑技术书籍，书中资料主要来自历来工匠 想传经久可行之法，不仅对北宋末年京城的宫廷建筑有直接影响。南宋时，还因在苏州重刊而影响江南一带。
</code></pre><h2 id="9-北宋是城市结构由里坊制转向厢坊制的起点"><a href="#9-北宋是城市结构由里坊制转向厢坊制的起点" class="headerlink" title="9, 北宋是城市结构由里坊制转向厢坊制的起点"></a>9, 北宋是城市结构由里坊制转向厢坊制的起点</h2><pre><code>北宋城市结构和布局起了根本变化。
唐以前的封建都城实行夜禁和里坊制度，以保证统治者的安全。但是日益发展的手工业和商业要求突破这种封建统治的制度。
到了宋朝，都城汴梁也无法再采取里坊制度和夜禁，虽然保留“坊”名称，但实际内容已改变。
</code></pre><h2 id="10-宋的基本模数制度：材份制"><a href="#10-宋的基本模数制度：材份制" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面, “材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折"><a href="#11-宋式殿堂的特点及屋面举折" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"><a href="#12-我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？" class="headerlink" title="12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？"></a>12, 我国南北朝时期比较著名的石窟？石窑寺的三种类型都是什么？</h2><pre><code>云冈石窟, 龙门石窟
石窟可以分为三种：一是塔院型，二是佛殿型，三是僧院型，此外还有一种小窟，分布在一、二类窟的周围，也属打坐用的禅窟。
</code></pre><h2 id="13-唐代建筑的主要特点是什么？"><a href="#13-唐代建筑的主要特点是什么？" class="headerlink" title="13, 唐代建筑的主要特点是什么？"></a>13, 唐代建筑的主要特点是什么？</h2><pre><code>1, 规模宏大，规划严整
2, 建筑群 处理愈加成熟
3, 木建筑单体技术成熟，解决了大体量的技术问题，已经定型化
4, 设计与施工水平提高
5, 砖石建筑发展
6, 建筑艺术真实成熟
</code></pre><h2 id="14-元代盛行的减柱法是什么意思？举例说明"><a href="#14-元代盛行的减柱法是什么意思？举例说明" class="headerlink" title="14, 元代盛行的减柱法是什么意思？举例说明"></a>14, 元代盛行的减柱法是什么意思？举例说明</h2><pre><code>减柱法: 在祠庙殿宇中抽去若干柱子。构件简化: 省略斗拱，用直梁、直柱。
元代一般寺庙建筑加工粗糙，用料草率，都反映了社会经济凋零和木材短缺而不得不采用了种种节约措施。
举例：山西洪洞 广胜寺, 山西永济 永乐宫。
</code></pre><h2 id="15-进行明代建筑木构架与唐宋风格比较"><a href="#15-进行明代建筑木构架与唐宋风格比较" class="headerlink" title="15, 进行明代建筑木构架与唐宋风格比较"></a>15, 进行明代建筑木构架与唐宋风格比较</h2><pre><code>1, 唐木建筑解决了大面积，大体量的技术问题，用材制度的出现，反映了施工管理水平进步，艺术加工真实成熟。斗拱宏大，出檐深远，宏大豪放，屋顶舒展，斗拱受力性质直接表现建筑美。
2, 宋代木架建筑采用了古典的模数制。《营造法式》成书。
3, 明代斗拱的结构作用减少，梁柱构架的整体性加强，构件卷杀简化。
4, 唐代多采用板行与直椂窗，宋代则采用格子门，格子窗，明代基本沿用。
</code></pre><h2 id="16-明清北京城四圈城的名称是什么？"><a href="#16-明清北京城四圈城的名称是什么？" class="headerlink" title="16, 明清北京城四圈城的名称是什么？"></a>16, 明清北京城四圈城的名称是什么？</h2><pre><code>外城, 永定门
内城, 正阳门
皇城, 天安门
紫禁城, 午门
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就"><a href="#17-简述北京故宫的建筑艺术成就" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><h2 id="18-天坛总体布局及祭祀建筑特点"><a href="#18-天坛总体布局及祭祀建筑特点" class="headerlink" title="18, 天坛总体布局及祭祀建筑特点"></a>18, 天坛总体布局及祭祀建筑特点</h2><pre><code>设计特点:
1, 反复用圆, 天圆地方，(强调圆形的重复表达强调完美和谐天的概念)
2, 环境处理
    a, 建筑只占1/20, 融于绿色之中
    b, 轴线上的建筑位于高地, 树比路高2.5m, 超然于林海之上, 与天相近
3, 运用数字和色彩的象征
</code></pre><h2 id="19-佛塔的主要类型是什么？"><a href="#19-佛塔的主要类型是什么？" class="headerlink" title="19, 佛塔的主要类型是什么？"></a>19, 佛塔的主要类型是什么？</h2><pre><code>中国古代佛塔类型有：楼阁式塔、单层塔、密檐塔、喇嘛塔和金刚宝座塔
1, 楼阁式塔:山西应县 佛宫寺 释迦塔，我国现存唯一的木塔,
2, 单层塔，山东济南 隋代 神通寺 四门塔,
3, 密檐塔，河南登封 北魏 嵩岳寺塔，我国现存最早的砖塔,
4, 金刚宝座塔，北京明代 正觉寺塔, 源于印度,
5, 喇嘛塔，北京元代 妙应寺 白塔, 源于印度。
</code></pre><h2 id="20-简述平板枋（普拍枋）的位置和作用"><a href="#20-简述平板枋（普拍枋）的位置和作用" class="headerlink" title="20, 简述平板枋（普拍枋）的位置和作用"></a>20, 简述平板枋（普拍枋）的位置和作用</h2><pre><code>平板枋置于阑额之上, 可以承受斗拱。
</code></pre><h2 id="21-屋顶做法：收山、推山"><a href="#21-屋顶做法：收山、推山" class="headerlink" title="21, 屋顶做法：收山、推山"></a>21, 屋顶做法：收山、推山</h2><pre><code>推山：是庑殿建筑处理屋顶的一种特殊手法
收山：是歇山屋顶两侧 山花 自 山面 沿 柱中线 向内收进的做法。其目的是使屋顶不过于庞大，但引起了结构上的某些变化（增加了顺梁或扒梁和采步金梁架等）。
</code></pre><h2 id="22-清式彩画常用的三大类是什么？"><a href="#22-清式彩画常用的三大类是什么？" class="headerlink" title="22, 清式彩画常用的三大类是什么？"></a>22, 清式彩画常用的三大类是什么？</h2><pre><code>和玺, 旋子, 苏式
</code></pre><h2 id="23-宋式柱网布局中分心槽是什么意思？"><a href="#23-宋式柱网布局中分心槽是什么意思？" class="headerlink" title="23, 宋式柱网布局中分心槽是什么意思？"></a>23, 宋式柱网布局中分心槽是什么意思？</h2><pre><code>以一列中柱以及柱上斗拱将殿身分成前后两个相同的空间。
</code></pre><h2 id="24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？"><a href="#24-应县木塔外观几层，内部结构几层？平面柱网形式是什么？" class="headerlink" title="24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？"></a>24, 应县木塔外观几层，内部结构几层？平面柱网形式是什么？</h2><pre><code>外5, 内9;
金厢斗底槽。
</code></pre><h1 id="绘制简图题"><a href="#绘制简图题" class="headerlink" title="绘制简图题"></a>绘制简图题</h1><p>嵩岳寺塔平面和立面 P181 考<br>九开间重檐歇山屋顶宫殿的正立面、屋顶平面和轴测图<br>佛光寺大殿平立剖面 P156<br>晋祠圣母殿平立剖面<br>独乐寺观音阁剖面 P162<br>应县木塔平面、剖面 P176 考<br>北京天坛总平面图 P131<br>清式抬梁式七架无廊结构示意图 P297<br>宋式进深八椽屋的屋面举折做法示意图 P285</p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="5-中国古代建筑史上的主要著作-1"><a href="#5-中国古代建筑史上的主要著作-1" class="headerlink" title="5, 中国古代建筑史上的主要著作"></a>5, 中国古代建筑史上的主要著作</h2><pre><code>春秋时期《考工记》五代《木经》宋朝《营造法式》元朝《梓人遗制》明代《鲁班经》《园冶》清代《工程做法》
</code></pre><h2 id="10-宋的基本模数制度：材份制-1"><a href="#10-宋的基本模数制度：材份制-1" class="headerlink" title="10, 宋的基本模数制度：材份制"></a>10, 宋的基本模数制度：材份制</h2><pre><code>1, 以斗栱中栱的截面——“材”作为模数的基本单位。“材”进一步细分为“分”.
2, 材分制作用
    a, 统一建筑标准，建立设计规范，把握比例尺度,
    b, 简化设计工作,
    c, 方便工料预算，便于构件预制，加快施工进度。
</code></pre><h2 id="11-宋式殿堂的特点及屋面举折-1"><a href="#11-宋式殿堂的特点及屋面举折-1" class="headerlink" title="11, 宋式殿堂的特点及屋面举折"></a>11, 宋式殿堂的特点及屋面举折</h2><pre><code>1, 殿堂特点
    a, 清雅逸之风采, 尤其是屋顶形象, 轻盈。
    b, 体量较唐朝时较小, 细部装饰增加, 注重彩画雕刻, 总体绚烂柔美。
2, 屋面举折
    a, 举折是我国传统建筑确定屋面曲度的一种方法
    b, 利于屋面排水和檐下采光
</code></pre><h2 id="17-简述北京故宫的建筑艺术成就-1"><a href="#17-简述北京故宫的建筑艺术成就-1" class="headerlink" title="17, 简述北京故宫的建筑艺术成就"></a>17, 简述北京故宫的建筑艺术成就</h2><pre><code>1, 是世界上规模最大，保存最完好的古代皇宫建筑群，是中国古代建筑最高水平的体现。(不确定)
2, 是中国封建社会末期的代表性建筑之一，在利用建筑群来烘托皇帝的崇高与神圣方面，达到了登峰造极的地步。一宫之成，役作遍于全国。（自己从书上找的，尚不确定）
</code></pre><hr>
<h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><h2 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h2><p>1, 汉代木构建筑渐趋成熟，根据当时的画像砖、画像石、明器等间接资料来看，后世常见的<code>抬梁式</code>和<code>穿斗式</code>两种主要木结构已经形成。<br>2, 北宋初年浙东木匠<code>喻皓</code>著有《<code>木经</code>》一书，可惜已经失传，现存沈括《梦溪笔谈》摘录了原书若干片段。<br>3, 北宋末年政府颁布的《营造法式》中规定，把<code>材</code>作为造屋的尺度标准，即将木构架建筑的用料尺寸分成<code>八</code> 等，按照屋宇的大小主次量屋用材。<br>4, 清式彩画分为<code>和玺彩画</code>、<code>旋子彩画</code>、<code>苏式彩画</code><br>5, 建筑屋顶中，为了防止屋脊显得短小，常常把庑殿顶的正脊向两侧<code>推出</code>，从而使四条垂脊形成空间曲线，这种做法称为<code>推山</code> 。<br>6, 应县木塔外观<code>5</code> 层，内部结构层为<code>9层</code>木塔, 有内外两圈柱网，各层通过柱、梁、斗拱嵌套在一起而形成套筒结构。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>1, 隋大兴城的规划设计者为：（ A ）<br>    <code>A宇文凯</code> B郭守敬 C雷发达 D蒯祥<br>2, 北京故宫天安门前院落的形状为：（ D）<br>    A凹字形 B工字型 C“L型” <code>D“T字形”</code><br>3, 清代工部工程做法中规定大木建筑斗口分为几等：（  C  ）<br>    A八等 B九等 <code>C十一等</code> D十三等<br>4, “斗拱宏大，出檐深远”形容的是哪个朝代木构殿堂的风格：（  A  ）<br>    <code>A唐代</code> B宋代 C明代 D清代</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.006]]></title>
      <url>/2018/01/16/cpp/cpp-notes-0006/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 局部变量的销毁顺序</span><br><span class="line">	================= source code ===============================</span><br><span class="line">	void f(int i) &#123;</span><br><span class="line">		Table aa(1);</span><br><span class="line">		Table bb(2);</span><br><span class="line">		if (i &gt; 0) &#123;</span><br><span class="line">			Table cc(3);</span><br><span class="line">		&#125;</span><br><span class="line">		Table dd(4);</span><br><span class="line">	&#125;</span><br><span class="line">	-------------- ./a.out ----------------</span><br><span class="line">	in Table() sz = 1</span><br><span class="line">	in Table() sz = 2</span><br><span class="line">	in Table() sz = 3</span><br><span class="line">	in ~Table() sz = 3        // cc在if退出时析构, 在dd构造之前</span><br><span class="line">	in Table() sz = 4</span><br><span class="line">	in ~Table() sz = 4        // a, b, c构造; c, b, a析构</span><br><span class="line">	in ~Table() sz = 2</span><br><span class="line">	in ~Table() sz = 1</span><br><span class="line">	=============================================================</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, 构造函数复制</span><br><span class="line"></span><br><span class="line">	&gt;* 直接复制</span><br><span class="line">		======= source code ========</span><br><span class="line">		void h() &#123;</span><br><span class="line">			Table t1;</span><br><span class="line">			// Table t2 = t1;    // ERROR: 复制初始化</span><br><span class="line">			Table t3;</span><br><span class="line">			</span><br><span class="line">			// t3 = t2;          // ERROR: 复制赋值</span><br><span class="line">		&#125;</span><br><span class="line">		==============================</span><br><span class="line">		</span><br><span class="line">		t1所创建而分配的数组, 将同时分配给t1, t2, t3, 被删除3次。</span><br><span class="line">		所导致结果是无意义的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&gt;* 清楚定义复制构造函数</span><br><span class="line">		================ source code =======================</span><br><span class="line">		Table::Table(const Table&amp; t) &#123;</span><br><span class="line">			p = new Name[sz = t.sz];</span><br><span class="line">			for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">				p[i] = t.p[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Table&amp; Table::operator=(const Table&amp; t) &#123;</span><br><span class="line">			if (this != &amp;t) &#123;         // 防止自复制</span><br><span class="line">				delete[] p;</span><br><span class="line">				p = new Name[sz = t.sz];</span><br><span class="line">				for (int i = 0; i &lt; sz; i++) &#123;p[i] = t.p[i];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return *this;</span><br><span class="line">		&#125;</span><br><span class="line">		void f() &#123;</span><br><span class="line">			Table t1(2);</span><br><span class="line">			Table t2 = t1;</span><br><span class="line">			Table t3(t1);</span><br><span class="line">		&#125;</span><br><span class="line">		----------- ./a.out --------------------</span><br><span class="line">		in Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		in ~Table() sz = 2</span><br><span class="line">		===================================================</span><br><span class="line">	</span><br><span class="line">	&gt;* 原因</span><br><span class="line">		在复制构造函数中, 对之前未初始化的储存区域初始化, 而不会造成储存丢失的情况。这在C++中用new和delete我不清楚在C和其他语言中如何做到, delete有何劣势等等。</span><br><span class="line">		</span><br><span class="line">		而复制赋值符要对结构本身有些优化, 如： 防止自赋值, 删除那些老元素, 初始化, 复制那些新元素, 通常每个非静态成员都必须复制, 可以通过异常去报告复制中的出错。</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">		</span><br><span class="line">3, 类和数组的关系</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		为什么能对指针类型使用索引?</span><br><span class="line">	</span><br><span class="line">	&gt;* 测试</span><br><span class="line">		========= source code =====================</span><br><span class="line">		class Name &#123;</span><br><span class="line">			const char* s;</span><br><span class="line">		&#125;;</span><br><span class="line">	</span><br><span class="line">		void test_array() &#123;</span><br><span class="line">			Name* t;</span><br><span class="line">			t[0];          // t是指针也是数组</span><br><span class="line">			</span><br><span class="line">			int i = 5;</span><br><span class="line">			int* ptr_i = &amp;i;</span><br><span class="line">			int r = ptr_i[0];     // ptr_i是指针也是数组</span><br><span class="line">			std::cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; std::endl;    // prints r = 5</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 某一类型的指针, 也同样是指向某一类型的数组。</span><br><span class="line">		到现在为止, 可以把指针理解成一个表。 比如 int i, j, k; 三个整型。如何用一个变量将他们表示? </span><br><span class="line">		========= source code ===========</span><br><span class="line">		int a = 2, b = 3, c = 4;</span><br><span class="line">		int table_v[] = &#123;a, b, c&#125;;</span><br><span class="line">		std::cout &lt;&lt; *table_v &lt;&lt; std::endl;</span><br><span class="line">		-------./a.out---------------------</span><br><span class="line">		2</span><br><span class="line">		=================================</span><br></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于休息]]></title>
      <url>/2018/01/15/essay/about-rest/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">人的一生有多少时间是在休息中度过的？</span><br><span class="line"></span><br><span class="line">时间流淌的太快, 于是乎进入了考试周, 加之这学期没去上过几门课，至于我竟然还在开学前的状态中。</span><br><span class="line">J课一学期只看了一天的题型, 便匆匆考过。接下来还有4门, P课和H课的知识点较多, 时间也紧张。</span><br><span class="line">早上考完J课, 天气正好, 和久病的Y去打网球。本想着回来便看书, 但是整个人很困, 又不去睡觉休息。</span><br><span class="line">结果浏览网页中不知觉的流逝了一个下午, 等到翻开题目, 便开始犯困, 从5点半睡到8点半。</span><br><span class="line">一没看数据结构和C++, 二没把复习的想法实现。</span><br><span class="line"></span><br><span class="line">回过头来, 这件事情要是这样, </span><br><span class="line">回寝室, 洗澡, 午觉, H画图, 摘考点, 吃晚饭, 代码, 回信息。也许会好很多。</span><br><span class="line">我不知疲倦的想要学点什么, 而忽视了人是会疲倦的本能。</span><br><span class="line">因此, 将生活与工作的接口分离是有必要的。</span><br><span class="line"></span><br><span class="line">先生活后工作。有些道理看似简单, 成为一种践行的观念对我来说还有点距离。</span><br><span class="line">但我希望缓慢能做到。</span><br><span class="line"></span><br><span class="line">一天24小时, 睡8小时的话, 有1/3在睡眠中度过。</span><br><span class="line">剩下的时间对我来说是这样算的: 去大学里上水课像是一种休息, 但对我来说却无异于折磨, 老师在敷衍讲课, 学生在涣散玩手机, 所以它不是; </span><br><span class="line">打网球是种休息, 在传统的人比如我妈看来是在受罪; </span><br><span class="line">书和电影是种休息, 对那些更爱享受物质生活的人来说却很疲劳; </span><br><span class="line">亲密朋友约会吃饭是种休息, 也许我还没有到应酬这个词所描述的阶段; 跟恋人聊天约会是休息, 在温柔乡里让大脑重启; </span><br><span class="line">...等等很多。</span><br><span class="line">我这个人有个特点就是, 对大家不爱做的事情, 乐此不疲, 对大家很热衷做的, 甚至是日常的事, 我却批判和提不起劲来。</span><br><span class="line">这个也许是天性, 也许是习惯, 但总归已经形成, 已经形成的事情要去适应它, 不去用力过猛的扭转它。</span><br><span class="line"></span><br><span class="line">休息是一种智慧。 </span><br><span class="line">记得那回我迫切的想研究出offset空间域的算法, 但深陷在数据前后的相连性, </span><br><span class="line">无法去除循环的操作中, 连想三个晚上仍旧没想出, 最终还是牙龈淤血, 神经衰弱。</span><br><span class="line">而那回, 当我顶着牙痛在小组内做事情的时候, S提醒我, 希特勒初期对德国的国力复兴是有很大贡献的,</span><br><span class="line">但是他风光时身边的军官没能制止他, 让他去休息, 他也没能有这种知乎, 结果就是一场浩劫, 我们正享受着余波。</span><br><span class="line"></span><br><span class="line">对休息也需要重构。</span><br><span class="line">当结构不对, 走错方向, 需要重构。不是因为走错方向的问题, 迷失本身是美好的, 但在一定结构下的涌现才是这种迷失的前提, 而不是失控。</span><br><span class="line"></span><br><span class="line">先生活后工作。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.005]]></title>
      <url>/2018/01/13/cpp/cpp-notes-0005/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, protected能否被实例对象访问</span><br><span class="line"></span><br><span class="line">	&gt;* 发现问题	</span><br><span class="line">		重新实现Vector中, 要对ADT的access进行区别。</span><br><span class="line">		protected能否被实例对象访问?</span><br><span class="line">		protected能否被继承类访问?</span><br><span class="line">	&gt;* 尝试</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		class Base &#123;</span><br><span class="line">		private:</span><br><span class="line">			int i = 0;</span><br><span class="line">			void f_priv() &#123;std::cout &lt;&lt; &quot;calling f_priv() in private&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		protected:</span><br><span class="line">			void f_prot() &#123;std::cout &lt;&lt; &quot;calling f_prot() in protected&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		public:</span><br><span class="line">			void f() &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;calling f() in public&quot; &lt;&lt; std::endl;</span><br><span class="line">				f_prot();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		class Derived : Base &#123;</span><br><span class="line">		public:</span><br><span class="line">			void call_f_prot() &#123;f_prot();&#125;</span><br><span class="line">			// void call_f_priv() &#123;f_priv();&#125;    // private不能被继承类直接访问</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		int main() &#123;</span><br><span class="line">			Base b;</span><br><span class="line">			Derived d;</span><br><span class="line">			// b.f_prot();      // protected成员不能被实例对象直接访问</span><br><span class="line">			d.call_f_prot();    // 通过继承类的public成员, 访问基类的protected</span><br><span class="line">			// d.call_f_priv();</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 特点</span><br><span class="line">		protected不会被实例访问, 会被继承类在类中进行访问。</span><br><span class="line">		</span><br><span class="line">		希望用户不能访问到protected中的成员, 但继承类能够访问到。</span><br><span class="line">		而private让用户和继承类都不能访问到, 只有友元能访问到。</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">2, for循环语句的简单写法</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">	for语句的三个表达式如何写?</span><br><span class="line">	Vector(int c = DEAFAULT_CAPACITY, int s = 0, T v = 0)</span><br><span class="line">	&#123;_elem = new T[_capacity = c];</span><br><span class="line">		for (_size = 0; _size &lt; s; _elem[size++] = v)&#125;     // 默认</span><br><span class="line">		</span><br><span class="line">	&gt;* 利用for的参数</span><br><span class="line">		for ( declaration-or-expression(optional) ; </span><br><span class="line">			declaration-or-expression(optional) ; </span><br><span class="line">			expression(optional) )</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		const int s = 8;</span><br><span class="line">		int size = 0;</span><br><span class="line">		int elem[s] = &#123;&#125;;</span><br><span class="line">		/*</span><br><span class="line">		for (size = 0; size &lt; s; size++) &#123;</span><br><span class="line">			elem[size] = 2;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		// 第三个参数, 递增size的同时, 给修改elem</span><br><span class="line">		for (size = 0; size &lt; s; elem[size++] = 2) &#123;&#125;</span><br><span class="line">		// 第三个参数, 修改i的同时, 打印elem[i]对应的元素</span><br><span class="line">		for (int i = 0; i &lt; size; std::cout &lt;&lt; elem[i++] &lt;&lt; std::endl) &#123;&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	&gt;* 反思</span><br><span class="line">		某变量会让循环条件false, 且该变量又是语句中的某一要素时候，一举两得。</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">3, T const&amp;, const T&amp;, T&amp; const, T const*, const T*, T* const 辨析</span><br><span class="line">	</span><br><span class="line">	&gt;* 发现问题</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		Vector(T* const A, Rank lo, Rank hi)           // 数组区间复制</span><br><span class="line">		Vector(Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi)   // 向量区间复制</span><br><span class="line">		============================================================</span><br><span class="line">		对上述代码中的 Vector&lt;T&gt; const&amp; V不理解, 为什么const&amp; 跟在type之后? 它是否表达常量引用?</span><br><span class="line"></span><br><span class="line">	&gt;* 常量引用</span><br><span class="line">		type const&amp;, type&amp; const之间是什么区别 ?</span><br><span class="line">		先回答: 没区别。 但偏向写成前者, 能直接看出这是一个引用类型, 且为常量引用.</span><br><span class="line">		</span><br><span class="line">		让测试代码跑跑。</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		int f() &#123;</span><br><span class="line">		int a = 0, b = 1;</span><br><span class="line">		const int ca = 0, cb = 1;</span><br><span class="line">		</span><br><span class="line">		int&amp; ref_a = a;      // ref_a是整数a的引用类型</span><br><span class="line">		int* ptr_a = &amp;a;     // ptr_a是指向整数a的指针</span><br><span class="line">		const int* ptr_ca = &amp;ca;           // ptr_ca是指向常量整型的指针</span><br><span class="line">		const int* const cptr_ca = &amp;ca;    // cptr_ca是指向常量整型的常量指针</span><br><span class="line">		int const&amp; cref_a = a;             // cref_a是对整型的常量引用?</span><br><span class="line">		const int&amp; cref_a_1 = ca;          // cref_a_1是对整型常量引用?</span><br><span class="line">		// const int&amp; const cref_a_2 = ca;    // 对整型常量的常量引用?</span><br><span class="line">		// const int const&amp; cref_a_3 = ca;    // 还是这样? 对整型常量的常量引用?</span><br><span class="line">		// 引用不能duplicate const</span><br><span class="line">		f1(cref_a);       // 将cref_a传入f1(), cref_a类型为 int const&amp;匹配</span><br><span class="line">		// cref_a++;      // read-only    // 两者都是常量引用</span><br><span class="line">		// cref_a_1++;    // read-only</span><br><span class="line">		</span><br><span class="line">		// 引用指针</span><br><span class="line">		int* const&amp; cref_ptra = ptr_a;            // 对整型指针的常量引用</span><br><span class="line">		// int const&amp; cref_ptra_1 = ptr_a;        // 错误: 引用对象类型int*</span><br><span class="line">		const int* const&amp; cref_ptrca = ptr_ca;    // 对指向常量指针的常量引用</span><br><span class="line">		// int* const&amp; cref_ptrca_1 = ptr_ca;     // 错误: 引用对象类型const int*</span><br><span class="line">		const int* const&amp; cref_cptrca = cptr_ca;</span><br><span class="line">		</span><br><span class="line">		(*cref_ptra)+=1;          // cref_ptra整型指针的常量引用, 改变指向整型</span><br><span class="line">		// (*cref_cptrca)+=1;     // ERROR: 无法通过引用, 改变指向常量的常量指针指向的整数(常量)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void f1(int const&amp; ic) &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling f1()...\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		</span><br><span class="line">		常量引用的写法. 所引用的对象类型为type</span><br><span class="line">		(type) const&amp; ref_t;</span><br><span class="line">		// const&amp;写在右边是因为侧重于表明其常量指针</span><br><span class="line">		</span><br><span class="line">		另外, 这一type可以是int, const int, int*, const int*等等</span><br><span class="line">		</span><br><span class="line">	&gt;* 常量指针</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int a = 0, b = 0, c = 0, d = 0;</span><br><span class="line">		int* p_a = &amp;a;                 // 指向int的指针</span><br><span class="line">		// 指针地址可变, 指向的a可变</span><br><span class="line">		(*p_a)++; p_a = &amp;b;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_a = &quot; &lt;&lt; *p_a &lt;&lt; &quot;, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">		const int* p_b = &amp;b;          // 指向const int的指针</span><br><span class="line">		// 指针地址可变, 指向的元素转换成const不可变</span><br><span class="line">		// (*p_b)++;</span><br><span class="line">		p_b = &amp;c;</span><br><span class="line">		std::cout &lt;&lt; &quot;*p_b = &quot; &lt;&lt; *p_b &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">		int* const cp_c = &amp;c;          // 指向int的const指针</span><br><span class="line">		// 指针地址不可变, 指向的元素可以变</span><br><span class="line">		(*cp_c)++;</span><br><span class="line">		// cp_c = &amp;d;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_c = &quot; &lt;&lt; *cp_c &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">		// int const* cp_c1 = &amp;c;         // 指向const int的指针, 仍采用上种方法</span><br><span class="line">		const int* const cp_cd = &amp;d;   // 指向const int的const指针</span><br><span class="line">		// 指针地址不可变, 指向值不可变</span><br><span class="line">		// (*cp_cd)++;</span><br><span class="line">		// cp_cd = &amp;a;</span><br><span class="line">		std::cout &lt;&lt; &quot;*cp_cd = &quot; &lt;&lt; *cp_cd &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">		------------------------ ./a.out ---------------------------</span><br><span class="line">		*p_a = 0, a = 1</span><br><span class="line">		*p_b = 0, b = 0</span><br><span class="line">		*cp_c = 1, c = 1</span><br><span class="line">		*cp_cd = 0, d = 0</span><br><span class="line">		============================================================</span><br><span class="line">		T*               = &amp;a;      // 指针</span><br><span class="line">		const T*         = &amp;ca;     // 指向常量的指针</span><br><span class="line">		T* const         = &amp;a;      // 常量指针, 指针地址不可变</span><br><span class="line">		const T* const   = &amp;ca;     // 指向常量的常量指针, 指向值和指针地址都不可变</span><br><span class="line">		</span><br><span class="line">	&gt;* const_cast&lt;type&gt;();</span><br><span class="line">		=======</span><br><span class="line">		int b = 0;</span><br><span class="line">		const int* p_b= &amp;b;</span><br><span class="line">		*(const_cast&lt;int*&gt;(p_b))+=1;   // 这种方式可以让b递增1</span><br><span class="line">		// (*p_b)++                    // const_cast只是一个临时操作</span><br><span class="line">		==========</span><br><span class="line">		一方面可以去掉const的性质, 另外一方面又是临时的, 可以确保安全。</span><br><span class="line">		我想这可能会用在, 绝大多数是const, 只有极少情况才会变的数据类型中。</span><br><span class="line">	</span><br><span class="line">	&gt;*  最初的辨析</span><br><span class="line">		T const&amp; : 引用, T类型的常量引用, 该引用不会被修改</span><br><span class="line">		const T&amp; : 同上, 只是不同写法。现在偏向用上面那种</span><br><span class="line">		T&amp; const : 非法 </span><br><span class="line">		T const* : 指针, 指向常量T的指针, const T*相同 </span><br><span class="line">		const T* : 指针, 指向常量T的指针, 我偏向用这种</span><br><span class="line">		T* const : 指针, 指向T的常量指针</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> const </tag>
            
            <tag> 常量指针 </tag>
            
            <tag> 常量引用 </tag>
            
            <tag> protected </tag>
            
            <tag> for </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[楚门的世界, 写于观后和离前]]></title>
      <url>/2018/01/13/movies/the-Truman-show-critic/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">凌晨睡不着看了一部电影叫&lt;&lt;看楚门的世界&gt;&gt;。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1, 疑惑</span><br><span class="line">	1) 戏中戏外的时间不同步</span><br><span class="line">		戏内的楚门经历挫折, 徘徊折磨的这段时间大概有一个星期之多。而TV前的观众身处环境无太多变化。</span><br><span class="line">		是否意味着，在这样一个世界时间也是可以改变的可能。</span><br><span class="line">		大刘在三体中， 对宇宙历史时间的描述, 地球人出现了几次冬眠后被唤醒, 却被告知时间减少。</span><br><span class="line">		在危机纪年, 世界变化很大, 中国成为超级大国。这就好像不难解释时间消失的问题....</span><br><span class="line">	2) 关于梦醒</span><br><span class="line">		长大生活在导演下, 歪书架, 红旗下, 以及梦的那些人, </span><br><span class="line">		梦何时醒? 梦醒需要多久? 梦醒的痛苦？</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">2, 观点</span><br><span class="line">	1) 戏里戏外都在被安慰</span><br><span class="line">		戏里的楚门被creator安排在一个normal的世界里生活。</span><br><span class="line">		有趣的是, creator认为现世是肮脏病态的, 楚门生活的Seahaven应该是世界应该有的样子。</span><br><span class="line">		而给了楚门Fiji梦的女孩却认为，正常的人不应该是囚犯、演员。</span><br><span class="line">		他们都想用自己认为的方式安慰戏中的楚门。</span><br><span class="line">		</span><br><span class="line">		戏外在Fan Club聚众，昏沉同性恋夫妇, 洗澡油腻中年男人, 说出真相期待真爱的女主, 小镇警察, 导演以及制片人，</span><br><span class="line">		通过秀来排解对现实的不满，不需要过多思考就安慰。</span><br><span class="line">		创造, 沉迷, 打破, 遵守。屏幕前的我何尝不是呢？</span><br><span class="line"></span><br><span class="line">	2) 构成生活看似真实性的一些元素</span><br><span class="line">		说早安的幸福一家人。养了一条狗倒垃圾的邻居。打招呼的双胞胎路人。办公室的同事。</span><br><span class="line">		交通, island boat, bus, car。给你插广告, 想要小孩的妻子。给你插广告, 拎着啤酒, 扯着道理，回忆往昔的朋友。</span><br><span class="line">		独自吹风的海滩月光。童年回忆。母亲翻出的老旧照片。恋人的吻和留下的外套。工作日早晨的忙碌。</span><br><span class="line">		神的安排。</span><br><span class="line"></span><br><span class="line">	3) 二十世纪末的美国科技和科幻能力</span><br><span class="line">		98年的片子以电视为主要媒介, 还出现电幕, 摄像头等设备。</span><br><span class="line">		制片场中，用大型计算机, 内部交流用的设备，乌托邦主义者的形象，以及内部的装饰比较科幻, 让人不由想到1984中的监控场景。</span><br><span class="line">		楚门的生活中汽车, 个人计算机, 不需接线员的电话, 录音机等都已经出现。</span><br><span class="line">		当时都是不错的技术, 我感叹技术革新之快, 和当下环境中那些对技术的浮躁和推崇, 还有有些怀旧, 人到底需要多少的资源和科技呢?</span><br><span class="line"></span><br><span class="line">	4) 如果对现有的生活不再眷恋</span><br><span class="line">		除草。漂泊。割舍。接受。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 随想 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-D2]]></title>
      <url>/2018/01/12/dsacpp/02-D2/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d2 有序向量: 二分查找</span><br><span class="line"></span><br><span class="line">	Vector::find(e, lo, hi);</span><br><span class="line">	Vector::search(e, lo, hi);</span><br><span class="line"></span><br><span class="line">	操作参数和接口语义类似。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 统一接口</span><br><span class="line">	&gt;* ADT接口</span><br><span class="line">	======================== source code ==========================</span><br><span class="line">	// ADT接口</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::srand(std::time(0));</span><br><span class="line">		return (std::rand() % 2) ?</span><br><span class="line">			binSearch(_elem, e, lo, hi)     // 二分查找算法</span><br><span class="line">			: fibSearch(_elem, e, lo, hi);  // fibonacci查找算法</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	Rank Vector&lt;T&gt;::fibSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">		std::cout &lt;&lt; &quot;calling fibSearch... &quot; &lt;&lt; std::endl;</span><br><span class="line">		return lo;</span><br><span class="line">	&#125;</span><br><span class="line">	================================================================</span><br><span class="line">	可以设计不同的算法, 根据数据的性质进算法的选择。</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 语义约定</span><br><span class="line"></span><br><span class="line">	约点语义的好处就是, 能够更好的和其他代码配合。</span><br><span class="line">	&gt;* 优点: </span><br><span class="line">		维护自身 V.insert(1 + V.search(e), e)</span><br><span class="line">			即便是失败, 也给出插入新元素的位置。</span><br><span class="line">			若允许重复元素, 则每组也按照其插入的次序排序。</span><br><span class="line">	</span><br><span class="line">	&gt;* 约点:</span><br><span class="line">		有序V[lo, hi), 不大于e的最后元素秩</span><br><span class="line">		-00 &lt; e &lt; V[lo], 返回 lo - 1 (左侧哨兵)</span><br><span class="line">		V[hi] &lt; e &lt; +00, 返回 hi - 1 (末元素, 右哨兵左邻)</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 原理</span><br><span class="line"></span><br><span class="line">	&gt;* 减而治之</span><br><span class="line">		待查找区间分成三部分</span><br><span class="line">		S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)       // S[mi]轴点</span><br><span class="line">	</span><br><span class="line">	&gt;* 三种比较情况</span><br><span class="line">		e &lt; x: 左</span><br><span class="line">		x &lt; e: 右</span><br><span class="line">		e = x: 命中             // 多个解?</span><br><span class="line">	</span><br><span class="line">	&gt;* 二分(折半)策略</span><br><span class="line">		每经过至多两次比较, 或命中, 或将规模缩减一半</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实现</span><br><span class="line"></span><br><span class="line">	&gt;* 我的尝试</span><br><span class="line">		======= source code ======================================</span><br><span class="line">		// 二分查找: 版本A</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			std::cout &lt;&lt; &quot;calling binSearch.... &quot; &lt;&lt; std::endl;</span><br><span class="line">			if (lo &lt; hi) &#123;   // 区间不存在, 没找到e</span><br><span class="line">				Rank mi = (lo + hi) &gt;&gt; 1;    // 中点秩</span><br><span class="line">				if (elem[mi] == e) return mi;     // 命中, 递归基</span><br><span class="line">				if (e &lt; elem[mi]) &#123;     // 在mid左侧</span><br><span class="line">					return (binSearch(elem, e, lo, mi));</span><br><span class="line">				&#125; else &#123; return binSearch(elem, e, mi + 1, hi);&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		==========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 给出的版本</span><br><span class="line">		==================== source code ========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		Rank Vector&lt;T&gt;::binSearch(T* elem, T const&amp; e, Rank lo, Rank hi) const &#123;</span><br><span class="line">			while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">				Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">				if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">				else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">				else                   return mi;    // 在mi命中</span><br><span class="line">			&#125;</span><br><span class="line">		return -1;   // 查找失败</span><br><span class="line">		&#125;</span><br><span class="line">		=========================================================</span><br><span class="line">		</span><br><span class="line">	&gt;* 分析</span><br><span class="line">		1, 将递归变成while loop, 内部对hi, lo进行修改。</span><br><span class="line">		2, while循环通过hi, lo改变, 改变区间。</span><br><span class="line">		3, if...else 和 else...if什么差别？</span><br><span class="line">	</span><br><span class="line">	&gt;* 技巧</span><br><span class="line">		善用 &quot;&lt;&quot; 比较</span><br><span class="line">			因为数据结构画图理解时候, 都是从左向右, 小于号能直观的看出在哪个区间, 不容易出错。</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"># 版本A: 实例与复杂度</span><br><span class="line"></span><br><span class="line">	&gt;* S.search(8, 0, 7): 2 + 1 + 2 = 5, S[4]命中</span><br><span class="line">	&gt;* S.search(3, 0, 7): 1 + 1 + 2 = 4, S[1]失败</span><br><span class="line">	</span><br><span class="line">	&gt;* 线性递归 T(n) = T(n/2) + O(1) = O(logn), 大大由于顺序查找O(n)</span><br><span class="line">	递归跟踪: 轴点总取中点, 递归深度O(logn); 各个递归实例均 O(1)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"># 版本A：查找长度</span><br><span class="line"></span><br><span class="line">	&gt;* 更为精细的评估算法性能:</span><br><span class="line">		考察关键码的比较次数, 查找长度(search length)</span><br><span class="line">	&gt;* 成功与失败的最好, 最坏, 平均角度评估</span><br><span class="line">	&gt;* 这个算法 = O(1.5logn)</span><br><span class="line">		向左节点 + 1, 向右节点 +2</span><br><span class="line">		n = 8</span><br><span class="line">		最好, 29/7 = 4+</span><br><span class="line">		最差, 36/8 = 4.5 = 1.5log28</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.004]]></title>
      <url>/2018/01/12/cpp/cpp-notes-0004/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1, bool和int的隐式转换</span><br><span class="line">	[cppd - bool_int_convert](https://github.com/timtingwei/cppd/blob/master/tmp/bool_int_convert.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt;* 问题起因</span><br><span class="line">		======================= source code =========================</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">		int count = 0;   // 计数器</span><br><span class="line">		for (int i = i; i &lt; _size; i++)</span><br><span class="line">			count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">		return count;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">		数据结构学习中, 一次循环将布尔值作为右值递增左值计数器。</span><br><span class="line">	</span><br><span class="line">	&gt;* sizeof(bool) = 1</span><br><span class="line">  </span><br><span class="line">	&gt;* bool-&gt; not bool</span><br><span class="line">		布尔值转赋值给非布尔值, 初始值false时0, true时1 	</span><br><span class="line">	</span><br><span class="line">	&gt;* not bool -&gt; bool</span><br><span class="line">		非布尔值转换成布尔值, 初始值非0为true, 初始值为0和空指针为false;</span><br><span class="line">	</span><br><span class="line">		其他都没什么问题, 值得注意的是, 引用和指针</span><br><span class="line">		=================== source code =============================</span><br><span class="line">		void f_to_bool() &#123;</span><br><span class="line">		int i1 = 5, i2 = 0;</span><br><span class="line">		int* pi0 = 0;       // 定义空指针</span><br><span class="line">		int* pi1 = &amp;i1;      // 指针指向i1</span><br><span class="line">		int&amp; ri0 = i2;      // 引用i2, i2的值为0</span><br><span class="line">		int&amp; ri1 = i1;      // 引用i1</span><br><span class="line">		</span><br><span class="line">		bool bi = i1;        // prints  bi = 1</span><br><span class="line">		bool bpi0 = pi0;     // prints  bpi0 = 0</span><br><span class="line">		bool bpi1 = pi1;     //         bpi1 = 1</span><br><span class="line">		bool bri0 = ri0;     //         bri0 = 0</span><br><span class="line">		bool bri1 = ri1;     //         bri1 = 1</span><br><span class="line">		=============================================================</span><br><span class="line">----------------------------------------------------------------------------------------------------  </span><br><span class="line"># 2, 不能返回函数内部初始化的指针</span><br><span class="line">	[cppd - return_ptr](https://github.com/timtingwei/cppd/blob/master/tmp/return_ptr.cpp)</span><br><span class="line"></span><br><span class="line">	&gt;* 问题</span><br><span class="line">		数据结构学习中, Rank* deduplicate_lower();</span><br><span class="line">		我想返回函数内部声明并初始化的指针, 即保存索引的数组, 但结果却出错了。</span><br><span class="line">	&gt;* 错误的方法</span><br><span class="line">		函数体内声明定义的指针，返回不了</span><br><span class="line">		===================== source code ===========================</span><br><span class="line">		int* f() &#123;</span><br><span class="line">			int iarr[] = &#123;&#125;;</span><br><span class="line">			iarr[0] = 2;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out -----------------------------</span><br><span class="line">		warning: address of local variable ‘iarr’ returned [-Wreturn-local-addr]</span><br><span class="line">		============================================================</span><br><span class="line">		我理解一下，函数内部定义的局部变量会在退出函数体后回收, 即使返回后地址也找不到，更谈不上指向谁。</span><br><span class="line">	</span><br><span class="line">	&gt;* 可行的方法</span><br><span class="line">		将指针作为参数传入</span><br><span class="line">		================== source code =============================</span><br><span class="line">		int* f1(int* iarr) &#123;</span><br><span class="line">			*iarr += 1;</span><br><span class="line">			return iarr;</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		另外一个疑问, 将指针作为参数, 可以在修改指针后返回, 但既然是指针, 还有什么返回的必要??</span><br><span class="line">		便于函数之间的调用, 还是需要的。</span><br><span class="line">	</span><br><span class="line">	&gt;* 另一种可行方法: malloc返回指针</span><br><span class="line">		================= source code ============================</span><br><span class="line">		// 强制返回指针, 分配内存却不释放</span><br><span class="line">		int* fun() &#123;</span><br><span class="line">			int* i_ptr = (int*) malloc(sizeof(int*));    // malloc分配内存</span><br><span class="line">			for (int i = 0; i &lt; sizeof(int*); i++)</span><br><span class="line">				*(i_ptr+i) = 0;</span><br><span class="line">			// free(i_ptr);  // 释放指针</span><br><span class="line">			return i_ptr;    // 函数返回指针</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"># 3, malloc和free</span><br><span class="line">	[cppd - malloc_free](https://github.com/timtingwei/cppd/blob/master/tmp/malloc_free.cpp)</span><br><span class="line">  </span><br><span class="line">	&gt; * 概念</span><br><span class="line">		malloc:</span><br><span class="line">		void* malloc (size_t size);</span><br><span class="line">		在语句块中分配一个memeory, 返回一个在作用域中的指针</span><br><span class="line">		free:</span><br><span class="line">		void free(void* ptr);</span><br><span class="line">		重新分配作用域中的memeory, 给未来的分配使用</span><br><span class="line">	</span><br><span class="line">	&gt; * 需要include的库</span><br><span class="line">		#include &lt;stdlib.h&gt;</span><br><span class="line">		#include &lt;stdio.h&gt;</span><br><span class="line">	</span><br><span class="line">	&gt; * 案例</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int main() &#123;</span><br><span class="line">			int i, n;</span><br><span class="line">			char* buffer;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;how long do you want the string?&quot;);</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line"></span><br><span class="line">	        buffer = (char*) malloc(i+1);</span><br><span class="line">	        if (buffer==NULL) exit(1);</span><br><span class="line"></span><br><span class="line">	        for (n=0; n &lt; i; n++)</span><br><span class="line">				buffer[n] = rand()%26 + &apos;a&apos;;</span><br><span class="line">			buffer[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	        printf(&quot;Random string: %s\n&quot;, buffer);</span><br><span class="line">	        free(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		------------------ ./a.out -------------------------------</span><br><span class="line">		how long do you want the string?5</span><br><span class="line">		Random string: nwlrb</span><br><span class="line">		===========================================================</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"># 4, 未声明大小的数组</span><br><span class="line">	[cppd - array_size](https://github.com/timtingwei/cppd/blob/master/tmp/array_size.cpp)</span><br><span class="line"></span><br><span class="line">	&gt; * 问题</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int size = 5;</span><br><span class="line">		int iarr[size] = &#123;&#125;;</span><br><span class="line">		------------------- ./a.out ----------------------------------</span><br><span class="line">		error: variable-sized object ‘iarr1’ may not be initialized</span><br><span class="line">		===========================================================</span><br><span class="line">	</span><br><span class="line">	&gt; * const</span><br><span class="line">		=========== source code ==========</span><br><span class="line">		const unsigned int size = 5;</span><br><span class="line">		int iarr1[size] = &#123;&#125;;</span><br><span class="line">		==================================</span><br><span class="line">	</span><br><span class="line">	&gt; * define</span><br><span class="line">		========== source code ==============</span><br><span class="line">		#define ARRAY_SIZE 5;</span><br><span class="line">		// #define ARRAY_SIZE = 5;    // ERROR</span><br><span class="line">		int iarr[ARRAY_SIZE] = &#123;&#125;</span><br><span class="line">		======================================</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"># 5, continue 和 break 区别</span><br><span class="line">	[cppd - continue_break](https://github.com/timtingwei/cppd/blob/master/tmp/continue_break.cpp)</span><br><span class="line">	</span><br><span class="line">	&gt; * 概念 </span><br><span class="line">		continue: 跳过for, range-for, while or do-while, 循环体剩余部分 </span><br><span class="line">		break: 闭合的for, range-for, while, do-while 循环或 switch选择终止</span><br><span class="line">	</span><br><span class="line">	&gt; * continue实例:</span><br><span class="line">		loop:</span><br><span class="line">		=================== source code ============================</span><br><span class="line">		// 跳过loop剩余部分</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;</span><br><span class="line">				std::cout &lt;&lt; &quot;j-i = 2&quot; &lt;&lt; std::endl;</span><br><span class="line">				continue;&#125;</span><br><span class="line">				// ...</span><br><span class="line">				std::cout &lt;&lt; &quot;after continue &quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">    &gt; * break实例:	</span><br><span class="line">		1, loop:</span><br><span class="line">		==================== source code ===========================</span><br><span class="line">		// 终止循环</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			for (int j = 2; j &lt;7; j++) &#123;</span><br><span class="line">				if (j - i == 2) &#123;break;&#125;      // 终止内存循环</span><br><span class="line">				std::cout &lt;&lt; &quot;j - i = &quot; &lt;&lt; j - i &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line">	</span><br><span class="line">		2, switch</span><br><span class="line">		=================== source code ===========================</span><br><span class="line">		int i = 2;</span><br><span class="line">		switch (i) &#123;</span><br><span class="line">			case 1: std::cout &lt;&lt; &quot;1\n&quot;;</span><br><span class="line">			case 2: std::cout &lt;&lt; &quot;2\n&quot;;         // 选择到这里</span><br><span class="line">			case 3: std::cout &lt;&lt; &quot;3\n&quot;;</span><br><span class="line">			case 4:</span><br><span class="line">			case 5: std::cout &lt;&lt; &quot;45 \n&quot;;</span><br><span class="line">				break;                            // 终止switch</span><br><span class="line">			case 6: std::cout &lt;&lt; &quot;6\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		------------------- ./a.out ------------------------------</span><br><span class="line">		2</span><br><span class="line">		3</span><br><span class="line">		45</span><br><span class="line">		============================================================</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"># if...else 和 if...else if的区别</span><br><span class="line">	[cppd - if_else_elseif](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line">	&gt;* 问题</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		while (lo &lt; hi) &#123;    // 区间存在</span><br><span class="line">			Rank mi =  (lo + hi) &gt;&gt; 1;        // 取中点</span><br><span class="line">			if      (e &lt; elem[mi]) hi = mi;      // 深入前半段查找</span><br><span class="line">			else if (elem[mi] &lt; e) lo = mi + 1;  // 深入后半段查找</span><br><span class="line">			else                   return mi;    // 在mi命中</span><br><span class="line">		&#125;</span><br><span class="line">		===========================================================</span><br><span class="line">		if, else...if 和 else是什么关系？</span><br><span class="line">		从结果上看, 二分查找, 在前半段找到至少比较1次, 后半段2次。</span><br><span class="line">	</span><br><span class="line">	&gt;* if...else</span><br><span class="line">		====</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 5) &#123;std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (i &gt; 5) &#123;std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">			&#125; else &#123; std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--------------------- ./a.out ---------------------------</span><br><span class="line">		i &gt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if...else if...else if</span><br><span class="line">		===</span><br><span class="line">		int i = 4;</span><br><span class="line">		if (i == 5) std::cout &lt;&lt; &quot;i = 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &lt; 5) std::cout &lt;&lt; &quot;i &lt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		else if (i &gt; 5) std::cout &lt;&lt; &quot;i &gt; 5&quot; &lt;&lt; std::endl;</span><br><span class="line">		-----</span><br><span class="line">		i &lt; 5</span><br><span class="line">		===</span><br><span class="line">	&gt;* if</span><br><span class="line">		===</span><br><span class="line">		int i = 6;</span><br><span class="line">		if (i == 6) std::cout &lt;&lt; &quot;i = 6&quot; &lt;&lt; std::endl;</span><br><span class="line">		if (i != 7) std::cout &lt;&lt; &quot;i != 7&quot; &lt;&lt; std::endl;</span><br><span class="line">		----------------- ./a.out --------------------------</span><br><span class="line">		i =  6</span><br><span class="line">		i != 7</span><br><span class="line">		====================================================</span><br><span class="line">	&gt;* 各自的作用域辨析</span><br><span class="line">		==================== source code ==========================</span><br><span class="line">		bool foo = false, bar = true, baz = true;</span><br><span class="line">		if (foo) &#123;</span><br><span class="line">			// &lt;- this block is only executed if &apos;foo&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;if(foo)\n&quot;;</span><br><span class="line">		&#125; else if (bar) &#123;  // &lt;- &apos;bar&apos; is only checked if &apos;foo&apos; is false</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; is false and &apos;bar&apos; is true</span><br><span class="line">			std::cout &lt;&lt; &quot;else if(bar)\n&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// &lt;- this block only executed if &apos;foo&apos; and &apos;bar&apos; are both false</span><br><span class="line">			std::cout &lt;&lt; &quot;else &#123;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		if (baz) &#123;   // &lt;- no &apos;else&apos;, so previous &apos;ifs&apos; don&apos;t matter</span><br><span class="line">			// &lt;- this block only executed if &apos;baz&apos; is true.   foo/bar don&apos;t matter</span><br><span class="line">			std::cout &lt;&lt; &quot;if(baz)\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		---------------------- ./a.out ----------------------------------</span><br><span class="line">		// else if(bar)</span><br><span class="line">		// if(baz)</span><br><span class="line">		==============================================================</span><br><span class="line">		我用的是Google cpplint的cpp书写方式, else要在两个反花括号之间。</span><br><span class="line">		这样更容易看到 if, else..if, else 是一个语句块, if又是单独的一个。</span><br><span class="line">	&gt;* 总结</span><br><span class="line">		if(i &lt; n), if...else(n &lt; i), 这两个语句条件除了n = i互补。</span><br><span class="line">		如果有一个true, 则不会执行接下来的else; </span><br><span class="line">		如果都为false, else执行, 条件相当于(n==i)为true.</span><br><span class="line">		</span><br><span class="line">		因此，对于二分查找来说, </span><br><span class="line">		前半段找到只执行一次if, 后半段找到执行 if 和 if else两次比较, 还节省一次判等的操作。</span><br><span class="line">		</span><br><span class="line">		1, if...else if...else 可作三个并列关系的选择, 但运行时有先后顺序</span><br><span class="line">		2, if...else 多用 (cond)? expre1 : expre2; 代替</span><br><span class="line">		===== source code ======</span><br><span class="line">		int i = 4, count = 0;</span><br><span class="line">		(i == 4) ? count++</span><br><span class="line">			: i = 4;</span><br><span class="line">		========================</span><br><span class="line">		缺点是执行的语句只能为一个表达式且单行, 也不能return</span><br><span class="line">		3, if, if 语句多为两个condtions没有并列关系。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-D1]]></title>
      <url>/2018/01/11/dsacpp/02-D1/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">觉得markdown格式的页面, 排版很不舒服。虽然有标题的概念, 但是标题字体大小不容易分清, 结构不是显而易见。尝试使用不带格式的记笔记，仍然保留markdown语法, 以便复制对比效果。</span><br><span class="line">------------------------------ split line ---------------------------</span><br><span class="line">实现源码[dsacpp - vector_ordered](https://github.com/timtingwei/dsacpp/blob/master/src/02/vector_ordered.cpp)</span><br><span class="line"></span><br><span class="line"># 有序向量唯一化</span><br><span class="line">	无序: 比对</span><br><span class="line">	有序: 比较</span><br><span class="line"></span><br><span class="line">## 有序性及其甄别</span><br><span class="line"></span><br><span class="line">	&gt; * 有序/无序序列中, 任意/总有一对相邻元素顺序/逆序。</span><br><span class="line">	</span><br><span class="line">	&gt; * 相邻逆序对数目, 可以度量逆序程度。</span><br><span class="line">	</span><br><span class="line">		&gt; * 逆序程度实现</span><br><span class="line">		</span><br><span class="line">		===================== source code =========================</span><br><span class="line">		// 逆序程度</span><br><span class="line">		/* my test code </span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;</span><br><span class="line">			for (int i = 0; i &lt; _size - 1; i++)</span><br><span class="line">				if (_elem[i] != _elem[i+1]) count++;  // ERROR: 逆序:前个元素大于后一元素</span><br><span class="line">			return count;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::disordered() const &#123;</span><br><span class="line">			int count = 0;   // 计数器</span><br><span class="line">			for (int i = i; i &lt; _size; i++)</span><br><span class="line">				count += (_elem[i-1] &gt; _elem[i]);    // 逆序对则计数+1, bool和int的隐式转换</span><br><span class="line">			return count;  // 向量有序当且仅当n = 0</span><br><span class="line">		&#125; // 若只需要判断是否有序, 首次遇到逆序对之后, 就立即终止</span><br><span class="line">		============================================================</span><br><span class="line">		</span><br><span class="line">	&gt; * 若元素支持大小比较, 可将无序向量转换为有序向量。</span><br><span class="line">	&gt; * 无序向量转换为有序向量后, 算法多可优化。</span><br><span class="line"></span><br><span class="line">## 低效算法</span><br><span class="line"></span><br><span class="line">	&gt; 1, 我自己的低效deduplicate()版本, </span><br><span class="line">		依赖一次性remove函数.</span><br><span class="line">		&gt; * 尝试自己实现,</span><br><span class="line">		</span><br><span class="line">		======================== sourece code =======================</span><br><span class="line">		// my deduplicate code</span><br><span class="line">		// 唯一化(低效)</span><br><span class="line">		int deduplicate_lower(int rm_arr[]);</span><br><span class="line">		// 唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		void remove(int rm_arr[], int n);</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::deduplicate_lower(int rm_arr[]) &#123;</span><br><span class="line">			// 删除有序向量重复的元素, rm_arr是保存删除对象索引数组, 返回被删除元素的数量</span><br><span class="line">			assert(!disordered());   // 当前为有序向量</span><br><span class="line">			Rank n = 0;            // 数组当前插入位置</span><br><span class="line">			Rank r1 = 0, r2 = 1;   // 创建两个索引值线性扫描</span><br><span class="line">			while (r2 &lt; _size) &#123;</span><br><span class="line">				if (_elem[r1] == _elem[r2]) &#123;   // r2指向的元素和r1对应元素重复</span><br><span class="line">					rm_arr[n++] = r2;     // 索引数组中加入r2</span><br><span class="line">					// remove(r2);</span><br><span class="line">				&#125; else &#123; r1 = r2;&#125;</span><br><span class="line">				r2++;    // 递增r2</span><br><span class="line">				&#125;</span><br><span class="line">			remove(rm_arr, n);   // 一次性删除索引对应的元素</span><br><span class="line">			return n;            // 返回删除元素数量</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	    // 有序向量唯一化所依赖的通过索引数组一次性remove函数</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		void Vector&lt;T&gt;::remove(int rm_arr[], int n) &#123;</span><br><span class="line">			// 删除索引除外的索引对应元素保留, 从左向右扫描</span><br><span class="line">			int i_n = 0;     // 指向rm_arr中的元素</span><br><span class="line">			int new_i = 0;   // 保留索引</span><br><span class="line">			T* old_elem = _elem;    // 备份一份当前元素</span><br><span class="line">			_elem = new T[_capacity = _capacity];</span><br><span class="line">			for (int i = 0; i &lt; _size; i++) &#123;</span><br><span class="line">				if (i != rm_arr[i_n]) &#123;     // 当前索引不在表中</span><br><span class="line">					_elem[new_i++] = old_elem[i];   // 当前索引对应元素赋值给当前元素的新位置</span><br><span class="line">				&#125; else &#123;     // 当前索引在删除索引的表中</span><br><span class="line">					i_n++;     // 指向下一个rm_arr中的元素</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			_size -= n;</span><br><span class="line">			delete [] old_elem;</span><br><span class="line">		&#125;</span><br><span class="line">		=============================================================</span><br><span class="line">	</span><br><span class="line">	&gt; 2, 视频中的唯一化(低效版)</span><br><span class="line">		代码如下:</span><br><span class="line">		======================= source code ========================</span><br><span class="line">		// 有序向量唯一化</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size; int i = 0;  // 首元素开始</span><br><span class="line">			while (i &lt; _size - 1) &#123;</span><br><span class="line">				(_elem[i+1] == _elem[i]) ? remove(i+1) : i++;</span><br><span class="line">			&#125;    // _size的改变由remove隐式完成</span><br><span class="line">			return old_size - _size;</span><br><span class="line">		&#125;</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">## 低效算法: 复杂度</span><br><span class="line">	&gt; 1, 低效复杂度</span><br><span class="line">		运行时间取决于while循环, 总计 _size - 1 = n - 1 </span><br><span class="line">		最坏情况: 每次调用remove(), 耗时O(n)~ O(1), 累计O(n^2)</span><br><span class="line">	&gt; 2, 比较</span><br><span class="line">		我实现了一次性remove的操作, 应该可以将O(n^2)的复杂度降到O(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 高效算法:</span><br><span class="line">	&gt; 1, 反思</span><br><span class="line">		低效来自于, 同一元素可作为删除元素的后继, 而多次参与前移。</span><br><span class="line">	&gt; 2, 启示</span><br><span class="line">		将重复区间视为单位, 成批的删除</span><br><span class="line">	&gt; 3, 算法</span><br><span class="line">		[i] [] [ . . . . duplicates] [j] </span><br><span class="line">		从i开始扫描, 直达找到不相等的元素j, 将j移动到i的后一位置。</span><br><span class="line">		</span><br><span class="line">		高明之处在于: 实际上没有删除, 却等效于删除</span><br><span class="line">		================== source code ==============================</span><br><span class="line">		/* my test code</span><br><span class="line">		template &lt;typename&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">			int old_size = _size;</span><br><span class="line">		    int i = 0, j = 1;   // i指向首位置</span><br><span class="line">			int n = 1;    // 实际更新后的_elem的索引</span><br><span class="line">			while (i &lt; _size - 1)</span><br><span class="line">				if (_elem[i] != _elem[j])</span><br><span class="line">					&#123; _elem[n++] = _elem[j]; i = j; size--;</span><br><span class="line">					&#125; else &#123;j++;&#125;</span><br><span class="line">	        return old_size - n;</span><br><span class="line">		&#125;</span><br><span class="line">		*/</span><br><span class="line">		</span><br><span class="line">		template &lt;typename T&gt;</span><br><span class="line">		int Vector&lt;T&gt;::uniquify_faster() &#123;</span><br><span class="line">			int i = 0, j = 0;   // 两个计数都指向首元素</span><br><span class="line">			while (++j &lt; _size) &#123;   // j扫描到末尾</span><br><span class="line">				if (_elem[i] != _elem[j]) &#123;_elem[++i] = _elem[j];&#125;  // j指向元素移到i后</span><br><span class="line">			&#125;</span><br><span class="line">			_size = ++i; shrunk();      // 改变_size数值后, 缩容</span><br><span class="line">			return j - i;    // 注意j扫到尾端的特性</span><br><span class="line">		&#125;     // 依赖shrink();</span><br><span class="line">		============================================================</span><br><span class="line"></span><br><span class="line">	    /* 实现问题分析</span><br><span class="line">		// 为什么不要另外的n作为索引计数?</span><br><span class="line">		当j移动至i后, 计数i也增加, 重新指向移动位置后的j, 不需要对原有那份的拷贝即可完成索引操作。记录位置只用i。算法设计时，也考虑一个操作是否必要。一份复制是否必要。</span><br><span class="line">		// 为什么不在uniquify中进行new 和 delete?</span><br><span class="line">		接口分离的体现, 在函数中改变_size, 通过_size的改变, 再由shrunk/expand对空间进行操作。</span><br><span class="line">	    */</span><br><span class="line"></span><br><span class="line">## 高效算法: 实例与复杂度</span><br><span class="line">	&gt; 1, *反思 (典型例子)</span><br><span class="line">		共计n-1次迭代, 每次常数时间, 累计O(n)时间。</span><br><span class="line">		</span><br><span class="line">		优化之处在于, 没有亦步亦趋的移动, 而是直接移动到最终的位置；又只通过计算得到_size规模, 没有任何显式的删除操作。</span><br><span class="line">		体现了, 一个差的算法, 在经过反思之后, 拟定的改进策略, 最终使得效率有所改进。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 有序向量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.003]]></title>
      <url>/2018/01/11/cpp/cpp-notes-0003/</url>
      <content type="html"><![CDATA[<h1 id="重载函数什么时候用virtual"><a href="#重载函数什么时候用virtual" class="headerlink" title="重载函数什么时候用virtual?"></a>重载函数什么时候用virtual?</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/overload_function.cpp" target="_blank" rel="noopener">source code - load_funtion.cpp</a></p>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit)</span></span>;</span><br><span class="line"><span class="comment">// template &lt;typename VST&gt; virtual void traverse(VST visit, T* e);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST visit, T* e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为什么这里不需要virtual??</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个T类型元素加1的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;e)</span> </span>&#123;e++;&#125;    <span class="comment">// Increase&lt;T&gt;()实现函数功能  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么这里又需要virtual??</p>
<h2 id="概念偏差"><a href="#概念偏差" class="headerlink" title="概念偏差"></a>概念偏差</h2><p>virtual 和我原先理解的重载函数不太相同。也就是vitual和重载函数不是同一个概念。</p>
<p><strong>vitual为虚函数</strong>：基类的引用或者指针调用一个虚成员函数时会执行动态绑定。 </p>
<p><strong>重载函数</strong>：同一作用域内的几个函数名字相同但形参列表不同。</p>
<h2 id="使用与不使用virtual"><a href="#使用与不使用virtual" class="headerlink" title="使用与不使用virtual"></a>使用与不使用virtual</h2><p>解释一下 virtual 和 override 搭配, 继承类中可对基类的虚函数重载<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>    <span class="comment">// 声明virtual后, 可被继承类override重载</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;   <span class="comment">// 'override'可写可不写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> override </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived\n"</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>关键问题: 上述两者什么差别????</code></p>
<p>运行测试一下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释是使用virtual结果</span></span><br><span class="line">  Base b;</span><br><span class="line">  Derived d;</span><br><span class="line"></span><br><span class="line">  Base&amp; br = b;      <span class="comment">// refer b, br的类型是Base&amp;</span></span><br><span class="line">  Base&amp; dr = d;      <span class="comment">// dr类型也是Base&amp;</span></span><br><span class="line">  br.print();        <span class="comment">// Base</span></span><br><span class="line">  dr.print();        <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  Base* pb = &amp;b;     <span class="comment">// pointer to b, Base*</span></span><br><span class="line">  Base* pd = &amp;d;     <span class="comment">// Base* as well</span></span><br><span class="line"></span><br><span class="line">  pb-&gt;print();       <span class="comment">// Base</span></span><br><span class="line">  pd-&gt;print();       <span class="comment">// Derived</span></span><br><span class="line"></span><br><span class="line">  b.Base::print();   <span class="comment">// Base</span></span><br><span class="line">  d.Base::print();   <span class="comment">// Base</span></span><br></pre></td></tr></table></figure></p>
<p>使用vitual的运行结果:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Derived</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure>
<p>不使用虚方法的运行结果:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br><span class="line">Base</span><br></pre></td></tr></table></figure></p>
<p>virtual版本, 基类的引用或者指针会在调用一个虚函数时候, 动态绑定对应的函数。</p>
<h2 id="解决最初问题"><a href="#解决最初问题" class="headerlink" title="解决最初问题"></a>解决最初问题</h2><h3 id="为什么traverse函数不需要virtual"><a href="#为什么traverse函数不需要virtual" class="headerlink" title="为什么traverse函数不需要virtual"></a>为什么traverse函数不需要virtual</h3><p>traverse函数，属于在同一作用域，形参列表不同的函数。重载的概念是函数重载的概念，并不是继承类之间的虚函数override概念。</p>
<h3 id="为什么函数对象需要virtual重载操作符函数"><a href="#为什么函数对象需要virtual重载操作符函数" class="headerlink" title="为什么函数对象需要virtual重载操作符函数?"></a>为什么函数对象需要virtual重载操作符函数?</h3><p>定义继承类Increase_two, override在基类中被声明成virtual的类, 实现元素加2<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象用virtual声明operator()()</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span> &#123;</span></span><br><span class="line">  <span class="comment">// 重载()后, 对象可充当函数的功能</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> </span>&#123;(*e)++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase_two</span> :</span> Increase &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>* e)</span> override </span>&#123;(*e)+= <span class="number">2</span>;&#125;    <span class="comment">// 元素+2;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试函数, 以及prints结果如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Increase a;</span><br><span class="line">  Increase_two b;</span><br><span class="line"></span><br><span class="line">  Increase&amp; ra = a;</span><br><span class="line">  Increase&amp; rb = b;     <span class="comment">// rb的类型为 Increase&amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> e = <span class="number">5</span>; <span class="keyword">int</span>* pe = &amp;e;</span><br><span class="line">  ra.<span class="keyword">operator</span>()(pe);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e = "</span> &lt;&lt; e &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// prints "e = 6"</span></span><br><span class="line">  <span class="keyword">int</span> e2 = <span class="number">5</span>; <span class="keyword">int</span>* pe2 = &amp;e2;</span><br><span class="line">  rb.<span class="keyword">operator</span>()(pe2);   <span class="comment">// 调用基类的引用时, 动态绑定到Increase_two中的方法</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"e2 = "</span> &lt;&lt; e2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// prints "e2 = 7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对重载操作符声明virtual, 可以让继承类对他的重载操作符行为进行重载。当调用基类的引用或者指针时候, 在编译阶段就能绑定到继承类对应的重载函数版本。</p>
<h1 id="静态成员声明定义使用"><a href="#静态成员声明定义使用" class="headerlink" title="静态成员声明定义使用"></a>静态成员声明定义使用</h1><p>源码: <a href="https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp" target="_blank" rel="noopener">source code - static.cpp</a></p>
<h2 id="静态成员的特点"><a href="#静态成员的特点" class="headerlink" title="静态成员的特点"></a>静态成员的特点</h2><p>静态数据成员不属于任何类的一个对象。</p>
<p>类似于全局变量, 存在于任何的函数定义之外, 一直存在于整个程序的生命周期</p>
<h2 id="类内static成员如何声明定义"><a href="#类内static成员如何声明定义" class="headerlink" title="类内static成员如何声明定义?"></a>类内static成员如何声明定义?</h2><blockquote>
<ul>
<li>在类内部声明, 外部通过类名作用域访问定义<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatic</span></span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> i_stc;   <span class="comment">// 类内部声明</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyStatic::i_stc = <span class="number">0</span>;     <span class="comment">// 类外部定义, 注意需要声明成员的类型</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>也可以通过静态成员函数和一般的成员函数对它进行修改, 此时静态成员函数可通过类名访问。</p>
<h2 id="在不同实例中被多次调用改变后的情况"><a href="#在不同实例中被多次调用改变后的情况" class="headerlink" title="在不同实例中被多次调用改变后的情况?"></a>在不同实例中被多次调用改变后的情况?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MyStatic::increment() &#123;++i_stc;&#125;</span><br><span class="line"></span><br><span class="line">void f() &#123;</span><br><span class="line">  MyStatic c0;</span><br><span class="line">  c0.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c0 = &quot; &lt;&lt; c0.i_stc &lt;&lt; std::endl;</span><br><span class="line">  MyStatic c1;</span><br><span class="line">  c1.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f1() &#123;</span><br><span class="line">  MyStatic c2;</span><br><span class="line">  c2.increment();</span><br><span class="line">  std::cout &lt;&lt; &quot;c2 = &quot; &lt;&lt; c2.i_stc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">c0 = 1</span><br><span class="line">c1 = 2</span><br><span class="line">c2 = 3</span><br></pre></td></tr></table></figure>
<p>静态数据成员类似于全局变量, 无论在何处, 每调用一次修改静态成员的函数, 数据相应的改变, 且不会随着作用域的离开而销毁。</p>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 类 </tag>
            
            <tag> virtual </tag>
            
            <tag> override </tag>
            
            <tag> 函数重载 </tag>
            
            <tag> static </tag>
            
            <tag> 静态成员 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建筑设计应用和计算机科学一点随想]]></title>
      <url>/2018/01/10/essay/architecture-application-between-computer-science/</url>
      <content type="html"><![CDATA[<p>要掌握一门技术或者一种思想, 离不开实践和思考。即使从最简单的问题入手, 也可以检验自己对知识是否融会贯通。这是计算机科学的一种特性吧。在认识到这一点之后, 学习应该更注重知识与知识之间的联系, 这一点我本身的思维特点决定了它不差; 另一点便是, 注重知识的应用, 我容易陷入这个陷阱, 以致于现在抛开应用, 离开建筑, 去学习思考这些问题。</p>
<p>批判性思维指引我, 我的做法和别人的作法有什么区别, 别人可以是书籍, 视频, 演讲还有编译器。得益于这一点, 我最近找到了一些学习语言的门道。但是如果要说到应用，可能需要批判性思考的嵌套, 也就是指向批判性思维的指针。这个技巧在实际应用中哪些地方会用到？如何运用？这个DSA和建筑问题是否相关？这个库的调用或者学习对建筑的生成有多少帮助？提这些问题,  并不是说对计算机科学的深入学习点到为止, 而是让我循序渐进的学习。它能告诉我这一段知识的学习, 内存泄漏的厉害; 这一段知识的学习, 太追求结果和封装; 这一段知识的学习, 缺少自我和外我的交流。 </p>
<p>学习角度讲, 即使从一个很小很简单的问题入手, 也能对自己有所提高。 因为, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。而建筑恰恰就是一个复杂黑箱。事实也证明, 往往穿透的, 创新的思想, 在学科的结合之间会泵发出生命力。我该反思。</p>
]]></content>
      
        
        <tags>
            
            <tag> 随想 </tag>
            
            <tag> 建筑 </tag>
            
            <tag> 计算机科学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.002]]></title>
      <url>/2018/01/10/cpp/cpp-notes-02/</url>
      <content type="html"><![CDATA[<h1 id="数组-指针数组-指向指针的指针的数组-…"><a href="#数组-指针数组-指向指针的指针的数组-…" class="headerlink" title="数组, 指针数组, 指向指针的指针的数组, …."></a>数组, 指针数组, 指向指针的指针的数组, ….</h1><p>在逛<a href="http://www.cplusplus.com/forum/beginner/" target="_blank" rel="noopener">Cplusplus Forum - Beginner</a>的时候发现了一个看上去看简单的<a href="http://www.cplusplus.com/forum/beginner/228196/" target="_blank" rel="noopener">问题</a></p>
<p><strong>How do I receive two numbers from the keyboard, save them in an array of two element?</strong></p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a><strong>第一次尝试</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;     <span class="comment">// ERROR: 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 不合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iarr[<span class="number">0</span>] &lt;&lt; <span class="string">' '</span> &lt;&lt; iarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想得太简单了。不能在标准输入中, 直接对数据进行修改。</p>
<h2 id="下面给出的答案"><a href="#下面给出的答案" class="headerlink" title="下面给出的答案"></a><strong>下面给出的答案</strong></h2><p>1,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; iarr[<span class="number">0</span>] &gt;&gt; iarr[<span class="number">1</span>];     <span class="comment">// 直接输入到数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;     <span class="comment">// 先输入, 再存放</span></span><br><span class="line">  <span class="keyword">int</span> iarr[<span class="number">2</span>] = &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="但是我仍然考虑我思路实现的可能性？"><a href="#但是我仍然考虑我思路实现的可能性？" class="headerlink" title="但是我仍然考虑我思路实现的可能性？"></a><strong>但是我仍然考虑我思路实现的可能性？</strong></h2><p>对已经放置在数组中的值进行修改的思路如何实现？</p>
<h3 id="第一个想到的就是指针。"><a href="#第一个想到的就是指针。" class="headerlink" title="第一个想到的就是指针。"></a>第一个想到的就是指针。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;  <span class="comment">// <span class="doctag">BUG:</span> 为什么不能通过数组中保存的指针修改数组??</span></span><br><span class="line">  <span class="keyword">int</span> *pa, *pb;</span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;</span><br><span class="line">  <span class="keyword">int</span> tmp_a, tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp_a &gt;&gt; tmp_b;        <span class="comment">// 存放到临时变量</span></span><br><span class="line">  pa = &amp;tmp_a; pb = &amp;tmp_b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pa = "</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// *pa = 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(*iarr) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(iarr[<span class="number">0</span>]) &lt;&lt; <span class="string">' '</span> &lt;&lt; *(iarr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">*pa = 1</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>
<p>很气, 我得出结论。不能通过数组中保存的指针修改数组。</p>
<h3 id="数组作为函数形参"><a href="#数组作为函数形参" class="headerlink" title="数组作为函数形参"></a>数组作为函数形参</h3><p>接着, 我想起之前在函数中通过数组改变过值, 便想要实现如下任务：<br><strong>创建一个函数, 输入一个保存指向整数的指针的数组, 修改索引n位置的指针所指向的值, 返回</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_int</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n指向的整数递增1</span></span><br><span class="line">  (*(arr+n)) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  revise_value_int(iarr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iarr[2] = "</span> &lt;&lt; iarr[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise();</span><br></pre></td></tr></table></figure>
<p>可以改变。但是仔细一想, 我仅仅只是在数组中存放了整数。</p>
<h3 id="函数形参为存放指针的数组"><a href="#函数形参为存放指针的数组" class="headerlink" title="函数形参为存放指针的数组"></a>函数形参为存放指针的数组</h3><p>接着，我改变了数组，用于存放指针<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span> ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>编译时就出现了错误,.<em>error: invalid conversion from ‘int</em>’ to ‘int’ [-fpermissive]<em><br><strong>因为现在数组保存着的是指向整型的指针, 因此数组的类型应该是 int\</strong></em></p>
<p>修改<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>写修改指针所指向整数的函数, 注意, 这个形参类型是<code>int**</code>, <strong>ptrArr是指向指针的指针, 调用数组, 实际上是调用指向数组首元素的指针。</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revise_value_ptr</span><span class="params">(<span class="keyword">int</span>** ptrArr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 索引为n的指向的指针所指向的整数递增1</span></span><br><span class="line">  (**(ptrArr+n))+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Segmentation-fault-core-dumped"><a href="#Segmentation-fault-core-dumped" class="headerlink" title="Segmentation fault (core dumped)"></a>Segmentation fault (core dumped)</h3><p>再次编译<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure></p>
<p>出现 Segmentation fault (core dumped) 的原因， 参考[<a href="http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b9eab320100uivj.html</a>]</p>
<h4 id="1-内存访问越界"><a href="#1-内存访问越界" class="headerlink" title="1 内存访问越界"></a>1 内存访问越界</h4><p>  a) 由于使用错误的下标，导致数组访问越界</p>
<p>  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p>
<p>  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p>
<h4 id="2-多线程程序使用了线程不安全的函数。"><a href="#2-多线程程序使用了线程不安全的函数。" class="headerlink" title="2 多线程程序使用了线程不安全的函数。"></a>2 多线程程序使用了线程不安全的函数。</h4><h4 id="3-多线程读写的数据未加锁保护。"><a href="#3-多线程读写的数据未加锁保护。" class="headerlink" title="3 多线程读写的数据未加锁保护。"></a>3 多线程读写的数据未加锁保护。</h4><p>对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p>
<h4 id="非法指针"><a href="#非法指针" class="headerlink" title="非法指针"></a>非法指针</h4><p>  a) 使用空指针<br>  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它时就很容易因为bus error而core dump.</p>
<h4 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h4><p>不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p>
<h3 id="非法指针-1"><a href="#非法指针-1" class="headerlink" title="非法指针"></a>非法指针</h3><p>我的代码是:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa, *pb, *pc;</span><br><span class="line"><span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我使用了非法的指针, 这个指针没有指向任何</p>
<p>修改,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_revise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span>* ptrArr[] = &#123;pa, pb, pc&#125;;</span><br><span class="line">  another_revise_value_ptr(ptrArr, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"**(ptrArr)   = "</span> &lt;&lt; **(ptrArr)   &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+1) = "</span> &lt;&lt; **(ptrArr+<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"**(ptrArr+2) = "</span> &lt;&lt; **(ptrArr+<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_revise()</span><br></pre></td></tr></table></figure>
<p>编译得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">**(ptrArr)   = 1</span><br><span class="line">**(ptrArr+1) = 2</span><br><span class="line">**(ptrArr+2) = 4</span><br></pre></td></tr></table></figure></p>
<h3 id="解决最开始问题并总结"><a href="#解决最开始问题并总结" class="headerlink" title="解决最开始问题并总结"></a>解决最开始问题并总结</h3><p><strong>修改后的代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;     <span class="comment">// DE<span class="doctag">BUG:</span> 先存放再输入不会修改数组中的数据</span></span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, <span class="keyword">int</span>* pb = &amp;b;     <span class="comment">// 注意: 不要定义空指针</span></span><br><span class="line">  <span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 注意数组的类型是数组中元素的类型</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">// 也能合理:先存放, 再输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; **iarr &lt;&lt; <span class="string">' '</span> &lt;&lt; **(iarr+<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 解引用</span></span><br><span class="line">  <span class="comment">// 4197661 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不要定义空指针"><a href="#不要定义空指针" class="headerlink" title="不要定义空指针"></a>不要定义空指针</h4><p>如这样<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pa;</span><br></pre></td></tr></table></figure></p>
<p>即使要定义也要<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *pa = 0;</span><br><span class="line">int *pb = nullptr;</span><br></pre></td></tr></table></figure></p>
<p>尽量让指针指向某个对象<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><p>数组的类型是数组中元素的类型<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 类型为 int*</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解引用数组"><a href="#解引用数组" class="headerlink" title="解引用数组"></a>解引用数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* iarr[<span class="number">2</span>] = &#123;pa, pb&#125;;        <span class="comment">// 如果数组这样定义</span></span><br><span class="line">iarr;                           <span class="comment">// iarr是指向数组首个元素的指针</span></span><br><span class="line">*iarr;                          <span class="comment">// 因为pa是指针, 所以解引用数组头指针, 得到pa地址</span></span><br><span class="line">**iarr;                         <span class="comment">// 再次解引用得到pa指向的int</span></span><br></pre></td></tr></table></figure>
<p>标准输出它们得到<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iarr = 0x7ffed5caa560</span><br><span class="line">*iarr = 0x7ffed5caa548</span><br><span class="line">**iarr = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="更多的尝试"><a href="#更多的尝试" class="headerlink" title="更多的尝试"></a><strong>更多的尝试</strong></h2><h3 id="数组中存放对象"><a href="#数组中存放对象" class="headerlink" title="数组中存放对象"></a>数组中存放对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* _c; <span class="keyword">int</span> _length; <span class="keyword">int</span> _capacity;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Name(<span class="keyword">char</span>* c, <span class="keyword">int</span> length): _c(c), _length(length) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* Name&lt;T&gt;::getName() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Name&lt;T&gt;::getLength() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c1[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> c2[] = &#123;<span class="string">'h'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length1 = <span class="number">3</span>, length2 = <span class="number">2</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; name1(c1, length1), name2(c2, length2);</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; nArr[] = &#123;name1, name2&#125;;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">2</span>;</span><br><span class="line">  print_instance_data_in_array(nArr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c[] = &#123;<span class="string">'t'</span>, <span class="string">'i'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">3</span>;</span><br><span class="line">  Name&lt;<span class="keyword">int</span>&gt; n(c, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_instance_data_in_array</span><span class="params">(Name&lt;<span class="keyword">int</span>&gt;* nArr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name = "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nArr[i].getLength(); j++) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *((nArr[i].getName())+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Name = tim</span><br><span class="line">Name = hu</span><br></pre></td></tr></table></figure>
<p>面向对象可以让我从无尽的指针中抽身出来, 关注相互之间的联系。</p>
<h3 id="数组中存放长度不同的数组"><a href="#数组中存放长度不同的数组" class="headerlink" title="数组中存放长度不同的数组"></a>数组中存放长度不同的数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>, c = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span>* pa = &amp;a, *pb = &amp;b, *pc = &amp;c;</span><br><span class="line">  <span class="keyword">int</span> _size_pa = <span class="number">1</span>, _size_pb = <span class="number">1</span>, _size_pc = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr1[] = &#123;pa&#125;;    <span class="comment">// pArr1数组存放pa, pb指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr2[] = &#123;pa, pb, pc&#125;;    <span class="comment">// pArr2数组存放pa, pb, pc指针</span></span><br><span class="line">  <span class="keyword">int</span> _size_pArr2 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span>* pArr3[] = &#123;pa, pc&#125;;</span><br><span class="line">  <span class="keyword">int</span> _size_pArr3 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> size_pArr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>** ppArr[] = &#123;pArr1, pArr2, pArr3&#125;;   <span class="comment">// ppArr存放3个指针数组</span></span><br><span class="line">  <span class="keyword">int</span> _size_ppArr = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> size_ppArr[] = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>* size_arr[] = &#123;size_ppArr, size_pArr&#125;;</span><br><span class="line">  <span class="comment">// convert_size_structor(size_arr);</span></span><br><span class="line">  print_arr_b(ppArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr_b</span><span class="params">(<span class="keyword">int</span>*** ppArr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解引用并打印ppArr数组中依次数组中的pa, pb, pc</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a0 = "</span> &lt;&lt; ***ppArr&lt;&lt; <span class="string">" in pArr1[0]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"b0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">1</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr2[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">"c0 = "</span> &lt;&lt; **(*(ppArr+<span class="number">2</span>)+<span class="number">1</span>)&lt;&lt; <span class="string">" in pArr3[1]"</span> &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于简单的数组, 打印储存不同长度数组的数组, 需要更多的数据结构知识, 而且不同的算法还有好坏, 可见数据结构的重要性. 这部分的打印实现, 留作日后我数据结构解引用后的小试牛刀。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a><strong>感想</strong></h2><p>即使从一个很小很简单的问题入手, 也能对自己有所提高, 计算机科学没有简单, 复杂是由简单构成的, 计算机科学承认复杂, 计算机科学尝试破译复杂。</p>
<h1 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">  MyClass(<span class="keyword">int</span> v) :x(v) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;   <span class="comment">// 常量成员函数在是否为常量上可以重载</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span>&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> --x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="声明时引用符号总最靠近变量名"><a href="#声明时引用符号总最靠近变量名" class="headerlink" title="声明时引用符号总最靠近变量名"></a>声明时引用符号总最靠近变量名</h2><h2 id="为什么可以对a-get-赋值"><a href="#为什么可以对a-get-赋值" class="headerlink" title="为什么可以对a.get()赋值"></a>为什么可以对a.get()赋值</h2><p>get()返回的是引用, 引用可作为左值, 且如果非常量引用的话,  该值可以被修改。</p>
<h2 id="在是否为成员函数上重载后如何匹配"><a href="#在是否为成员函数上重载后如何匹配" class="headerlink" title="在是否为成员函数上重载后如何匹配?"></a>在是否为成员函数上重载后如何匹配?</h2><p>成员函数在是否为常量函数上可以重载。如果对象实例化成const类型, 则匹配常量成员函数。</p>
<h2 id="const-int-amp-get-const-return-x-为什么返回类型需要const"><a href="#const-int-amp-get-const-return-x-为什么返回类型需要const" class="headerlink" title="const int&amp; get() const {return x;} 为什么返回类型需要const?"></a>const int&amp; get() const {return x;} 为什么返回类型需要const?</h2><p>常量函数返回数据成员, 编译器会将数据成员声明成const类型;</p>
<h2 id="什么是数据成员"><a href="#什么是数据成员" class="headerlink" title="什么是数据成员?"></a>什么是数据成员?</h2><p>MyClass类public中定义新成员测试是否为数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; get() <span class="keyword">const</span> &#123;<span class="keyword">return</span> --a;&#125;    <span class="comment">// 错误：改变a的值,</span></span><br></pre></td></tr></table></figure>
<p>改变a的值无法通过编译, a为数据成员。</p>
<p>在class中声明的, 无论是私有的还是公有的数据, 都是成员数据。如果在常量函数中返回, 会常量函数会被声明成const类型。</p>
<h1 id="template基础用法"><a href="#template基础用法" class="headerlink" title="template基础用法"></a>template基础用法</h1><h2 id="typename-T-和-class-T的区别"><a href="#typename-T-和-class-T的区别" class="headerlink" title="typename T 和 class T的区别"></a>typename T 和 class T的区别</h2><p>在模板参数列表中, typename和class没有什么不同。 但每个参数类型前必须加上typename 或者 class</p>
<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P580 模板与泛型编程</code></p>
<h2 id="特殊化模板"><a href="#特殊化模板" class="headerlink" title="特殊化模板"></a>特殊化模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span></span><br><span class="line">  T element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> T e) : element(e) &#123;&#125;</span><br><span class="line">  <span class="function">T <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增element</span></span><br><span class="line">  <span class="function">T <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对char类型, 有特定的方法uppercase()大写化字母<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span></span><br><span class="line">  <span class="keyword">char</span> element;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  mycontainer(<span class="keyword">const</span> <span class="keyword">char</span> e): element(e) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;    <span class="comment">// 递增char</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">getElement</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> element;&#125;   <span class="comment">// 返回element数据</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">uppercase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element &lt;= <span class="string">'z'</span> &amp;&amp; element &gt;= <span class="string">'a'</span>) &#123;   <span class="comment">// 是小写字母</span></span><br><span class="line">      element += <span class="string">'A'</span> - <span class="string">'a'</span>; <span class="keyword">return</span> element;</span><br><span class="line">    &#125;  <span class="comment">// 返回元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"element "</span> &lt;&lt; element &lt;&lt; <span class="string">"is not lower"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>格式如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span>&lt;char&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 常量成员函数 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Zero To One 0.001]]></title>
      <url>/2018/01/10/cpp/cpp-notes-01/</url>
      <content type="html"><![CDATA[<p>接下来, 准备archive每天实际编程中遇到的C++问题，解决问题的过程， 以及得到的结果。以此来熟悉C++的各种特性。</p>
<p>这样做或许会造成知识点离散, 因此, 后续有必要有选择的，对某些特性进行深入剖析。先破破的来吧，以致于我不会从一个细节陷阱中出来，又陷入另一个。</p>
<h2 id="右移，左移"><a href="#右移，左移" class="headerlink" title="右移，左移"></a>右移，左移</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_capacity &gt;&gt;= 1;     // _capacity *= 0.5;</span><br><span class="line">_capacity &lt;&lt;= 1;     // _capacity *= 2;</span><br></pre></td></tr></table></figure>
<h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new delete"></a>new delete</h2><p>要先new一个新的, 才能delete旧的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::shrunk() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size &gt; (_capacity/<span class="number">2</span>)) <span class="keyword">return</span>;   <span class="comment">// 规模大于1/2不必缩容</span></span><br><span class="line">  _capacity = <span class="built_in">std</span>::max(_capacity, DEAFAULT_CAPACITY);</span><br><span class="line">  <span class="comment">// 储存一份旧元素, 创建新的数据空间</span></span><br><span class="line">  T* old_elem = _elem; _elem = <span class="keyword">new</span> T[_capacity &gt;&gt;= <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (Rank r = <span class="number">0</span>; r &lt; _size; r++) &#123;</span><br><span class="line">    _elem[r] = old_elem[r];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除旧元素的内存空间</span></span><br><span class="line">  <span class="keyword">delete</span> [] old_elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>new分配空间<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* tarr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi - lo)];</span><br><span class="line">    _size = hi - lo;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*tarr = "</span> &lt;&lt; tarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*_elem = "</span> &lt;&lt; *_elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* tarr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    _size = hi - lo;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*tarr = "</span> &lt;&lt; tarr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*_elem = "</span> &lt;&lt; *_elem &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; _size; i++) &#123;*(_elem+i) = tarr[i];&#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为什么一定要为_elem分配空间? 内存回收问题。 在C++ Primer中具体学习</p>
<h2 id="同一if语句-同一行中的后置递增"><a href="#同一if语句-同一行中的后置递增" class="headerlink" title="同一if语句, 同一行中的后置递增"></a>同一if语句, 同一行中的后置递增</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"---- test in same if statement----"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="comment">// 在同if, for, while中, 对某一变量i后置递增, i前后不变</span></span><br><span class="line">  <span class="keyword">if</span> (equal(i++, arr[i])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"equal\n"</span></span><br><span class="line">                                    &lt;&lt; <span class="string">"now i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一if, for, while语句中, 后置递增返回当前值<br>同一行, 不同语句, 当然会让值产生变化</p>
<h2 id="重载后置-操作符号"><a href="#重载后置-操作符号" class="headerlink" title="重载后置++操作符号"></a>重载后置++操作符号</h2><p>前置递增 operator++()<br>后置递增, 以前置递增为基础 operator++(int i)<br>increment_and_decrement_operators.cpp</p>
<p>递增运算符重载的返回类型:<br><code>为什么返回*_elem 而不是 *this??</code><br>递减运算符重载函数的返回类型是int&amp;<br>*this的类型为Vector<int>, 而*_elem 的类型是int</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>--() &#123;          <span class="comment">// 重载前置--操作符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    _elem[i]--;                    <span class="comment">// 对每个元素-1</span></span><br><span class="line">  <span class="keyword">return</span> *_elem;                    <span class="comment">// 返回当前 *this or *_elem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Vector&lt;T&gt;::<span class="keyword">operator</span>--(<span class="keyword">int</span> i) &#123;          <span class="comment">// 重载后置--操作符</span></span><br><span class="line">  T* e = _elem;</span><br><span class="line">  --*<span class="keyword">this</span>;                         <span class="comment">// 调用前置递减</span></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;C++ Primer 5th&gt;&gt; P502, P421</code></p>
<h2 id="函数指针-和-函数对象"><a href="#函数指针-和-函数对象" class="headerlink" title="函数指针 和 函数对象"></a>函数指针 和 函数对象</h2><p>对无序向量的遍历操作中, 统一对各个元素分别实施visit操作</p>
<p><strong>函数指针</strong>, 只读或者<span style="color:red"><strong>局部性修改</strong></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span> (*visit)(T&amp;))      <span class="comment">// 函数指针</span></span><br><span class="line">  &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) visit(_elem[i]);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数对象</strong>, 可<span style="color:red"><strong>全局性修改</strong></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; &lt;<span class="keyword">template</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST &amp; visit) &#123;        <span class="comment">// 函数对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) visit(_elem[i];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a><span style="color:red"><strong>函数指针</strong></span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLarger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i1 &lt; i2 ? i2: i1;            <span class="comment">// 返回两者较大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h4><p>声明和定义分离:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);</span><br><span class="line"></span><br><span class="line">pf1 = getLarget;</span><br><span class="line">pf1 = &amp;getLarget;       <span class="comment">// 等价,</span></span><br></pre></td></tr></table></figure></p>
<p>个人认为&amp;表达出pf1是个指针的语义明确点。</p>
<p>声明并定义:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = &amp;getLarger;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i_pf1 = (*pf1)(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> i_pf1_2 = (pf1)(<span class="number">3</span>, <span class="number">5</span>);           <span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">int</span> i_pf1_3 = getLarget(<span class="number">3</span>, <span class="number">5</span>);       <span class="comment">// 等价 调用原函数</span></span><br></pre></td></tr></table></figure></p>
<h4 id="赋值-指向新的函数"><a href="#赋值-指向新的函数" class="headerlink" title="赋值, 指向新的函数?"></a>赋值, 指向新的函数?</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i1 &lt; i2 ? <span class="literal">true</span> : <span class="literal">false</span>;      <span class="comment">// i1 &lt; i2, 返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并定义</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = &amp;compareInt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋nullptr:指针没有指向任何一个函数</span></span><br><span class="line">pf = <span class="number">0</span>;</span><br><span class="line">pf = getLarger;     <span class="comment">// error: pf已经被声明成bool(*)(const int&amp;, const int&amp;)</span></span><br><span class="line">pf = increment;     <span class="comment">// error: 同上</span></span><br></pre></td></tr></table></figure>
<p>能重新指向一个nullptr或0, 但是不能指向一个与声明类型不同的新函数地址。</p>
<p><code>但如果是一个类型相同的函数, 便可以重新指向该函数。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">otherCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i1, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">pf = otherCompare;</span><br></pre></td></tr></table></figure>
<h4 id="重载函数的指针"><a href="#重载函数的指针" class="headerlink" title="重载函数的指针"></a>重载函数的指针</h4><p>函数指针 指向重载函数, 需要在声明时, 形参列表和返回类型需要完全匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="keyword">void</span> (*pff1)(<span class="keyword">int</span> *) = &amp;ff;      <span class="comment">// pff1指向ff的 void (int*)版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pff2)(<span class="keyword">int</span>) = &amp;ff;        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">int</span> (*pff3)(<span class="keyword">unsigned</span>) = &amp;ff;    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针作为形参-调用函数指针"><a href="#函数指针作为形参-调用函数指针" class="headerlink" title="函数指针作为形参(调用函数指针)"></a>函数指针作为形参(调用函数指针)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三个参数是函数指针类型</span></span><br><span class="line">void useBigger(const int&amp;, const int&amp;, bool (*pf)(const int&amp;, const int&amp;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时, 传入指向compareInt的指针</span></span><br><span class="line">useBigger(i1, i2, &amp;compareInt);</span><br></pre></td></tr></table></figure>
<p>可以用别名的方法简化定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(compareInt)</span> *FuncP2</span>;    <span class="comment">// FuncP2是指向函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(compareInt)</span> Func</span>;       <span class="comment">// decltype()返回函数类型, Func是函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, FuncP2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;, Func2)</span></span>;   <span class="comment">// 编译器将Func2函数类型自动转换为了函数的指针类型</span></span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h4><p>一般, 别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PF = <span class="keyword">bool</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);      <span class="comment">// PF是函数的指针类型</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="keyword">bool</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;);          <span class="comment">// F是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;          <span class="comment">// 返回函数的指针类型</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;          <span class="comment">// 显式f1返回的是一个指针类型</span></span><br><span class="line"><span class="function">F <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>;           <span class="comment">// Error:F是函数类型, 无法返回一个函数</span></span><br></pre></td></tr></table></figure>
<p>尾置<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto f1(int) -&gt; int(*)(int*, int)</span><br></pre></td></tr></table></figure></p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a><span style="color:red"><strong>函数对象</strong></span></h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载()"></a>重载()</h4><p>说明这个对象, 他可以当作函数来使用。因此需要重载”()”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> iarr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      sum += iarr[i];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用这个函数对象"><a href="#使用这个函数对象" class="headerlink" title="使用这个函数对象"></a>使用这个函数对象</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sum s;</span><br><span class="line"><span class="keyword">int</span> iarr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">s(iarr, n);      <span class="comment">// sum = 21</span></span><br></pre></td></tr></table></figure>
<h4 id="作为其他函数的参数"><a href="#作为其他函数的参数" class="headerlink" title="作为其他函数的参数"></a>作为其他函数的参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象作为另一个函数的形参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CLS&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(CLS &amp; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> iarr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">  c(iarr, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Sum s1;</span><br><span class="line">f(s1);       <span class="comment">// sum = 18</span></span><br></pre></td></tr></table></figure>
<h4 id="回顾一下数据结构中的用法"><a href="#回顾一下数据结构中的用法" class="headerlink" title="回顾一下数据结构中的用法"></a>回顾一下数据结构中的用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST visit) &#123;</span><br><span class="line">  <span class="comment">// 对每个元素执行visit操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;visit(_elem[i]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不能用引用类型?</span></span><br><span class="line"><span class="comment">// no known conversion for argument 1 from ‘Increase&lt;int&gt;’ to ‘Increase&lt;int&gt;&amp;’</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* my error test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void increase(Vector&lt;T&gt; V) &#123;</span></span><br><span class="line"><span class="comment">  V.traverse(Increase(T&amp; e));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Increase&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么不用实例化, 带入参数便可直接调用??</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 位操作 </tag>
            
            <tag> new </tag>
            
            <tag> delete </tag>
            
            <tag> 运算符重载 </tag>
            
            <tag> 函数指针 </tag>
            
            <tag> 函数对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-C]]></title>
      <url>/2018/01/10/dsacpp/02-C/</url>
      <content type="html"><![CDATA[<h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>&#125;;    <span class="comment">// template定义方式</span></span><br></pre></td></tr></table></figure>
<p>模板和模板, 模板和类之间可以互相组合。意味着数据结构之间也可以互相组合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTree</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  Vector&lt;<span class="keyword">int</span>&gt; myVector;    <span class="comment">// Right</span></span><br><span class="line"></span><br><span class="line">  Vector&lt;<span class="keyword">float</span>&gt; myfVector;</span><br><span class="line"></span><br><span class="line">  Vector&lt;BinTree&gt; binForest;       <span class="comment">// Combine with other class;</span></span><br><span class="line">  Vector&lt;Tree&lt;<span class="keyword">int</span>&gt;&gt; binForest;     <span class="comment">// Combine with template;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无序向量: 没有顺序, 甚至不可能排成顺序。</p>
<h2 id="元素访问-寻秩访问"><a href="#元素访问-寻秩访问" class="headerlink" title="元素访问(寻秩访问)"></a>元素访问(寻秩访问)</h2><p>v.get(r), v.put(e)</p>
<p>A[r]</p>
<p>重载下标运算符”[]”<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻秩访问</span></span><br><span class="line"><span class="comment">/* // my test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">T&amp; Vector&lt;T&gt;::operator[](std::size_t n) &#123;    // 这个类 Vector&lt;T&gt;</span></span><br><span class="line"><span class="comment">  assert(n &lt; _size);</span></span><br><span class="line"><span class="comment">  return _elem[n];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span> &#123;   <span class="comment">// 不改变数据成员, 定义成常量成员函数</span></span><br><span class="line">  <span class="comment">// 在vector内部, 定义了秩的类型, 统一用Rank</span></span><br><span class="line">  assert(r &lt; _size);   <span class="comment">// 对下标秩进行溢出检测</span></span><br><span class="line">  <span class="keyword">return</span> _elem[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>左值, 右值, <code>引用??</code><br>引用类型可作为左值。</p>
<p>寻秩访问</p>
<p>代码健壮性简化</p>
<ul>
<li>assert 断言, <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line">assert(r &lt; _size);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="comment">/* my test</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::insert(const Rank r, const int value) &#123;</span></span><br><span class="line"><span class="comment">  // 检查移动后是否需要扩容</span></span><br><span class="line"><span class="comment">  if (++_size &gt; _capacity) expand();</span></span><br><span class="line"><span class="comment">  // 将秩为r后的所有元素后移一位</span></span><br><span class="line"><span class="comment">  for (Rank i = _size-2; i &gt;= r; i--) &#123;     // 为了不覆盖数据, 从尾部开始移动</span></span><br><span class="line"><span class="comment">    _elem[i+1] = _elem[i];     // 向后移动一位</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 在r秩位置上填入要插入的值</span></span><br><span class="line"><span class="comment">  _elem[r] = value;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::insert(<span class="keyword">const</span> Rank r, T <span class="keyword">const</span> &amp;e) &#123;</span><br><span class="line">  <span class="comment">// value不应该是某一中特点的类型, 而应该利用template的特性</span></span><br><span class="line">  assert(<span class="number">0</span>&lt;= r &amp;&amp; r &lt; _size);</span><br><span class="line">  expand();  <span class="comment">// 若有必要扩容  结合expand()中, _size &lt; _capacity的定义</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">// 习惯把改变后的值的索引设置成i</span></span><br><span class="line">    _elem[i] = _elem[i<span class="number">-1</span>];     <span class="comment">// 后继元素顺次后移一个单元</span></span><br><span class="line">  _elem[r] = e; _size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Template中泛型T的作用,<br>模板类中函数的互相搭配,<br>插入元素对vector操作的顺序<br>对_capacity和_size的影响。</p>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p>自前向后的迁移操作<br>缩容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::del(const Rank lo, const Rank hi) &#123;</span></span><br><span class="line"><span class="comment">  for (Rank i = lo; i &lt; _size; i++) &#123;</span></span><br><span class="line"><span class="comment">    // 清空区间元素</span></span><br><span class="line"><span class="comment">    if (i &lt; hi) &#123; _elem[i] = 0;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">      // 将元素整体前移</span></span><br><span class="line"><span class="comment">      _elem[i - (hi-lo)] = _elem[i];</span></span><br><span class="line"><span class="comment">      // 前移后元素清空</span></span><br><span class="line"><span class="comment">       _elem[i] = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 缩短规模和空间容量</span></span><br><span class="line"><span class="comment">  _size -= hi-lo; _capacity -= hi-lo;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::del(Rank lo, Rank hi) &#123;</span><br><span class="line">  <span class="comment">// 处理退化情况</span></span><br><span class="line">  <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> length = hi - lo;</span><br><span class="line">  <span class="comment">// 自前向后的迁移操作</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; _size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt; _capacity) &#123;_elem[lo++] = _elem[hi++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;_elem[lo++] = <span class="number">0</span>;&#125;   <span class="comment">// 处理hi++超出_capacityg容量的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新规模或者缩容</span></span><br><span class="line">  _size -= length;</span><br><span class="line">  shrunk();</span><br><span class="line">  <span class="comment">// 返回被删除元素的数目</span></span><br><span class="line">  <span class="keyword">return</span> hi-lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>1, 规模仍旧不变? 删除一段区间, 这里可以不改变规模, 相当于后面留空?</code> 改进成改变size的版本用于shrunk<br><code>2 , _elem[hi++]能够被一直索引到?</code> 超过_capacity时, 返回未定义的值<br><code>3, _elem[hi++]为什么不清空?</code>把_capacity的剩余空间对应元素赋值给它的方法清空<br><code>4, 看出移动操作过程中, 变量的同步性</code><br><code>5, 缩容不光光是改变_capacity的值, 仍旧要释放空间</code></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>无序向量： T为可判等, 重载 “==”或者”!=”<br>有序向量： T为可比较，重载 “&lt;” 或  “&gt;”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">int Vector&lt;T&gt;::find(Rank lo, Rank hi, T const &amp;e) const &#123;</span></span><br><span class="line"><span class="comment">  // 查找e在区间[lo,hi)内</span></span><br><span class="line"><span class="comment">  // 从右往左查找</span></span><br><span class="line"><span class="comment">  while (hi &gt;= lo) &#123;</span></span><br><span class="line"><span class="comment">    if (_elem[hi] == e) &#123;return hi;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    hi--;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // 没有在while循环中返回, 不存在匹配元素</span></span><br><span class="line"><span class="comment">  return -1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Rank Vector&lt;T&gt;::find(Rank lo, Rank hi, T <span class="keyword">const</span> &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// O(hi - lo) = O(n), 在命中多个元素时可返回秩最大者</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi-- &amp;&amp; e != _elem[hi]) &#123;&#125;   <span class="comment">// 逆向查找</span></span><br><span class="line">  <span class="keyword">return</span> hi;   <span class="comment">// hi &lt; lo失败; 否则hi即命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>利用while本身的条件语句；后置递增的特性</code><br><code>返回hi?</code> 将判断是否成功, 交给<code>上层的调用者</code>;以及成功后被<code>上层算法</code>进一步利用</p>
<p>最好情况 O(1), 最坏情况O(n)<br>输入敏感(input-sensitive): 最好情况和最坏情况相差悬殊的算法。</p>
<h2 id="删除单元素"><a href="#删除单元素" class="headerlink" title="删除单元素"></a>删除单元素</h2><p><code>视为区间操作的特例</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除单个元素</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::remove(Rank r) &#123;</span></span><br><span class="line"><span class="comment">  // 单元素的删除操作, 视为区间操作的特例 [r, r+1)</span></span><br><span class="line"><span class="comment">  remove(r, r+1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// 删除向量中秩为r的元素, 0 &lt;= r &lt; size</span></span><br><span class="line">T&amp; Vector&lt;T&gt;::remove(Rank r) &#123;  <span class="comment">// O(n-r)</span></span><br><span class="line">  T&amp; <span class="keyword">old_t</span> = _elem[r];    <span class="comment">// 备份被删除的元素</span></span><br><span class="line">  remove(r, r+<span class="number">1</span>);         <span class="comment">// 调用区间删除算法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">old_t</span>;           <span class="comment">// 返回被删除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>颠倒考虑</code></p>
<p>复杂度分析:<br>每次循环的耗时正比于删除区间的后缀长度 O(n-hi)<br>循环的次数等于区间宽度 O(hi-lo)<br>总体 O(n^2) 复杂度</p>
<p>right, but not fast!!</p>
<h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><p><code>实现</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::deduplicate(Rank lo, Rank hi) &#123;</span></span><br><span class="line"><span class="comment">  // 对向量中的元素遍历,</span></span><br><span class="line"><span class="comment">  for (Rank i = lo; i &lt; hi; i++) &#123;</span></span><br><span class="line"><span class="comment">    // find右往左查, 返回lo-1代表失败</span></span><br><span class="line"><span class="comment">    // 删除当前元素, 不再对后续元素查找</span></span><br><span class="line"><span class="comment">    if (find(lo, i, _elem[i]) != lo-1) &#123;remove(i); break;&#125;</span></span><br><span class="line"><span class="comment">    if (find(i+1, hi, _elem[i]) != i) &#123; remove(i);&#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class="line">  <span class="keyword">int</span> old_size = _size;</span><br><span class="line">  Rank i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; _size) &#123;</span><br><span class="line">    find(<span class="number">0</span>, i, _elem[i]) &lt; <span class="number">0</span> ?</span><br><span class="line">                             i++  <span class="comment">// 小于0说明无雷同, 继续查找</span></span><br><span class="line">                             : remove(i);    <span class="comment">// 删除雷同者(至多一个?!)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  old_size - _size;      <span class="comment">// 返回规模的变化量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>记录规模?</code> 考虑返回值怎么设计，这里我估计会在更高级的接口中用到<br><code>从1开始?</code> 因为要在当前i的前缀中查找<br><code>至多一个?</code> 删除至多一个, 实际不一定至多一个<br><code>为什么不需要改变_size和_capacity大小?</code> 说明remove为更底层的操作, 在底层操作中, 定义底层的数据成员的修改, 这样做的话, 在更高级的操作中, 可以不去管这些细节。也是封装调用的好处。</p>
<p><code>**正确性证明**</code>：<br><strong>不变性</strong>: 对于当前元素V[i]的前缀V[0, i)中, 各元素彼此互异<br>初始时, i = 1, 两个元素成立,…</p>
<p><strong>单调性</strong>:<br>1)前缀单调非降, 后缀减少, 且前缀迟早增至_size;   // 与1)结合<br>2)后缀单调下降, _size迟早减至0;     // 2)更容易把握</p>
<p>故算法必然终止, 至多迭代O(n)轮</p>
<p><code>复杂度</code></p>
<p>主要来自find() 和 remove();<br>find()从右向左针对前缀, remove()从左向右针对后缀, 因此每次while循环不超过O(n);<br>while循环会进行n次,<br>总体复杂度为 O(n^2)</p>
<p><code>练习三种优化方案（未完成）</code></p>
<p>1, 仿照uniquify()高效版本的思路.<br>元素移动的次数可以降至O(n), 但比较次数依然是O(n^2); 而且破坏稳定性<br>2, 先对需要删除的重复元素标记, 然后统一删除.<br>稳定性保持, 但因查找长度更长, 从而导致更多的对比操作<br>3, V.sort().uniquify(): 简明实现最优的O(nlogn)</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>visit</p>
<p><a href="https://timtingwei.github.io/2018/01/10/cpp/cpp-notes-01/">关于函数指针和函数对象的笔记</a><br>函数指针机制 ?? </p>
<p>函数对象机制 ??</p>
<p>两种方法优劣</p>
<p>实例: 将向量中所有的元素统一加一<br>重载操作符 “++”<br>重载操作符 “()”</p>
<p>练习更为复杂的遍历</p>
<h3 id="减1"><a href="#减1" class="headerlink" title="减1"></a>减1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历运用函数对象机制，对各个元素减1</span></span><br><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">// 单个T类型元素减1的类</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">Vector&lt;T&gt;::struct Decrease &#123;</span></span><br><span class="line"><span class="comment">  virtual void operator() &#123;T &amp;e--;&#125;     // 重载()操作, 类对象当作函数来用</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void decrease(Vector&lt;T&gt;&amp; V) &#123;</span></span><br><span class="line"><span class="comment">  V.traverse(Decrease&lt;T&gt;());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 泛型模板在调用的时候都要带&lt;type&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Decrease</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;e)</span> </span>&#123;e--;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrease</span><span class="params">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Decrease&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么不是Vector-struct-Decrease"><a href="#为什么不是Vector-struct-Decrease" class="headerlink" title="为什么不是Vector::struct Decrease?"></a>为什么不是Vector<t>::struct Decrease?</t></h4><p>// Decrease对象, 不需要声明在vector类内, 这是借用函数对象作为traverse的参数, traverse声明在类内, 这个参数的类型是VST, 即函数对象。</p>
<h4 id="为什么需要virtual"><a href="#为什么需要virtual" class="headerlink" title="为什么需要virtual"></a>为什么需要virtual</h4><h4 id="void-operator-T-amp-e"><a href="#void-operator-T-amp-e" class="headerlink" title="void operator()(T &amp;e)?"></a>void operator()(T &amp;e)?</h4><p>// 第一个括号是代表重载运算符是(), 第二个是该重载函数的参数列表</p>
<h4 id="三个函数之间的关系"><a href="#三个函数之间的关系" class="headerlink" title="三个函数之间的关系?"></a>三个函数之间的关系?</h4><p>Decrease<t>(T&amp;)函数对象, Vector<t>::traverse(VST&amp;)遍历函数, decrease(Vector<t>)</t></t></t></p>
<p>// 在类的外部定义decrease函数, 它具有泛型T, 参数为Vector<t>&amp; 类型<br>// decrease()函数内部, 实例V调用traverse方法, 通过多次调用这个函数对象去遍历所有元素</t></p>
<h4 id="为什么需要函数对象"><a href="#为什么需要函数对象" class="headerlink" title="为什么需要函数对象?"></a>为什么需要函数对象?</h4><h4 id="本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢"><a href="#本质问题-为什么需要函数对象or-函数指针-为什么不直接调用函数呢" class="headerlink" title="本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?"></a>本质问题: 为什么需要函数对象or 函数指针,  为什么不直接调用函数呢?</h4><p>将遍历traverse作为一种统一的接口, 具体的操作让其他的函数对象来完成, 这样子的接口相对清晰。</p>
<h3 id="加倍"><a href="#加倍" class="headerlink" title="加倍"></a>加倍</h3><p>Double(T &amp;e)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Double_value</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>&#123;e *= <span class="number">2</span>;&#125;   <span class="comment">// 函数对象对元素翻倍</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_value</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  V.traverse(Double_value&lt;T&gt;());      <span class="comment">// 函数对象作为遍历函数的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><h4 id="函数中传入指针"><a href="#函数中传入指针" class="headerlink" title="函数中传入指针"></a>函数中传入指针</h4><p>Sum(T&amp; e, T* sumPtr)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用于traverse的求和函数对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct Sum &#123;</span><br><span class="line">  virtual void operator()(const T&amp; e, T* sumPtr) &#123;(*sumPtr) += e;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; template &lt;typename VST&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::traverse(VST visit, T* e) &#123;</span><br><span class="line">  // 重载traverse(), 对Sum对象函数传入保存求和结果的指针</span><br><span class="line">  for (int i = 1; i &lt; _size; i++) visit(_elem[i], e);   // 从第二个值开始累加</span><br><span class="line">  return *e;       // 返回求和结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Sum()函数对象中传入的参数, 在traverse的visit中定义好的, 因此需要重载traverse函数, 让它传入一个保存求和结果的指针。</strong></p>
<p>前面都没什么问题,<br>实际调用的函数, 第一次我是这样写的, 返回的结果正确无误。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_ptr</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  T* sumPtr = &amp;(V[<span class="number">0</span>]);        <span class="comment">// 别定义空指针, 该指针指向向量首位</span></span><br><span class="line">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class="comment">// 调用并赋值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但print_vector()之后<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- --------print_vector--------- --</span><br><span class="line">_size = 3</span><br><span class="line">_capacity = 10</span><br><span class="line">0:52                 ==&gt; _elem的首位被修改, 原本应该是10</span><br><span class="line">1:24</span><br><span class="line">2:18</span><br><span class="line">3:0</span><br><span class="line">4:0</span><br><span class="line">5:0</span><br><span class="line">6:0</span><br><span class="line">7:0</span><br><span class="line">8:0</span><br><span class="line">9:0</span><br></pre></td></tr></table></figure></p>
<p>因为Sum函数对象中, 会通过解引用指针, 不小心修改了V[0]的值!!!</p>
<p>于是我便做了如下修改:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_ptr</span><span class="params">(Vector&lt;T&gt;&amp; V)</span> </span>&#123;</span><br><span class="line">  T sum_init = V[<span class="number">0</span>];              <span class="comment">// 创建一个副本, 避免通过指针修改V[0]</span></span><br><span class="line">  T* sumPtr = &amp;(sum_init);        <span class="comment">// 别定义空指针, 该指针指向副本</span></span><br><span class="line">  T sum = V.traverse(Sum&lt;T&gt;(), sumPtr);     <span class="comment">// 调用并赋值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- --------print_vector--------- --</span><br><span class="line">_size = 3</span><br><span class="line">_capacity = 10</span><br><span class="line">0:10</span><br><span class="line">1:24</span><br><span class="line">2:18</span><br><span class="line">3:0</span><br><span class="line">4:0</span><br><span class="line">5:0</span><br><span class="line">6:0</span><br><span class="line">7:0</span><br><span class="line">8:0</span><br><span class="line">9:0</span><br></pre></td></tr></table></figure>
<h5 id="重载函数什么时候用virtual"><a href="#重载函数什么时候用virtual" class="headerlink" title="重载函数什么时候用virtual?"></a>重载函数什么时候用virtual?</h5><h4 id="类内static存放"><a href="#类内static存放" class="headerlink" title="类内static存放"></a>类内static存放</h4><p>static sumStc<br>静态数据成员在类内部声明, 外部定义, 作用相当于全局变量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类内static求和的函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum_static</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> T <span class="keyword">sum_t</span>;     <span class="comment">// 内部声明存放求和结果的static变量</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">sum_t</span> += e; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"revise static sum_t, sum_t = "</span></span><br><span class="line">                          &lt;&lt; <span class="keyword">sum_t</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 当心全局变量出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Sum_static&lt;T&gt;::<span class="keyword">sum_t</span> = <span class="number">0</span>;   <span class="comment">// 外部定义静态数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_static</span><span class="params">(Vector&lt;T&gt; V)</span> </span>&#123;</span><br><span class="line">  Sum_static&lt;T&gt; sumstc;           <span class="comment">// 实例化模板别忘记&lt;type&gt;</span></span><br><span class="line">  V.traverse(Sum_static&lt;T&gt;());</span><br><span class="line">  T sum = sumstc.<span class="keyword">sum_t</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"in sum_static, sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于static, 我的相关练习<a href="https://github.com/timtingwei/cppd/blob/master/tmp/static.cpp" target="_blank" rel="noopener">source code</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 向量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-B]]></title>
      <url>/2018/01/10/dsacpp/02-B/</url>
      <content type="html"><![CDATA[<h1 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h1><h2 id="静态管理空间"><a href="#静态管理空间" class="headerlink" title="静态管理空间"></a>静态管理空间</h2><p>_capacity固定, 存在不足:</p>
<blockquote>
<p>1, 上溢(overflow）, _elem[]不足以存放元素<br>2, 下溢(underflow), _elem[]中元素寥寥无几<br>装填因子(load factor) = <em>size/ </em> capacity &lt;&lt; 50% 空间利用率低</p>
</blockquote>
<h1 id="动态管理空间"><a href="#动态管理空间" class="headerlink" title="动态管理空间"></a>动态管理空间</h1><p>蝉的哲学：每过一段时间，身体生长，以致于无法外壳容纳自己的身体，退去一层外壳，但之以容纳新的外壳。</p>
<p>即将发生<strong>上溢</strong>，适当扩展容量</p>
<h2 id="扩容算法实现"><a href="#扩容算法实现" class="headerlink" title="扩容算法实现"></a>扩容算法实现</h2><p>最终的扩容代码如下: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;    <span class="comment">// 容量未到达不必扩容</span></span><br><span class="line">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    <span class="comment">// 不小于最小容量</span></span><br><span class="line">  <span class="comment">// 存储旧元素, 新数组容量扩大</span></span><br><span class="line">  T* old_elem = _elem; _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">    _elem[i] = old_elem[i];   <span class="comment">// 复制原数组到新数组的对应位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> [] old_elem;    <span class="comment">// 释放原数组的对应空间，归还系统</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外尝试两种出现BUG的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* my test code</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class="line"><span class="comment">  if (_size == _capacity) &#123;   // 规模到达最大容量时</span></span><br><span class="line"><span class="comment">    // 创建一个容量更大的数组</span></span><br><span class="line"><span class="comment">    T* _new_elem = new T[_capacity *= 1.2];  // ERROR:没有delete又重新new了一个</span></span><br><span class="line"><span class="comment">    Rank _tmp_size = _size;</span></span><br><span class="line"><span class="comment">    _size = 0;</span></span><br><span class="line"><span class="comment">    // 复制原数组到新数组的对应位置</span></span><br><span class="line"><span class="comment">    copyFrom(this-&gt;_elem, 0, _tmp_size);</span></span><br><span class="line"><span class="comment">    // 释放原数组的对应空间，归还系统</span></span><br><span class="line"><span class="comment">    delete [] _elem;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最终版本的expand()中, new一个数组储存旧元素, 下面new一个数组, 作为扩容数组</span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">void Vector&lt;T&gt;::expand() &#123;</span></span><br><span class="line"><span class="comment">  if (_size &lt; _capacity) return;    // 容量未到达不必扩容</span></span><br><span class="line"><span class="comment">  _capacity = max(_capacity, DEAFAULT_CAPACITY);    // 不小于最小容量</span></span><br><span class="line"><span class="comment">  // 存储旧元素, 新数组容量扩大</span></span><br><span class="line"><span class="comment">  T* new_elem = new T[_capacity &lt;&lt;= 1];</span></span><br><span class="line"><span class="comment">  for (int i = 0; i &lt; _size; i++) &#123;</span></span><br><span class="line"><span class="comment">    new_elem[i] = _elem[i];   // 复制原数组到新数组的对应位置</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  // ERROR:不能直接赋值, 需要copyFrom(), 这里对_elem的更新不直接, 先新后旧的原则</span></span><br><span class="line"><span class="comment">  _elem = new_elem;      // ERROR:当前数组元素更新为新数组元素, 可T类型还没有operator=()</span></span><br><span class="line"><span class="comment">  delete [] new_elem;    // 释放临时数组的对应空间，归还系统</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>第二种错误代码分析：</p>
<blockquote>
<ul>
<li>备份一份旧的, 把当前的刷成新的。</li>
<li>创建一份新的, 把旧的拷贝过去， 在赋值给旧的。这种方法做了多余的操作。</li>
</ul>
</blockquote>
<p>封装的好处</p>
<blockquote>
<ul>
<li><code>得益于向量的封装, 尽管扩容之后数据区的物理地址有所改变, 却不致出现野指针</code>, 封装后，上述通过_elem统一的指示器标记起点.</li>
</ul>
</blockquote>
<p>为何必须采用容量加倍</p>
<blockquote>
<ul>
<li>递增式扩容</li>
<li>加倍式扩容</li>
</ul>
</blockquote>
<h1 id="递增式扩容"><a href="#递增式扩容" class="headerlink" title="递增式扩容"></a>递增式扩容</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_elem = <span class="keyword">new</span>[T = _capacity + INCREMENT];     <span class="comment">// 追加固定大小量</span></span><br></pre></td></tr></table></figure>
<p>每次扩容, 复制原向量的成本<br>I, 2I, 3I, … (m-1)I           // 算术级数</p>
<p><span style="color:red"><strong>算术级数</strong></span>:从某个数开始, 以固定间隔为<br>单位, 不断的线性递增，总和成为算术级数。<strong>总和和末项成平方关系</strong></p>
<p>总耗时 = I <em> (m-1) </em> m/2 = O(n^2), 每次O(n)</p>
<h1 id="加倍式扩容"><a href="#加倍式扩容" class="headerlink" title="加倍式扩容"></a>加倍式扩容</h1><p>1, 2, 4, 8, 16…2^m 次扩容           // 几何级数<br>几何级数与末项等阶, O(n)</p>
<p>总耗时O(n), 每次扩容分摊成本为O(1)</p>
<p>空间上的牺牲, 在时间上获得巨大的收益。</p>
<h1 id="分摊复杂度"><a href="#分摊复杂度" class="headerlink" title="分摊复杂度"></a>分摊复杂度</h1><h2 id="平均分析-vs-分摊分析"><a href="#平均分析-vs-分摊分析" class="headerlink" title="平均分析 vs 分摊分析"></a>平均分析 vs 分摊分析</h2><p><code>平均分析(average/ expected complexity)</code><br>独立事件, 割裂相关性<br>往往不能准确反应。</p>
<p><code>分摊分析(amortized complexity)</code><br>连续的, 足够多的操作。<br>实际可行，整体考量。<br>更为真实反应。</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 复杂度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-02-A]]></title>
      <url>/2018/01/10/dsacpp/02-A/</url>
      <content type="html"><![CDATA[<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><p>如何根据同一接口规范，定制ADT和实现implementation一个数据结构?<br>如何通过更有效的算法，使得对外接口更高效的工作?</p>
<ul>
<li>search </li>
<li><p>sort</p>
<p><code>Abstract Data Type vs. Data Structure</code></p>
<p>抽象数据类型 = 数据模型 + 定义在该模型上的一组操作<br>数据结构     = 基于某种特定语言，实现ADT的一套算法</p>
</li>
</ul>
<h1 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h1><h2 id="数组到向量"><a href="#数组到向量" class="headerlink" title="数组到向量"></a>数组到向量</h2><p>数组是连续的内存空间，均匀划分成若干个单元，而每一个单元都与[0, n)的<strong>编号一一对应</strong></p>
<p>A[i] = A + i * s, s为单个元素所占空间量, 故亦称作线性数组(linear array)</p>
<p>向量是数组的抽象和泛化， 由一组元素按照线性次序封装而成<br>与[0, n)内的<strong>秩(rank)</strong>一一对应    // 循秩访问(call-by-rank)<br>元素类型不限于基本类型<br>操作，管理维护更加简化安全。<br>可更为简便的参与更复杂的数据结构的定制。</p>
<h1 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h1><h2 id="Vector模板类"><a href="#Vector模板类" class="headerlink" title="Vector模板类"></a>Vector模板类</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank;             <span class="comment">// 秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEAFAULT_CAPACITY 3   <span class="comment">// 默认初始容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* ... 构造函数*/</span></span><br><span class="line">  <span class="comment">/* ... 析构函数*/</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>应用和实现相互分离;<br>实现对内部数据项的封装。</p>
<h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span>   <span class="comment">// 向量模板类</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity; T* _elem;   <span class="comment">// 规模, 容量, 数据区</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/* ... 内部函数*/</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// /* ... 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(T* <span class="keyword">const</span> A, Rank lo, Rank hi)</span></span>;</span><br><span class="line">  Vector(<span class="keyword">int</span> c = DEAFAULT_CAPACITY)</span><br><span class="line">  &#123;_elem = <span class="keyword">new</span> T[_capacity = c]; _size = <span class="number">0</span>;&#125;     <span class="comment">// 默认</span></span><br><span class="line">  Vector(T* <span class="keyword">const</span> A, Rank lo, Rank hi)          <span class="comment">// 数组区间复制</span></span><br><span class="line">  &#123;copyFrom(A, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi)   <span class="comment">// 向量区间复制</span></span><br><span class="line">  &#123;copyFrom(V, lo, hi);&#125;</span><br><span class="line">  Vector(Vector&lt;T&gt; <span class="keyword">const</span>&amp; V)                     <span class="comment">// 向量整体复制</span></span><br><span class="line">  &#123;copyFrom(V._elem, <span class="number">0</span>, V._size);&#125;</span><br><span class="line">  <span class="comment">//  */</span></span><br><span class="line">  <span class="comment">// /* ... 析构函数</span></span><br><span class="line">  ~Vector() &#123;<span class="keyword">delete</span> [] _elem;&#125;                   <span class="comment">// 释放内部空间</span></span><br><span class="line">  <span class="comment">// */</span></span><br><span class="line">  <span class="comment">/* ... 只读函数*/</span></span><br><span class="line">  <span class="comment">/* ... 可写函数*/</span></span><br><span class="line">  <span class="comment">/* ... 遍历函数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom(T* <span class="keyword">const</span> A, Rank lo, Rank hi) &#123;</span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span>*(hi- lo)];      <span class="comment">// 分配空间</span></span><br><span class="line">  _size = <span class="number">0</span>;  <span class="comment">// 清零规模</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi)   <span class="comment">// A[lo, hi)中的元素逐一</span></span><br><span class="line">    _elem[_size++] = A[lo++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 向量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-01-F]]></title>
      <url>/2018/01/10/dsacpp/01-F/</url>
      <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work  \<br>Make it right - 递归<br>Make it fast  - 迭代<br>     – Kent Beck</p>
<p><code>动态规划</code>: 通过递归找出算法本质，并且给出了初步解，再讲其等效成迭代形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span> &gt; n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work, right, but not fast.</p>
<h1 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h1><p>$^36 = 2^25,  ==&gt; $^43 = 2^30 = (2^10)^3 = 10^9 flo = 1sec<br>$^5 = 10,     ==&gt; $^67 = 10^14 flo = 10^5 sec = 1 day</p>
<h1 id="递归跟踪"><a href="#递归跟踪" class="headerlink" title="递归跟踪"></a>递归跟踪</h1><p>效率低的原因是递归实例被重复调用。</p>
<p><code>解决方法A(记忆:memoization)</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_memoization</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> mem_lst[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将已经计算的结果, 制成表备查</span></span><br><span class="line">  <span class="keyword">if</span> (is_exist(mem_lst[n])) &#123;</span><br><span class="line">    <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> &gt; n) &#123;mem_lst[n] = n;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mem_lst[n] = fib_memoization(n<span class="number">-1</span>, mem_lst) +</span><br><span class="line">          fib_memoization(n<span class="number">-2</span>, mem_lst);</span><br><span class="line">      <span class="keyword">return</span> mem_lst[n];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>解决方法B 动态规划</code><br>上楼梯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_dynamic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;          <span class="comment">// fib(0) = 0; fib(1) = 1;</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) &#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太能理解, 先放着</p>
<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><code>子序列(Subsequence)</code>: 有序列中若干字符，按原相对次序构成</p>
<p><code>最长公共子序列(Longest common subsequence)</code>，两个序列公共子序列的最长者</p>
<p>可能有多个，可能有歧义</p>
<p><code>实现</code></p>
<p>暂时还实现不了</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>理解了一下，方法上有差异，思想上为自下而上的求解，有那么点在gh中做的时候的思想在里面。</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-01-E]]></title>
      <url>/2018/01/10/dsacpp/01-E/</url>
      <content type="html"><![CDATA[<h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><p>分而治之：分解成子问题，递归式的求解。</p>
<p>空间复杂度：指不包含算法的输入本身所占的空间之外，所需要的另加的用于计算所必须的空间总量。</p>
<h1 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 合                合并</span><br><span class="line">----&gt;    问题   --------</span><br><span class="line">^      /      \        ^</span><br><span class="line">| 缩减/        \ 平凡   |</span><br><span class="line">|	   /          \       |</span><br><span class="line"> -&gt; 子问题     子问题 &lt;---</span><br><span class="line"> !     !         !    !</span><br><span class="line"> -------         ------</span><br><span class="line">   治              治</span><br></pre></td></tr></table></figure>
<p>-—例子1—–<br><code>求n个总数之和</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A为整数数组, n为问题规模, 返回数组中整数的总和</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">      (n &lt; <span class="number">1</span>) ?</span><br><span class="line">      <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析:</strong></p>
<blockquote>
<ul>
<li>该问题分解为一个缩减问题sum(A, n-1) 和 一个平凡问题A[n-1]</li>
<li>最后规模小到一定程度时， 缩减问题变为 平凡问题</li>
<li>将两个问题合并得到结果</li>
</ul>
</blockquote>
<p><strong>复杂度如何？</strong></p>
<p><code>递归跟踪(recursion trace)</code>分析 (用于简单的递归)</p>
<ul>
<li>检查每个<span style="color:red"><strong>递归实例</strong></span></li>
<li>累积所需要时间（调用语句本身抹去，计入递归实例）</li>
<li>其总和是算法执行时间<br>||          ||<br>vv          vv<br><code>线性递归</code>：得出上述递归是线性递归，复杂度渐进O(n)</li>
</ul>
<p><code>递推方程</code>分析 (用于复杂的递归)<br>上述例子中:<br>T(n) = T(n-1) + O(1)         // recurrence<br>T(0) = O(1)                  // base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) ...</span><br><span class="line">         = T(2) - 2</span><br><span class="line">		 = T(1) - 1</span><br><span class="line">		 = T(0) - 0 = O(1)</span><br><span class="line"></span><br><span class="line">T(n) = O(1) + n = O(n)</span><br></pre></td></tr></table></figure>
<p>-——例子2—————–<br><code>任给数组A[0,n), 将其前后颠倒</code>            // 更一般的子区间[lo, hi]<br><strong>统一接口</strong> : void reverse(int * A, int lo, int hi);</p>
<p><code>递归版</code></p>
<p>规模缩小两个单位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 输入指向数组A的指针, A中要转置的左区间lo， A中要转置的右区间lo</span></span><br><span class="line">  <span class="comment">// 无返回值，改变指针A所指向的数组, 使其倒序</span></span><br><span class="line">  <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">    swap(&amp;(A[lo]), &amp;(A[hi]));</span><br><span class="line">    <span class="keyword">if</span> (((hi-lo) == <span class="number">1</span>) || ((hi - lo) == <span class="number">0</span>)) <span class="keyword">return</span>;</span><br><span class="line">    reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析时间复杂度：</p>
<p><code>递归跟踪(recursion trace)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main();</span><br><span class="line">reverse(A[n], lo, hi);</span><br><span class="line">reverse(A[n-2], lo+1, hi-1);</span><br><span class="line">reverse(A[n-4], lo+2, hi-2);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">reverse(A[1], lo+(n-1)/2, hi+(n-1)/2);</span><br><span class="line">or</span><br><span class="line">reverse(A[0], lo + n/2, hi+ n/2);</span><br><span class="line">      (n-1)/2 , n是奇数</span><br><span class="line">     /                   </span><br><span class="line">O(1)*                    = O(n)</span><br><span class="line">     \n / 2,    n是偶数</span><br></pre></td></tr></table></figure></p>
<p><code>递推方程</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) = T(n) + O(1);</span><br><span class="line">T(n) - n = T(n-1) - (n-1)</span><br><span class="line">T(n) - n = T(2) - 2</span><br><span class="line">         = T(0) - 0</span><br><span class="line">T(n) = T(0) + n = O(n)</span><br></pre></td></tr></table></figure></p>
<p>&lt;span style=”color”:blue”&gt;<em>感觉不怎么正确??</em></p>
<p>课后推敲:</p>
<p><code>迭代原始版本</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_iterate_original</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代原始版本</span></span><br><span class="line">next:</span><br><span class="line">  <span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">  &#123;swap(&amp;A[lo], &amp;A[hi]); lo++; hi--; <span class="keyword">goto</span> next;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><em>使用next作为分支标记,goto跳转，真的能让代码运行，从来没用过</em></span></p>
<p><code>迭代精简版</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_iterate</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代版本</span></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi) swap(&amp;A[lo++], &amp;A[hi--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="分而治之-divide-and-conquer"><a href="#分而治之-divide-and-conquer" class="headerlink" title="分而治之(divide-and-conquer)"></a>分而治之(divide-and-conquer)</h1><p>分解为多个或两个子问题，得到解后归并。<br>-—–二分递归———-</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mid_sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组求和 :二分递归</span></span><br><span class="line">  <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">  <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> mid_sum(A, lo, mid) + mid_sum(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>注意 mid + 1</strong></span></p>
<p>// 分析:<br>// 被分解成两个相似问题，mid_sum(n/2)<br>// 规模每次缩减一半，最后到达递归基<br>// 将多个问题结果合并</p>
<p>分析复杂度:</p>
<p><code>递归跟踪(几何归纳)</code></p>
<p>以2为倍数的<strong>几何级数</strong>，总和与<strong>末项同阶</strong>。</p>
<p><code>递推方程(代数运算)</code></p>
<p>两个问题都是n/2<br>累加O(1)时间<br>递归基O(1)时间返回</p>
<p>递推关系<br>T(n) = 2* T(n/2) + O(1)<br>T(1) = O(1)</p>
<p>..<br>T(n) = O(n)</p>
<h1 id="Max2-迭代1"><a href="#Max2-迭代1" class="headerlink" title="Max2: 迭代1"></a>Max2: 迭代1</h1><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]   // A[x1] &gt; A[x2]<br>比较次数要尽可能的少</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2_three_iters</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;   <span class="comment">// 1 &lt; n = hi - lo</span></span><br><span class="line">  <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> x1, x2;</span><br><span class="line">  <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">    <span class="keyword">if</span> (max1 &lt; A[i]) &#123;max1 = A[i]; x1 = i;&#125;       <span class="comment">// hi-lo-1 = n-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x1 != lo) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i_lo  = lo; i_lo &lt; x1; i_lo++)</span><br><span class="line">      <span class="keyword">if</span> (max2 &lt; A[i_lo]) &#123;max2 = A[i_lo]; x2 = i_lo;&#125; <span class="comment">// x1-lo-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x1 != hi) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i_hi = x1+<span class="number">1</span>; i_hi &lt;= hi; i_hi++)</span><br><span class="line">      <span class="keyword">if</span> (max2 &lt; A[i_hi]) &#123;max2 = A[i_hi]; x2 = i_hi;&#125; <span class="comment">// hi-x1-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> max_array[<span class="number">2</span>] = &#123;max1, max2&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A[x1] = "</span> &lt;&lt; A[x1] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">" A[x2] = "</span> &lt;&lt; A[x2] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总共比较n-1+n-2 =2n-3 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历一次，改变指针</span></span><br><span class="line">  <span class="keyword">int</span>* x1 = &amp;lo;</span><br><span class="line">  <span class="keyword">int</span> lo_next = lo + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>* x2 = &amp;lo_next;</span><br><span class="line">  <span class="keyword">if</span> (A[*x1] &lt; A[*x2]) &#123;x1 = &amp;lo_next; x2 = &amp;lo;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[*x2] &lt; A[i]) &#123;      <span class="comment">// 索引i的对象比较小的值大</span></span><br><span class="line">      <span class="keyword">if</span> (A[*x1] &lt; A[i]) &#123;    <span class="comment">// 索引i的对象甚至超过了较大值</span></span><br><span class="line">        x2 = &amp;(*x1); x1 = &amp;i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      *x2 = i;                <span class="comment">// x1指针指向的元素赋值成i</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" A[*x1] "</span>  &lt;&lt; A[*x1] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">            &lt;&lt; <span class="string">" A[*x2] "</span>  &lt;&lt; A[*x2] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况: 1 + (n-2)<em>1 = n-1<br>最坏情况: 1+ (n-2) </em>2 = 2n-3</p>
<p><code>即使在最坏情况，也更高效的改进算法</code></p>
<blockquote>
<ul>
<li>分而治之</li>
<li>实现退化情况</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp; x1, <span class="keyword">int</span> &amp; x2)</span> </span>&#123;     <span class="comment">// [lo, hi)</span></span><br><span class="line">  <span class="keyword">if</span> (lo + <span class="number">2</span> == hi) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[lo] &lt; A[lo+<span class="number">1</span>]) &#123;</span><br><span class="line">      x1 = A[lo+<span class="number">1</span>]; x2 = A[lo];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x2 = A[lo+<span class="number">1</span>]; x1 = A[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;                         <span class="comment">// T(2) = 1</span></span><br><span class="line">  <span class="keyword">if</span> (lo + <span class="number">3</span> == hi) &#123;       <span class="comment">// lo, lo+1, lo+2, lo+3; 19, 2, 3, -1;</span></span><br><span class="line">    x1 = lo, x2 = lo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (A[x1] &lt; A[x2]) &#123;x1 = lo+<span class="number">1</span>; x2 = lo;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo+<span class="number">2</span>; i &lt; hi+<span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[i] &gt; A[x2]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[x1]) &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = x1;</span><br><span class="line">          x1 = i; x2 = tmp;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x2 = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;                         <span class="comment">// T(3) &lt;= 3</span></span><br><span class="line">  <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> x1L, x2L; max2(A, lo, mid, x1L, x2L);</span><br><span class="line">  <span class="keyword">int</span> x1R, x2R; max2(A, mid+<span class="number">1</span>, hi, x1R, x2R);</span><br><span class="line">  <span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">    x1 = x1L; x2 = (x2L &lt; x1R) ? x1R:x2L;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x1 = x1R; x2 = (x2R &lt; x1L) ? x1L:x2R;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 1 + 1 = 2</span></span><br></pre></td></tr></table></figure>
<p>最坏情况: T(n) = 2 * T(n/2) + 2 &lt;= 5n/3 -2</p>
<p><code>递推方程推导过程:</code> ? </p>
<p><code>最好情况复杂度:</code> ?</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种重要算法策略：减而治之，分而治之</p>
<p>两种分析方法：递归跟踪和递推方程</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-01-C]]></title>
      <url>/2018/01/10/dsacpp/01-C/</url>
      <content type="html"><![CDATA[<p>渐进分析: 大O记号 </p>
<p>好读书不求甚解。</p>
<p>考察DSA（考察人）:</p>
<blockquote>
<ul>
<li>长远</li>
<li>主流,</li>
</ul>
</blockquote>
<p>渐进分析(Asymptotic Analysis) n &gt;&gt; 2, 对于规模为n输入，算法</p>
<ul>
<li>需要执行的基本操作数: T(n) = ?</li>
<li>..存储单元: S(n) = ?       // 通常不考虑？<strong>教材</strong></li>
</ul>
<p><strong>教材P33</strong></p>
<blockquote>
<ul>
<li>空间复杂度不会超过常数规模，纵然是新开辟的，算法所需的空间总量，也不过与基本操作的次数同阶。从这个意义上，时间复杂度是空间复杂度的天然上限。</li>
<li>但两种情况下会有意义:<ul>
<li>对空间效率也异常在乎(时间复杂度的平凡上界难以令人满意)</li>
<li>数据的输入规模大。</li>
</ul>
</li>
</ul>
</blockquote>
<p>big-O()比T(n), f(n)更简洁，但依然反应增长趋势(长远)</p>
<blockquote>
<ul>
<li>常系数可忽略(主流):O(f(n)) = O(c*f(n))</li>
<li>低次项可忽略(主流)</li>
</ul>
</blockquote>
<p>O(1)<br>常数</p>
<blockquote>
<ul>
<li>2 = 2013 = 2013*2013 = O(1)</li>
<li>效率: 最高效</li>
<li>出现的情况，需要具体分析<pre><code>不含循环，不含分支转向，一定不能有(递归)调用？
</code></pre><strong>教材</strong></li>
</ul>
</blockquote>
<p>O(logn)<br>对数</p>
<blockquote>
<ul>
<li>常底数无所谓</li>
<li>常数次幂无所谓</li>
<li>多项式</li>
<li>效率: 接近于常数</li>
</ul>
</blockquote>
<p>O(n^c)<br>多项式</p>
<blockquote>
<ul>
<li>一般 取最高次<br>线性：所有O(n)函数<br>从O(n)到O(n^2):编程习题主要覆盖范围<br>效率: 已经可令人满意。</li>
</ul>
</blockquote>
<p>O(2^n)<br>指数<br>效率: 算法成本增长极快，通常不可忍受。<br>n^x-&gt;2^n, 是从有效算法到无效算法的分水岭。</p>
<p>2-Subset<br>直觉算法：逐一枚举S的每一个子集，并统计其中元素总和<br>定理:2-Subset is NP-complete<br>意即:就目前模型而言，不存在在多项式时间内回答此问题的算法。<br>     除非，添加条件：分布规律啦, 票的总数啦，</p>
<p>复杂度增长速度表格。</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-01-B]]></title>
      <url>/2018/01/10/dsacpp/01-B/</url>
      <content type="html"><![CDATA[<p>功能：<br>算法:<br>规范：图灵机复位h的原因。 =&gt; 在软件中叫做接口</p>
<p>RAM: Random Access Machine<br>共同之处：无限的空间。<br>寄存器：</p>
<blockquote>
<ul>
<li>常数赋值给RAM             </li>
<li>RAM之间直接赋值 R[i] &lt; R[j]</li>
<li>RAM之间间接赋值 R[i] &lt;- R[R[j]]</li>
<li>RAM+-</li>
<li>判断0跳转      IF R[i] = 0 GOTO l</li>
<li>判断正跳转             &gt; 0</li>
<li>跳转</li>
<li>停止           STOP</li>
</ul>
</blockquote>
<p>概括:<br>对计算工具抽象后的简化。<br>独立于环境和平台，可评判效率。</p>
<blockquote>
<ul>
<li>将执行时间，转化为操作次数。T(n) = 算法为求求解规模为n问题的，所需执行次数</li>
<li><h1 id="这个次数是清晰的，可度量的。"><a href="#这个次数是清晰的，可度量的。" class="headerlink" title="这个次数是清晰的，可度量的。"></a>这个次数是清晰的，可度量的。</h1></li>
</ul>
</blockquote>
<p>RAM实例:Floor<br>向下取整除法, 0 &lt;= c, 0 &lt; d<br>c%d = max {x | d<em>c &lt;= c}<br>    = max {x | d</em>x &lt; 1+c}</p>
<h2 id="R-0-c-1-R-1-d"><a href="#R-0-c-1-R-1-d" class="headerlink" title="R[0] = c+1, R[1] = d"></a>R[0] = c+1, R[1] = d</h2><p>0, R[0] &lt;- c                 // int c = c;<br>1, R[1] &lt;- d                 // int d = d;<br>2, R[2] &lt;- 0                 // int x = 0;<br>3, R[3] &lt;- 1                 // int a = 1;<br>4, R[0] &lt;- R[0] + R[2]       // c++<br>6, R[0] &lt;- R[0] - R[1]       // c-=d<br>7, R[2] &lt;- R[2] + R[3]       // x++<br>8, IF R[0] &gt; 0 GOTO 4        // if c &gt; 0 goto 4<br>9, R[0] &lt;- R[2] - R[3]       // else x– and;<br>9, STOP                      // return R[0] = x</p>
<p>src:</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[<<游戏之旅>>笔记]]></title>
      <url>/2018/01/04/trip-of-game-notes/</url>
      <content type="html"><![CDATA[<p>最近读了云风大大的书, 感谢云风, 对我有所帮助。<br>选读 第1章， 第2章, 3.1, 3.2, 3.3, 3.5.2, 4.4.4, 8.1, 第9章, 13, 14</p>
<h1 id="对我有所启发的points"><a href="#对我有所启发的points" class="headerlink" title="对我有所启发的points"></a>对我有所启发的points</h1><blockquote>
<ul>
<li>写email的建议</li>
<li>C和C++的关系</li>
<li>C++的开发经验</li>
<li>学习C++阅读次序</li>
<li>template的技巧</li>
<li><strong>开发的成功和失败的经验</strong></li>
<li>游戏编程几个反思</li>
<li>后记中编程实践和思考方法 </li>
<li>致谢中云风父亲的背景以及教育方法</li>
</ul>
</blockquote>
<hr>
<h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h1><h2 id="2-1-程序-算法-数据结构"><a href="#2-1-程序-算法-数据结构" class="headerlink" title="2.1 程序 = 算法+数据结构"></a>2.1 程序 = 算法+数据结构</h2><p>计算机解决的问题，看成一个需要求解的函数，</p>
<blockquote>
<ul>
<li>算法：将输入转化为输出的方法。</li>
<li>数据结构: 需要解决问题中的信息用计算机进行的数字描述方法，以及相应的对这些信息的操作。</li>
</ul>
</blockquote>
<h4 id="2-1-1-算法"><a href="#2-1-1-算法" class="headerlink" title="2.1.1 算法"></a>2.1.1 算法</h4><p>时间和空间之间寻求平衡。</p>
<blockquote>
<ul>
<li>空间换时间的做法，非常广泛，即预处理</li>
<li>时间换空间，不容忽视，即使重复计算。</li>
</ul>
</blockquote>
<p>依赖平台特性:</p>
<blockquote>
<ul>
<li>非并行计算机，不考虑用并行来提速。</li>
<li>空间允许随机访问，不是纸带机的顺序。</li>
</ul>
</blockquote>
<h4 id="2-1-2-数据结构"><a href="#2-1-2-数据结构" class="headerlink" title="2.1.2 数据结构"></a>2.1.2 数据结构</h4><p>简单定义：对数据的组织方法，还有对数据组织方式的处理方法。<br>C++已经提供了常见的数据结构，为什么还要学？</p>
<blockquote>
<ul>
<li>学蕴含思想</li>
<li>根据实际情况对数据结构进行改造，更高效。</li>
</ul>
</blockquote>
<h5 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h5><pre><code>有限逻辑上的有序数列，有确定的前驱和后驱；
分为成：数组和链表;

数组:
</code></pre><h5 id="2-堆栈、队列和串"><a href="#2-堆栈、队列和串" class="headerlink" title="2. 堆栈、队列和串"></a>2. 堆栈、队列和串</h5><h5 id="3-树、二叉树及其他"><a href="#3-树、二叉树及其他" class="headerlink" title="3. 树、二叉树及其他"></a>3. 树、二叉树及其他</h5><p><strong>树：</strong><br>有层次的数据集的组织方式。</p>
<p>GUI界面，通常用树来组织；<br>游戏中的对象管理，用树来解决管理上的层次问题。</p>
<p><strong>二叉树:</strong><br>严格来说不算是树。<br>表达式计算，数据压缩，排序查找方面有很多用途。</p>
<p><strong>四叉树、八叉树：</strong><br>空间状态划分，</p>
<blockquote>
<ul>
<li>四叉树：平面</li>
<li>八叉树: 空间</li>
</ul>
</blockquote>
<p>空间: 场景空间+ 调色盘算法等（向量空间）</p>
<p><strong>图：</strong><br>节点没有父子关系，纯粹的点和边的集合。<br>节点和节点之间允许加上一些与它有关的数，称为权(weight)， 带权图称为网络。<br>节点和节点之间可以有方向，也可以无方向。</p>
<p><strong>图应用于现代网络游戏中，多服务器设计，或者三维游戏中的大场景描述，值得开发者好好研究。</strong></p>
<p><strong>映射表</strong><br>std::map,STL最复杂的容器。</p>
<p><strong>禁忌思想，</strong></p>
<blockquote>
<ul>
<li>模拟人的记忆过程，从某点开始，想临近区域扩展解。经过的地方一概进入禁忌状态，为了短期搜索回来，造成循环搜索，会有一个记忆寿命，超过若干步骤后解决禁忌。这个步骤叫做Tabu Length, 禁忌长度。禁忌长度过大会导致计算量增加，过小则会进入循环搜索。</li>
<li>蚂蚁队伍在附近找最高点。任意选择一个起点，一开始就保持队伍胡乱地向周围爬。蚂蚁队伍遵循一个原则，就是不能回到最近经过的位置。</li>
</ul>
</blockquote>
<p>算法一种思想，自己动手实践，了解这些方法，慢慢地就可以真正运用它到实际中去。不光光要会描述一个问题，以适应不同的算法；还要了解更多的算法会让我们更快解决棘手问题。</p>
<h4 id="2-4-优化"><a href="#2-4-优化" class="headerlink" title="2.4 优化"></a>2.4 优化</h4><blockquote>
<ul>
<li>数学方法的改进</li>
<li>预运算来节省时间（空间换时间避免重复运算）或是重复运算来节省空间</li>
<li>简化算法求得近似来取代精确解（或最有解）</li>
<li>改进数据组织方式，用更少的操作处理更多的数据，甚至避免冗杂数据的处理。</li>
</ul>
</blockquote>
<p>碰到棘手的问题，不要先急于找Google,或者问别人，应该自己思考最好的解决方法。每个人都有自己无数的解决方法，每次独立的思考，都是对思维的一次开阔。</p>
<p>&lt;<c语言程序设计400例>&gt;</c语言程序设计400例></p>
<p><strong>C</strong><br>C语言本身是简洁的。语言本身仅仅只是提供了一种用计算机角度实现算法的符号。<br>C语言函数，让问题分而治理它。<br>全局变量，可以让函数之间不通过输入参数来访问一些公有的数据。<br>最让人诟病就是指针的设计。从高级语言的角度来讲，程序员不需要指针。我们只需要有可以指带数据的标识之物。</p>
<p><strong>BASIC</strong></p>
<h3 id="比较解释语言和C语言的不同"><a href="#比较解释语言和C语言的不同" class="headerlink" title="比较解释语言和C语言的不同"></a>比较解释语言和C语言的不同</h3><p>解释型语言：</p>
<blockquote>
<ol>
<li>每运行一次，解释器就读一次，对符号进行翻译</li>
<li>中间状态以严格规定保存起来，在后面的语句需要时被重新加载<br>C语言</li>
<li>在编码后需要多做一些工作，即他们会被翻译成为机器码，运行时就不需要翻译。</li>
<li>编译器对代码同类向合并，最后的机器码会很简洁。</li>
</ol>
</blockquote>
<p>逻辑学教育，BASIC，适合理解编程。</p>
<h1 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="3. 编程语言"></a>3. 编程语言</h1><h2 id="3-3-C"><a href="#3-3-C" class="headerlink" title="3.3 C++"></a>3.3 C++</h2><h3 id="C-的不同理解"><a href="#C-的不同理解" class="headerlink" title="C++的不同理解"></a>C++的不同理解</h3><p>第一印象可能是为了面向对象的设计，实际上C++是一种支持各种编程范式的语言。它支持面向过程的编程，基于对象的编程，面向对象的编程，以及使用template实现的泛型编程。</p>
<h3 id="C对于C-的优势"><a href="#C对于C-的优势" class="headerlink" title="C对于C++的优势"></a>C对于C++的优势</h3><p>简洁，而非高效；适合做小内存的嵌入式系统开发。</p>
<h3 id="但大多数游戏平台，C-比C更适合"><a href="#但大多数游戏平台，C-比C更适合" class="headerlink" title="但大多数游戏平台，C++比C更适合"></a>但大多数游戏平台，C++比C更适合</h3><h2 id="3-4-汇编语言"><a href="#3-4-汇编语言" class="headerlink" title="3.4 汇编语言"></a>3.4 汇编语言</h2><p>合适场合使用汇编，能让程序跑得更快。<br>了解汇编，能让你了解代码最终会以什么形态运行于CPU，对理解高级语言有所帮助，<br>在紧要关头帮忙，程序出现莫名错误，又不能在源码级调整程序。</p>
<h1 id="4-前Windows时代"><a href="#4-前Windows时代" class="headerlink" title="4. 前Windows时代"></a>4. 前Windows时代</h1><h2 id="4-3-保护模式下的开发工具"><a href="#4-3-保护模式下的开发工具" class="headerlink" title="4.3 保护模式下的开发工具"></a>4.3 保护模式下的开发工具</h2><p>个人主页建立之初，我罗列出了个人兴趣 ：…很多。但是大而全的效果是，我一样都做不好，而且和其他人的个人主页相比没有特色。稍加考虑，立刻砍掉了除了游戏开发之外的所有项目。</p>
<blockquote>
<ul>
<li>翻译allgero文档:自己做了一个辅助翻译的工具;细致了解; 交朋友</li>
<li><p>写关于游戏编程技术方面的小文，各处转载</p>
</li>
<li><p>利用假期，走访网上认识的从事游戏开发的朋友，慢慢踏上了游戏制作的道路。</p>
</li>
</ul>
</blockquote>
<p>学习新的技术，翻译一本相关的英语著作可以算是捷径。</p>
<blockquote>
<ul>
<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>
<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>
<li>即使对此有所了解，翻译后也能更上一层楼。</li>
<li>英语水平也会提高。</li>
</ul>
</blockquote>
<h2 id="4-4-闲话allegro"><a href="#4-4-闲话allegro" class="headerlink" title="4.4 闲话allegro"></a>4.4 闲话allegro</h2><h3 id="4-4-4-几何图形和3D"><a href="#4-4-4-几何图形和3D" class="headerlink" title="4.4.4 几何图形和3D"></a>4.4.4 几何图形和3D</h3><p>图形引擎提供，可以绘制一些几何图形，点，线，多边形等等，但制作平面游戏这些并不是必须的，因为游戏中的一切，事先都可以用预先制作好的图片代替掉。</p>
<p>3D游戏，却是基于多边形。通过空间多边形的网络信息，把一些平面的图片，做一些变形，映射到多边形网格上。<br>相关的:</p>
<blockquote>
<ul>
<li>透视映射</li>
<li>矩阵，三维空间中变换的工具, 自带一套矩阵运算。</li>
<li>实现了一套定点数的运算该改善游戏中需要的数学运算速度。</li>
</ul>
</blockquote>
<p><strong>1,定点数</strong><br>巧妙的利用定点数，可以避免许多浮点误差问题，是很有价值的。</p>
<p>浮点数：计算机用一种纯小数加指数的形式表示实数。<br>定点数：利用整数运算来模拟小数的方法，那就是定点数来表示小数。</p>
<p>高16位，表示整数位；低16位，表示小数部分；实际是60000+倍，小数点的位置是固定的。</p>
<p>精读在1/6*10^4, 十进制小数点后四位的精度。</p>
<p>定点数的一些计算技巧和优势：</p>
<blockquote>
<ul>
<li>原本复杂的三角函数计算，可以依照所需要的精度，预先制作好查询表，以空间换取时间。</li>
<li>角度表示方式不是360和2pi, 而是64表示直角， 256表示圆周角。</li>
</ul>
</blockquote>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h2><p>云风关于写email的建议：</p>
<blockquote>
<ul>
<li>回复收到的每封email, 即使没空写， 也让对方知道自己已读。</li>
<li>使用纯文本，发送过大附件前请求</li>
<li>合适的标题，能概括内容；偏题时，修改标题。</li>
<li>删除尽可能多的引信，尤其是对方的签名，对主题表达无意义。</li>
<li>合理分段，表达自己意见，别赞同两字多写一点。</li>
<li>发出之前，读一遍，修改掉错别字和语法错误，核对一次收件人是否正确</li>
<li>不要随意公开转载私人信件，即使转载也注明出处。</li>
</ul>
</blockquote>
<h1 id="8-引擎中的优化"><a href="#8-引擎中的优化" class="headerlink" title="8. 引擎中的优化"></a>8. 引擎中的优化</h1><p>“风魂”中很多蹩脚的编码方法，不成熟的整体架构、非系统的编码规范和不严谨的接口定义，但对于自己干了这件贻笑大方的事情，自己却不后悔。敢于把自己的无知展现给世人，是一种勇气。</p>
<p>只要保持真诚谦逊，错误的存在就能得到理解；整体上或许不完善，但还是有后来者，依旧可以从中学到闪光点，避免踏上弯路。</p>
<h1 id="9-C和C"><a href="#9-C和C" class="headerlink" title="9. C和C++"></a>9. C和C++</h1><h2 id="9-1-从C到C"><a href="#9-1-从C到C" class="headerlink" title="9.1 从C到C++"></a>9.1 从C到C++</h2><p>1, C只提供了CPU本来就提供的操作，把他映射到更容易让人理解和描述的书写形式上。为了让程序员使用，引入了栈上临时变量，和堆上动态变量的概念，而不是直接面向寄存器。</p>
<p>2, C对大块的数据，使用数据指针来表达。</p>
<p>3, C一个个函数组织起来，函数之间按层次调用，去处理那些不同结构的数据</p>
<p>4, C是对汇编语言的一种抽象, 正如汇编语言是对机器底层指令的一个最小幅度的抽象，为了人类方便控制机器。C程序员要做问题描述和机器模型之间的桥梁。</p>
<p>5, C是容易学的，它非常接近机器模型，而机器模型非常简洁，有条理；有效率，接近机器模型；困难性，离实际描述太远，在问题描述和机器模型之间找到对应关系，会随着问题的复杂性提高而急剧增加。</p>
<p><code>困难性的说明</code>，<br>高级语言往往改为对问题本身抽象，把问题归为特定的类别，然后，语言本身只解决这些被抽象的问题，来简单编程的难度，但往往<strong>只能针对特定的类型</strong>。</p>
<p><code>C++面向对象的说明</code></p>
<blockquote>
<ul>
<li>既然保持强大的抽象能力，又保持底层符合机器模型的优势，在设计变得简单的情况下不失效率。</li>
<li>将对象分为不同的类型，每个对象都是这种对象的实例。类型的设计是有层次的，就好像动物是一种大类型，而哺乳动物和爬行动物都属于动物。</li>
</ul>
</blockquote>
<h2 id="9-2-C-vs-C-，-效率至上"><a href="#9-2-C-vs-C-，-效率至上" class="headerlink" title="9.2 C vs C++， 效率至上"></a>9.2 C vs C++， 效率至上</h2><p><code>C++中混有C语言的好处:</code></p>
<blockquote>
<p>1, 更广泛的移植性<br>2, C的思考方式，会让不致于陷入面向对象和泛型编程的泥沼，只是说很容易钻进设计方法的牛角尖<br>3, 良好的C语言接口可能使得模块的使用方法更容易理解，对多人合作和多语言编程是一种好事<br>4, C简洁, 编译速度快</p>
</blockquote>
<h2 id="9-3-优雅的C"><a href="#9-3-优雅的C" class="headerlink" title="9.3 优雅的C++"></a>9.3 优雅的C++</h2><p>将C细化，又不增加额外的开销;<br>不对程序员有过多限制。</p>
<h3 id="9-3-1-宏"><a href="#9-3-1-宏" class="headerlink" title="9.3.1 宏"></a>9.3.1 宏</h3><p><code>宏的作用</code></p>
<blockquote>
<p>1, 定义常数<br>2, 代码生成<br>3, 内联代码<br>4, 对编译流程作出选择</p>
</blockquote>
<p>1, 定义常数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926f;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> PI;</span><br></pre></td></tr></table></figure>
<p>C++会选择inline函数+template定义常数，最终编译器会把它优化成一个常数，而没有对函数调用的消耗。</p>
<p>经典的如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a&lt;b)?(a):(b))</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&lt;b ? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-const修饰以及类型转换"><a href="#9-3-2-const修饰以及类型转换" class="headerlink" title="9.3.2 const修饰以及类型转换"></a>9.3.2 const修饰以及类型转换</h3><h4 id="const修饰"><a href="#const修饰" class="headerlink" title="const修饰"></a>const修饰</h4><p>const chat<em> 而不是 C 的 char</em></p>
<p>将函数参数写成const;<br>成员变量修饰成const, 只有在构造的时构建他们;<br>为成员函数增加一个const, 表达这个函数不会修改类的成员变量</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>C中几乎任何类型都可以任意转换，缘于C汇编的根。<br>C++用static_cast 以模板的语法表达看起来可以互相转换的类型互换</p>
<p>const和const之间的转换，只能通过const_cast转换。</p>
<p>严格描述每个对象的const性质，可以帮助在编译期发生错误减少。</p>
<h3 id="9-3-3-隐藏实现"><a href="#9-3-3-隐藏实现" class="headerlink" title="9.3.3 隐藏实现"></a>9.3.3 隐藏实现</h3><p>好的C++程序会把所有数据都声明成private的，尽量在同一类中暴露过多的public方法，而protected慎用，至少尽量不用在成员数据上。</p>
<p>作为良好的面向对象设计，继承类很少去扩展基类的功能，这样子作为具体实现，被隐藏于接口后，结构变得干净整洁。</p>
<h3 id="9-3-4-引用而非指针"><a href="#9-3-4-引用而非指针" class="headerlink" title="9.3.4 引用而非指针"></a>9.3.4 引用而非指针</h3><p>指针是导致资源被遗忘释放的罪魁祸首。</p>
<blockquote>
<ul>
<li>当旧的指针被赋予新值，旧的值消失，如果消失的值是唯一指向某个对象的地址，那么这个对象控制的资源将永远留在内存中，直到进程结束被系统回收。</li>
</ul>
</blockquote>
<p>引用和指针在实现本质上是完全相同的，但引用的语法只能在构造的那一刻被赋值，并永远不能修改。</p>
<p>C++优雅设计中，会用引用代替成员变量中的指针，而减少实现类的时候不小心犯错误。</p>
<h3 id="9-3-5-命名空间"><a href="#9-3-5-命名空间" class="headerlink" title="9.3.5 命名空间"></a>9.3.5 命名空间</h3><p>引用外部的名字空间到当前位置。可以防止不同库之间的名字冲突。</p>
<h2 id="9-4-C-的误区"><a href="#9-4-C-的误区" class="headerlink" title="9.4 C++的误区"></a>9.4 C++的误区</h2><p>自己的一条准则： 尽可能地使用结构最简单的工具来完成任务，直到这个工具不合适。</p>
<p>举例:</p>
<blockquote>
<ul>
<li>能用C写的程序，不用C++；能用C的原生数组的情况不用std::vector。能用std::vector的情况不要用std::map, 能自己写的代码不用第三方库。</li>
</ul>
</blockquote>
<p>解释：</p>
<blockquote>
<ul>
<li>没有完美的程序，也没有完美的原则。</li>
<li>不主张写C++的标准库，重写MFC或者广为大众所使用的代码。大多数C++程序员，没到达这个技术理解。</li>
</ul>
</blockquote>
<h3 id="9-4-1-类层次过细"><a href="#9-4-1-类层次过细" class="headerlink" title="9.4.1 类层次过细"></a>9.4.1 类层次过细</h3><p>会造成间接调用引起的损耗。</p>
<h3 id="9-4-2-滥用操作符重载"><a href="#9-4-2-滥用操作符重载" class="headerlink" title="9.4.2 滥用操作符重载"></a>9.4.2 滥用操作符重载</h3><p>为了让用户写出的类适用于现存的模板，让用户构造的对象和C++原生的类型有相同的表现，操作符重载是有意义的。<br>如果仅仅是让程序看起来紧凑，或者是类使用起来“好玩”，那就是对其的滥用了。</p>
<h3 id="9-4-3-滥用标准容器"><a href="#9-4-3-滥用标准容器" class="headerlink" title="9.4.3 滥用标准容器"></a>9.4.3 滥用标准容器</h3><p>用std::vector就不想再碰语言中的原生数组，用过std::string, 就不知道 const char* 是为何物，这是许多C++程序员的通病。</p>
<p><code>std::map可以这样子做，</code><br>如果只是为了创建一张key-value的对应表可供查询，完全可以用<br>key-value对应的关系记录下来，只做一次排序，在检索的时候可以使用二分查找查找，一种快捷又节省内存的方法。</p>
<h3 id="9-4-5-滥用多重继承"><a href="#9-4-5-滥用多重继承" class="headerlink" title="9.4.5 滥用多重继承"></a>9.4.5 滥用多重继承</h3><p>会造成实现过于复杂，几乎所有的多重继承问题，都可以化为组合方式来解决。</p>
<h3 id="9-4-6-忽视C-高级特性的复杂度"><a href="#9-4-6-忽视C-高级特性的复杂度" class="headerlink" title="9.4.6 忽视C++高级特性的复杂度"></a>9.4.6 忽视C++高级特性的复杂度</h3><p>如果把两种复杂度高的特性运用于项目中，其复杂度不是两倍，而是平方。</p>
<h3 id="9-4-7-学习C"><a href="#9-4-7-学习C" class="headerlink" title="9.4.7 学习C++"></a>9.4.7 学习C++</h3><p>我现在无法把自己学会的东西，理解的东西借助文字教给入门者，因为许多的知识需要自己在实践中领悟。过多的细节，太快地展现出来反而会增加学习的复杂度，难以消化。</p>
<p>因此，需要</p>
<blockquote>
<p>1，学<br>2, 用<br>3, 思考<br>2, 回到1</p>
</blockquote>
<p>如果期望C++成为自己开发中的利器，应该尽量多用C++做项目，尽量可能地体验更多的设计方法，用心去写程序，而不是单单去实现而已。自己写出的代码，多多思考，对感觉不好的部分重新设计。</p>
<p>推荐一个阅读次序:</p>
<blockquote>
<p>1, 先学会C，只是也是C++子集的部分。<br>2, &lt;<c++编程思想>&gt;<br>3, &lt;<c++ primer="">&gt; 和 &lt;<c++ programing="" language="">&gt;<br>4, C++ 标准文档(1998定制，电子档)，遇到问题不是去查某本教材，而是直接翻阅文档。<br>5, &lt;<c++的发展和演化>&gt;，深入了解C++设计的根源以及C++编译器实现方法入手.<br>6, &lt;&lt;深度探索C++物件模型&gt;&gt;对追求高效的C++程序员尤为受用。</c++的发展和演化></c++></c++></c++编程思想></p>
</blockquote>
<p>进阶学习: 需要一定的开发经验才能阅读</p>
<blockquote>
<ul>
<li>&lt;<effective c++="">&gt;, &lt;<more effective="" c++="">&gt;, &lt;<c++沉思录>&gt;</c++沉思录></more></effective></li>
<li>泛型编程&lt;<stl 源码剖析="">&gt;，有点难，但是花上一定的时间一定有收获。</stl></li>
<li>&lt;<c++设计新思维------泛型编程与设计模式之应用>&gt;template使用自信，对泛型编程感觉良好，</c++设计新思维------泛型编程与设计模式之应用></li>
<li>&lt;<c++标准程序库>&gt;想更精通标准库，C++程序员案头必备的参考手册。</c++标准程序库></li>
<li>&lt;<effective stl="" 中文版="">&gt;， 与前面的effcive系列一样</effective></li>
</ul>
</blockquote>
<h3 id="9-5-3-再论动态内存分配"><a href="#9-5-3-再论动态内存分配" class="headerlink" title="9.5.3 再论动态内存分配"></a>9.5.3 再论动态内存分配</h3><p>//…</p>
<p>理解动态内存的捷径，自己写一个内存分配器。从一大块给定的内存上，分配出用户提交的内存。</p>
<h3 id="9-6-template"><a href="#9-6-template" class="headerlink" title="9.6 template"></a>9.6 template</h3><p>template最初只为了取代C++语言的宏设计，后来被赋予了实例化的特性，可以针对某些特别的类型做特殊的操作。</p>
<h4 id="9-6-1-封装C-的成员函数的调用"><a href="#9-6-1-封装C-的成员函数的调用" class="headerlink" title="9.6.1 封装C++的成员函数的调用"></a>9.6.1 封装C++的成员函数的调用</h4><h4 id="9-6-4-避免重复代码"><a href="#9-6-4-避免重复代码" class="headerlink" title="9.6.4 避免重复代码"></a>9.6.4 避免重复代码</h4><p><code>大部分程序错误的根源:</code></p>
<blockquote>
<ul>
<li>在多个地方表达相似的概念，意味着日后改动一个地方，就必须记得改动相似的所有地方。而直接复制这些代码，导致编译器并不知道这些地方的相似性，不能为你提供帮助。而人，随着项目扩大，几乎不可能记住做过多少次这种复制动作。</li>
</ul>
</blockquote>
<p>没有意识到在重复，可以用加强对代码糟糕味道的嗅觉敏感度和提高作为编码者的责任心来达到。</p>
<p>举个blit()例子</p>
<h4 id="9-6-5-选择最佳的容器"><a href="#9-6-5-选择最佳的容器" class="headerlink" title="9.6.5 选择最佳的容器"></a>9.6.5 选择最佳的容器</h4><p>很多语言都提供了一种未定义类型的变量，可以用来保存各种不同类型的变量。而C++没有提供这样的类型，但是可以用template来模拟一个，也就是设计一个容器存放不同类型的对象。</p>
<p>对于一个容器到底是保存</p>
<blockquote>
<ul>
<li>对象指针</li>
<li><p>对象值</p>
</li>
<li><p>对于体积较大的对象，保存指针, 复制很快</p>
</li>
<li>对于体积较小的对象，保存对象值, 减少间接；减少指针空间的占用</li>
</ul>
</blockquote>
<p>可以利用模板在编译期间由编译器自动进行；</p>
<h4 id="9-6-5-延迟计算"><a href="#9-6-5-延迟计算" class="headerlink" title="9.6.5 延迟计算"></a>9.6.5 延迟计算</h4><p>由于涉及到了关于重载运算符的内容，暂且通读。大概是讲，可以自定义一种运算方式，但是又要对这种运算方式进行优化，所以需要模板的帮助，在编译期就对他进行不同函数的选择。</p>
<h4 id="9-6-7-编译时的计算游戏（未完成）"><a href="#9-6-7-编译时的计算游戏（未完成）" class="headerlink" title="9.6.7 编译时的计算游戏（未完成）"></a>9.6.7 编译时的计算游戏（未完成）</h4><p>三个数排序<br>+</p>
<h3 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7 小结"></a>9.7 小结</h3><p>早犯一天错误，就可以早一天改正错误。</p>
<h1 id="13-开发方法"><a href="#13-开发方法" class="headerlink" title="13. 开发方法"></a>13. 开发方法</h1><h2 id="13-1-失败的经验"><a href="#13-1-失败的经验" class="headerlink" title="13.1 失败的经验"></a>13.1 失败的经验</h2><blockquote>
<p>1, 过多的工作压力压到一个人身上。<br>2, 过分的弹性工作制<br>3, 没完没了的变化和返工<br>4, 没有及时的测试<br>5, 项目的主导严重偏向了某一职位上</p>
</blockquote>
<p><code>1, 过多的工作压力压到一个人身上。</code><br>迫于压力，无法学习新的东西，使用好方法解决问题。独揽大局，只能解决眼前碰到的bug, 耦合度太高。</p>
<p><code>2, 过分的弹性工作制</code><br>兴奋时效率高，停下来几天没有进展也可能发生。到了项目后期，bug重重，受到挫折之后，失去新鲜感，假借弹性工作制之名，导致怠工拖垮项目。放弃的时候，并非没有压力，可能只是不知道下一步该怎么做，或是问题太多，无法入手，项目已经失控。</p>
<p><code>3, 没完没了的变化和返工</code><br>想法太多，什么都想加入进来，导致最后漏洞很多。</p>
<p><code>&gt; 4, 没有及时的测试</code><br>很少有严格的测试，而是把错误积累。 </p>
<p><code>5, 项目的主导严重偏向了某一职位上</code><br>程序员，策划，美术，盲目的跟从和固执的坚持自己都可能会影响整个项目.</p>
<h2 id="13-2-成功的经验"><a href="#13-2-成功的经验" class="headerlink" title="13.2 成功的经验"></a>13.2 成功的经验</h2><blockquote>
<p>1, 引擎和实现的分离<br>2, 结对编程（XP 极限编程）<br>3, 随时方便地测试<br>4, 尽早发现结构上的问题, 并尽早重构<br>5, 其他</p>
</blockquote>
<p><code>1, 引擎和实现的分离</code><br>早期的程序员都是研究图形显示的技术开始的，总想表达更绚丽的图案，游戏程序变成了代码的集合。<br>许多程序员都是模块见耦合度过高，对于软件的整体稳定性不利。<br>和图形图像打交道的人，整个团队一个人就够了，他不需要去管任何的游戏的逻辑。</p>
<p>其他还包括，图像处理模块，声音，网络，时钟，文件读写，windows窗口控制，需要和操作系统直接打交道的东西，不管多简单都应该分离。</p>
<p><code>2, 结对编程</code><br>找个水平差的不太远的程序员和自己配成一对，只有一台计算机，大家选一个人坐在键盘前，另外一个人口述。两个人需要不断的交流，频率不应该低于一分钟一次。整个设计思想是由后面只动口不动手的人主导，而由键盘操作的人实现。由于人的思维速度是快于键盘输入的速度的，那么观看的人有空闲的时间可以用来思考，很容易看出代码和结构的问题。</p>
<p>潜在问题的代码，在XP极限编程中，被称做代码的<strong>坏味道</strong>。</p>
<p>好处:</p>
<blockquote>
<p>1, 促进参与项目的程序员的自身的提高。水平较低的学习新东西，水平较高的把思路说出来整理思路。<br>2, 参与项目人员互换位置，使得维护繁杂的文档不再那么重要，一旦有人离开，项目不会受到影响。大家的交流更顺畅，关系更融洽。<br>3, 提高工作效率。单独工作遇到问题刷网站，而这种方法是交流解决问题。互相监督和激65励。</p>
</blockquote>
<p><code>3, 随时方便地测试</code><br>测试应该从开发者开始，从项目一开始就开始。</p>
<p><code>4, 尽早发现结构上的问题, 并尽早重构</code></p>
<p><code>5, 其他</code></p>
<p>脚本和版本控制。<br>软件开发的素养。</p>
<h1 id="14-编程和游戏"><a href="#14-编程和游戏" class="headerlink" title="14. 编程和游戏"></a>14. 编程和游戏</h1><p>技术派在挖空心思模拟出更真实，更绚丽的画面；创意派在为自己构思的游戏中的一个绝妙的主意沾沾自喜。<br>而忽略了一些更重要的东西。</p>
<h2 id="14-1-操作"><a href="#14-1-操作" class="headerlink" title="14.1 操作"></a>14.1 操作</h2><p>任何一个游戏都是玩家和程序之间通过操作设备进行交互产生乐趣。</p>
<h2 id="14-2-角色设定"><a href="#14-2-角色设定" class="headerlink" title="14.2 角色设定"></a>14.2 角色设定</h2><p>生动的角色，RPG，增加游戏气氛</p>
<h2 id="14-3-操作技术"><a href="#14-3-操作技术" class="headerlink" title="14.3 操作技术"></a>14.3 操作技术</h2><p><code>3D和2D</code></p>
<blockquote>
<ul>
<li>应该由游戏本身的需要决定。</li>
<li>3D技术问题是通过一些近似算法而不是数学上严格的方案，得到令人满意的效果。</li>
<li>2D技术怎样控制和管理不断膨胀的图片数量</li>
</ul>
</blockquote>
<h2 id="14-4-浅谈网络游戏"><a href="#14-4-浅谈网络游戏" class="headerlink" title="14.4 浅谈网络游戏"></a>14.4 浅谈网络游戏</h2><p><code>社会性</code><br>除了传统的游戏它自身的娱乐性之外，还存在一种社会性。<br>因为社会性，就更需要在游戏中设计完备的经济体系，追踪货币的流通，实物的交换，弄清游戏社会中的经济是如何运作的。</p>
<p>看似不是程序的事情，但非程序的策划很难去做：</p>
<blockquote>
<ul>
<li>大规模的数字采集和统计的工作</li>
<li>大规模所要求的服务器架构，需要减轻数据库负担，减轻服务器压力，必须在设计上针对硬件水平作出精简。只有熟悉软件架构的人才能去做。</li>
</ul>
</blockquote>
<p><code>平衡性</code></p>
<blockquote>
<ul>
<li>传统游戏中渡过来的方法，多数是依靠经验而不是数学推算来解决，慢慢的会变得不那么有效果。</li>
<li>程序员有数学和计算机运算工具的能力，可以完善为平衡而更理论化的工具。</li>
</ul>
</blockquote>
<h2 id="14-5-小结"><a href="#14-5-小结" class="headerlink" title="14.5 小结"></a>14.5 小结</h2><p>一个好的游戏程序员和策划之间的界限往往很模糊，所以游戏程序员除了编程方面的修养，各个领域的只是都应该有所涉猎，以提高自身的修养。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>技术问题，固然本源的方法，理论变化不大。但计算机这种偏重工程的实践，一旦实际化到具体上，却有日新月异的变化，想要搞清楚问题，不是朝夕之功，只好借着自己对旧知识的理解去参悟新的知识。</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>记得在初中毕业前夕，我曾经萌发过放弃上重点高中乃至上大学的想法。但是，面对盛怒之后，老泪纵横的父亲，第一次看到父亲的眼泪时，我理解了，理解了一个求知欲如此强烈的人却由于时代的错误，甚至连高中都没有机会去读，在繁忙的工作中，熬夜自学考上大学的人，怎能不对自己的儿子在学业上有更高的期望呢。</p>
]]></content>
      
        
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 游戏 </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于文档学习方法和图形学学习的随想]]></title>
      <url>/2017/12/28/doc-computer-graphic-learn/</url>
      <content type="html"><![CDATA[<p>上篇笔记<a href="http://timtingwei.github.io/2017/12/25/hello-triangle-three-execises/">OpenGL绘制三角形附练习</a>来来回回写了三天，当然，除了学习外，我还去练习了网球，还去参加了一次grasshopper草猛歌会；学习openGL之外，我同时在学习dsa, 看了云风的<code>&lt;&lt;游戏之旅&gt;&gt;</code>， 查阅了OpenGL与图形引擎的相关资料, </p>
<h2 id="BLOG整理文档学习方法"><a href="#BLOG整理文档学习方法" class="headerlink" title="BLOG整理文档学习方法"></a>BLOG整理文档学习方法</h2><p>从云风的书中偶得一段话，</p>
<p><code>学习新的技术，翻译一本相关的英语著作可以算是捷径。</code></p>
<blockquote>
<ul>
<li>比囫囵吞枣的读一遍英文原文要有效的多。</li>
<li>因为有责任感，必须用心搞清楚每一个句子的意思，以免错误而误导阅读你的译作的人们。</li>
<li>即使对此有所了解，翻译后也能更上一层楼。</li>
<li>英语水平也会提高。</li>
</ul>
</blockquote>
<p><code>发现产生了一些共鸣。</code><br>其中之一，是之前学习Grasshooper的一段经历，我学grasshopper已经是0.76版本了, NCF那一批人开始学习也是10左右的事情了，那个时候他们组织学运算器的方式也跟这个很相似，就是翻译Help, 所以有了<code>&lt;&lt;grasshopper运算器手册&gt;&gt;</code>一书。不知道是否这种是共通的？还是因为他们中也有程序员，亦或者是因为grasshopper变成了程序爱好者，理解了这种方式？</p>
<p>之二是石老师推荐学生翻译<code>&lt;&lt;Form Space &amp; Order&gt;&gt;, &lt;&lt;Parten Language&gt;&gt;, &lt;&lt;A New Kind of Science&gt;&gt;</code>等书来学习数字化技术。</p>
<p>我自己也享受到了这些方法的好处，现在又被云风清晰说出了那种模糊的感觉。便开始尝试在写笔记的时候，结合着文档理解下函数原理，并把它们用心整理好。这也是最近开始写博客来的好处，虽然之前一直用evernote记笔记写日记，但是用一种这是要整理给别人看的心态去做一件事情，效果便也很不同，总之这对于技术学习来说是很好的。</p>
<h2 id="图形学学习"><a href="#图形学学习" class="headerlink" title="图形学学习"></a>图形学学习</h2><p>另外，这几天在跟着OpenGL的教程学习，开始对OpenGL和图形学有了模糊的认识：</p>
<blockquote>
<ul>
<li>图形学是研究用计算机如果画出一个图像的学科。</li>
<li>OpenGL教程会教我如何去用封装代码去渲染一个场景，以及背后没展开的图形学原理。</li>
<li>他的封装性，与我原来想象的能够研究一些与计算几何相关的图形问题算法有较大出入。</li>
<li>但是学习封装性能够让我先去了解一个大概，以及算法的具体应用性，等到发现其中核心算法的学习路径，开始学习也为时不晚，一是对图形学有了些理解，二是明白各自使用方向，三是dsa的课程也是那些算法实现的前提，四是每天都能够编写C++找到乐趣和问题。</li>
</ul>
</blockquote>
<p>下面是摘自 <span style="color:red"><strong>Milo Yip</strong></span> 叶神在<a href="https://www.zhihu.com/question/24786878" target="_blank" rel="noopener">知乎</a>上的回答，要借鉴这个学习轨迹, 并以此勉励自己：</p>
<p><code>如何开始用 C++ 写一个光栅化渲染器？</code></p>
<p><strong>Milo Yip</strong><br>计算机图形学、编程、C++ 等 7 个话题的优秀回答者<br>228 人赞同了该回答<br>@空明流转 开发过高大上的SALVIA， @Yong He 则提到了Larrabee。我来提供另一些观点。</p>
<p>首先，如果从学习角度出发，不必一开始完全根据现时GPU的架构及概念，来用软件复制一遍。现时的GPU主要是基于三角形光栅化及z-buffer。</p>
<p>如果我们从图形学的历史进程来学习，可以这样做练习：</p>
<p>2D部分：</p>
<blockquote>
<p>1, 光栅化2D点（就是在二维数组上画点，了解色彩基本原理，并解决影像输出问题）<br>2, 光栅化2D直线（布雷森漢姆直線演算法、吴小林直线算法等）<br>3, 2D直线的剪切算法（见Line clipping）<br>4, 光栅化2D三角形（scan conversion）。避免重复光栅化相邻三角形边界的像素（edge equation）。<br>5, 光栅化简单／复杂多边形<br>3D部分：<br>1, 把顶点从三维世界空间变换至二维屏幕空间，绘画顶点（如银河星系数据），操控摄像机旋转模型。<br>2, 在剪切空间进行3D直线的剪切算法，把顶点连线（如各种三维正多面体）光栅化成wire frame模型<br>3, 以多边形来定义三维模型。使用画家算法来光栅化那些多边形。<br>改为使用深度缓冲。<br>4, 实现简单的纹理映射，先做屏幕空间的插值，然后实现简单的perspective-correct texture mapping。<br>5, 实现简单的顶点光照，使用顶点颜色插值实现Gouraud shading。<br>6, 通过顶点法线插值，实现Phong shading。<br>7, 实现其他贴图技术，如mipmapping（也可试Summed area table）、bilinear/trilinear filtering、bump mapping、normal mapping、environment mapping等。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> OpenGL </tag>
            
            <tag> 读书 </tag>
            
            <tag> 随想 </tag>
            
            <tag> 方法论 </tag>
            
            <tag> 引擎 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[邓俊辉<<数据结构>>-公开课-01-D]]></title>
      <url>/2017/12/28/dsacpp/01-D/</url>
      <content type="html"><![CDATA[<p><span style="color:blue"><em>我把邓老师课上对自己有需要的笔记写下来，并在看完视频后补充教材和课后习题的内容.</em></span></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>运用DSA</p>
<p>算法分析的两个任务</p>
<blockquote>
<ul>
<li>正确性(不变性 * 单调性)</li>
<li>复杂度增长速度表格</li>
</ul>
</blockquote>
<p>C++等高级语言的基本指令，等效于常数条RAM的基本指令；渐进意义下，相当<br>  分支转向：goto   // 算法灵魂；出于结构考虑，被隐藏<br>  迭代循环:for(), while()..   // 本质上 “if+goto”<br>  调用+递归                   // 本质上也是 “goto”</p>
<p>复杂度分析方法:</p>
<blockquote>
<ol>
<li>迭代: 级数求和</li>
<li>递归: 递归跟踪 + 递推方程<br>猜测 + 验证</li>
</ol>
</blockquote>
<h1 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h1><h2 id="算术级数：与末项平方同阶"><a href="#算术级数：与末项平方同阶" class="headerlink" title="算术级数：与末项平方同阶"></a>算术级数：与<strong>末项平方</strong>同阶</h2><h2 id="幂方级数：比幂次高出一阶"><a href="#幂方级数：比幂次高出一阶" class="headerlink" title="幂方级数：比幂次高出一阶"></a>幂方级数：比幂次高出一阶</h2><h2 id="几何级数（a-gt-1）-与末项同阶"><a href="#几何级数（a-gt-1）-与末项同阶" class="headerlink" title="几何级数（a &gt; 1）:与末项同阶"></a>几何级数（a &gt; 1）:与末项同阶</h2><h2 id="收敛级数-O-1"><a href="#收敛级数-O-1" class="headerlink" title="收敛级数:O(1)"></a>收敛级数:O(1)</h2><h2 id="未必收敛，但长度有限"><a href="#未必收敛，但长度有限" class="headerlink" title="未必收敛，但长度有限"></a>未必收敛，但长度有限</h2><p>h(n) = 1 + 1/2 + 1/3 + … + 1/n = O(logn)            // 调和级数<br>log1 + log2 + log3 + … + logn = log(n!) = O(nlogn)  // 对数级数</p>
<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p><code>&lt;&lt;Concrete Math&gt;&gt;</code> 具体数学</p>
<h1 id="循环-vs-级数"><a href="#循环-vs-级数" class="headerlink" title="循环 vs 级数"></a>循环 vs 级数</h1><h2 id="没有耦合的二层循环"><a href="#没有耦合的二层循环" class="headerlink" title="没有耦合的二层循环"></a>没有耦合的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数:  n * n = O(n^2)<br>等效：矩形被填充的过程，时间复杂度等于矩形面积。</p>
<h2 id="耦合的二层循环"><a href="#耦合的二层循环" class="headerlink" title="耦合的二层循环"></a>耦合的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数: n(n-1) / 2 = O(n^2)<br>等效：三角形被填充，复杂度等于矩形面积。</p>
<h2 id="递增不为1的二层循环"><a href="#递增不为1的二层循环" class="headerlink" title="递增不为1的二层循环"></a>递增不为1的二层循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j += <span class="number">2013</span>)</span><br><span class="line">    O1Operation(i, j);</span><br></pre></td></tr></table></figure>
<p>算术级数：O(n^2)</p>
<h2 id="外循环左移一位-加倍"><a href="#外循环左移一位-加倍" class="headerlink" title="外循环左移一位(加倍)"></a>外循环左移一位(加倍)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    O1peration(i, j);</span><br></pre></td></tr></table></figure>
<p>几何级数：O(n)     // ??</p>
<h2 id="更复杂的实例"><a href="#更复杂的实例" class="headerlink" title="更复杂的实例"></a>更复杂的实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;  i; j += j)</span><br><span class="line">    O1peration(i, j);</span><br></pre></td></tr></table></figure>
<h2 id="习题解析"><a href="#习题解析" class="headerlink" title="习题解析"></a>习题解析</h2><h1 id="取非极端元素、冒泡排序"><a href="#取非极端元素、冒泡排序" class="headerlink" title="取非极端元素、冒泡排序"></a>取非极端元素、冒泡排序</h1><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>算法： </p>
<blockquote>
<p>1, 从S中取出三个元素{x, y, z}<br>2, 确定并排除其中的最小值和最大值<br>3, 输出剩下的元素z</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinaryElements</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从n &gt;= 3个互异整数中,除最大、最小者以外,任取一个“常规元素”</span></span><br><span class="line">  <span class="comment">// 先比较a,b;再确定c对于(a,b)区间的关系</span></span><br><span class="line">  <span class="keyword">int</span> a = A[<span class="number">0</span>], b = A[<span class="number">1</span>], c = A[<span class="number">2</span>];    <span class="comment">// 从特定单元读取元素O(3)</span></span><br><span class="line">  <span class="comment">// 统一成区间(a, b), 用于c对其判断</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123; &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c &lt; a) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; b) <span class="keyword">return</span> b;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  <span class="comment">// return 输出非极端数O(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// =======================================</span></span><br><span class="line">  <span class="comment">// T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论:无论输入规模有多大，所需执行该算法的执行时间都不变。</p>
<h2 id="起泡排序问题"><a href="#起泡排序问题" class="headerlink" title="起泡排序问题"></a>起泡排序问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++) &#123;  <span class="comment">// 自左向右逐对检查[0,n)各相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> (A[i<span class="number">-1</span>] &gt; A[i]) &#123;         <span class="comment">// 若逆序,则</span></span><br><span class="line">        swap(&amp;A[i<span class="number">-1</span>], &amp;A[i]);      <span class="comment">// 令其交换位置</span></span><br><span class="line">        sorted = <span class="literal">false</span>;            <span class="comment">// 消除全局有序标记</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>不变性：经k轮扫描交换后，最大的k个元素必然就位<br>单调性：经k轮扫描交换后，问题的规模缩减至n-k<br>正确性：经至多k轮扫描后，算法必然终止，且能给出正确答案</p>
<p>基本且重要的技巧：通过挖掘不变性和单调性，证明算法的正确性</p>
<h1 id="封底估计-Back-Of-The-Envelope-Calculation"><a href="#封底估计-Back-Of-The-Envelope-Calculation" class="headerlink" title="封底估计 Back-Of-The-Envelope Calculation"></a>封底估计 Back-Of-The-Envelope Calculation</h1><p>不需要工具</p>
<p>787km 占据整个周长的1/50 =&gt; 整个周长4wkm</p>
<p>抓住问题的主要方面，简洁得出总体规律</p>
<p>在复杂度分析中，对象是时间。</p>
<h1 id="封底估计实例"><a href="#封底估计实例" class="headerlink" title="封底估计实例"></a>封底估计实例</h1><blockquote>
<ul>
<li>一天: = 24hr <em> 60min </em> 60sec = 25 * 4000 = 10^5 sec</li>
<li>一生: = 1世纪 = 100yr <em> 365 = 3 </em> 10^4 = 3 * 10^9 sec</li>
<li>“50年” = 1.6 * 10^9 sec</li>
<li>三生三世: 300yr = 10^10 = (1 googel)^(1/10) sec</li>
<li>宇宙大爆炸至今: 10^21 = 10^(10^10)^2 sec<br>三生三世是10^10s<br>三生三世中的一天，相当于在一天中的1s<br>整个宇宙中的三生三世，就是在三生三世中的0.1s</li>
</ul>
</blockquote>
<p>1亿 = 10^9</p>
<p>复杂度和浮点运算能力flops相除，能得到某算法的时间。</p>
<p>人口普查 n = 10^9<br>\=====================<br>普通PC 1Ghz 10^9 flops<br>Bullesort: O(n^2) ==&gt; (10^9)^2 = 10^18 </p>
<p>时间: 10^18 / 10^9  = 10^9<br>3<em>10^9 = 100yr, 10^9 = 30年<br>\=====================<br>普通PC  10^9 flops<br>Mergesort: O(n\</em>logn) =&gt; (10^9)*log(10^9) = 30 * 10^9</p>
<p>时间; 30 * 10^9 / 10^9 = 30s<br>\=====================<br>天河1A 10^15 flops<br>Bullesort:</p>
<p>时间:20min: 10^3s<br>\=====================</p>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 复杂度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gitignore-invalid]]></title>
      <url>/2017/12/27/gitignore-invalid/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL绘制三角形附练习]]></title>
      <url>/2017/12/25/hello-triangle-three-execises/</url>
      <content type="html"><![CDATA[<p>代码已托管在<a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started" target="_blank" rel="noopener">/timtingwei/LearnOpenGL</a></p>
<h1 id="图形管线渲染有哪几个阶段？"><a href="#图形管线渲染有哪几个阶段？" class="headerlink" title="图形管线渲染有哪几个阶段？"></a>图形管线渲染有哪几个阶段？</h1><p>顶点数据(Vertex data[])  -&gt;</p>
<blockquote>
<p>1, <strong>顶点着色器</strong>(Vertex Shader) -&gt;<br>2, 形状(图元)装配(Shape Assembly) -&gt;<br>3, <strong>几何着色器</strong>(Geometry Shader) -&gt;<br>4, 光栅化(Rasterization) -&gt;<br>5, <strong>片段着色器</strong>(Fragment Shader) -&gt;<br>6, 测试与混合(Test And Blending)</p>
</blockquote>
<p>三个着色器可以自己定义。</p>
<p><strong>顶点数据(Vertex data)：</strong></p>
<blockquote>
<ul>
<li>Vertex是一个3D坐标的集合</li>
<li>Vertex Data是用顶点属性(Vertex Attribute), 如位置Position, 颜色Color</li>
</ul>
</blockquote>
<p><strong>顶点着色器(Vertex Shader)：</strong></p>
<blockquote>
<ul>
<li>把3D坐标转换成另外一种3D坐标</li>
<li>允许对Vertex Attribute做基本处理</li>
</ul>
</blockquote>
<p><strong>片段着色器(Fragment Shader)：</strong></p>
<blockquote>
<ul>
<li>计算一个像素最终的颜色</li>
<li>着色器包含3D场景数据(光照，阴影，光的颜色)</li>
</ul>
</blockquote>
<p><strong>Alpha测试和混合(Blending):</strong></p>
<blockquote>
<ul>
<li>测试深度，反应前后。</li>
<li>检查Alpha并混合，(同个片段着色器，渲染多个三角形时候的颜色可能不同)</li>
</ul>
</blockquote>
<p>补充: 图元(Primitive):</p>
<blockquote>
<ul>
<li>任何一个绘制指令的调用，都把图元传递给OpenGL。</li>
<li>如GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</li>
</ul>
</blockquote>
<h1 id="绘制绘制三角形"><a href="#绘制绘制三角形" class="headerlink" title="绘制绘制三角形"></a>绘制绘制三角形</h1><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>使用GLSL(OpenGL Shading Language)编写顶点着色器<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core          <span class="comment">// 每个着色器起始于版本声明, core代表核心模式</span></span></span><br><span class="line"></span><br><span class="line">layout (location=<span class="number">0</span>) in vec3 aPos;      <span class="comment">// 设定输入变量的位置值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么需要<strong>layout (location=0)</strong>设定位置值？</p>
<blockquote>
<ul>
<li><strong>glVertexAttributPointer</strong>函数第一个参数指定配置顶点属性，而**layout (location=0) 定义了顶点某变量的position属性。</li>
</ul>
</blockquote>
<p>相关内容in, out, uniform, type类型, 向量组合, main函数，会在下一节，<a href="https://timtingwei.github.io">着色器中</a>讲解</p>
<h2 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h2><p>编写着色器源码后，</p>
<blockquote>
<p>1, 先创建着色器对象;<br>2, 再把源码附加到着色器对象上;<br>3, 编译并检查</p>
</blockquote>
<p><strong>1, 创建顶点着色器对象</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;                         <span class="comment">// ID引用</span></span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);   <span class="comment">// 传递着色器类型参数</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2, 附源码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>glShaderSource</strong>函数的几个参数：</p>
<blockquote>
<p>0, 着色器对象<br>1, 传递的源码字符数量<br>2, 顶点着色器的真正源码<br>3, 先设置为NULL</p>
</blockquote>
<p><strong>3, 编译</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glCompileShader(vertexShader);</span><br><span class="line"><span class="comment">// 检查编译是否成功</span></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="comment">// 如果不成功，用glGetShaderInfoLog获取信息, 存储再InfoLog中，打印</span></span><br><span class="line"><span class="keyword">if</span> &#123;!success&#125; &#123;</span><br><span class="line">  glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>同理顶点着色器，编写着色器源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FragColor =  vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器只有一个vec4作为out, 表示最终的输出颜色, 最后一个值是alpha量</p>
<h2 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h2><p>1, 创建对象<br>2, 附加源码<br>3, 编译并检查</p>
<p>自己重新写一遍, 并检查错误<br>1, 创建对象尝试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">glCreateShader(fragmentShader, GL_FRAGMENT_SHADER);   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">glCreateShader(GL_FRAGMENT_SHADER);     <span class="comment">// DE<span class="doctag">BUG:</span>:不需要用着色器对象作为函数的参数，</span></span><br></pre></td></tr></table></figure></p>
<p>查阅<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glCreateShader.xhtml" target="_blank" rel="noopener">khronos.org - glCreateShader</a></p>
<blockquote>
<ul>
<li>Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.<br>会绑定上下文中的ID创建object, 而且同一ShaderType会被联系起来。</li>
</ul>
</blockquote>
<p>2, 附源码尝试<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(<span class="number">1</span>, fragmentShader, fragmentSource, <span class="literal">NULL</span>)   <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, fragmentShaderSource, <span class="literal">NULL</span>);  <span class="comment">// DE<span class="doctag">BUG:</span>:交换参数位置</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>着色器对象</li>
<li>传递源码字符的数量</li>
</ol>
</blockquote>
<p>3, 尝试编译<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> success;    <span class="comment">// ERROR</span></span><br><span class="line">glCompileShader(GL_FRAGMENT_SHADER, fragmentShader, success); <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* infoLog[<span class="number">512</span>];                                <span class="comment">// ERROR</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="comment">// 失败把报错内容储存再infoLog中输出</span></span><br><span class="line">  glGetShaderinfoLog(fragmentShader, &amp;success, &amp;infoLog);   <span class="comment">// ERROR</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPILE::ERROR::FRAGEMENT::SHADER"</span> </span><br><span class="line">            &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:red"> <em>改正</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glCompileShader(fragmentShader);     <span class="comment">// DE<span class="doctag">BUG:</span>:只要着色器对象一个参数</span></span><br><span class="line"><span class="keyword">int</span> success;                         <span class="comment">// DE<span class="doctag">BUG:</span>: success是一个int类型</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];                   <span class="comment">// DE<span class="doctag">BUG:</span>: char 并非 unsigned cha*</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);   <span class="comment">// DE<span class="doctag">BUG:</span>:获取success在先，才能对success做判断</span></span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  <span class="comment">// 失败输出</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建着色器程序"><a href="#创建着色器程序" class="headerlink" title="创建着色器程序"></a>创建着色器程序</h2><p>绘制图元时，使用的是glUseProgram(shaderProgram), 因此，先要创建着色器程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure>
<h2 id="链接着色器对象"><a href="#链接着色器对象" class="headerlink" title="链接着色器对象"></a>链接着色器对象</h2><p>两个着色器对象要链接。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure></p>
<h2 id="编译着色程序"><a href="#编译着色程序" class="headerlink" title="编译着色程序"></a>编译着色程序</h2><p>与之前的着色器编译原理相同，只是调用函数和参数变量改变了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">  glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后可以glUseProgram函数，激活程序对象。激活后，着色器调用和渲染调用都会使用这个程序对象。</p>
<h2 id="删除着色器"><a href="#删除着色器" class="headerlink" title="删除着色器"></a>删除着色器</h2><p>完成以上几步后不要忘记删除着色器<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure></p>
<h2 id="输入顶点以及索引"><a href="#输入顶点以及索引" class="headerlink" title="输入顶点以及索引"></a>输入顶点以及索引</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点输入</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>赋值array的时候, 不要忘记{};</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">GLuint indices[] = &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>                <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="comment">// ...                 // 可根据vertices数组, 建立多组索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="创建和绑定顶点数组对象-VAO"><a href="#创建和绑定顶点数组对象-VAO" class="headerlink" title="创建和绑定顶点数组对象(VAO)"></a><strong>创建和绑定顶点数组对象(VAO)</strong></h2><p>VAO = Vertex Array Object</p>
<p>功能:</p>
<blockquote>
<ul>
<li>随后的顶点属性调用都会储存在这个VAO之中。</li>
<li>使得在不同顶点数据和属性设置之间切换变得简单。</li>
</ul>
</blockquote>
<p><strong>存储内容</strong>:</p>
<blockquote>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
</blockquote>
<p>使用注意:</p>
<blockquote>
<ul>
<li><strong>先VAO，再绑定和设置VBO, EBO 以及设置顶点属性指针</strong></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);   <span class="comment">// 创建VAO对象</span></span><br><span class="line">glBindVertexArray(VAO);       <span class="comment">// 绑定顶点数组对象</span></span><br></pre></td></tr></table></figure>
<h2 id="创建和绑定顶点缓冲对象-VBO"><a href="#创建和绑定顶点缓冲对象-VBO" class="headerlink" title="创建和绑定顶点缓冲对象(VBO)"></a><strong>创建和绑定顶点缓冲对象(VBO)</strong></h2><p>OpenGL如何解释顶点数据的内存，并指定其如何发送给显卡。</p>
<p>作用:</p>
<blockquote>
<ul>
<li>通过VBO(Vertex Buffer Object)管理这个内存，它会在GPU内存中存储大量顶点。</li>
<li>一次性发送大量数据到显卡上，而不是每个顶点发送一次。CPU发到显卡上速度慢，因此，一次发送多个比较好。而发送过去之后顶点着色器又能够立即访问。</li>
</ul>
</blockquote>
<p><span style="color:blue"><em>我想这个过程应该是发生图形管线渲染的第一个阶段，是顶点数据和顶点着色器如何对接？就是依靠CPU发送到显卡上</em> </span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VBO;</span><br><span class="line">glGenBuffer(<span class="number">1</span>, &amp;VBO);           <span class="comment">// 创建</span></span><br><span class="line"><span class="comment">// 把顶点数组复制到缓存中提供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></p>
<h2 id="索引缓冲对象-EBO"><a href="#索引缓冲对象-EBO" class="headerlink" title="索引缓冲对象(EBO)"></a><strong>索引缓冲对象(EBO)</strong></h2><p>可以创建不同的索引数组，而使用同一个顶点数组。如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint EBO;</span><br><span class="line">glGenBuffer(<span class="number">1</span>, &amp;EBO);                <span class="comment">// 创建</span></span><br><span class="line"><span class="comment">// 把顶点索引复制到缓存中提供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h2 id="设置顶点属性"><a href="#设置顶点属性" class="headerlink" title="设置顶点属性"></a><strong>设置顶点属性</strong></h2><p><img src="/images/vertex_attribute_pointer.png" alt="vertex_attribute_pointer">    </p>
<blockquote>
<ul>
<li>位置数据被储存为32位(4字节)浮点值 =&gt; siezeof(flaot) = 4 types = 32bits</li>
<li>每个位置包含3个这样的值</li>
<li>没有空隙, 紧密排列。</li>
<li>数据中的第一个值再缓冲开始位置。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexattribArray(<span class="number">0</span>);    <span class="comment">// 开启位置为0的顶点属性</span></span><br></pre></td></tr></table></figure>
<p><strong>glVertexAttribPointer参数</strong></p>
<blockquote>
<p>1, 要配置的顶点属性的位置值。输入的参数顶点属性的位置值。还记得之前的 <span style="color:red"><strong>layout (location=0) in vec3 xx</strong></span> 吗？<br>2, 顶点属性的大小。 vec3 =&gt; 3个值组成<br>3, 指定数据类型。 (GLSL中vec*都是由浮点数值组成的)<br>4, 是否被标准化。 GL_TRUE代表是，所有数据(对有符号数据是-1)映射到0到1之间;<br>5, 步长，这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节。因为是紧密排列设置成0也可以，OpenGL自己会设置。</p>
<ol>
<li>偏移量。位置数据在数组开头就设置成0</li>
</ol>
</blockquote>
<p>顶点属性默认是禁用的，要用glEnableVertexAttribArray函数开启。<br>输入的参数顶点属性的位置值。<span style="color:red"><strong>layout (location=0) in vec3 xx</strong></span> </p>
<h2 id="绘制图元"><a href="#绘制图元" class="headerlink" title="绘制图元"></a>绘制图元</h2><p><code>在主循环内部绘制图元。</code></p>
<p>1, 激活程序对象<br>2, 绑定缓存对象<br>3, 绘制<br>4, 解绑缓存对象</p>
<p><strong>绘制两种方式：</strong><br>glDrawArrays();</p>
<blockquote>
<ul>
<li>使用当前绑定的顶点缓存对象进行绘制<br>glDrawElements()</li>
<li>使用当前绑定的索引缓冲对象中的索引进行绘制</li>
</ul>
</blockquote>
<p>第一种，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 使用当前绑定的顶点缓存对象进行绘制</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 解绑缓存对象</span></span><br><span class="line">glBindVertArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>第二种,<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 绑定顶点数组对象 </span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 使用当前绑定的索引缓冲对象中的索引进行绘制</span></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 解绑缓存对象</span></span><br><span class="line">glBindVertArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><span style="color:blue"><em>VAO有种结合VBO+EBO的意思</em></span><br><strong>再回顾一遍它的存储内容</strong>:</p>
<blockquote>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
</blockquote>
<p><code>退出循环后删除对象，释放缓存</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glDeleteVertexArray(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>实现完成一个三角形/矩形的绘制后，对很多问题不是很清楚。如，</p>
<blockquote>
<p>1, 索引缓冲对象EBO绘制和顶点缓冲绘制VBO的区别和联系？<br>2, 顶点着色器和片段着色器之间的关系？<br>3, 设置顶点属性glVertexAttribPointer();函数的几个参数并不理解？</p>
</blockquote>
<h2 id="1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形"><a href="#1-添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形" class="headerlink" title="1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形"></a><strong>1. 添加加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形</strong></h2><p><strong>glDrawArrays();</strong><br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先设置顶点数组</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个triangle</span></span><br><span class="line">    <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,    <span class="comment">// 连接处</span></span><br><span class="line">    <span class="comment">// 第二个triangle</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左上角</span></span><br><span class="line">    <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>     <span class="comment">// 连接处</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);  <span class="comment">// 从顶点数组索引0开始依次绘制6个顶点</span></span><br></pre></td></tr></table></figure>
<p><strong>glDrawElements();</strong><br>根据索引的数组数据渲染图元，可以指定渲染图元的类型，给定一个数量，索引的类型以及指向索引的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点输入</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLuint indices[] = &#123;     <span class="comment">// 索引从0开始</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,               <span class="comment">// 第一个三角形</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>                <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还需要在绑定VAO后绑定VBO和EBO<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活程序对象</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)  <span class="comment">// 索引数组绘制6个顶点</span></span><br></pre></td></tr></table></figure>
<p><span style="color:blue"><em>这里并没有给出索引数组的指针，我估计是绑定VAO后，Draw函数调用会从上下文获得这个指针。不知道这个猜想是否正确。</em></span></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/blob/master/src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp" target="_blank" rel="noopener">练习1源码 - github</a></p>
<hr>
<h2 id="2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO"><a href="#2-创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO" class="headerlink" title="2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO"></a><strong>2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO</strong></h2><p>// 不同VAO和VBO的ID各自放在同一个数组中，可以以数组创建，但需要单独绑定，复制缓存，设置顶点属性，以及单独绘制。</p>
<p><strong>glGenBuffers</strong>(GLsizei n,<br>                GLuint<em> buffers);<br>生成缓存对象的名字，输入缓存名字的数量n以及缓存对象名字存在的数组，返回n个缓存对象名字在<em>*Buffers</em></em>中。直到调用glBindBuffer()，生成的缓存名字才和某一缓存对象绑定在一起。</p>
<p><strong>glGenVertexArrays</strong>(GLsizei n,<br>                      GLuint* arrays);<br>返回n个顶点数组对象名字，存储到arrays指针中。</p>
<p><strong>glBindBuffer(GLenum target,<br>               GLuint buffer);</strong><br>绑定一个已经命名的缓存对象。</p>
<p><em>target</em><br><code>----------------------------------------------------------</code><br><code>GL_ARRAY_BUFFER</code>            |     顶点属性<br><code>GL_ELEMENT_ARRAY_BUFFER</code>    |     顶点数组索引<br><code>GL_TEXTURE_BUFFER</code>          |     纹理数据缓存<br><code>GL_UNIFORM_BUFFER</code>          |     Uniform块存储<br><code>----------------------------------------------------------</code></p>
<p><em>buffer</em><br>    缓存对象的名字</p>
<p><strong>glBindVertexArray</strong>(GLuint array);<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>
<p><strong>glBufferData</strong>(GLenum target<br>                 GLsizeiptr size<br>                 const GLvoid * data<br>                 GLenum usage);<br>创建或者初始化一个缓冲对象的数据的储存。</p>
<p><em>target</em><br>     这里是GL_ARRAY_BUFFER</p>
<p><em>size</em><br>   新建的缓冲对象大小，以字节(type)类型表示，可以使用sizeof(data)得到</p>
<p><em>data</em><br>   用于拷贝和初始化新的data对象的，指向data的指针，如果是NULL的话，没有数据被拷贝</p>
<p><em>usage</em><br>    储存好的数据的使用模式。 <code>GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY</code>有这么几种。这里只用于静态绘制</p>
<p><strong>glVertexAttribPointer</strong>(GLuint index,<br>                      GLint size,<br>                       GLenum type,<br>                       GLboolean normalized,<br>                       GLsizei stride,<br>                       const GLvoid * pointer);<br>上面有所解释。现在就够用了。</p>
<p><strong>glEnableVertexAttribArray</strong>(GLuint index);<br>启用设置好的顶点属性数组，<br><em>glDisableVertexAttribArray</em>(GLuint index);<br>关闭</p>
<p><em>index</em><br>   顶点属性的序号，即位置的序号。与顶点着色器的(location=n)相关.</p>
<p><strong>glBindVertexArray</strong>();<br>用名字array绑定一个顶点数组对象。array是从之前glGenVertexArrays()返回的，或者是0意味着接触当前的绑定。</p>
<p><strong>glDrawArrays</strong>(GLenum mode,<br>               GLint first,<br>               GLsizei count);<br>练习1中已经出现过，调用之前先要绑定Array;<br>根据数组数据中渲染图元,可以指定渲染图元的类型，给定第一个索引和绘制点的个数，从而确定哪些点被绘制。</p>
<p>代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入两个三角形各自的顶点数组</span></span><br><span class="line">GLfloat firstTriangleVertices[] = &#123;</span><br><span class="line">  <span class="comment">// 第一个triangle</span></span><br><span class="line">  <span class="number">0.5f</span>,   <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右上角</span></span><br><span class="line">  <span class="number">0.1f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 右下角</span></span><br><span class="line">  <span class="number">-0.5f</span>,  <span class="number">0.3f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLfloat secondTriangleVertices[] = &#123;</span><br><span class="line">  <span class="comment">// 第二个triangle</span></span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左下角</span></span><br><span class="line">  <span class="number">-0.1f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,    <span class="comment">// 左上角</span></span><br><span class="line">  <span class="number">0.5f</span>,  <span class="number">-0.3f</span>, <span class="number">0.0f</span>     <span class="comment">// 右下角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>1, 共同以VAOs和VBOs以数组创建<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br></pre></td></tr></table></figure></p>
<p>2, 单独绑定, 复制, 设置顶点属性<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangleVertices),</span><br><span class="line">               firstTriangleVertices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class="line">                        <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理VAOs[1], VBOs[1]..</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangleVertices),</span><br><span class="line">               secondTriangleVertices, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</span><br><span class="line">                        <span class="number">3</span> * <span class="keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>3, 单独绘制<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==========firstTriangle=========</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// ==========secondTriangle========</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.4.hello_triangle_exercise2" target="_blank" rel="noopener">练习2源码</a></p>
<h2 id="3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色"><a href="#3-创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色" class="headerlink" title="3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色"></a><strong>3.创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色</strong></h2><p>之前提出了一个问题，顶点着色器和片段着色器之间的关系？在这个练习中，有所涉及。</p>
<p>// 放在同一个数组中，但需要各自绑定和各自绘制， 也可以匹配不同的顶点数组<br>// 注意：片段着色器不能放在数组里。<br>// 顶点着色器，片段着色器attach+link成program, 着色器需要创建，绑定源码，编译，检查编译四个步骤。</p>
<p>1, GLSL编写橙色和黄色着色器代码<br>2，分别附着，编译，检查着色器，并attach到不同的program<br>3, 用不同的program进行draw</p>
<p><strong>1, GLSL编写橙色和黄色着色器代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 片段着色器0</span></span><br><span class="line"><span class="keyword">const</span> GLchar* fragmentShaderSource0 = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"out vec4 color;\n"</span></span><br><span class="line">    <span class="string">"void main() &#123;\n"</span></span><br><span class="line">    <span class="string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>   <span class="comment">// orange</span></span><br><span class="line">    <span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器1</span></span><br><span class="line"><span class="keyword">const</span> GLchar* fragmentShaderSource1 = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"out vec4 color;\n"</span></span><br><span class="line">    <span class="string">"void main() &#123;\n"</span></span><br><span class="line">    <span class="string">"color = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span>   <span class="comment">// yellow</span></span><br><span class="line">    <span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>2，分别附着，编译，检查着色器，并attach到不同的program</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建片段着色器</span></span><br><span class="line">  GLuint fragmentShaderOrange;</span><br><span class="line">  GLuint fragmentShaderYellow;</span><br><span class="line">  GLuint shaderProgramOrange;</span><br><span class="line">  GLuint shaderProgramYellow;</span><br><span class="line">  fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">  shaderProgramOrange = glCreateProgram();</span><br><span class="line">  shaderProgramYellow = glCreateProgram();</span><br><span class="line">  <span class="comment">// ===========编译第一个片段着色器===================</span></span><br><span class="line">  <span class="comment">// 源码附加到着色器对象上</span></span><br><span class="line">  glShaderSource(fragmentShaderOrange, <span class="number">1</span>, &amp;fragmentShaderSource0, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragmentShaderOrange);</span><br><span class="line">  <span class="comment">// 检测glComplieShader是否编译成功</span></span><br><span class="line">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ===========编译第二个片段黄色着色器===================</span></span><br><span class="line">  <span class="comment">// 源码附加到着色器对象上</span></span><br><span class="line">  glShaderSource(fragmentShaderYellow, <span class="number">1</span>, &amp;fragmentShaderSource1, <span class="literal">NULL</span>);</span><br><span class="line">  glCompileShader(fragmentShaderYellow);</span><br><span class="line">  <span class="comment">// 检测glComplieShader是否编译成功</span></span><br><span class="line">  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把两个着色器对象链接到用来渲染的两个着色程序中</span></span><br><span class="line">  glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class="line">  <span class="comment">// =====连接第一个片段着色器=====</span></span><br><span class="line">  glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class="line">  glLinkProgram(shaderProgramOrange);</span><br><span class="line">  glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgramOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// =====连接第二个片段着色器=====</span></span><br><span class="line">  glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class="line">  glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class="line">  glLinkProgram(shaderProgramYellow);</span><br><span class="line">  glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">  <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgramYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span></span><br><span class="line">              &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除着色器</span></span><br><span class="line">  glDeleteShader(vertexShader);</span><br><span class="line">  glDeleteShader(fragmentShaderOrange);</span><br><span class="line">  glDeleteShader(fragmentShaderYellow);</span><br></pre></td></tr></table></figure></p>
<p><strong>3, 用不同的program进行draw</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =====激活程序对象绘制第一个triangle======</span></span><br><span class="line">glUseProgram(shaderProgramOrange);      <span class="comment">// 使用第一个片段着色器连接的program</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 从索引0开始依次绘制3个顶点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====激活程序对象绘制第二个triangle======</span></span><br><span class="line">glUseProgram(shaderProgramYellow);      <span class="comment">// 使用第二个片段着色器连接的program</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 从索引0开始依次绘制3个顶点</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/timtingwei/LearnOpenGL/tree/master/src/1.getting_started/2.5.hello_triangle_exercise3" target="_blank" rel="noopener">练习3源码</a></p>
<p>=======</p>
<p>refwebsite:<br><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">你好三角形 - learnopengl-CN</a></p>
]]></content>
      
        
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(转载)谈编程语言]]></title>
      <url>/2017/12/24/how-to-learn-program/</url>
      <content type="html"><![CDATA[<p><strong>文章目录</strong><br><a href="#Bruce-Eckel：编程生涯">Bruce Eckel：编程生涯</a><br><a href="#Peter-Norvig：十年学会编程">Peter Norvig：十年学会编程</a></p>
<p>转载自<a href="https://program-think.blogspot.com/2012/05/weekly-share-5.html" target="_blank" rel="noopener">编程随想 - program think</a>整理的， 关于编程的心态定位和实践方法的文章，比较经典， 对我有所启发的两篇。</p>
<hr>
<h1 id="Bruce-Eckel：编程生涯"><a href="#Bruce-Eckel：编程生涯" class="headerlink" title="Bruce Eckel：编程生涯"></a>Bruce Eckel：编程生涯</h1><p>作者 Bruce Eckel 是编程界的大牛，著有大名鼎鼎的《Thinking in C++》和《Thinking in Java》。<br>本文是他对程序员（尤其是新手）的忠告。</p>
<p>================================</p>
<p>大家总是问一个错误的问题：“我应该学习C++还是Java？”在本文中，我将告诉大伙儿：对于选择编程生涯真正需要关注的是哪些问题。</p>
<p>请注意，这篇文章的目标读者并不是那些已经做出自己选择的人。（对于这些人而言）你会继续自己的编程生涯，而不管别人会怎么说。因为它已经渗透到你的血液中，你已经无法摆脱。你已经知道答案：C++、Java、Shell脚本、Python、还有其它一大堆的语言和技术，你都理所当然地会去学习。甚至有可能你才仅仅14岁，就已经知道好几种不同的语言。</p>
<p>问我这样的问题的人可能来自其他行业，或者来自诸如Web开发之类的领域。他们知道HTML是一种类编程语言，而且想尝试构建某些更大型的应用。但我特别希望，当你在问这个问题时，你已经意识到了想要在计算机领域取得成功，你需要掌握自学能力，而且永不停息。</p>
<p><strong>在这个领域做得越多，我越觉得软件开发比任何行业都更接近于写作。</strong> 我们从来不知道是什么造就了优秀的作者，我们只知道什么时候我们会喜欢某个人的文字。编程不是一种工程，仅需要把东西从入口倒进去，然后再转动手柄。把软件开发看成确定性的，是一个诱人的想法。因为这个想法，人们总想搞出一些工具来帮我们开发出想要的软件。但是我的经验告诉我，事实并非如此——人的重要性远高于流程。而软件是否运行在一部精确的机器上已经越来越不重要了——这犹如测不准原理对人类的影响。</p>
<p>我的父亲是造房子的，小时候我偶尔会帮忙打下手，放放砖块之类。他和他的木工告诉我，他们是为我好才让我干这些活——这样我就不至于走入这个行业。事实确实是这样。</p>
<p>我们不妨把软件开发比作盖房子。造房子的人当然不可能完全一样。这些人里面有：混凝土工、屋顶工、管道工、电工、砖瓦工、水泥工、瓦片工、搬运工、粗木工、细木工。当然，还有工头。每个工种都需要相应的技能，这些技能都需要花时间和精力去掌握。<strong>跟软件开发一样，造房子也是一个“建立/推翻”的过程。如果你想很快地获得回报，你可能从搬运工和砖瓦工开始做，这样的话，你无需太多的学习曲线就可以获得回报。当需求很多时，你的工作会很稳固，甚至收入也可能提升——如果没有足够的人手的话。但是，一旦行情不妙，木匠甚至工头就可能把砖瓦工一脚踢开。</strong></p>
<p>当互联网刚刚兴起时，仅仅是花一点时间学习HTML，你就可以得到一份薪水丰厚的工作。但是当形势惨淡时，对于技能的要求更高了——HTML程序员（就像搬运工和砖瓦工一样）第一个被抛弃了，而拥有更高技能的程序员则留了下来。</p>
<p>我想说的是： <strong>除非你准备活到老学到老，不然的话，不要进入这个行业！编程看起来似乎是一个高收入而又稳定的工作。但要做到这一点，唯一的途径是：始终让自己更有价值。</strong></p>
<p>当然，你总能找到例外。总有那么一些人，仅仅学了一门编程语言，就可以胜任留在一个岗位上，而不需要增长他的技能。但他们只是幸免于难而已，他们最终无疑是很脆弱的。为了不让自己变得脆弱，你需要持续的提高自己，通过阅读、加入用户组、参加研讨会…… 你学得越深入，你就越有价值，也就意味着你有更好的职业前景，可以配得上更高的薪水。</p>
<p><strong>另一个方法是：先大致了解这个领域，找到最适合你的地方。</strong>打个比方：我的兄弟对软件很感兴趣，也入了这行，只不过他的工作是安装、维修、升级电脑。他总是一丝不苟，所以当他把电脑搞好，一定会很完美——不光是软件，连电线都会被仔细地捆好。他总是生意兴隆，远超出他的精力所能及。他甚至都不用担心 .com 泡沫的崩溃。显然他的饭碗不容易被抢走。</p>
<p>我在高校里待了很久，甚至还在UCLA（加州大学洛杉矶分校）进修博士学位，后来又幸运地终止了。我说“幸运”是因为我不再喜欢呆在学校，而我之前在高校待了那么久，只是因为我很享受它。但我所享受的，基本上是不务正业的东西——艺术和舞蹈课，在校报工作，还有一小撮计算机课程（之所以说计算机课程“不务正业”，是因为我本科是物理专业，研究生才是计算机专业）。虽然我在学术上远谈不上卓越（有意思的是很多当时也许不会接受我这个学生的学校现在却用我的书做教材）。我真的很享受作为学生的日子，当我完成博士课程，也许会以一个教授的身份终老一生。</p>
<p>但就如现在看到的，我在学校里最大的收获恰恰来自我那些“不务正业”的课程，它们拓展了我的思维，使之超越了“我们已经知道的东西”。<strong>在计算机领域中，你总是为某种目标而编程。你对目标了解得越多，你就做得越好。我遇到过一些欧洲的研究生，他们需要结合其它专业领域来搞编程，他们的论文需要解决这个专业领域的特定的问题。</strong></p>
<p>了解编程之外的领域，将会极大得提高你解决问题的能力 （就如同多学几种编程语言将极大地提高你的编程技能）。很多时候，我发现仅仅学习计算机专业的学生，比那些（除了计算机之外）拥有其它背景的学生，在思维上有更多的局限性。因为后者有着更严谨的思维，也不那么容易想当然。</p>
<p>有一次我组织了一次会议，其中一个议题是：理想的应聘者有哪些特征：<br>◇把学习当成生活方式。比如：你应该知道不止一种语言，没有什么比学习一门新语言更能让你开阔眼界了。</p>
<blockquote>
<ul>
<li>知道如何获取知识</li>
<li>Study prior art</li>
<li>善用工具</li>
<li>学会把事情简化</li>
<li>理解业务</li>
<li><strong>为自己的错误负责。“我就是这样的”是不能接受的托词。能找到自己的失误。</strong></li>
<li>成为一个领导者，善于沟通和激励。</li>
<li>搞清楚你在为谁服务</li>
<li><strong>没有绝对正确的答案（更好的方法总是存在的）。展示并讨论你的代码，不要带着感情因素——你的代码并不等于你本人。</strong></li>
<li><strong>明白完美是渐进的</strong></li>
</ul>
</blockquote>
<p>适当尝试一些冒险——尤其是能令人感到害怕的冒险。当你尝试之后，将体会到出乎意料的兴奋。（在冒险的过程中）最好不要刻意去计划某个特定的结果。当你过于注重结果，你往往会错过那些真正有价值的问题。我的冒险往往是这样开始的——“我们先做些试验，看看它会把我们带到什么地方”。</p>
<p>或许某些人会对我的回答感到失望，并回复我说：“是的，这很有趣也很有用。但我到底应该学什么？C++还是Java？” 我再重复一次：并不是所有的问题都有一个唯一的简单的答案。<strong>问题的关键不在于选择某个编程语言，然后掌握之。问题的关键在于：持续学习，并且很多时候，有不止一个选择。</strong> 相信我所说的，你的生活会更精彩！</p>
<p>原文出处：<br><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=259358" target="_blank" rel="noopener">http://www.artima.com/weblogs/viewpost.jsp?thread=259358</a></p>
<hr>
<h1 id="Peter-Norvig：十年学会编程"><a href="#Peter-Norvig：十年学会编程" class="headerlink" title="Peter Norvig：十年学会编程"></a>Peter Norvig：十年学会编程</h1><p>作者 Peter Norvig 是计算机科学家，Google 的研究总监。<br>在本文中，Peter Norvig会告诉你：为什么急功近利地学习软件开发技术是没效果滴？</p>
<p>================================</p>
<h2 id="为啥都想速成？"><a href="#为啥都想速成？" class="headerlink" title="为啥都想速成？"></a>为啥都想速成？</h2><p>随便逛一下书店，你会看到《7天自学Java》等诸如此类的N天甚至N小时学习Visual Basic、Windows、Internet的书。我用亚马逊网站的搜索功能，出版年份选1992年以后，书名关键词是：“天”、“自学”、“教你”，查到248个结果，前78个是计算机类图书，第79个是《30天学孟加拉语》。我用“天”换成“小时”，结果更惊人，有多达253本书，前77本是计算机图书，第78是《24小时自学语法句式》。在前200名中，96%是计算机的书。</p>
<p>结论就是：要么人们急于学习电脑，要么计算机比其他东西学起来要异常简单。没有任何书是关于几天学习贝多芬或量子物理的，甚至连犬类装扮都没有。费雷森（Felleisen）等人在其著作《如何设计程序》中同意这个趋势，其中提到：“坏设计很简单，笨蛋才用21天学，尽管他们还是真傻。”</p>
<p>让我们看看《三日学会C++》这个书名意味着什么：</p>
<p>◇学习：<br><strong>三天内你可能没有时间写出有意义的程序，或者从中积累经验。</strong>你不可能有时间去跟职业编程者一起去理解在C++环境下的状况。简而言之，你没有充足的时间学很多。所以这本书只能说肤浅的知识。正如亚历山大·波普（Alexander Pope）所言：一知半解是很危险的。</p>
<p>◇C++：<br><strong>三天内你可能学会C++的句法（如果你已经了解其他的语言），但你还不会使用它。</strong>打个比方，假如你是个Basic程序员，你可能写出Basic风格的C++程序，而无法理解C++的真实好处。那要点是什么？艾伦·佩里斯(Alan Perlis)曾经说过：“一门不能影响你编程观点的语言不足学的。”有可能你学了一点点C++（或者诸如Javascript、Flex之类），因为你需要和现成的工具接口以完成手头的任务。这种情况下，你不是在学习如何编程，只是在学习如何完成任务。</p>
<p>◇三日：<br>不幸地是，这远远不够，下一部分会详细讲。</p>
<h2 id="如何用十年掌握编程"><a href="#如何用十年掌握编程" class="headerlink" title="如何用十年掌握编程"></a>如何用十年掌握编程</h2><p>研究人员（Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)）得出结论：<strong>想要在诸多领域达到职业水平需要十年，比如国际象棋，作曲，电报操作，绘画，弹钢琴，游泳，网球以及神经心理学和拓扑学的研究。关键是精心练习，只是一遍一遍地重复是不够的，必须挑战恰好超越你能限的事情，尝试并思考你的表现，并自我矫正。周而复始。这并无捷径！</strong>4岁的音乐奇才莫扎特用了13年才能创作世界级的音乐。另外，披头士乐队似乎在1964年的埃德·苏利文（ Ed Sullivan show）演出中一炮而红，但是他们自从1957年就在利物浦和汉堡的酒吧演出，在取得广泛关注后，第一部重量级作品《佩珀军士》（Sgt. Peppers）是在1967年发行。马尔科姆·格拉德威尔（Malcolm Gladwell）撰文描述了一项针对柏林音乐学院学生的研究，他们被分为尖子，中等和不足三类，并被问到他们练琴的情况：<br>所有三组中的人，开始学琴的年龄大概相差无几，五岁左右。在刚开始的几年，所有人练习量也差不多，一周两三个小时。自八岁开始，实质性变化就有了。那些精英学生开始比其他人练习更多：九岁的时候一周六个小时，十二岁的时候一周八个小时，十四岁的时候一周十六个小时，一直到二十岁的时候一周要超过三十小时。截止到二十岁，在他们的生涯里已经有总计一万小时练琴。仅仅表现可以的那部分学生加起来是八千小时，那些未来的音乐老师有四千小时。</p>
<p>所以，更确切地说，一万小时，而非十年，是个神奇之数。萨缪尔·约翰逊（Samuel Johnson, 1709-1784）认为还需更长时间：“卓越乃一生之追求，而非其它”。 乔叟（Chaucer, 1340-1400）抱怨道”the lyf so short, the craft so long to lerne.” （生之有限，学也无涯）。希波克拉底（Hippocrates, c. 400BC）因这句话被世人所知：”ars longa, vita brevis”（译注：拉丁语，意为“艺无尽，生有涯”），更长的版本是 “Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”，翻译成英文就是 “Life is short, (the) craft long, opportunity fleeting, experiment treacherous, judgment difficult.” （生有涯，艺无尽，机遇瞬逝，践行误导，决断不易）。</p>
<h2 id="我的编程成功秘笈是："><a href="#我的编程成功秘笈是：" class="headerlink" title="我的编程成功秘笈是："></a>我的编程成功秘笈是：</h2><blockquote>
<ul>
<li><p>首先要对编程感兴趣，能从编程中得到乐趣。一定要让它足够有趣，因为你要保持你的兴趣长达十年。</p>
</li>
<li><p><strong>与别的程序员交流；阅读别人的代码——这比看任何书或参加培训课都重要。</strong></p>
</li>
<li><p>实践。最好的学习乃实践。俗话说：“编程的至高境界一定要通过充分的实践才能达到，而个人的能力可通过不懈努力获得显著提升。” (p. 366) <strong>“最有效率的学习需要明确的目标，适当的难度，知识回馈，并容许重复或修正错误。”</strong> (p. 20-21) 《实践认知：每日的思维、数学及文化》（Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life） 在这方面可做参考。</p>
</li>
<li><p>如果你愿意，花四年学习大学课程（或者再加上读研）。这将给你赢得某些工作机会，并给予你在该领域的深层见解。<strong>但如果你不喜欢学校的学习，你同样可以在工作中获得相似的经验。无论如何，单靠书本是远远不够的。</strong>“学习计算机科学不会让你成为编程专家，如同学习绘画和色彩理论不会让你成为画家一样”。这是埃里克·雷蒙德（Eric Raymond）说的，他是《新黑客字典》（The New Hacker’s Dictionary）的作者。我雇用过的最优秀程序员，只有高中文凭。但他开发过许多伟大软件，有自己的新闻组，通过公司认股赚的钱就让他买下了自己的夜店。</p>
</li>
<li><p>和其他程序员一起参与工程项目。在某些项目中担当最优秀程序员，在另一些项目中充当最差劲程序员。<strong>充当领头羊的时候，你要测试你领导一项工程的能力，并用你的视野来激发他人；如果在项目组中垫底，就应该学习其它牛人在做些啥，以及他们不喜欢做的（看他们把哪些活让给你做）。</strong></p>
</li>
<li><p>继续别人的工程项目。去理解先前程序员写的程序。<strong>学习如何理解并解决先前程序员没有考虑到的问题。思考你的程序该如何设计以便让之后的程序员更容易维护。</strong></p>
</li>
<li><p>至少学6种程序语言。其中包括一种支持类抽象的（Java和C++），一种支持函数抽象的（如Lisp或ML），一种支持语义抽象的（Lisp），一种支援声明规范的（如Prolog或C++模板），还有一种支援协程的（Icon或Scheme），另外一种支持并发的（Sisal）。</p>
</li>
<li><p>记住，在“计算机科学”里有“计算机”一词。理解计算机执行你的代码的时候花费的时间。比如：从内存中取一个字（考虑有无缓存未命中情形），连续从磁盘读字，或者在磁盘中定位。</p>
</li>
<li><p>参加语言标准化工作。这可能是有关 ANSI C++ 委员会，也可能是决定你编码风格是两格缩进或四格缩进。无论如何，你要知道其他人对语言的喜好程度，有时还要想想他们为什么喜欢这样。</p>
</li>
<li><p>知道自己应该在何时脱身于语言标准化</p>
</li>
</ul>
</blockquote>
<p>所有上述这些，很难通过书本的学习来达到。我头一个孩子出生时，我读了所有的“如何做”（How To）系列的书籍，却依然对育婴毫无头绪。30个月后，我第二个孩子出生，我还需要温习一下那些书吗？绝对不！相反，我完全可以参照个人经验，而结果相当有效。这更让我确信：我的经验胜过那些专家们写的上千页文字。</p>
<p>弗雷德·布鲁克斯（Fred Brooks）在《没有银弹》（No Silver Bullet）一书给出了寻找顶级设计师的三条建议：</p>
<blockquote>
<ul>
<li>尽早系统地识别出顶级设计师。</li>
<li>分配一个人作为其职业规划的导师。</li>
<li><strong>给予机遇让成长中的设计师互相磨砺。</strong></li>
</ul>
</blockquote>
<p>此处假定有部分人已经有成为伟大设计师的潜质，你所需的就是要诱导他们。艾伦·佩里斯（Alan Perlis）一针见血地指出：<strong>“假如人人都可以学雕刻，那就得教米开朗基罗如何不去干雕刻。对于伟大程序员，也是如此。”</strong></p>
<p>所以，简单地买一本Java书，你或许能找到些有用的东西，但绝不会让你在24小时内甚至24天抑或24月内，成为行家里手。</p>
<p>原文出处：<br><a href="http://norvig.com/21-days.html" target="_blank" rel="noopener">http://norvig.com/21-days.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> program </tag>
            
            <tag> learn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冬至的一点光亮]]></title>
      <url>/2017/12/22/essay/a-little-light/</url>
      <content type="html"><![CDATA[<p>今日冬至，晒太阳翻了翻&lt;&lt;鸟哥的Linux入门&gt;&gt;，通读了一遍，了解结构为后续学习挑出主次。中午找S交谈OpenGL相关问题，当然不止于此。有几点收获:<br>1, 学习底层知识，少学习容易过时的知识。我引用Quora上得到的回答，对自己目前的状态做一个反思:”Are you good at object-oriented programming? C? The Unix tools? Have you taken discrete math? A course in computer systems?”<br>2, 不轻易做一个计划，做一个计划不轻易放弃。我对什么事情都感兴趣，什么都想玩一玩，但是如果不把一项技术学精，虎头蛇尾，是一种空言壮志的表现。S举例了我从GH, Python, 计算几何, C++, Flask, OpenGL等计划, 当然我知道还有其他, 说明我容易循着一条轨迹向下寻溯。但时未兴，我无法准确判断计划的可靠性。<br>3, 不把当下决定看得太重。对于那些无所事事的人，他们要减少对时间的浪费;对于我，浪费的时间反而有意义的。浪费与否，学习哪条方向, 都是一种经历。不能陷入到对未知的结果的忧虑当中去，要承认对未知的复杂性。<br>4, 捡最近的镜子。满地镜子看花眼睛时候，找最近的镜子。对S来说，数字化的最近镜子是学生；他如此提醒我，想必是要说，我最近的镜子，应该是我的同学和S。但是什么是技术的最近的镜子呢？数据结构，图形，游戏。也许。</p>
<p>冬至夜， 按照去年留下的习俗， 和朋友约一起煮火锅下水饺和汤圆。吃得也饱，聊得也欢快。</p>
<p>其他人陆陆续续的去忙别的事情，只剩下X，H和我。话题的起因是老生常谈，女孩。我看上去是个优胜者，他们两个向我请教。给出了一些符合xu逻辑的方法,<br>1, 列出关于学校集体活动的一个list;<br>2, 将每个活动的具体形式考量一遍;<br>3, 加入该活动的方式;<br>4, 可能会出现的几个状况;<br>5, 综合考量后排序挑选前5个活动参加。<br>因为，前前后后也跟X讲了好多次，没有什么实际行动，我想，问题可能出在，我总是讲具体跟女孩的交流方式，其实这是因人而异的，刻意的追求结果未必是好。但作为前馈数据，需要的大概是接触到更多人的环境，让他自己在这个环境中摸爬。希望这大概能够好些。</p>
<p>聊完这个，便聊第二个老生常谈，但并未透彻的话题，体制。重新思考话题展开的原因相对来说比较有意义，是探索一种启蒙的模型。这个话题能够展开，总得来讲，出于对当下以及未来的困惑，我尝试分开来讲几点原因，<br>1, 计算机科学自下而上的思维模式，撼动原有的自上而下的体系。这其中差异，看上去是从技术角度出发，却渗透到经济，结构，体制，文化，人性等各个方面。<br>2, 怀有对资社的不充分理解和想要探求的心理状态。<br>3, 评论和试图解决遇到的问题，寻求一种生活的模型。</p>
<p>X先提出了对该体制是否会倒塌的质疑，我觉得这个问题好回答，但也不好回答，确实凭借我的认知还无法解释清楚，能够解释清楚的人大多也都别有用心。我但是从我的数据库中索引出来一些，但凌晨四点睡去醒来后，又作了些思考。</p>
<p>人一般走上畸路的过程分成几个阶段，先是犯错误，错误带来不良后果，判断他没救的依据是，依旧不改正错误，后果没得到解决。道理是相同的。</p>
<p>错误性体现在，社会主义相对于资本主义的乌托邦本质。共产主义，当财富是大家共有的时候，谁来决定财富的分配？能够决定分配的人，势必会有权力。如果该掌权者是一个大公无私的，理性智慧的人，大家能够得到平等的分配。这看上去很对，能够实现。但却忽略了一个关键的事实，人性是有阴暗面的，是有私心的。这种私心若是顺其自然的发展，以共同利益为由，是能够孕育出灿烂果实的；有趣的是，但若想消除这种私心，这种私心就被放大了，因为看上去大家都不存在私心了，但消除别人私心的行为本身就是一种私心，说这是私心温和了些，应该说是恶，然而这种恶会被不断的累积和放大，因此，在最高位置上的伟大领袖，或许并非那么伟大。</p>
<p>那么后果是什么？总体上讲是系统内耗造成的资源短缺。这种框架下，势必一切会向权力看。人们会为了生存而追求利益，而追求利益的竞争在这个情况下，又转变成了为追逐权力而努力竞争。值得一提的是，生存是第一要义。竞争是必要的，但除了竞争之外还有合作；利益是必要的，但除了利益之外还有共同利益；追逐地位是必要的，但地位的来源不是唯一的来自于权力和财富。</p>
<p>这种追求利益的方式，产生了第一种后果，其实就是系统内耗。拿我熟悉的高等教育举例子，真正想做科研的教授，他势必不想将时间浪费在这一内耗上，但是不进行这种内耗他便得不到科研经费，科研没有开始就已经结束。然而，也许有人会说，教授你只要忍受一下，便可以开始真正的科研，但事实情况是这样:1, 一旦进行了一次这样的内耗，他会找你第二次; 2, 要记住，这是在进行权力的斗争，如果你做的研究是你的上一级无法控制的，他会对你起疑心；如果你的研究是上一级可以控制的，他会把你的研究为他所用作为自己权力斗争的筹码。也就是说，在这种机制的情况下，他是逆向淘汰的，有科研能力的人，被最终的边缘化。</p>
<p>第二种后果便是，内耗之后，是对系统资源的严重浪费。这个问题在各行各业各个单位普遍都是存在，且按照中共逻辑来说是正常的。权力的斗争中，可不像我在计算机上写代码一样，他有很多区别，但仍然可以用计算机的角度来解释。</p>
<p>1, 区别在于，建立一个模型，跑一跑数据资源，出错了；重新建立一个模型，再跑一跑。但现实世界中，没人会给我们这个机会。地下水就是地下水，矿产就是矿产，森林就是森林，不多不少就放在这里，终究竭尽。</p>
<p>2, 用计算机的角度解释就是说， 上述所说的权力斗争，导致创新能力低下，经济对重工业的依赖性强，资源的消耗速度快。也就是，没有优秀的算法，数据结构选择又不合理，内存管理又不做，建立模型后，冗余运算大，结果是消耗了很多资源，却写了个破程序，还要把时间花在无止尽的debug上。之后也会相应解释。</p>
<p>那么，错误是否被改正？这其实是个相对较伪命题，这个问题上我们翻过很多次跟斗，共党把他们最信任的，工人骗了，学生骗了，农民也骗了。只要认识到乌托邦的本质，就能够得出结论，他不无法被改正的。如果说要从计划经济走向市场经济，原因是有了权力之后就要用权力去换取财富。十年寒窗是为了什么？更何况12年苦读之后，换来的是更鲜艳的红旗。拿建筑学的建模软件来说，如果sketchUp开源底层代码了，那它还是sketchUp吗？还是叫sketchDown?</p>
<p>后果是否得到解决呢？对应的，当我写错一个程序的时候，我可能会把他扔掉，甚至说从一开始我就应该谨慎设计一个程序，那样就不至于后面一大堆麻烦。 政府官员需要权力斗争的筹码，这些筹码要从白手套，也就是商人那里得到，企业发展势会消耗资源，在资本主义中这种消耗是良性的，因为商人为了自身利益出发，要考虑一种相对长远的发展，商人就会去选择新的技术，投资新的研发，考虑如何合理分配现有资源，因为他们的资本决定了他们的相对自由。然而，在天朝，权力斗争是激烈的，对筹码的欲望是贪婪的，商人是被迫无奈如妓女似的，环境？资源？这种考虑是可能只会是在某个失眠的夜晚发问内心，然而事实上却是不会存在的，而这种对内心的发问，又会用另外一种形式去完成对内心的救赎。只有这种发展不可持续，才会提出可持续发展观。同理，只有在素质低下的国家，才会提出乐于助人般的口号，提出共识，就先不展开了。</p>
<p>天朝统治者和民众一起，在追求结果的平等的过程中，必然造成了过程的不平等，而统治者享受到了不平等的高点，低点留给民众享受。然而他们真的是在高点了吗？领袖足够了吗？常委们幸福吗？首富们的日子好过吗？共产主义马克思是cancer, 把白的黑的都卷入了这场漩涡中，无法脱身。但是cancer现在有医治手段了吗？上帝会像看着一个犯错的孩子一样看着我们，他终究还是宽容的吧，他会“给岁月以文明，而不是给文明以岁月”的吧，中华民族还要在时间中被消耗迭代，但他终归还是坚强的吧。即使，有的人选择在别人将他逼疯之前先逼疯了自己，但他们还是坚强无比的吧。</p>
<p>我们很多人不承认，但事实上不得不承认：我们习惯于将现在当作是过去历史的结果，用历史去解释未来，但事实上，现在就是未来的原因。</p>
]]></content>
      
        
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git Push免密码设置]]></title>
      <url>/2017/12/22/git-push-credential/</url>
      <content type="html"><![CDATA[<h2 id="使用-git-credentials保存验证"><a href="#使用-git-credentials保存验证" class="headerlink" title="使用.git-credentials保存验证"></a><strong>使用.git-credentials保存验证</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ touch .git-credentials</span><br><span class="line">$ emacs .git-credentials</span><br><span class="line">https://&#123;timting***&#125;:&#123;********&#125;@github.com</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.emacs.d/</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">'https://github.com'</span>:   C-c C-c</span><br></pre></td></tr></table></figure>
<p><strong>去掉{}</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ emacs ~/.git-credentials</span><br><span class="line">https://timting***:********@github.com</span><br><span class="line">$ git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[user]</span><br><span class="line">	email = timtingwei@hotmail.com</span><br><span class="line">	name = timtingwei</span><br><span class="line">[credential]</span><br><span class="line">	helper = store</span><br></pre></td></tr></table></figure>
<p>现在push不再需要验证。</p>
<p><strong>但我不希望用文件保存我的密码</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls -ld .git-credentials</span><br><span class="line">-rw------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class="line">tim@htwt:~$ sudo chmod 200 .git-credentials</span><br><span class="line">[sudo] password <span class="keyword">for</span> tim: </span><br><span class="line">tim@htwt:~$ ls -ld .git-credentials</span><br><span class="line">--w------- 1 tim tim 42 12月 22 15:00 .git-credentials</span><br><span class="line">tim@htwt:~$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<p>重启bash</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tim@htwt:~/.emacs.d$ git push origin master</span><br><span class="line">fatal: unable to open /home/tim/.git-credentials: Permission denied</span><br></pre></td></tr></table></figure>
<p>=&gt; 修改权限的方法没用, 别人看不到, git也看不到。</p>
<p>======</p>
<h2 id="安全性存疑，因此改用设置cache"><a href="#安全性存疑，因此改用设置cache" class="headerlink" title="安全性存疑，因此改用设置cache"></a><strong>安全性存疑，因此改用设置cache</strong></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ rm ~/.git-credentials</span><br></pre></td></tr></table></figure>
<p>通过设置git的cache的话可以让它记住密码之后自己设置一个cache有效时间 这样也一定程度保证了一些安全性。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper cache</span><br><span class="line">\<span class="comment"># Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line">\<span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>
<p>======</p>
<p>refwebsite:<br>[1], <a href="https://www.zhihu.com/question/31836445" target="_blank" rel="noopener">https://www.zhihu.com/question/31836445</a><br>[2], <a href="http://www.jianshu.com/p/f54053afecf2" target="_blank" rel="noopener">http://www.jianshu.com/p/f54053afecf2</a><br>[3], <a href="https://help.github.com/articles/caching-your-github-password-in-git/" target="_blank" rel="noopener">https://help.github.com/articles/caching-your-github-password-in-git/</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown删除线]]></title>
      <url>/2017/12/22/markdown-delete-line/</url>
      <content type="html"><![CDATA[<p>~~删除一句~~<br><del>删除一句</del></p>
<p>~~删除<br>多行~~<br><del>删除<br>多行</del></p>
<p>~~删除包含语法\[mituh’s notes\]\[timtingwei.github.io\]~~<br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>
<p>\====<br>不知道还有其他方法否？</p>
<p>\====<br>refwebsite:<br><a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Markdown</a></p>
]]></content>
      
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在ubuntu14.04上建立OpenGL编译环境]]></title>
      <url>/2017/12/20/install-openGL-in-ubuntu14-04/</url>
      <content type="html"><![CDATA[<p>学习教程<a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/" target="_blank" rel="noopener">LearnOpenGL-CN</a>前先配置学习环境，对照后面编译时链接的函数库，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br></pre></td></tr></table></figure>
<p>需要：</p>
<blockquote>
<ul>
<li>GLEW</li>
<li>GLFW/GLFW3</li>
<li>libgl1-mesa</li>
<li>libglu1-mesa</li>
</ul>
</blockquote>
<p><code>ps: 不是完全明白这里链接库的对应关系</code></p>
<p>==========</p>
<p>参考:<a href="https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment" target="_blank" rel="noopener">Howto_Install_OpenGL_Development_Environment</a></p>
<p><strong>建立基本编译环境</strong><br>首先不可或缺的，就是編譯器與基本的函式庫，如果系統沒有安裝的話，請依照下面的方式安裝：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure></p>
<p><strong>安裝OpenGL Library</strong><br>接下來要把我們會用到的 Library 裝上去，首先安裝 OpenGL Library<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libgl1-mesa-dev</span><br></pre></td></tr></table></figure></p>
<p><strong>安裝OpenGL Utilities</strong><br>OpenGL Utilities 是一組建構於 OpenGL Library 之上的工具組，提供許多很方便的函式，使 OpenGL 更強大且更容易使用。 接下來我們安裝OpenGL Utilities</p>
<blockquote>
<p>在Linux下你需要链接libGL.so库文件，这需要添加-lGL到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libglu1-mesa-dev</span><br></pre></td></tr></table></figure>
<p><strong>安裝GLFW/GLFW3</strong><br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入，这正是我们需要的。</p>
<p>GLFW可以从它官方网站的<a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">下载页</a>上获取。</p>
<p>参考网站<a href="https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project" target="_blank" rel="noopener">How to build &amp; install GLFW 3 and use it in a Linux project</a><br>解压后,</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install cmake</span><br><span class="line"></span><br><span class="line">$ cmake -G <span class="string">"Unix Makefiles"</span></span><br><span class="line"></span><br><span class="line">$ sudo apt-get build-dep glfw</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line"></span><br><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br><span class="line"></span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: <span class="string">""</span></span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/include/GLFW</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/include/GLFW/glfw3.h</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/include/GLFW/glfw3native.h</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/cmake/glfw3/glfw3Config.cmake</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/cmake/glfw3/glfw3ConfigVersion.cmake</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/cmake/glfw3/glfw3Targets.cmake</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/cmake/glfw3/glfw3Targets-noconfig.cmake</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/pkgconfig/glfw3.pc</span><br><span class="line">-- Installing: /usr/<span class="built_in">local</span>/lib/libglfw3.a</span><br></pre></td></tr></table></figure>
<p><strong>从<a href="http://www.glfw.org/docs/3.0/quick.html" target="_blank" rel="noopener">测试源码网站</a>复制案例代码测试</strong><br>该案例中#include <glfw glfw3.h=""></glfw></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ -std=c++11 -c main.cpp</span><br><span class="line"></span><br><span class="line">$ ./main.o</span><br><span class="line">bash: ./main.o: cannot execute binary file: Exec format error  &amp;lt;==执行main.o提示不是二进制可执行文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi</span><br><span class="line">/usr/bin/ld: //usr/<span class="built_in">local</span>/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol <span class="string">'dlclose@@GLIBC_2.2.5'</span></span><br><span class="line">//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from <span class="built_in">command</span> line</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p>You may also need to add the linker options -ldl -lXinerama -lXcursor to get it to work correctly if you are getting undefined references to <strong>dlclose</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ main.o -o main.exec -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class="line"></span><br><span class="line">$ ./main.exec</span><br></pre></td></tr></table></figure>
<p>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></p>
<p>执行:</p>
<p>$ ./main.exec</p>
<p><del>*<em>安装glut\</em>*</del></p>
<p><del>```sh<br>sudo apt-get install libglut-dev<br>```</del></p>
<p><del>沒有libglut-dev可以改用<br>```sh<br>sudo apt-get install freeglut3-dev<br>```</del></p>
<p><del>設定編譯參數與編譯<br>在這之前，我們需要一個測試範例，example.c</del> <a href="https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment" target="_blank" rel="noopener">如下</a>：</p>
<p><del>有了測試範例、基礎編譯環境與各個 OpenGL 相關的函式庫之後，我們所需要做的就是告訴編譯器我們有安裝 OpenGL 函式庫，編譯程式時要連結這些函式庫。</del></p>
<p><del>gcc example.c -o example.out -lGL -lGLU -lglut<br>因為我們安裝了 OpenGL Utility Toolkit ，它是建立在 OpenGL Utilities 與 OpenGL Library 之上，因此我們可以簡單連結 OpenGL Utility Toolkit 的函式庫就可以達到我們的目地了。下面的編譯參數跟上面的是同樣效果：</del></p>
<p><del>gcc example.c -o example.out -lglut<br>下面簡單說明一下所使用的 gcc 參數</del></p>
<p><del>-l<library>  告訴 gcc 去連結指定 Library<br>-o<file>     指定執行檔的輸出名字</file></library></del></p>
<p><del>執行<br>接下來我們就可以來看看我們的結果，如果看到右圖，代表成功了!~<br>./example.out</del></p>
<p><strong>编译和链接GLEW</strong></p>
<p>对于用GCC编译的Linux用户建议使用这个命令行选项-lGLEW -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi。没有正确链接相应的库会产生 undefined reference(未定义的引用) 这个错误。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get build-dep glew</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line"></span><br><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<p>==========</p>
<p><strong>测试教程中的案例代码</strong></p>
<p>复制 [代码hello_window.cpp][<a href="https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp" target="_blank" rel="noopener">https://github.com/timtingwei/LearnOpenGL/src/1.getting_started/1.1.hello_window/hello_window.cpp</a>]<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ g++ -std=c++11 hello_window.cpp -lGLEW -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl -lXinerama -lXcursor</span><br><span class="line">$ ls</span><br><span class="line">a.out  hello_window.cpp</span><br><span class="line">$ ./a.out</span><br><span class="line">Starting GLFW context, OpenGL 3.3</span><br></pre></td></tr></table></figure></p>
<p>看到初始化窗口，代表成功。</p>
<p><strong>编译后窗口透明问题</strong><br>虽然窗口初始化成功, 但不知道我的窗口为什么是透明的, 难道是ubuntu的原因吗？<br>Render部分再加入两行代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure></p>
<p><strong>编译后libGLEW.so.2.1: No such file or directory 问题</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">..</span><br><span class="line">$ ./a.out</span><br><span class="line">./a.out: error <span class="keyword">while</span> loading shared libraries: libGLEW.so.2.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>查询<a href="https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew" target="_blank" rel="noopener">stackoverflow libGLEW相关问题</a><br>得到libGLEW在lib64下, 于是便创建软link<br>$ sudo ln -s /usr/lib64/libGLEW.so.2.1 /usr/lib/libGLEW.so.2.1</p>
<p>==========</p>
<p>refwebsite:<br><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/" target="_blank" rel="noopener">https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/02%20Creating%20a%20window/</a><br><a href="https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment" target="_blank" rel="noopener">https://wiki.ubuntu-tw.org/index.php?title=Howto_Install_OpenGL_Development_Environment</a><br><a href="https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project" target="_blank" rel="noopener">https://stackoverflow.com/questions/17768008/how-to-build-install-glfw-3-and-use-it-in-a-linux-project</a><br><a href="http://www.glfw.org/docs/3.0/quick.html" target="_blank" rel="noopener">http://www.glfw.org/docs/3.0/quick.html</a><br><a href="https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew" target="_blank" rel="noopener">https://stackoverflow.com/questions/26372359/error-loading-shared-library-glew</a><br><a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">http://www.glfw.org/download.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在不同机器上配置部署hexo]]></title>
      <url>/2017/12/20/hexo-in-different-computers/</url>
      <content type="html"><![CDATA[<p>将学习平台从Windows转移到ubuntu上后，需要重新配置hexo，但和重头配置有所区别。虽然，将Windows的磁盘擦干净前，我已经把数据全转移到移动硬盘上，可以用拷贝的方式在ubuntu上重新部署hexo, 但是这种方法相对手动，且既然用了github pages， 就通过实践github来部署。</p>
<p>查阅后得到两种比较通用的hexo发布github的方式，</p>
<blockquote>
<ol>
<li>重新create a repo, 将静态文件push上去。</li>
<li>利用git branch的特性，将静态和部署文件放在一个repo的两个branch中。<br>这里我选择了后者。</li>
</ol>
</blockquote>
<p><strong>检查git：</strong><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure></p>
<p><strong>安装npm(node package manager):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm --version</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install npm</span><br></pre></td></tr></table></figure></p>
<p><strong>安装node-legacy</strong><br><a href="https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu" target="_blank" rel="noopener">装node-legacy原因</a><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure></p>
<p><strong>安装nvm</strong><br>nvm和npm一样是node的包的管理工具<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>
<p><strong>安装 Node.js</strong></p>
<blockquote>
<p>Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护，并与Linux基金会有合作关系。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。<br>visit <a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">node.js</a> for more information<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ nvm install 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>安装 hexo</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">$ npm install hexo -g</span><br></pre></td></tr></table></figure></p>
<p><strong>配置git</strong></p>
<p>查看:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br><span class="line">ls: cannot access /home/tim/.ssh: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>生成:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">"timtingwei@hotmail.com"</span></span><br></pre></td></tr></table></figure></p>
<p>确认:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ssh-agent -s</span><br></pre></td></tr></table></figure></p>
<p>添加:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>
<p>在github中添加SHH KEY<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ clip &lt; cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>并在github setting中添加shh key</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi timtingwei! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>
<p><strong>利用git branch在不同机器上部署hexo</strong><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">CrazyMilk的知乎回答</a></p>
<blockquote>
<ol>
<li>创建repo, timtingwei.github.io;</li>
<li>创建master和hexo两个分支，hexo用于存放静态文件, master用于部署;</li>
<li>repo setting 中设置hexo为默认分支;</li>
<li>git clone git@github.com:timtingwei/timtingwei.github.io.git 拷贝repo;</li>
<li>npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git –save（此时当前分支应显示为hexo）;如果在不同机器上不需要hexo init;</li>
<li>修改_config.yml的deploy::branch参数为master;</li>
<li>依次执行 git add., git commit -m “…”, git push origin hexo 提交相关文件;</li>
<li>执行hexo g -d 生成并部署到github上</li>
<li>日常改动:依次7,8.</li>
</ol>
</blockquote>
<p>以上配置完成后, hexo s没反应<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">INFO  Start processing</span><br></pre></td></tr></table></figure></p>
<p>hexo 3.0把服务器独立成个别模块，必须安装hexo-server才能使用。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br><span class="line"></span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<p>安装后, 仍旧没有反应。</p>
<p>考虑用<strong>静态模式</strong>, 服务器只处理public文件夹内的文件，而不处理文件变动。先要执行hexo generate<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server -s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>
<p>refweb:<br><a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Node.js</a><br><a href="http://www.jianshu.com/p/24cb74aeb0a3" target="_blank" rel="noopener">http://www.jianshu.com/p/24cb74aeb0a3</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762</a><br><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/server.html</a><br><a href="https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu" target="_blank" rel="noopener">https://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[添加git bash到右键菜单]]></title>
      <url>/2017/11/23/add-git-bash-to-right-click-menu/</url>
      <content type="html"><![CDATA[<h2 id="issue"><a href="#issue" class="headerlink" title="issue:"></a>issue:</h2><p>因为.git文件所在的目录如下：</p>
<blockquote>
<p>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\d3d</p>
</blockquote>
<p>当在bash中cd到该目录时：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\d3d</span><br><span class="line">bash: syntax error near unexpected token `(&apos;</span><br></pre></td></tr></table></figure></p>
<p>试图通过右键进入bash</p>
<h2 id="hack"><a href="#hack" class="headerlink" title="hack:"></a>hack:</h2><blockquote>
<ol>
<li>CMD中输入”regedit”</li>
<li>切换到 HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\Background\shell</li>
<li>右键点击 “shell” 选择 New &gt; Key. 将KEY命名为 “Bash”</li>
<li>设置值为 “open in Bash” </li>
<li>创建一个新的KEY命名为”command”. 设置值为git-bash.exe 路径.</li>
</ol>
</blockquote>
<p>此时在文件夹中右键, 出现Open in bash选项.</p>
<p>以上为通过注册表添加bash到右键的方法，但还是建议重装git</p>
<hr>
<p>reference:<br>[1]: <a href="https://www.zhihu.com/question/48091139" target="_blank" rel="noopener">https://www.zhihu.com/question/48091139</a> @轩辕Rowboat的回答</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客中文乱码]]></title>
      <url>/2017/11/23/hexo-random-symbol/</url>
      <content type="html"><![CDATA[<h2 id="issue"><a href="#issue" class="headerlink" title="issue:"></a>issue:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p>此时<a href="http://localhost:4000/" target="_blank" rel="noopener">localhost</a>中出现如下中文乱码, 英文部分正常。</p>
<blockquote>
<p>��Ȼ���(depth buffer)</p>
</blockquote>
<p>此时_config.yml中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<h2 id="hack"><a href="#hack" class="headerlink" title="hack:"></a>hack:</h2><blockquote>
<ol>
<li>Notepad++打开出现中文的*.md, 此时右下角为ANSI格式.</li>
<li>格式-&gt;转为UFT-8编码格式</li>
<li>保存</li>
<li>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</li>
</ol>
</blockquote>
<p>此时<a href="http://localhost:4000/" target="_blank" rel="noopener">localhost</a>中</p>
<blockquote>
<p>深度缓存(depth buffer)</p>
</blockquote>
<h2 id="issue-1"><a href="#issue-1" class="headerlink" title="issue++:"></a>issue++:</h2><blockquote>
<ul>
<li>批量转化post中的md文件</li>
<li>自动生成UTF-8格式的md文件</li>
</ul>
</blockquote>
<hr>
<p>reference:<br>[1]: </p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> UTF-8 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DirectX9.0 notes 1.3 预备知识]]></title>
      <url>/2017/11/22/d3d-preparation/</url>
      <content type="html"><![CDATA[<h3 id="深度缓存-depth-buffer"><a href="#深度缓存-depth-buffer" class="headerlink" title="深度缓存(depth buffer)"></a>深度缓存(depth buffer)</h3><blockquote>
<p>定义: 一个含有特定像素的深度信息而不含图像数据的表面。<br>  用于计算每个像素而定深度值并进行深度测试: 让处于同一位置的不同像素进行竞争，选出应写入该位置的像素。距离摄像机最近的像素获胜。<br>  深度缓存格式决定深度测试精度, 精度度 16位&lt;24位&lt;32位, 一般选择24位满足效果</p>
<ul>
<li>D3DFMT_D32         32位深度缓存</li>
<li>D3DFMT_D23S8       24位深度缓存, 其中8位保留供模板缓存(stencil buffer)[1]使用</li>
<li>D3DFMT_D24X8       24位深度缓存</li>
<li>D3DFMT_D16         16位深度缓存</li>
</ul>
</blockquote>
<h3 id="顶点运算-Vertex-Processing"><a href="#顶点运算-Vertex-Processing" class="headerlink" title="顶点运算(Vertex Processing)"></a>顶点运算(Vertex Processing)</h3><blockquote>
<ul>
<li>软件顶点运算(software vertex process)</li>
<li>硬件顶点运算(harfware …)</li>
</ul>
</blockquote>
<p>软件顶点运算 <strong> 总是会被支持 </strong> , 硬件只有得到图形卡的支持才可使用。</p>
<p>优先考虑硬件顶点运算方式，理由：</p>
<blockquote>
<ol>
<li>使用的硬件可能有加速功能</li>
<li>可以不占用CPU， CPU可被解放出来进行其他运算</li>
</ol>
</blockquote>
<h3 id="设备性能-Device-Capabilities"><a href="#设备性能-Device-Capabilities" class="headerlink" title="设备性能(Device Capabilities)"></a>设备性能(Device Capabilities)</h3><p>DeCaps 表示”Device Capabilities”<br>D3DCAP9::DevCaps的D3DDEVCAPS_HWTYRANSFORMANDLIGHT 可用来表示设备是否支持变换和光照的硬件计算。<br>多查阅D3DCAP9相关的SDK文档, 继续研究一下Directt3D所提供能够设备性能的完整列表。</p>
<p>[1] : 18章论述</p>
]]></content>
      
        
        <tags>
            
            <tag> DirectX </tag>
            
            <tag> Games </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法整理(不定期更新)]]></title>
      <url>/2017/11/21/my-markdown/</url>
      <content type="html"><![CDATA[<p>In this post, I will focus on use of Markdown and hexo push.</p>
<blockquote>
<ol>
<li>title level</li>
<li>insert a link</li>
<li>highlight the code</li>
<li>three lists of point</li>
<li>insert a note”[^code]”</li>
<li>bold fonts</li>
<li>reference</li>
<li>edit a formula</li>
<li>draw a flow picture</li>
</ol>
<ul>
<li><a href="#补充">补充</a></li>
</ul>
</blockquote>
<p>reference website: <a href="https://www.zybuluo.com/mdeditor#fn:latex" target="_blank" rel="noopener">Cmd Markdown reader</a></p>
<h2 id="1-Title-level"><a href="#1-Title-level" class="headerlink" title="1. Title level"></a>1. Title level</h2><h3 id="level-3-0"><a href="#level-3-0" class="headerlink" title="level 3-0"></a>level 3-0</h3><h4 id="level-4-0"><a href="#level-4-0" class="headerlink" title="level 4-0"></a>level 4-0</h4><h3 id="level-3-1"><a href="#level-3-1" class="headerlink" title="level 3-1"></a>level 3-1</h3><h4 id="level-4-1"><a href="#level-4-1" class="headerlink" title="level 4-1"></a>level 4-1</h4><h4 id="level-4-2"><a href="#level-4-2" class="headerlink" title="level 4-2"></a>level 4-2</h4><h2 id="2-Insert-a-link"><a href="#2-Insert-a-link" class="headerlink" title="2. Insert a link."></a>2. Insert a link.</h2><h3 id="Tim’s-Blog"><a href="#Tim’s-Blog" class="headerlink" title="Tim’s Blog"></a><a href="https://timtingwei.github.io/">Tim’s Blog</a></h3><h3 id="Tim’s-Blog-1"><a href="#Tim’s-Blog-1" class="headerlink" title="Tim’s Blog"></a><a href="https://timtingwei.github.io/">Tim’s Blog</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### [Tim&apos;s Blog](https://timtingwei.github.io/)</span><br><span class="line">### [Tim&apos;s Blog][2]</span><br></pre></td></tr></table></figure>
<h2 id="3-Highlight-the-code"><a href="#3-Highlight-the-code" class="headerlink" title="3. Highlight the code"></a>3. Highlight the code</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-three-lists-of-point"><a href="#4-three-lists-of-point" class="headerlink" title="4. three lists of point"></a>4. three lists of point</h2><h3 id="Bulleted-List"><a href="#Bulleted-List" class="headerlink" title="Bulleted List"></a>Bulleted List</h3><blockquote>
<ul>
<li>first line</li>
<li>second line</li>
<li>third line</li>
</ul>
</blockquote>
<h3 id="Numbered-List"><a href="#Numbered-List" class="headerlink" title="Numbered List"></a>Numbered List</h3><blockquote>
<ol>
<li>first line</li>
<li>second line</li>
<li>third line</li>
</ol>
</blockquote>
<h3 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO list"></a>TODO list</h3><ul>
<li style="list-style: none"><input type="checkbox"> first todo </li>
<li style="list-style: none"><input type="checkbox"> second todo</li>
<li style="list-style: none"><input type="checkbox" checked> third todo -&gt; Done</li>
</ul>
<h2 id="5-insert-a-note-code"><a href="#5-insert-a-note-code" class="headerlink" title="5. insert a note[^code]"></a>5. insert a note[^code]</h2><p>LaTex formula support [LaTex][^LaTex]<br>high light code [code][^code]<br>insert a web note <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a></p>
<h2 id="6-bold-fonts"><a href="#6-bold-fonts" class="headerlink" title="6. bold fonts"></a>6. bold fonts</h2><p><strong> bold fonts </strong> by adding two asteriskes *  as prefix and suffix respectively</p>
<h2 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7. Reference"></a>7. Reference</h2><blockquote>
<p>You can insert a reference by “&gt;”,<br>and input enter to create a new line,<br>This is the end line. Until the next symbol occur.</p>
</blockquote>
<h2 id="8-edit-a-formula"><a href="#8-edit-a-formula" class="headerlink" title="8. edit a formula"></a>8. edit a formula</h2><p>$$E=mc^2$$    use $$</p>
<h2 id="9-draw-a-flow-picture"><a href="#9-draw-a-flow-picture" class="headerlink" title="9.draw a flow picture"></a>9.draw a flow picture</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Opreation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<p>[^LaTex]: support <strong>LaTex</strong> edit and display, such as: $\sum_{i=1}^n a_i=0$, visit <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> for more information.<br>[^code]: include Java, Python, JavaScript etc.</p>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote>
<ul>
<li><a href="#背景色灰">背景色灰</a></li>
<li><a href="#实现页面内跳转">实现页面内跳转</a></li>
<li><a href="#删除线">删除线</a></li>
<li><a href="#插入图片">插入图片</a></li>
<li><a href="#标记文本颜色">标记文本颜色</a><br>20171224之后补充但未作整理。本来可以将每个语法分成多个博客离散列出，但后来出于对博客页面和知识索引的考虑，还是放在一个post内，也许将来会又变动，但是先不提前优化。</li>
</ul>
</blockquote>
<h2 id="背景色灰"><a href="#背景色灰" class="headerlink" title="背景色灰"></a>背景色灰</h2><p>`gray background`</p>
<p><code>gray background</code></p>
<p>背景灰可以代替 反斜杠 \,去完成注释。这个很好用。原理估计和代码块差不多吧。</p>
<h2 id="实现页面内跳转"><a href="#实现页面内跳转" class="headerlink" title="实现页面内跳转"></a>实现页面内跳转</h2><p><code>[create an anchor](#anchors-in-markdown)</code></p>
<p><a href="#anchors-in-markdown">create an anchor</a></p>
<p>\===========<br>refwebsite:</p>
<p><a href="https://gist.github.com/asabaylus/3071099" target="_blank" rel="noopener">Anchors in Markdown</a></p>
<h3 id="anchors-in-markdown"><a href="#anchors-in-markdown" class="headerlink" title="anchors in markdown"></a>anchors in markdown</h3><pre><code>skip into this title
</code></pre><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><code>~~删除一句~~</code><br><del>删除一句</del></p>
<p><code>~~删除</code><br><code>多行~~</code><br><del>删除<br>多行</del></p>
<p><code>~~删除包含语法[mituh’s notes][timtingwei.github.io]~~</code><br><del>删除包含语法[mituh’s notes][timtingwei.github.io]</del></p>
<p>====<br>不知道还有其他方法否？</p>
<p>\==========<br>refwebsite:</p>
<p><a href="https://en.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Markdown</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><code>![Logo](/images/logo.png)</code><br><img src="/images/logo.png" alt="Logo"></p>
<p>\===========<br>refwebsite:</p>
<p>hexo图片的其他用法：<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/asset-folders.html</a><br><a href="https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo" target="_blank" rel="noopener">https://webapps.stackexchange.com/questions/29602/markdown-to-insert-and-display-an-image-on-github-repo</a></p>
<h2 id="标记文本颜色"><a href="#标记文本颜色" class="headerlink" title="标记文本颜色"></a>标记文本颜色</h2><p><code>&lt;span style=&quot;color:blue&quot;&gt;*This is Blue italic.*&lt;/span&gt;</code><br><span style="color:blue"><em>This is Blue italic.</em></span></p>
<p><code>&lt;span style=&quot;color:red&quot;&gt;**This is Red Bold.**&lt;/span&gt;</code><br><span style="color:red"><strong>This is Red Bold.</strong></span></p>
<p>相比之下,<br>italic 给人轻松的感觉，<br>blod有种警告意味。</p>
<p>\===========<br>refwebsite:</p>
<p><a href="https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown" target="_blank" rel="noopener">https://stackoverflow.com/questions/35465557/how-to-apply-color-in-markdown</a></p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>段落前后是空行<br>段落内插入<code>&lt;br&gt;</code>换行</p>
<p>test1<br>test2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br></pre></td></tr></table></figure>
<p>test1</p>
<p>test2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">test1</span><br><span class="line"></span><br><span class="line">test2</span><br></pre></td></tr></table></figure>
<p>test1<br><br>test2<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test1&lt;br&gt;</span><br><span class="line">test2&lt;br&gt;</span><br></pre></td></tr></table></figure></p>
<p>\====<br>ref:<br><a href="http://xianbai.me/learn-md/article/syntax/paragraphs-and-line-breaks.html" target="_blank" rel="noopener">http://xianbai.me/learn-md/article/syntax/paragraphs-and-line-breaks.html</a></p>
<h2 id="next-one"><a href="#next-one" class="headerlink" title="next one ?"></a>next one ?</h2><hr>
<p>以上是我的个人笔记收录，markdown主要用来写笔记和写博客<br>其他有什么好玩的用法，欢迎指教。<br>timtingwei@gmail.com</p>
]]></content>
      
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
